# <a name="exceptions"></a>Исключения

Исключения в C# предоставляют структурированный, однородный и строго типобезопасный способ обработки системного уровня и уровня приложения условия ошибок. Механизм обработки исключений в C# очень похож на, c++, с помощью несколько важных различий:

*  В C# все исключения должны быть представлены с помощью экземпляра типа класса, производного от `System.Exception`. В C++ можно использовать любое значение любого типа, который представляет исключение.
*  В C# блок finally ([оператора try](statements.md#the-try-statement)) может использоваться для записи кода завершения, который выполняется в нормальном выполнении и исключительных условий. Такой код будет сложно создавать на языке C++ без дублирования кода.
*  В C# исключения системного уровня, например переполнение, деление на ноль и null разыменовывает четко определенные классы исключений и находятся на одном уровне с состояниями ошибки уровня приложения.

## <a name="causes-of-exceptions"></a>Причины исключений

Исключение может вызываться двумя разными способами.

*  Объект `throw` инструкции ([инструкция throw](statements.md#the-throw-statement)) вызывает исключение немедленно и безусловно. Элемент управления никогда не достигает оператора, следующего `throw`.
*  Определенные исключительных условий, возникающих во время обработки операторов C# и выражения вызывает исключение в определенных обстоятельствах, когда обычно не удается выполнить операцию. Например, операции деления целое число ([оператор деления](expressions.md#division-operator)) создает `System.DivideByZeroException` Если знаменатель равен нулю. См. в разделе [общие классы исключений](exceptions.md#common-exception-classes) список различных исключений, которые могут возникнуть таким образом.

## <a name="the-systemexception-class"></a>Класс System.Exception

`System.Exception` Класс является базовым типом для всех исключений. Этот класс имеет несколько важных свойств, которые совместно используют все исключения.

*  `Message` является свойством только для чтения типа `string` , содержащий понятное описание причины исключения.
*  `InnerException` является свойством только для чтения типа `Exception`. Если его значение не равно null, он ссылается на исключение, вызвавшее текущее исключение — то есть, текущее исключение возникло в блоке catch обработки `InnerException`. В противном случае его значение null, указывает, что это исключение не было вызвано другое исключение. Количество объектов исключений, которые соединены друг с другом, таким образом может быть произвольным.

Значения этих свойств можно указать в вызовах конструктору экземпляра для `System.Exception`.

## <a name="how-exceptions-are-handled"></a>Обработка исключений

Исключения обрабатываются `try` инструкции ([оператора try](statements.md#the-try-statement)).

При возникновении исключения, система выполняет поиск ближайших `catch` предложение, которое может обработать исключение, как определяется типом времени выполнения исключения. Во-первых, текущий метод ищется лексически заключения `try` инструкции и предложения соответствующего блока catch оператора try считаются в порядке. В случае неудачи, метод, который вызвал текущий метод ищется лексически заключения `try` инструкцию, которая содержит точку вызова текущего метода. Этот поиск продолжается, пока `catch` предложение найдено, который может обрабатывать текущее исключение, назвав имеет того же класса или базового класса, типа времени выполнения исключения класса исключения. Объект `catch` предложение, которое не назовите класс исключения может обрабатывать любое исключение.

После обнаружения подходящего оператора catch система готовится к передаче управления в первый оператор в предложении catch. Перед началом выполнения предложения catch, система сначала выполняет, в порядке, любой `finally` предложения, которые были связаны с инструкции try дополнительные вложенные, чем тот, который вызвал исключение.

Если нет подходящего оператора catch найден, возникает одно из следующих действий:

*  Если поиск подходящего оператора catch достигает статический конструктор ([статические конструкторы](classes.md#static-constructors)) или инициализатор статического поля, а затем `System.TypeInitializationException` возникает в точке, запустившей вызов статического конструктора. Внутреннее исключение `System.TypeInitializationException` содержит исключение, которое изначально было выдано.
*  Если для сопоставления предложения catch достигается код, который изначально запуска потока, завершается выполнение потока. Влияние прекращение их действия определяется реализацией.

Исключения, возникающие при выполнении деструктора заслуживают отдельного упоминания. Если исключение возникает при выполнении деструктора, и это исключение не перехватывается, выполнение этого деструктора завершается, и вызывается деструктор базового класса (если таковые имеются). Если нет базового класса (как в случае `object` типа) или если деструктор базового класса, то исключение было удалено.

## <a name="common-exception-classes"></a>Общие классы исключений

Следующие исключения создаются с помощью определенных операций на C#.

|                                      |                |
|--------------------------------------|----------------|
| `System.ArithmeticException`         | Базовый класс для исключений, которые возникают при выполнении арифметических операций, таких как `System.DivideByZeroException` и `System.OverflowException`. | 
| `System.ArrayTypeMismatchException`  | Создается в случае сбоя хранилища в массив, так как фактический тип хранимых элемента несовместим с фактическим типом массива. | 
| `System.DivideByZeroException`       | Возникает, когда происходит при попытке деления целого значения на ноль. | 
| `System.IndexOutOfRangeException`    | Возникает при попытке индексирования массива с помощью индекса, которое меньше нуля или выходит за границы массива. | 
| `System.InvalidCastException`        | Возникает, если явное преобразование из базового типа или интерфейса в производный тип завершается ошибкой во время выполнения. | 
| `System.NullReferenceException`      | Возникает, когда `null` ссылка используется способом, который вызывает упоминаемого объекта обязательным. | 
| `System.OutOfMemoryException`        | Возникает при попытке выделения памяти (через `new`) завершается сбоем. | 
| `System.OverflowException`           | Возникает при переполнении арифметической операции в контексте `checked`. | 
| `System.StackOverflowException`      | Возникает, когда стек выполнения переполнен слишком много вызовов метода, ожидающих утверждения; Обычно это указывает на очень глубокой или неограниченной рекурсии. | 
| `System.TypeInitializationException` | Возникает, когда статический конструктор создает исключение и нет `catch` предложений существует перехватить. | 
