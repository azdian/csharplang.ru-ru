# <a name="namespaces"></a>Пространства имен

C#, структуре программ использование пространств имен. Пространства имен используются как в качестве системы для программы «internal» организации, так и в качестве системы «external» организации — способа представления элементы программы, которые предоставляются другим программам.

Директивы using ([директив Using](namespaces.md#using-directives)) предоставляются для упрощения использования пространств имен.

## <a name="compilation-units"></a>Единицы компиляции

Объект *compilation_unit* определяет общую структуру исходного файла. Единица компиляции состоит из нуля или более *using_directive*следуют ноль или более *global_attributes* следуют ноль или более *namespace_member_declaration*s .

```antlr
compilation_unit
    : extern_alias_directive* using_directive* global_attributes? namespace_member_declaration*
    ;
```

Программы на C# состоит из одного или несколько блоков компиляции, каждый из которых размещается в отдельном исходном файле. При компиляции программы на C# все единицы компиляции обрабатываются вместе. Таким образом единицы компиляции может зависеть друг от друга, возможно по кругу.

*Using_directive*s единицы компиляции эффект будет иметь *global_attributes* и *namespace_member_declaration*s этой единицы компиляции, но не оказывают влияния на другие единицы компиляции.

*Global_attributes* ([атрибуты](attributes.md)) единицы компиляции разрешают спецификацию атрибуты для целевой сборки и модуля. Сборки и модули действуют как физические контейнеры для типов. Сборка может состоять из нескольких физически отдельных модулей.

*Namespace_member_declaration*s каждой единицы компиляции программы размещают члены пространства одно объявление, называемого глобальное пространство имен. Пример:

Файл `A.cs`:
```csharp
class A {}
```

Файл `B.cs`:
```csharp
class B {}
```

Две единицы компиляции размещаются в одном глобальное пространство имен, в данном случае объявление двух классов с помощью полных имен `A` и `B`. Поскольку эти две единицы компиляции размещаются в одном пространстве объявлений, было бы ошибку, если каждый содержащийся объявление члена с таким именем.

## <a name="namespace-declarations"></a>Декларации пространств имен

Объект *namespace_declaration* состоит из ключевого слова `namespace`, за которым следует имя пространства имен и текста, при необходимости и точку с запятой.

```antlr
namespace_declaration
    : 'namespace' qualified_identifier namespace_body ';'?
    ;

qualified_identifier
    : identifier ('.' identifier)*
    ;

namespace_body
    : '{' extern_alias_directive* using_directive* namespace_member_declaration* '}'
    ;
```

Объект *namespace_declaration* наблюдается объявлением верхнего уровня в *compilation_unit* или объявлением члена внутри другого *namespace_declaration*. Когда *namespace_declaration* происходит объявлением верхнего уровня в *compilation_unit*, пространство имен становится членом глобального пространства имен. Когда *namespace_declaration* происходит внутри другого *namespace_declaration*, внутреннее пространство имен становится членом внешнего пространства имен. В любом случае имя пространства имен должно быть уникальным в пределах содержащего пространства имен.

Пространства имен являются неявно `public` и объявление пространства имен не может включать модификаторы доступа.

В рамках *namespace_body*, необязательный *using_directive*s импортировать имена других пространств имен, типов и членов, позволяющих ссылаться напрямую вместо того через полные имена. Необязательный *namespace_member_declaration*s размещают члены в области объявления пространства имен. Обратите внимание, что все *using_directive*s должны располагаться перед любыми объявлениями членов.

*Qualified_identifier* из *namespace_declaration* может быть один идентификатор или последовательность идентификаторов, разделенных "`.`" маркеров. Последняя форма позволяет программе определить вложенное пространство имен без лексически вложение несколько объявлений пространств имен. Например, примененная к объекту директива

```csharp
namespace N1.N2
{
    class A {}

    class B {}
}
```
семантически эквивалентен
```csharp
namespace N1
{
    namespace N2
    {
        class A {}

        class B {}
    }
}
```

Пространства имен являются открытыми, и два объявления пространств имен с тем же полным именем размещаются в одном пространстве объявлений ([объявления](basic-concepts.md#declarations)). В примере
```csharp
namespace N1.N2
{
    class A {}
}

namespace N1.N2
{
    class B {}
}
```
Два объявления пространства имен выше, размещаются в одной области объявления, в этом случае объявляются два класса с полными доменными именами `N1.N2.A` и `N1.N2.B`. Поскольку два объявления размещаются в одном пространстве объявлений, было бы что ошибку, если каждый содержится объявление члена с таким именем.

## <a name="extern-aliases"></a>Внешние псевдонимы

*Extern_alias_directive* представляет идентификатор, служащий в качестве псевдонима для пространства имен. Спецификации пространства имен с псевдонимом является внешним по отношению к исходному коду программы, а также распространяется на вложенные пространства имен пространства имен с псевдонимом.

```antlr
extern_alias_directive
    : 'extern' 'alias' identifier ';'
    ;
```

Область *extern_alias_directive* распространяется *using_directive*s, *global_attributes* и *namespace_member_declaration*s его непосредственно вмещающего компиляции единицы или пространства имен текста.

В теле компиляции единицы или пространства имен, содержащий *extern_alias_directive*, идентификатор, представленный *extern_alias_directive* может использоваться для ссылки на пространство имен с псевдонимом. Произошла ошибка во время компиляции для *идентификатор* слово `global`.

*Extern_alias_directive* делает псевдоним доступным в теле конкретной компиляции единицы или пространства имен, но не размещает новые члены в основной области объявления. Другими словами *extern_alias_directive* не является транзитивным, но, скорее, влияет только на компиляцию единицы или пространства имен тело в которой оно встречается.

Следующая программа объявляет и использует два псевдонима extern `X` и `Y`, каждый из который представляет корень иерархии отдельное пространство имен:
```csharp
extern alias X;
extern alias Y;

class Test
{
    X::N.A a;
    X::N.B b1;
    Y::N.B b2;
    Y::N.C c;
}
```

Программа объявляет существование extern псевдонимы `X` и `Y`, но фактические определения псевдонимов являются внешними по отношению к программе. Таким же именем `N.B` классов теперь можно ссылаться как на `X.N.B` и `Y.N.B`, либо с помощью квалификатор псевдонима пространства имен, `X::N.B` и `Y::N.B`. Ошибка возникает, если программа объявляющем внешний псевдоним для которой предоставляются не внешнее определение.

## <a name="using-directives"></a>директивы using

***С помощью директивы*** облегчают использование пространств имен и типов, определенных в других пространствах имен. Процесс разрешения с помощью директивы влияние *namespace_or_type_name*s ([пространства имен и тип](basic-concepts.md#namespace-and-type-names)) и *simple_name*s ([простые имена ](expressions.md#simple-names)), но в отличие от объявлений, с использованием директивы не включаются новые члены в базовых пробелы объявление единицы компиляции или пространства имен, в котором они используются.

```antlr
using_directive
    : using_alias_directive
    | using_namespace_directive
    | using_static_directive
    ;
```

Объект *using_alias_directive* ([директивы псевдонима Using](namespaces.md#using-alias-directives)) появился псевдоним для пространства имен или типа.

Объект *using_namespace_directive* ([с помощью директивы пространства имен](namespaces.md#using-namespace-directives)) импортирует элементы типа пространства имен.

Объект *using_static_directive* ([директивами Using static](namespaces.md#using-static-directives)) импортирует вложенные типы и статические члены типа.

Область *using_directive* распространяется *namespace_member_declaration*s его непосредственно вмещающего компиляции единицы или пространства имен текста. Область *using_directive* специально не содержит его коллеге *using_directive*s. Таким образом, одноранговые *using_directive*s не влияют друг на друга, и порядок, в котором они записаны не играет роли.

### <a name="using-alias-directives"></a>Директивы псевдонима using

Объект *using_alias_directive* представляет идентификатор, служащий в качестве псевдонима для пространства имен или тип в теле немедленно включающего компиляции единицы или пространства имен.

```antlr
using_alias_directive
    : 'using' identifier '=' namespace_or_type_name ';'
    ;
```

В объявлениях членов в единицу компиляции или пространстве имен тело, содержащий *using_alias_directive*, идентификатор, представленный *using_alias_directive* можно использовать ссылку на заданный пространство имен или тип. Пример:
```csharp
namespace N1.N2
{
    class A {}
}

namespace N3
{
    using A = N1.N2.A;

    class B: A {}
}
```

Выше, в объявлениях членов в `N3` пространства имен, `A` является псевдонимом для `N1.N2.A`и поэтому класс `N3.B` является производным от класса `N1.N2.A`. Тот же эффект достигается путем создания псевдонима `R` для `N1.N2` и указав `R.A`:
```csharp
namespace N3
{
    using R = N1.N2;

    class B: R.A {}
}
```

*Идентификатор* из *using_alias_directive* должно быть уникальным в области объявления блока компиляции или пространство имен, содержащее немедленно *using_alias_directive* . Пример:
```csharp
namespace N3
{
    class A {}
}

namespace N3
{
    using A = N1.N2.A;        // Error, A already exists
}
```

Выше, `N3` уже содержит элемент `A`, так что это ошибка времени компиляции для *using_alias_directive* использование этого идентификатора. Аналогичным образом, это ошибка времени компиляции в двух или более *using_alias_directive*s в одной единице компиляции или пространство имен теле объявлять псевдонимы с тем же именем.

Объект *using_alias_directive* делает псевдоним доступным в теле конкретной компиляции единицы или пространства имен, но не размещает новые члены в основной области объявления. Другими словами *using_alias_directive* не является транзитивным, а скорее влияет только единицы компиляции или пространстве имен тела в которой оно встречается. В примере
```csharp
namespace N3
{
    using R = N1.N2;
}

namespace N3
{
    class B: R.A {}            // Error, R unknown
}
```
область *using_alias_directive* , в которой вводятся `R` распространяется только на объявления членов в теле пространства имен, в котором она содержится, поэтому `R` неизвестно во втором объявлении пространства имен. Тем не менее, поместив *using_alias_directive* в содержащем компиляции единицы, то этот псевдоним, станут доступны в обоих объявления пространств имен:
```csharp
using R = N1.N2;

namespace N3
{
    class B: R.A {}
}

namespace N3
{
    class C: R.A {}
}
```

Так же как обычные элементы, представленные имена *using_alias_directive*s скрыты с помощью членов с таким же именем в вложенных областей. В примере
```csharp
using R = N1.N2;

namespace N3
{
    class R {}

    class B: R.A {}        // Error, R has no member A
}
```
ссылка на `R.A` в объявлении `B` приводит к ошибке времени компиляции, так как `R` ссылается на `N3.R`, а не `N1.N2`.

Порядок, в котором *using_alias_directive*s записываются не значимости, а также разрешение *namespace_or_type_name* ссылается *using_alias_directive*не зависит от *using_alias_directive* сам или другими *using_directive*s в непосредственно содержащей единицы компиляции или пространстве имен тела. Другими словами *namespace_or_type_name* из *using_alias_directive* разрешается, если непосредственно вмещающего единицы компиляции или пространстве имен тела бы нет *using_directive*s. Объект *using_alias_directive* тем не менее могут быть подвержены *extern_alias_directive*s в непосредственно содержащей единицы компиляции или пространстве имен тела. В примере
```csharp
namespace N1.N2 {}

namespace N3
{
    extern alias E;

    using R1 = E.N;        // OK

    using R2 = N1;         // OK

    using R3 = N1.N2;      // OK

    using R4 = R2.N2;      // Error, R2 unknown
}
```
последний *using_alias_directive* приводит к ошибке времени компиляции, так как он не влияет первый *using_alias_directive*. Первый *using_alias_directive* не приведет к ошибке с момента рамки внешний псевдоним `E` включает в себя *using_alias_directive*.

Объект *using_alias_directive* можно создать псевдоним для любого пространства имен или типа, включая пространство имен, в котором он отображается, и любое пространство имен или тип, вложенные в это пространство имен.

Доступ к пространство имен или тип через псевдоним дает точно такой же результат, как доступ к этому пространству имен или тип по ее объявленному имени. Например если
```csharp
namespace N1.N2
{
    class A {}
}

namespace N3
{
    using R1 = N1;
    using R2 = N1.N2;

    class B
    {
        N1.N2.A a;            // refers to N1.N2.A
        R1.N2.A b;            // refers to N1.N2.A
        R2.A c;               // refers to N1.N2.A
    }
}
```
имена `N1.N2.A`, `R1.N2.A`, и `R2.A` являются эквивалентом и все ссылки на класс является полное имя которого `N1.N2.A`.

С помощью псевдонимов можно имя закрытого сконструированного типа, но не имя является объявлением несвязанного универсального типа без указания аргументов типа. Пример:
```csharp
namespace N1
{
    class A<T>
    {
        class B {}
    }
}

namespace N2
{
    using W = N1.A;          // Error, cannot name unbound generic type

    using X = N1.A.B;        // Error, cannot name unbound generic type

    using Y = N1.A<int>;     // Ok, can name closed constructed type

    using Z<T> = N1.A<T>;    // Error, using alias cannot have type parameters
}
```

### <a name="using-namespace-directives"></a>С помощью директивы пространства имен

Объект *using_namespace_directive* импортирует типы, содержащиеся в пространстве имен в немедленно включающего единицы компиляции или пространстве имен тела, включение идентификатор каждый тип, который будет использоваться без уточнения.

```antlr
using_namespace_directive
    : 'using' namespace_name ';'
    ;
```

В объявлениях членов в единицу компиляции или пространстве имен тело, содержащий *using_namespace_directive*, можно непосредственно ссылаться на типы, содержащиеся в данном пространстве имен. Пример:
```csharp
namespace N1.N2
{
    class A {}
}

namespace N3
{
    using N1.N2;

    class B: A {}
}
```

Выше, в объявлениях членов в `N3` пространства имен, члены типа `N1.N2` доступны непосредственно и поэтому класс `N3.B` является производным от класса `N1.N2.A`.

Объект *using_namespace_directive* импортирует типы, содержащиеся в данном пространстве имен, но не импортирует вложенные пространства имен. В примере
```csharp
namespace N1.N2
{
    class A {}
}

namespace N3
{
    using N1;

    class B: N2.A {}        // Error, N2 unknown
}
```
*using_namespace_directive* импортирует типы, содержащиеся в `N1`, но не пространства имен, вложенные в `N1`. Таким образом, ссылку на `N2.A` в объявлении `B` приводит к ошибке времени компиляции, так как нет членов с именем `N2` находятся в области действия.

В отличие от *using_alias_directive*, *using_namespace_directive* может импортировать типы, идентификаторы которых уже определены в теле включающего компиляции единицы или пространства имен. По сути, имена импортируемых *using_namespace_directive* скрыты с помощью членов с таким же именем в включающего единицы компиляции или пространстве имен тела. Пример:
```csharp
namespace N1.N2
{
    class A {}

    class B {}
}

namespace N3
{
    using N1.N2;

    class A {}
}
```

Здесь в объявления членов в `N3` пространства имен, `A` ссылается на `N3.A` вместо `N1.N2.A`.

При импорте более одного пространства имен или типа *using_namespace_directive*s или *using_static_directive*s внутри же компиляции единицы или пространства имен содержат типы, с тем же именем, ссылки на Это имя как *type_name* неоднозначны. В примере
```csharp
namespace N1
{
    class A {}
}

namespace N2
{
    class A {}
}

namespace N3
{
    using N1;

    using N2;

    class B: A {}                // Error, A is ambiguous
}
```
оба `N1` и `N2` содержат член `A`и поскольку `N3` импортирует оба, ссылающиеся на `A` в `N3` ошибка времени компиляции. В этом случае конфликт разрешается или через уточнения ссылок на `A`, либо введя *using_alias_directive* , использует `A`. Пример:
```csharp
namespace N3
{
    using N1;

    using N2;

    using A = N1.A;

    class B: A {}                // A means N1.A
}
```

Кроме того, когда более одного пространства имен или типа импортировано *using_namespace_directive*s или *using_static_directive*внутри же компиляции единицы или пространства имен содержат типы или члены по таким же именем, ссылается на это имя как *simple_name* неоднозначны. В примере
```csharp
namespace N1
{
    class A {}
}

class C
{
    public static int A;
}

namespace N2
{
    using N1;
    using static C;

    class B
    {
        void M() 
        { 
            A a = new A();   // Ok, A is unambiguous as a type-name
            A.Equals(2);     // Error, A is ambiguous as a simple-name
        }
    }
}
```
`N1` содержит член типа `A`, и `C` содержит статический метод `A`и поскольку `N2` импортирует оба, ссылающиеся на `A` как *simple_name* является неоднозначным, а во время компиляции Ошибка. 

Как и *using_alias_directive*, *using_namespace_directive* не размещает новые члены в базовой области объявления блока компиляции или пространства имен, а влияет только тело компиляции единицы или пространства имен, в котором он находится.

*Namespace_name* ссылается *using_namespace_directive* разрешается в так же, как *namespace_or_type_name* ссылается  *using_alias_directive*. Таким образом *using_namespace_directive*s, в том же теле единицы или пространства имен компиляции не влияют друг на друга и могут быть записаны в любом порядке.

### <a name="using-static-directives"></a>Директивами using static

Объект *using_static_directive* импортирует вложенные типы и статические члены, содержащимися непосредственно в объявлении типа в немедленно включающего единицы компиляции или пространстве имен тела, включение идентификатор каждый член и тип быть использовать без уточнения.

```antlr
using_static_directive
    : 'using' 'static' type_name ';'
    ;
```

В объявлениях членов в единицу компиляции или пространстве имен тело, содержащий *using_static_directive*, доступный вложенные типы и члены статических (за исключением методов расширения) содержатся непосредственно в объявлении Данный тип можно ссылаться непосредственно. Пример:

```csharp
namespace N1
{
    class A 
    {
        public class B{}
        public static B M(){ return new B(); }
    }
}

namespace N2
{
    using static N1.A;
    class C
    {
        void N() { B b = M(); }
    }
}
```

Выше, в объявлениях членов в `N2` пространства имен, статические члены и вложенные типы `N1.A` доступны непосредственно и, следовательно, метод `N` может ссылаться на оба `B` и `M` членами `N1.A`.

Объект *using_static_directive* специально не импортирует методы расширения непосредственно как статические методы, но делает их доступными для вызова метода расширения ([вызовы методов расширения](expressions.md#extension-method-invocations)). В примере

```csharp
namespace N1 
{
    static class A 
    {
        public static void M(this string s){}
    }
}

namespace N2
{
    using static N1.A;

    class B
    {
        void N() 
        {
            M("A");      // Error, M unknown
            "B".M();     // Ok, M known as extension method
            N1.A.M("C"); // Ok, fully qualified
        }
    }
}
```
*using_static_directive* импортирует метод расширения `M` содержащихся в `N1.A`, но только в качестве метода расширения. Таким образом, первым обращением к `M` в теле `B.N` приводит к ошибке времени компиляции, так как нет членов с именем `M` находятся в области действия.

Объект *using_static_directive* импортирует только элементы и типы, объявленные непосредственно в указанный тип, не членов и типов, объявленных в базовых классах.

TODO: пример

Неоднозначность между несколькими *using_namespace_directives* и *using_static_directives* рассматриваются в [с помощью директивы пространства имен](namespaces.md#using-namespace-directives).

## <a name="namespace-members"></a>Члены пространства имен

Объект *namespace_member_declaration* либо *namespace_declaration* ([объявления пространств имен](namespaces.md#namespace-declarations)) или *type_declaration* () [Объявления типов](namespaces.md#type-declarations)).

```antlr
namespace_member_declaration
    : namespace_declaration
    | type_declaration
    ;
```

Блок компиляции или тело пространства имен может содержать *namespace_member_declaration*s и такие объявления добавляют новые члены в базовой области объявления, содержащего текста компиляции единицы или пространства имен.

## <a name="type-declarations"></a>Объявления типов

Объект *type_declaration* — *class_declaration* ([объявлений классов](classes.md#class-declarations)), *struct_declaration* ([структуры объявления](structs.md#struct-declarations)), *interface_declaration* ([объявления интерфейсов](interfaces.md#interface-declarations)), *enum_declaration* ([Enum объявления](enums.md#enum-declarations)), или *delegate_declaration* ([объявления делегатов](delegates.md#delegate-declarations)).

```antlr
type_declaration
    : class_declaration
    | struct_declaration
    | interface_declaration
    | enum_declaration
    | delegate_declaration
    ;
```

Объект *type_declaration* может возникнуть объявлением верхнего уровня в единице компиляции или объявлением члена внутри пространства имен, класса или структуры.

Если объявление типа для типа `T` происходит объявлением верхнего уровня в единице компиляции, полное имя вновь объявленного типа является просто `T`. Если объявление типа для типа `T` содержится в пространстве имен, класса или структуры, полное имя типа вновь объявленное `N.T`, где `N` полное имя вмещающего пространства имен, класса или структуры.

Тип, объявленный в пределах класса или структуры, называется вложенным типом ([вложенные типы](classes.md#nested-types)).

Разрешенные модификаторы доступа и доступ по умолчанию для объявления типа зависит от контекста, в котором происходит объявление ([объявленную доступность](basic-concepts.md#declared-accessibility)):

*  Типы, объявленные в единицах компиляции или пространства имен могут иметь `public` или `internal` доступа. По умолчанию используется `internal` доступа.
*  Типы, объявленные в классах могут иметь `public`, `protected internal`, `protected`, `internal`, или `private` доступа. По умолчанию используется `private` доступа.
*  Типы, объявленные в структурах может иметь `public`, `internal`, или `private` доступа. По умолчанию используется `private` доступа.

## <a name="namespace-alias-qualifiers"></a>Квалификаторы псевдонима пространства имен

***Квалификатор псевдонима пространства имен*** `::` делает возможным гарантирует, что поиск имени типа не влияет на общие сведения о новых типов и членов. Квалификатор псевдонима пространства имен всегда появляется между двумя идентификаторами, которые называют идентификаторы левую и правую. В отличие от обычного `.` квалификатор, слева идентификатор `::` квалификатор осуществляется только как extern или с помощью псевдонима.

Объект *qualified_alias_member* определяется следующим образом:

```antlr
qualified_alias_member
    : identifier '::' identifier type_argument_list?
    ;
```

Объект *qualified_alias_member* можно использовать в качестве *namespace_or_type_name* ([пространства имен и тип](basic-concepts.md#namespace-and-type-names)) или как левый операнд в *member_access* ([Доступ к членам](expressions.md#member-access)).

Объект *qualified_alias_member* имеет одну из двух форм:

*  `N::I<A1, ..., Ak>`, где `N` и `I` представляют идентификаторы, и `<A1, ..., Ak>` — список аргументов типа. (`K` всегда имеет по крайней мере одно.)
*  `N::I`, где `N` и `I` представляют идентификаторы. (В этом случае `K` считается равным 0.)

При использовании этой нотации значение *qualified_alias_member* определяется следующим образом:

*  Если `N` идентификатор `global`, а затем выполняется поиск глобальное пространство имен `I`:
   * Если глобальное пространство имен содержит пространство имен с именем `I` и `K` равен нулю, то *qualified_alias_member* ссылается на это пространство имен.
   * В противном случае, если глобальное пространство имен содержит не универсальный тип с именем `I` и `K` равен нулю, то *qualified_alias_member* ссылается на этот тип.
   * В противном случае, если глобальное пространство имен содержит тип с именем `I` с `K` параметры типа, а затем *qualified_alias_member* ссылается на этот тип, сформированный с заданными аргументами типа.
   * В противном случае *qualified_alias_member* — не определено и возникает ошибка времени компиляции.

*  В противном случае — начиная с объявление пространства имен ([объявления пространств имен](namespaces.md#namespace-declarations)), непосредственно содержащего *qualified_alias_member* (если таковые имеются), продолжение с каждого включающего объявления пространства имен (если таковые имеются) и заканчивая единицей компиляции, содержащей *qualified_alias_member*, оцениваются следующие действия, пока не будет обнаружена сущность:

   * Если пространство имен объявление или блоке компиляции содержит *using_alias_directive* , связывающая `N` с типом, а затем *qualified_alias_member* не определен и во время компиляции возникает ошибка.
   * В противном случае, если единица объявления или компиляции пространство имен содержит *extern_alias_directive* или *using_alias_directive* , связывающая `N` с пространством имен, затем:
     * Если пространство имен, связанное с `N` содержит пространство имен с именем `I` и `K` равен нулю, то *qualified_alias_member* ссылается на это пространство имен.
     * В противном случае, если пространство имен, связанное с `N` содержит не универсальный тип с именем `I` и `K` равен нулю, то *qualified_alias_member* ссылается на этот тип.
     * В противном случае, если пространство имен, связанное с `N` содержит тип с именем `I` с `K` параметры типа, а затем *qualified_alias_member* ссылается на этот тип, сформированный с заданным типом аргументы.
     * В противном случае *qualified_alias_member* — не определено и возникает ошибка времени компиляции.
*  В противном случае *qualified_alias_member* — не определено и возникает ошибка времени компиляции.

Обратите внимание на то, что с помощью квалификатор псевдонима пространства имен с псевдонимом, ссылающимся на тип приводит к ошибке времени компиляции. Также Обратите внимание, что если идентификатор `N` — `global`, а затем выполняется поиск в глобальном пространстве имен, даже если существует псевдоним using, связывающий `global` с типа или пространства имен.

### <a name="uniqueness-of-aliases"></a>Уникальность псевдонимов

Каждой компиляции модульных и пространство имен текст имеет отдельную область объявления для псевдонимов extern и использования псевдонимов. Таким образом, хотя имя псевдонима extern или с помощью псевдонима должно быть уникальным в пределах набора внешние псевдонимы и псевдонимы using объявленных в непосредственно содержащей единицы компиляции или пространстве имен тела, псевдоним может иметь имя, совпадающее с именем типа или пространства имен, при условии, я t используется только с `::` квалификатор.

В примере
```csharp
namespace N
{
    public class A {}

    public class B {}
}

namespace N
{
    using A = System.IO;

    class X
    {
        A.Stream s1;            // Error, A is ambiguous

        A::Stream s2;           // Ok
    }
}
```
имя `A` имеет два значения в тексте второго пространства имен, так как оба класса `A` и с помощью псевдонима `A` находятся в области действия. По этой причине использование `A` в полном имени `A.Stream` является неоднозначным и возникает ошибка времени компиляции. Однако использование `A` с `::` квалификатора не является ошибкой, поскольку `A` выполняется поиск только в качестве псевдонима пространства имен.
