# <a name="delegates"></a>Делегаты

Делегаты другие языки сценариев, таких как C++, Pascal и Modula, реализуются--решены с помощью указателей функций. Тем не менее, в отличие от указателей функций C++, делегаты являются полностью объектно-ориентированного программирования, и в отличие от C++ указателей на функции-члены, делегаты инкапсулируют и экземпляр объекта и метод.

Объявление делегата определяет класс, который является производным от класса `System.Delegate`. Экземпляр делегата инкапсулирует список вызова, который представляет собой список один или несколько методов, каждый из которых называется вызываемым объектом. Например методы, вызываемая сущность состоит из экземпляра и метод в этом экземпляре. Для статических методов вызываемая сущность состоит только из метода. Вызов экземпляра делегата с соответствующим набором аргументов приводит к каждой сущности, вызываемых делегата, вызываемого с указанным набором аргументов.

Интересной и полезной особенности делегата то, что он не знать или заботится о классах методов, которые она инкапсулирует; все это означает, что эти методы должны совместимы ([объявления делегатов](delegates.md#delegate-declarations)) с типом делегата. Это делает делегаты, прекрасно подходят для вызова «anonymous».

## <a name="delegate-declarations"></a>Объявления делегатов

Объект *delegate_declaration* — *type_declaration* ([объявления типов](namespaces.md#type-declarations)), объявляет новый тип делегата.

```antlr
delegate_declaration
    : attributes? delegate_modifier* 'delegate' return_type
      identifier variant_type_parameter_list?
      '(' formal_parameter_list? ')' type_parameter_constraints_clause* ';'
    ;

delegate_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | delegate_modifier_unsafe
    ;
```

Это ошибка времени компиляции для один и тот же модификатор встречается несколько раз в объявлении делегата.

`new` Модификатор допускается только для делегатов объявлена внутри другого типа, в этом случае он указывает, что такой делегат скрывает унаследованный член с тем же именем, как описано в разделе [Модификатор new](classes.md#the-new-modifier).

`public`, `protected`, `internal`, И `private` модификаторы определяют доступность типа делегата. В зависимости от контекста, в котором производится объявление делегата, некоторые из этих модификаторов запрещены ([объявленную доступность](basic-concepts.md#declared-accessibility)).

Имя типа делегата *идентификатор*.

Необязательный *formal_parameter_list* задает параметры делегата, и *return_type* указывает тип возвращаемого значения делегата.

Необязательный *variant_type_parameter_list* ([списков параметров типа Variant](interfaces.md#variant-type-parameter-lists)) задает параметры типа непосредственно к делегату.

Тип возвращаемого значения является типом делегата должен быть либо `void`, или безопасным при выводе ([безопасность вариативности](interfaces.md#variance-safety)).

Все типы формальных параметров типа делегата должен быть безопасным. Кроме того, любая `out` или `ref` типы параметров также должны быть безопасным при выводе. Обратите внимание что даже `out` параметры, требуется ли входные данные с точки зрения, из-за ограничений базовой платформы выполнения.

Типы делегатов в C# являются эквивалентом имени, не структурно эквивалентными. В частности две разные типы делегатов, которые имеют тот же параметр перечислены и типом возвращаемого значения считаются разными типами делегатов. Тем не менее, экземпляров двух типов различных, но структурно эквивалентных делегат может считаться равными ([делегировать операторы равенства](expressions.md#delegate-equality-operators)).

Пример:

```csharp
delegate int D1(int i, double d);

class A
{
    public static int M1(int a, double b) {...}
}

class B
{
    delegate int D2(int c, double d);
    public static int M1(int f, double g) {...}
    public static void M2(int k, double l) {...}
    public static int M3(int g) {...}
    public static void M4(int g) {...}
}
```

Методы `A.M1` и `B.M1 `совместимы с типами делегатов `D1` и `D2` , так как у них есть же возвращают тип и список параметров, однако эти типы делегатов являются два различных типа, поэтому они не взаимозаменяемыми. Методы `B.M2`, `B.M3`, и `B.M4` несовместимы с типами делегатов `D1` и `D2`, так как они имеют разные типы возвращаемого значения или списки параметров.

Как и других объявлениях универсального типа необходимо предоставить аргументы типа для создания сконструированного типа делегата. Типы параметров и тип возвращаемого значения сконструированного типа делегата создаются путем замены для каждого параметра типа в объявлении делегата, соответствующий аргумент типа из сконструированного типа делегата. Результирующий тип возвращаемого значения и типы параметров используются для определения, какие методы совместимы с сконструированного типа делегата. Пример:

```csharp
delegate bool Predicate<T>(T value);

class X
{
    static bool F(int i) {...}
    static bool G(string s) {...}
}
```

Метод `X.F` совместим с типом делегата `Predicate<int>` и метод `X.G` совместим с типом делегата `Predicate<string>` .

Единственный способ объявления типа делегата — через *delegate_declaration*. Тип делегата является типом класса, который является производным от `System.Delegate`. Типы делегатов являются неявно `sealed`, поэтому не допускается выполнять наследование любого типа является типом делегата. Допускается также не являются производными класса не являющийся делегатом тип из `System.Delegate`. Обратите внимание, что `System.Delegate` является сам по себе не тип делегата; он является типом класса, от которого наследуются все типы делегата.

C# предоставляет специальный синтаксис для делегата при создании экземпляра и вызов. За исключением создания экземпляра любая операция, которая может применяться к классу или экземпляру класса могут также применяться к классу делегата или экземпляр, соответственно. В частности, можно получить доступ к членам `System.Delegate` тип с помощью синтаксиса доступа через обычные члена.

Набор методов, инкапсулированных в экземпляр делегата, называется списком вызовов. При создании экземпляра делегата ([совместимость делегатов](delegates.md#delegate-compatibility)) из одного метода, он инкапсулирует этот метод, и списка вызовов содержит только одну запись. Тем не менее когда объединяются два экземпляра делегата отличное от null, их списки вызовов сцепляются — в порядке слева операнд, а затем правый операнд — для формирования нового списка вызова, который содержит две или несколько записей.

Делегаты объединяются с помощью двоичного файла `+` ([оператор сложения](expressions.md#addition-operator)) и `+=` операторы ([Составное присваивание](expressions.md#compound-assignment)). Делегат можно удалить из нескольких делегатов, с помощью двоичного файла `-` ([оператор вычитания](expressions.md#subtraction-operator)) и `-=` операторы ([Составное присваивание](expressions.md#compound-assignment)). Делегаты можно сравнить на равенство ([делегировать операторы равенства](expressions.md#delegate-equality-operators)).

В следующем примере показано создание нескольких делегатов, и их соответствующие списки вызова:

```csharp
delegate void D(int x);

class C
{
    public static void M1(int i) {...}
    public static void M2(int i) {...}

}

class Test
{
    static void Main() {
        D cd1 = new D(C.M1);      // M1
        D cd2 = new D(C.M2);      // M2
        D cd3 = cd1 + cd2;        // M1 + M2
        D cd4 = cd3 + cd1;        // M1 + M2 + M1
        D cd5 = cd4 + cd3;        // M1 + M2 + M1 + M1 + M2
    }

}
```

Когда `cd1` и `cd2` являются создан, каждый из них инкапсулирует один метод. При `cd3` будет создан, он имеет список вызова из двух методов `M1` и `M2`в этом порядке. `cd4`в список вызова содержит `M1`, `M2`, и `M1`в этом порядке. Наконец `cd5`в список вызова содержит `M1`, `M2`, `M1`, `M1`, и `M2`в этом порядке. Дополнительные примеры объединения делегатов (а также удаления), см. в разделе [вызов делегата](delegates.md#delegate-invocation).

## <a name="delegate-compatibility"></a>Совместимость делегатов

Метод или делегат `M` — ***совместимых*** с типом делегата `D` если выполняются все следующие условия:

*  `D` и `M` имеют одинаковый номер параметров, и каждый параметр в `D` имеет те же `ref` или `out` модификаторы, что и соответствующий параметр в `M`.
*  Для каждого параметра значения (параметр, не имеющий `ref` или `out` модификатор), преобразование идентификации ([преобразование идентификации](conversions.md#identity-conversion)) или неявное преобразование ссылок ([неявные преобразования ссылочных типов](conversions.md#implicit-reference-conversions)) существует от типа параметра в `D` к типу соответствующего параметра в `M`.
*  Для каждого `ref` или `out` параметра, тип параметра в `D` совпадает со значением параметра типа в `M`.
*  Удостоверение или неявное преобразование ссылок существует тип возвращаемого значения `M` для возвращаемого типа `D`.

## <a name="delegate-instantiation"></a>Создание экземпляров делегатов

Созданный экземпляр делегата *delegate_creation_expression* ([выражения создания делегата](expressions.md#delegate-creation-expressions)) или преобразование к типу делегата. Экземпляр созданного делегата затем ссылается один:

*  Ссылки на статический метод *delegate_creation_expression*, или
*  Целевой объект (который не может быть `null`) и ссылки на метод экземпляра *delegate_creation_expression*, или
*  Другой делегат.

Пример:

```csharp
delegate void D(int x);

class C
{
    public static void M1(int i) {...}
    public void M2(int i) {...}
}

class Test
{
    static void Main() { 
        D cd1 = new D(C.M1);        // static method
        C t = new C();
        D cd2 = new D(t.M2);        // instance method
        D cd3 = new D(cd2);        // another delegate
    }
}
```

После создания экземпляра, экземпляры делегата всегда относятся к тем же целевой объект и метод. Помните, что при объединении двух делегатов или удалении одного из другой, результате создается новый делегат со своим собственным списком вызова; списки вызовов делегатов объединять или удалять остаются неизменными.

## <a name="delegate-invocation"></a>Вызов делегатов

C# предоставляет специальный синтаксис для вызова делегата. Когда вызывается экземпляр делегата отличное от null, список вызовов которого содержит одну запись, он вызывает один метод с теми же аргументами, он был задан и возвращает то же значение, как указано в метод. (См. в разделе [вызовы делегатов](expressions.md#delegate-invocations) подробные сведения о вызове делегата.) Если исключение возникает при вызове такого делегата, и это исключение не перехватывается в вызванном методе, поиск предложения перехвата исключения продолжается в методе, который вызывается делегат, как если прямой вызов этого метода метод, к которому делегат называется.

Вызов экземпляр делегата, список вызовов которого содержит несколько записей выполняется путем вызова всех методов в списке вызова синхронно, в порядке. Каждый метод так называемых передается тот же набор параметров, заданный экземпляру делегата. Если такой вызов делегата включает параметры ссылок ([ссылочные параметры](classes.md#reference-parameters)), каждый вызов метода происходит со ссылкой на той же переменной; изменения в эту переменную в списке вызова одного из методов будут Видимый для дальнейшего методы списке вызова. Если вызов делегата включает выходные параметры или возвращаемое значение, их окончательное значение будет получено от вызова последнего делегата в списке.

При возникновении исключения во время обработки вызова такого делегата, и это исключение не перехватывается в вызванном методе, продолжает поиск предложения перехвата исключения в методе, который вызывается делегат, а также любые методы, расположенным ниже список вызовов, не вызываются.

Попытка вызвать экземпляр делегата, значение которого равно null приводят к возникновению исключения типа `System.NullReferenceException`.

В следующем примере показано, как создать экземпляр, объединения, удаления и вызова делегатов:

```csharp
using System;

delegate void D(int x);

class C
{
    public static void M1(int i) {
        Console.WriteLine("C.M1: " + i);
    }

    public static void M2(int i) {
        Console.WriteLine("C.M2: " + i);
    }

    public void M3(int i) {
        Console.WriteLine("C.M3: " + i);
    }
}

class Test
{
    static void Main() { 
        D cd1 = new D(C.M1);
        cd1(-1);                // call M1

        D cd2 = new D(C.M2);
        cd2(-2);                // call M2

        D cd3 = cd1 + cd2;
        cd3(10);                // call M1 then M2

        cd3 += cd1;
        cd3(20);                // call M1, M2, then M1

        C c = new C();
        D cd4 = new D(c.M3);
        cd3 += cd4;
        cd3(30);                // call M1, M2, M1, then M3

        cd3 -= cd1;             // remove last M1
        cd3(40);                // call M1, M2, then M3

        cd3 -= cd4;
        cd3(50);                // call M1 then M2

        cd3 -= cd2;
        cd3(60);                // call M1

        cd3 -= cd2;             // impossible removal is benign
        cd3(60);                // call M1

        cd3 -= cd1;             // invocation list is empty so cd3 is null

        cd3(70);                // System.NullReferenceException thrown

        cd3 -= cd1;             // impossible removal is benign
    }
}
```

Как показано в инструкции `cd3 += cd1;`, делегат могут присутствовать в списке вызова несколько раз. В этом случае он просто вызывается один раз за вхождения. В списке вызова, как это при удалении этого делегата последнего вхождения в списке вызовов является фактически удаляется.

Немедленно до выполнения последнего оператора `cd3 -= cd1;`, делегат `cd3` ссылается на пустой список вызова. Попытка удаления делегата из пустого списка (или удаления несуществующего делегата из списка непустой) не является ошибкой.

— Выходные данные:

```
C.M1: -1
C.M2: -2
C.M1: 10
C.M2: 10
C.M1: 20
C.M2: 20
C.M1: 20
C.M1: 30
C.M2: 30
C.M1: 30
C.M3: 30
C.M1: 40
C.M2: 40
C.M3: 40
C.M1: 50
C.M2: 50
C.M1: 60
C.M1: 60
```
