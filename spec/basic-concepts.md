# <a name="basic-concepts"></a>Основные понятия

## <a name="application-startup"></a>Запуск приложения

Сборка, ***точки входа*** называется ***приложения***. При запуске нового приложения ***домена приложения*** создается. Несколько различных экземпляров приложения могут существовать на одном компьютере, в то же время, и каждый из них имеет свой собственный домен приложения.

Домен приложения обеспечивает изоляцию приложения в качестве контейнера для состояния приложения. Домен приложения выступает в качестве контейнера и границы для типов, определенных в приложении и библиотеки классов, используемые в нем. Типы, загружаемые в один домен приложения отличаются от аналогичных типов, загруженных в другой домен приложения, и экземпляры объектов не применяются напрямую между доменами приложений. Например каждый домен приложения имеет свою собственную копию статических переменных для этих типов, а статический конструктор для типа выполняется не более одного раза каждого домена приложения. Реализации могут использовать реализации политики или механизмы для создания и удаления доменов приложений.

***Запуск приложения*** возникает, когда среда выполнения вызывает указанный метод, который упоминается как точка входа приложения. Этот метод точки входа всегда имеет имя `Main`и может иметь одно из следующих сигнатур:

```csharp
static void Main() {...}

static void Main(string[] args) {...}

static int Main() {...}

static int Main(string[] args) {...}
```

Как показано, точка входа может при необходимости вернуть `int` значение. Эта команда вернуть значение используется в завершение работы приложения ([завершение работы приложения](basic-concepts.md#application-termination)).

Точка входа может иметь один формальный параметр. Параметр может иметь любое имя, но тип параметра должен быть `string[]`. Если этот формальный параметр присутствует, среда выполнения создает и передает `string[]` аргумент, содержащий аргументы командной строки, которые были указано время запуска приложения. `string[]` Аргумент никогда не имеет значение null, но он может иметь нулевую длину, если указаны аргументы командной строки.

Так как C# поддерживает перегрузку методов, класс или структура может содержать несколько определений какого-либо метода предоставляемые каждый имеет другую подпись. Тем не менее, в одной программе, класс или структура может содержать более чем один метод под названием `Main` , определение которого позволяет квалифицировать его для использования в качестве точки входа приложения. Другие перегруженные версии `Main` разрешены, тем не менее, если они имеют более одного параметра, или их единственного параметра отличается от типа `string[]`.

Приложение может состоять из нескольких классов или структур. Это возможно для более чем одного из этих классов или структур, должен содержать метод с именем `Main` , определение которого позволяет квалифицировать его для использования в качестве точки входа приложения. В таких случаях внешнего механизма (например, параметр командной строки компилятора) должен использоваться для выбора одного из этих `Main` методы в качестве точки входа.

В C# каждый метод должен быть определен как член класса или структуры. Как правило, объявленный уровень доступности ([объявленную доступность](basic-concepts.md#declared-accessibility)) метода определяется модификаторы доступа ([модификаторы доступа](classes.md#access-modifiers)) в его объявлении и аналогичным образом объявленный доступность типа определяется модификаторы доступа, указанной в его объявлении. В порядке для данного метода заданного типа быть вызван тип и элемент должны быть доступны. Тем не менее точку входа приложения является особым случаем. В частности среду выполнения можно получить доступ к точке входа приложения, независимо от его объявленный уровень доступности и независимо от того, объявленный уровень доступности его включающего объявлений типов.

Метод точки входа приложения может оказаться в универсальном объявлении класса.

Во всех прочих отношениях методах точек входа ведут себя как те, которые не являются точками входа.

## <a name="application-termination"></a>Завершение работы приложения

***Завершение работы приложения*** возвращает элемент управления в среду выполнения.

Если тип возврата приложения ***точки входа*** метод `int`, возвращаемое значение служит в качестве приложения ***код состояния завершения***. Этот код предназначен для того, чтобы обеспечить обмен данными об успехе или неудаче в среду выполнения.

Если тип возвращаемого значения метода точки входа — `void`, достижение закрывающая фигурная скобка (`}`), завершающий метод или выполнение `return` инструкцию, которая не имеет выражения, приводит код состояния завершения `0`.

Перед завершением работы приложения, вызываются деструкторы для всех объектов, которые еще не был удален сборщиком мусора, если такая очистка не была отключена (путем вызова метода библиотеки `GC.SuppressFinalize`, например).

## <a name="declarations"></a>Объявления

Объявления в программе на C# определяют составные элементы программы. C#, структуре программ с помощью пространств имен ([пространства имен](namespaces.md)), который может содержать тип объявления и объявления вложенного пространства имен. Объявления типов ([объявления типов](namespaces.md#type-declarations)) используются для определения классов ([классы](classes.md)), структуры ([структуры](structs.md)), интерфейсы ([интерфейсы](interfaces.md) ), перечислений ([перечисления](enums.md)) и делегатов ([делегаты](delegates.md)). Типы членов, разрешенных в объявлении типа, зависят от формы объявления типа. Например, класс объявления могут содержать объявления для констант ([константы](classes.md#constants)), поля ([поля](classes.md#fields)), методы ([методы](classes.md#methods)), свойства ([ Свойства](classes.md#properties)), события ([события](classes.md#events)), индексаторов ([индексаторы](classes.md#indexers)), операторы ([операторы](classes.md#operators)), конструкторы экземпляров ([ Конструкторы экземпляров](classes.md#instance-constructors)), статические конструкторы ([статические конструкторы](classes.md#static-constructors)), деструкторы ([деструкторы](classes.md#destructors)) и вложенные типы ([вложенные типы](classes.md#nested-types)).

Объявление определяет имя в ***объявления*** , которому принадлежит объявление. За исключением перегруженных членов ([сигнатуры и перегрузка](basic-concepts.md#signatures-and-overloading)), произошла ошибка во время компиляции, чтобы иметь два или несколько объявлений, представляющих члены с тем же именем в области объявления. Никогда не бывает возможных область объявления для хранения различных видов членов с таким именем. Например, объявление область может не содержать поле и метод с тем же именем.

Существует несколько разных типов областей объявлений, как описано в следующем примере.

*  В рамках всех исходных файлов программы *namespace_member_declaration*s с без заключения *namespace_declaration* являются членами одной комбинированной области объявления вызывается ***глобального область объявления***.
*  В рамках всех исходных файлов программы *namespace_member_declaration*s в *namespace_declaration*, иметь то же имя полного пространства имен являются членами одно объединенное объявление пространство.
*  Каждого класса, структуры или интерфейса объявление создает новую область объявления. Имена вводятся в эту область объявления через *class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s, или *параметр_типа*s. За исключением экземпляра перегруженный конструктор объявления и статический конструктор, объявления, класс или структура не может содержать объявление члена с тем же именем, что класс или структура. Класс, структура или интерфейс допускает объявление перегруженных методов и индексаторов. Кроме того класс или структура допускает объявление перегруженных конструкторов экземпляров и операторов. Например, класса, структуры или интерфейса может содержать несколько объявлений методов с тем же именем, предоставляемых эти объявления методов отличаются по сигнатуре ([сигнатуры и перегрузка](basic-concepts.md#signatures-and-overloading)). Обратите внимание, что базовые классы не включаются в области объявления класса базовые интерфейсы не включаются в области объявления интерфейса. Таким образом производный класс или интерфейс может объявить элемент с таким именем наследуемого члена. Такой элемент считается ***скрыть*** наследуемый член.
*  Каждое объявление делегата создает новую область объявления. Имена вводятся в эту область объявления через формальных параметров (*fixed_parameter*s и *parameter_array*s) и *параметр_типа*s.
*  Каждое объявление перечисления создает новую область объявления. Имена вводятся в эту область объявления через *enum_member_declarations*.
*  Каждый объявление метода, объявление индексатора, объявление оператора, объявление конструктора экземпляра и анонимная функция создает новую область объявления вызывается ***области объявления локальных переменных***. Имена вводятся в эту область объявления через формальных параметров (*fixed_parameter*s и *parameter_array*s) и *параметр_типа*s. Тело функции-члена или анонимной функции, если таковые имеются, считается вкладываются в области объявления локальных переменных. Это ошибка для области объявления локальных переменных и вложенных в объявлении локальной переменной пробел будет содержать элементы с одинаковым именем. Таким образом внутри вложенной области объявления он не поддерживается для объявления локальной переменной или константы с тем же именем, как локальная переменная или константа в родительской области объявления. Это возможно для двух пространств объявления могут содержать элементы с тем же именем, до тех пор, пока ни одна из области объявления содержит другой.
*  Каждый *блок* или *switch_block* , а также *для*, *foreach* и *с помощью* создает инструкцию, в объявлении локальной переменной пространства для локальных переменных и локальные константы. Имена вводятся в эту область объявления через *local_variable_declaration*s и *local_constant_declaration*s. Обратите внимание, что блоки, возникающие в качестве или в теле функции-члена или анонимной функции вложены в области объявления локальных переменных, объявленных этими функциями для соответствующих параметров. Таким образом, это ошибка, например с помощью метода с локальной переменной и параметр с тем же именем.
*  Каждый *блок* или *switch_block* создает отдельную область объявления для меток. Имена вводятся в эту область объявления через *labeled_statement*s и имена указаны через *goto_statement*s. ***Метки объявления*** блока содержит любые вложенные блоки. Таким образом внутри вложенного блока не невозможно объявить метку с тем же именем, как метка во внешнем блоке.

Текстовом порядке, в котором объявлены имен обычно является не имеет значения. В частности текстовый порядок не имеет значения для объявления и использования пространств имен, константы, методы, свойства, события, индексаторы, операторы, конструкторы экземпляров, деструкторы, статических конструкторов и типов. Порядок объявления имеет одним из следующих способов:

*  Порядок объявления поля и локальных переменных определяет порядок, в котором выполняются их инициализаторы (если таковые имеются).
*  Локальные переменные должны быть определены, до их использования ([областей](basic-concepts.md#scopes)).
*  Порядок объявления членов перечисления ([члены перечисления](enums.md#enum-members)) действителен, когда *constant_expression* значения опускаются.

Объявление пространства имен является «Многовариантный формат» и два пространства имен, объявления с тем же полным именем размещаются в одном пространстве объявлений. Пример
```csharp
namespace Megacorp.Data
{
    class Customer
    {
        ...
    }
}

namespace Megacorp.Data
{
    class Order
    {
        ...
    }
}
```

Два объявления пространства имен выше, размещаются в одной области объявления, в этом случае объявляются два класса с полными доменными именами `Megacorp.Data.Customer` и `Megacorp.Data.Order`. Поскольку два объявления размещаются в одном пространстве объявлений, происходит ошибка времени компиляции, если каждый содержащийся в объявлении класса с тем же именем.

Как указано выше в области объявления блока включает любые вложенные блоки. Таким образом, в следующем примере `F` и `G` методы к ошибке во время компиляции, так как имя `i` объявляется во внешнем блоке и не может быть повторно объявлена во внутреннем блоке. Тем не менее `H` и `I` методы являются допустимыми, так как два `i`объявляются в отдельных блоках невложенными.

```csharp
class A
{
    void F() {
        int i = 0;
        if (true) {
            int i = 1;            
        }
    }

    void G() {
        if (true) {
            int i = 0;
        }
        int i = 1;                
    }

    void H() {
        if (true) {
            int i = 0;
        }
        if (true) {
            int i = 1;
        }
    }

    void I() {
        for (int i = 0; i < 10; i++)
            H();
        for (int i = 0; i < 10; i++)
            H();
    }
}
```

## <a name="members"></a>Участники

Пространства имен и типы имеют ***члены***. Элементы сущности являются общедоступными при помощи полного имени, начинающийся со ссылкой на сущность, а затем "`.`" маркеров, а затем имя члена.

Члены типа либо объявляются в объявлении типа или ***наследуется*** от базового класса типа. Если тип наследуется от базового класса, все члены базового класса, за исключением конструкторы экземпляров, деструкторы и статические конструкторы, становятся членами производного типа. Объявленный уровень доступности члена базового класса не контролирует, наследуется ли член — наследование распространяется на любой элемент, который не конструктор экземпляра, статический конструктор или деструктор. Тем не менее, унаследованный член могут оказаться недоступным в производном типе, либо из-за его объявленный уровень доступности ([объявленную доступность](basic-concepts.md#declared-accessibility)) либо потому, что он скрыт путем объявления в самом типе ([скрытие через наследование](basic-concepts.md#hiding-through-inheritance)).

### <a name="namespace-members"></a>Члены пространства имен

Пространства имен и типов, имеющих без вмещающего пространства имен являются членами ***глобальное пространство имен***. Это непосредственно соответствует именам, объявленным в глобальной области объявления.

Пространства имен и типы, объявленные в пространстве имен являются членами этого пространства имен. Это соответствует непосредственно имена, объявленные в области объявления пространства имен.

Пространства имен не имеют ограничений доступа. Невозможно объявить закрытого, защищенного или внутреннего пространства имен и пространств имен всегда являются общедоступными.

### <a name="struct-members"></a>Члены структуры

Члены структуры — члены, объявленные в структуре и члены, унаследованные от структуры прямой базовый класс `System.ValueType` и косвенный базовый класс `object`.

Элементы простого типа непосредственно соответствуют члены типа структуры с псевдонимами по простому типу.

*  Члены `sbyte` являются членами `System.SByte` структуры.
*  Члены `byte` являются членами `System.Byte` структуры.
*  Члены `short` являются членами `System.Int16` структуры.
*  Члены `ushort` являются членами `System.UInt16` структуры.
*  Члены `int` являются членами `System.Int32` структуры.
*  Члены `uint` являются членами `System.UInt32` структуры.
*  Члены `long` являются членами `System.Int64` структуры.
*  Члены `ulong` являются членами `System.UInt64` структуры.
*  Члены `char` являются членами `System.Char` структуры.
*  Члены `float` являются членами `System.Single` структуры.
*  Члены `double` являются членами `System.Double` структуры.
*  Члены `decimal` являются членами `System.Decimal` структуры.
*  Члены `bool` являются членами `System.Boolean` структуры.

### <a name="enumeration-members"></a>Члены перечисления

Члены перечисления — константы, объявленные в перечислении и члены, унаследованные от прямого базового класса перечисления `System.Enum` и косвенных базовых классов `System.ValueType` и `object`.

### <a name="class-members"></a>Члены класса

Члены класса — члены, объявленные в классе и члены, унаследованные от базового класса (за исключением класса `object` которого не имеет базового класса). Члены, унаследованные от базового класса включают константы, поля, методы, свойства, события, индексаторы, операторы и типы базового класса, но не конструкторы экземпляров, деструкторы и статические конструкторы базового класса. Члены базового класса наследуются вне зависимости от их доступности.

Объявление класса может содержать объявления константы, поля, методы, свойства, события, индексаторы, операторы, конструкторы экземпляров, деструкторы, статических конструкторов и типов.

Члены `object` и `string` напрямую соответствуют члены класса типов они псевдоним:

*  Члены `object` являются членами `System.Object` класса.
*  Члены `string` являются членами `System.String` класса.

### <a name="interface-members"></a>Члены интерфейса

Члены интерфейса являются члены, объявленные в интерфейсе и во всех интерфейсах базового интерфейса. Члены в классе `object` — нет, строго говоря, членами какого-либо интерфейса ([члены интерфейса](interfaces.md#interface-members)). Тем не менее элементы в классе `object` доступны через поиск члена в любой другой тип интерфейса ([поиск члена](expressions.md#member-lookup)).

### <a name="array-members"></a>Члены массива

Элементы массива являются члены, унаследованные от класса `System.Array`.

### <a name="delegate-members"></a>Члены делегата

Членами делегата являются члены, унаследованные от класса `System.Delegate`.

## <a name="member-access"></a>Доступ к членам

Объявления членов позволяют контролировать доступ к членам. Доступность члена устанавливается посредством объявленный уровень доступности ([объявленную доступность](basic-concepts.md#declared-accessibility)) члена в сочетании с доступности непосредственно вмещающего его типа, если таковые имеются.

Если разрешен доступ к конкретному элементу, элемент считается ***доступный***. И наоборот, если запрещен доступ к конкретному элементу, элемент считается ***недоступным***. Доступ к члену разрешен при фактическом, в котором происходит доступ в домен доступности ([области доступности](basic-concepts.md#accessibility-domains)) элемента.

### <a name="declared-accessibility"></a>Объявленная доступность

***Объявленную доступность*** члена может принимать одно из следующих:

*  Public, который можно выбрать, включив `public` модификатор в объявлении члена. Интуитивно понятный значение `public` «доступ не ограничен».
*  Защищенные, который выбран, включив `protected` модификатор в объявлении члена. Интуитивно понятный значение `protected` является «доступ ограничен содержащим классом или типами производным от содержащего класса».
*  Внутренний, который можно выбрать, включив `internal` модификатор в объявлении члена. Интуитивно понятный значение `internal` является «доступ возможен только из этой программы».
*  Защищенный внутренний (то есть защищенные или внутренние), который выбран, включая `protected` и `internal` модификатор в объявлении члена. Интуитивно понятный значение `protected internal` «доступ возможен только из этой программы или типам, производным от содержащего класса».
*  Private, который можно выбрать, включив `private` модификатор в объявлении члена. Интуитивно понятный значение `private` является «доступ возможен только из содержащего типа».

В зависимости от контекста, в котором происходит объявление члена поместить, разрешены только определенные типы объявленный уровень доступности. Кроме того при объявлении члена не включает модификаторы доступа, контекст, в котором происходит объявление определяет объявленную доступность по умолчанию.

*  Пространства имен неявно имеют `public` объявленную доступность. Модификаторы доступа не разрешены в объявлениях пространств имен.
*  Типы, объявленные в единицах компиляции или пространства имен могут иметь `public` или `internal` объявлен специальных возможностей и по умолчанию `internal` объявленную доступность.
*  Члены класса могут иметь любые пять видов объявленный уровень доступности и по умолчанию `private` объявленную доступность. (Обратите внимание, что тип, объявленный как член класса могут содержать любой из пяти типов объявленный уровень доступности, в то время как тип объявлен как члена пространства имен может иметь только `public` или `internal` объявленную доступность.)
*  Члены структуры могут иметь `public`, `internal`, или `private` объявлен специальных возможностей и по умолчанию `private` объявленную доступность, поскольку структуры неявно запечатаны. Члены структуры, размещенные в структуре (который не наследуется эта структура) не может иметь `protected` или `protected internal` объявленную доступность. (Обратите внимание, что тип, объявленный член структуры могут иметь `public`, `internal`, или `private` объявленную доступность, тогда как тип объявлен как члена пространства имен может иметь только `public` или `internal` объявленную доступность.)
*  Члены интерфейса неявно имеют `public` объявленную доступность. Модификаторы доступа не разрешены в объявлениях членов интерфейса.
*  Члены перечисления неявно имеют `public` объявленную доступность. Модификаторы доступа не разрешены в объявлениях членов перечислений.

### <a name="accessibility-domains"></a>Области доступности

***Домен доступности*** члена состоит из (возможно, не связанных) разделов текста программы, в которой разрешен доступ к члену. В целях определения область доступности члена считается членом ***верхнего уровня*** если он не объявлен внутри типа и члена считается ***вложенных*** если он объявлен внутри другого типа. Кроме того ***программы текст*** программы определяется, как все программы текст, содержащийся во всех исходных файлах программы, а текст программы типа определяется как все программы текст, содержащийся в *type_declaration*s этого типа (включая, возможно, типы, вложенные в тип).

Домен доступности предопределенного типа (например, `object`, `int`, или `double`) не ограничено.

Домен доступности верхнего уровня, не привязанный тип `T` ([привязан и несвязанные типы](types.md#bound-and-unbound-types)), объявленным в программе `P` определяется следующим образом:

*  Если объявленный уровень доступности `T` — `public`, то домен доступности `T` — это текст программы `P` и любой программы, которая ссылается на `P`.
*  Если объявленный уровень доступности `T` — `internal`, то домен доступности `T` совпадает с текстом программы `P`.

Из этих определений следует, что область доступности типа верхнего уровня свободной всегда является по крайней мере текст программы, программы, в которой данный тип объявлен.

Домен доступности для сконструированного типа `T<A1, ..., An>` представляет собой пересечение домена доступности несвязанного универсального типа `T` и доменов доступности аргументов типа `A1, ..., An`.

Домен доступности вложенного члена `M` , объявленного в типе `T` в рамках программы `P` определяется следующим образом (отметить, что `M` сам может являться типом):

*  Если объявленный уровень доступности `M` — `public`, то домен доступности `M` совпадает с доменом доступности `T`.
*  Если объявленный уровень доступности `M` — `protected internal`, позволяют `D` объединяются с текстом программы `P` и текстом программы любого типа, производный от `T`, который объявляется за пределами `P`. Домен доступности `M` представляет собой пересечение домена доступности `T` с `D`.
*  Если объявленный уровень доступности `M` — `protected`, позволяют `D` объединяются с текстом программы `T` и текстом программы любого типа, производный от `T`. Домен доступности `M` представляет собой пересечение домена доступности `T` с `D`.
*  Если объявленный уровень доступности `M` — `internal`, то домен доступности `M` представляет собой пересечение домена доступности `T` с текстом программы `P`.
*  Если объявленный уровень доступности `M` — `private`, то домен доступности `M` совпадает с текстом программы `T`.

Из этих определений следует, что домен доступности вложенного члена всегда является по крайней мере текст программы типа, в котором объявлен этот элемент. Кроме того следует, что область доступности члена никогда не является больше объектов, чем область доступности типа, в котором объявлен этот элемент.

Интуитивно понятно когда тип или член `M` имеет доступ, чтобы убедиться, что доступ разрешается вычисляются следующие шаги:

*  Во-первых, если `M` объявлены внутри типа (в отличие от единице компиляции или пространстве имен), ошибка времени компиляции возникает, если этот тип не является доступным.
*  Затем, если `M` является `public`, доступ разрешается.
*  В противном случае, если `M` — `protected internal`, доступ разрешается в том случае, если он встречается в программе, в которой `M` был объявлен, или если он встречается в класс, производный от класса, в котором `M` объявлен и осуществляется через производные тип класса ([защищенного доступа для экземпляра к членам](basic-concepts.md#protected-access-for-instance-members)).
*  В противном случае, если `M` — `protected`, доступ разрешается в том случае, если он встречается в класс, в котором `M` был объявлен, или если он встречается в класс, производный от класса, в котором `M` объявлен и осуществляется через производные тип класса ([защищенного доступа для экземпляра к членам](basic-concepts.md#protected-access-for-instance-members)).
*  В противном случае, если `M` — `internal`, доступ разрешается в том случае, если он встречается в программе, в которой `M` объявлен.
*  В противном случае, если `M` — `private`, доступ разрешается в том случае, если он встречается в тип, в которой `M` объявлен.
*  В противном случае тип или член недоступен, и возникает ошибка времени компиляции.

В примере
```csharp
public class A
{
    public static int X;
    internal static int Y;
    private static int Z;
}

internal class B
{
    public static int X;
    internal static int Y;
    private static int Z;

    public class C
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }

    private class D
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }
}
```
классы и члены имеют следующие области доступности:

*  Домен доступности `A` и `A.X` не ограничено.
*  Домен доступности `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X`, и `B.C.Y` совпадает с текстом программы содержания программы.
*  Домен доступности `A.Z` — это текст программы `A`.
*  Домен доступности `B.Z` и `B.D` — это текст программы `B`, включая текст программы `B.C` и `B.D`.
*  Домен доступности `B.C.Z` — это текст программы `B.C`.
*  Домен доступности `B.D.X` и `B.D.Y` — это текст программы `B`, включая текст программы `B.C` и `B.D`.
*  Домен доступности `B.D.Z` — это текст программы `B.D`.

Как показано в примере, то домен доступности члена никогда не должен превышать, содержащего типа. Например несмотря на то что все `X` члены имеют открытый объявленный уровень доступности, все, кроме `A.X` имеют области доступности, ограниченные содержащего типа.

Как описано в разделе [члены](basic-concepts.md#members), все члены базового класса, за исключением случаев, например, конструкторы, деструкторы и статические конструкторы, наследуются производными типами. Это касается даже закрытых членов базового класса. Однако домен доступности закрытого члена содержит только текст программы типа, в котором объявлен этот элемент. В примере
```csharp
class A
{
    int x;

    static void F(B b) {
        b.x = 1;        // Ok
    }
}

class B: A
{
    static void F(B b) {
        b.x = 1;        // Error, x not accessible
    }
}
```
`B` класс наследует закрытый член `x` из `A` класса. Так как член является закрытым, он был доступен только в пределах *class_body* из `A`. Таким образом, доступ к `b.x` успешно `A.F` метод, но завершается с ошибкой `B.F` метод.

### <a name="protected-access-for-instance-members"></a>Защищенный доступ для членов экземпляров.

Когда `protected` доступ к члену экземпляра вне класса, в котором он объявлен, текста и когда `protected internal` доступ к члену экземпляра вне текста программы, в котором он объявлен, доступ должен осуществляться в объявление класса, производного от класса, в котором она объявлена. Кроме того должно выполняться через экземпляр производного типа класса или типа класса, созданный из них необходим доступ. Это ограничение предотвращает доступ к защищенным членам другого производного класса, даже в том случае, если члены наследуются от одного базового класса одного производного класса.

Позвольте `B` быть базовым классом, который объявляет член защищенный экземпляр `M`и позволить `D` быть класс, производный от `B`. В рамках *class_body* из `D`, доступ к `M` может принимать одно из следующих форм:

*  Неопределенного *type_name* или *primary_expression* формы `M`.
*  Объект *primary_expression* формы `E.M`, предоставленный тип `E` — `T` или класс, производный от `T`, где `T` является типом класса `D`, или тип класса создан на основе `D`
*  Объект *primary_expression* формы `base.M`.

Помимо этих форм доступа производный класс может обращаться к защищенный экземпляр конструктора базового класса в *constructor_initializer* ([инициализаторы конструктора](classes.md#constructor-initializers)).

В примере
```csharp
public class A
{
    protected int x;

    static void F(A a, B b) {
        a.x = 1;        // Ok
        b.x = 1;        // Ok
    }
}

public class B: A
{
    static void F(A a, B b) {
        a.x = 1;        // Error, must access through instance of B
        b.x = 1;        // Ok
    }
}
```
в рамках `A`, имеется возможность доступа `x` через экземпляры оба `A` и `B`, так как в любом случае доступ осуществляется через экземпляр `A` или класс, производный от `A`. Тем не менее, в пределах `B`, невозможно получить доступ к `x` через экземпляр `A`, так как `A` является производным от `B`.

В примере
```csharp
class C<T>
{
    protected T x;
}

class D<T>: C<T>
{
    static void F() {
        D<T> dt = new D<T>();
        D<int> di = new D<int>();
        D<string> ds = new D<string>();
        dt.x = default(T);
        di.x = 123;
        ds.x = "test";
    }
}
```
три присваивания `x` разрешены, так как они все осуществляются через экземпляры типов классов, созданный из универсального типа.

### <a name="accessibility-constraints"></a>Ограничения доступности

Несколько конструкций на языке C# требуют, чтобы быть ***по крайней мере такой же уровень доступности, как*** члена или другого типа. Тип `T` говорят, что по крайней мере такой же уровень доступности, как член или тип `M` Если домен доступности `T` является надмножеством то домен доступности `M`. Другими словами `T` — по крайней мере такой же уровень доступности, как `M` Если `T` доступен во всех контекстах, в котором `M` доступен.

Существуют следующие ограничения доступности:

*  Прямой базовый класс для типа класса должен иметь по крайней мере такой же уровень доступности, как и сам тип класса.
*  Явные базовые интерфейсы для типа интерфейса должны иметь по крайней мере такой же уровень доступности, как и сам тип интерфейса.
*  Тип возвращаемого значения и типы параметров для типа делегата должны иметь по крайней мере такой же уровень доступности, как и сам тип делегата.
*  Тип константы должен иметь по крайней мере такой же уровень доступности, как и сама константа.
*  Тип поля должен иметь по крайней мере такой же уровень доступности, как и само поле.
*  Тип возвращаемого значения и типы параметров для метода должны иметь по крайней мере такой же уровень доступности, как и сам метод.
*  Тип свойства должен иметь по крайней мере такой же уровень доступности, как и само свойство.
*  Тип события должен иметь по крайней мере такой же уровень доступности, как и само событие.
*  Тип и типы параметров для индексатора должны иметь по крайней мере такой же уровень доступности, как и сам индексатор.
*  Тип возвращаемого значения и типы параметров для оператора должны иметь по крайней мере такой же уровень доступности, как и сам оператор.
*  Типы параметров конструктора экземпляра должно быть по крайней мере такой же уровень доступности, как и сам конструктор экземпляра.

В примере
```csharp
class A {...}

public class B: A {...}
```
`B` класса приводит к ошибке времени компиляции, так как `A` не является по крайней мере такой же уровень доступности, как `B`.

Аналогичным образом в примере
```csharp
class A {...}

public class B
{
    A F() {...}

    internal A G() {...}

    public A H() {...}
}
```
`H` метод в `B` приводит к ошибке времени компиляции, так как тип возвращаемого значения, `A` не является по крайней мере такой же уровень доступности, что и метод.

## <a name="signatures-and-overloading"></a>Сигнатуры и перегрузка

Методы, конструкторы экземпляров, индексаторы и операторы характеризуются их ***подписи***:

*  Сигнатура метода состоит из имени метода, количество параметров типа и типа и вида (значение, ссылку или вывод) каждого из своих формальных параметров, считается в порядке слева направо. Для этих целей любого параметра типа метода, который происходит в тип формального параметра идентифицируется не по имени, а также по ее порядковому номеру в списке аргументов типа метода. Сигнатура метода специально не поддерживает тип возвращаемого значения, `params` модификатор, который может быть указан для параметра справа, а также дополнительных ограничений параметра типа.
*  Сигнатура конструктора экземпляра состоит из типа и вида (значение, ссылку или вывод) каждого из своих формальных параметров, считается в порядке слева направо. Сигнатура конструктора экземпляра специально не содержит `params` модификатор, который может быть указан для параметра крайнее правое.
*  Сигнатура индексатора состоит из типа каждого из своих формальных параметров, считается в порядке слева направо. Сигнатура индексатора специально не содержит тип элемента, а также `params` модификатор, который может быть указан для параметра крайнее правое.
*  Сигнатура оператора состоит из имени оператора и типа каждого из своих формальных параметров, считается в порядке слева направо. Сигнатура оператора специально не поддерживает тип результата.

Использование механизма имеют сигнатуры ***перегрузка*** членов классов, структур и интерфейсов:

*  Перегрузка методов позволяет класса, структуры или интерфейса, чтобы объявить несколько методов с тем же именем, предоставляемые их подписи должны быть уникальными в пределах этого класса, структуры или интерфейса.
*  Перегрузка конструкторов экземпляров позволяет класса или структуры, чтобы объявить несколько конструкторов экземпляров, при условии, что их сигнатуры являются уникальными в пределах класса или структуры.
*  Перегрузка индексаторов позволяет класса, структуры или интерфейса, чтобы объявить несколько индексаторов, при условии, что их сигнатуры являются уникальными в пределах этого класса, структуры или интерфейса.
*  Перегрузка операторов позволяет классу или структуре объявить несколько операторов с тем же именем, предоставляемые их подписи должны быть уникальными в пределах класса или структуры.

Несмотря на то что `out` и `ref` модификаторов параметров, считаются частью сигнатуры, члены, объявленные в одном типе не могут различаться в сигнатуре исключительно записью `ref` и `out`. Ошибка времени компиляции возникает, если два объявления членов в тот же тип, с сигнатурами, которые бы прежним, если все параметры в обоих методах с `out` модификаторы были изменены для `ref` модификаторы. Для других целей соответствия сигнатур (например, скрытие или переопределение), `ref` и `out` считаются частью сигнатуры и не соответствуют друг другу. (Это ограничение является возможность C# программами легко перевести для запуска на Common Language Infrastructure (CLI), который не предоставляет способ определения методов, которые отличаются только в `ref` и `out`.)

В рамках подписи, типы `object` и `dynamic` считаются одинаковыми. Члены, объявленные в одном типе, могут не отличаться в сигнатуре исключительно записью `object` и `dynamic`.

Следующий пример показывает набор объявлений перегруженных методов с их сигнатурами.
```csharp
interface ITest
{
    void F();                        // F()

    void F(int x);                   // F(int)

    void F(ref int x);               // F(ref int)

    void F(out int x);               // F(out int)      error

    void F(int x, int y);            // F(int, int)

    int F(string s);                 // F(string)

    int F(int x);                    // F(int)          error

    void F(string[] a);              // F(string[])

    void F(params string[] a);       // F(string[])     error
}
```

Обратите внимание, что все `ref` и `out` модификаторов параметров ([параметры метода](classes.md#method-parameters)) являются частью сигнатуры. Таким образом `F(int)` и `F(ref int)` являются уникальные сигнатуры. Тем не менее `F(ref int)` и `F(out int)` нельзя объявлять в тот же интерфейс, так как их сигнатуры разные исключительно записью `ref` и `out`. Кроме того, обратите внимание, что тип возвращаемого значения и `params` модификатор не являются частью сигнатуры, поэтому невозможно перегружать исключительно на основе, тип возвращаемого значения или включение или исключение `params` модификатор. Таким образом, объявления методов `F(int)` и `F(params string[])` указанных выше приводят к ошибке времени компиляции.

## <a name="scopes"></a>Области

***Область*** имени является область текста программы, в течение которого можно будет ссылаться на сущность, объявленное имя без уточнения имени. Области могут быть ***вложенных***, и внутренней области может повторно объявить значение имени из внешней области (это не так, однако удалить ограничение, наложенное [объявления](basic-concepts.md#declarations) внутри вложенного блока не Возможно, чтобы объявить локальную переменную с тем же именем, как локальную переменную во внешнем блоке). Имя из внешней области затем считается ***скрытые*** в регионе программы текста, связанная с внутренней области, и доступ к внешним именем возможна только путем указания имени.

*  Областью члена пространства имен, объявленного *namespace_member_declaration* ([члены пространства имен](namespaces.md#namespace-members)) с без заключения *namespace_declaration* является всей программе текст.
*  Областью члена пространства имен, объявленного *namespace_member_declaration* в *namespace_declaration* полное имя которого является `N` — *namespace_body*  из каждого *namespace_declaration* полное имя которого является `N` или начинается с `N`, а затем по периоду.
*  Область определяется *extern_alias_directive* распространяется *using_directive*s, *global_attributes* и *namespace_member_ объявление*s его непосредственно вмещающего компиляции единицы или пространства имен текста. *Extern_alias_directive* не размещает новые члены в основной области объявления. Другими словами *extern_alias_directive* не является транзитивным, но, скорее, влияет только на компиляцию единицы или пространства имен тело в которой оно встречается.
*  Область имени определен и не импортирован *using_directive* ([директив Using](namespaces.md#using-directives)) распространяется *namespace_member_declaration*s из  *compilation_unit* или *namespace_body* в котором *using_directive* происходит. Объект *using_directive* можно освободить ноль или несколько имен пространства имен, типа или члена в пределах определенного *compilation_unit* или *namespace_body*, в отличие от размещает новые члены в основной области объявления. Другими словами *using_directive* не является транзитивным, а скорее влияет только *compilation_unit* или *namespace_body* в котором он используется.
*  Областью параметра типа, объявленного *type_parameter_list* на *class_declaration* ([объявлений классов](classes.md#class-declarations)) является *class_base*, *type_parameter_constraints_clause*s, и *class_body* , *class_declaration*.
*  Областью параметра типа, объявленного *type_parameter_list* на *struct_declaration* ([объявления структур](structs.md#struct-declarations)) является *struct_interfaces* , *type_parameter_constraints_clause*s, и *struct_body* , *struct_declaration*.
*  Областью параметра типа, объявленного *type_parameter_list* на *interface_declaration* ([объявления интерфейсов](interfaces.md#interface-declarations)) является *interface_base* , *type_parameter_constraints_clause*s, и *interface_body* , *interface_declaration*.
*  Областью параметра типа, объявленного *type_parameter_list* на *delegate_declaration* ([объявления делегатов](delegates.md#delegate-declarations)) является *return_type*, *formal_parameter_list*, и *type_parameter_constraints_clause*s, *delegate_declaration*.
*  Областью члена, объявленного *class_member_declaration* ([класса текст](classes.md#class-body)) является *class_body* в котором содержится объявление. Кроме того, область члена класса расширяется до *class_body* из этих производных классов, включенных в домен доступности ([области доступности](basic-concepts.md#accessibility-domains)) элемента.
*  Областью члена, объявленного *struct_member_declaration* ([члены структуры](structs.md#struct-members)) является *struct_body* в котором содержится объявление.
*  Областью члена, объявленного *enum_member_declaration* ([члены перечисления](enums.md#enum-members)) является *enum_body* в котором содержится объявление.
*  Областью параметра, объявленного в *method_declaration* ([методы](classes.md#methods)) является *method_body* , *method_declaration*.
*  Областью параметра, объявленного в *indexer_declaration* ([индексаторы](classes.md#indexers)) является *accessor_declarations* , *indexer_declaration*.
*  Областью параметра, объявленного в *operator_declaration* ([операторы](classes.md#operators)) является *блок* , *operator_declaration*.
*  Областью параметра, объявленного в *constructor_declaration* ([конструкторы экземпляров](classes.md#instance-constructors)) является *constructor_initializer* и *блок* , *constructor_declaration*.
*  Областью параметра, объявленного в *lambda_expression* ([выражения анонимных функций](expressions.md#anonymous-function-expressions)) является *anonymous_function_body* , *lambda_ выражение*
*  Областью параметра, объявленного в *anonymous_method_expression* ([выражения анонимных функций](expressions.md#anonymous-function-expressions)) является *блок* , *anonymous_method _expression*.
*  Областью метки, объявленной в *labeled_statement* ([с меткой инструкции](statements.md#labeled-statements)) является *блок* в котором содержится объявление.
*  Локальная переменная, объявленная в области *local_variable_declaration* ([объявления локальных переменных](statements.md#local-variable-declarations)) представляет собой блок, в котором содержится объявление.
*  Локальная переменная, объявленная в области *switch_block* из `switch` инструкции ([оператора switch](statements.md#the-switch-statement)) является *switch_block*.
*  Локальная переменная, объявленная в области *for_initializer* из `for` инструкции ([для инструкции](statements.md#the-for-statement)) является *for_initializer*,  *for_condition*, *for_iterator*и содержащиеся в нем *инструкции* из `for` инструкции.
*  Областью локальной константы, объявленной в *local_constant_declaration* ([локального объявления констант](statements.md#local-constant-declarations)) представляет собой блок, в котором содержится объявление. Произошла ошибка во время компиляции, для ссылки на локальную константу в позиции текста, который предшествует его *constant_declarator*.
*  Областью переменной, объявленной как часть *foreach_statement*, *using_statement*, *lock_statement* или *query_expression* — определить с помощью расширения заданной конструкции.

В пределах пространства имен, класса, структуры или перечисления элементов можно ссылаться на элемент в позиции текста, который предшествует объявление члена. Пример
```csharp
class A
{
    void F() {
        i = 1;
    }

    int i = 0;
}
```
Здесь, он является действительным для `F` для ссылки на `i` до ее объявления.

В области локальной переменной, это ошибка времени компиляции для ссылки на локальную переменную в позиции текста, который предшествует *local_variable_declarator* локальной переменной. Пример
```csharp
class A
{
    int i = 0;

    void F() {
        i = 1;                  // Error, use precedes declaration
        int i;
        i = 2;
    }

    void G() {
        int j = (j = 1);        // Valid
    }

    void H() {
        int a = 1, b = ++a;    // Valid
    }
}
```

В `F` описанный выше метод, первое присваивание `i` специально не ссылается на поле, объявленное во внешней области. Вместо этого он ссылается на локальную переменную, и он приводит к ошибке компиляции, так как присваивание предшествует объявление переменной. В `G` метод, использование `j` в инициализаторе для объявления `j` является допустимым, поскольку использование не предшествует *local_variable_declarator*. В `H` метод, последующая *local_variable_declarator* правильно ссылается локальная переменная, объявленная в предыдущем шаге *local_variable_declarator* внутри того же  *local_variable_declaration*.

Правила выбора области для локальных переменных разработаны для того, что значение имени, используемого в контексте выражения остается неизменным в пределах блока. Если область локальной переменной расширить только из ее объявления в конце блока, в приведенном выше примере первое присваивание будет назначен переменной экземпляра и второе назначение будет присвоен локальной переменной, может привести к ошибки времени компиляции, если были более поздней версии, изменять порядок инструкций блока.

Значение имени в пределах блока может отличаться в зависимости от контекста, в котором используется имя. В примере
```csharp
using System;

class A {}

class Test
{
    static void Main() {
        string A = "hello, world";
        string s = A;                            // expression context

        Type t = typeof(A);                      // type context

        Console.WriteLine(s);                    // writes "hello, world"
        Console.WriteLine(t);                    // writes "A"
    }
}
```
имя `A` используется в контексте выражения для ссылки на локальную переменную `A` и в контексте типа для ссылки на класс `A`.

### <a name="name-hiding"></a>Скрытие имен

Область сущности обычно включает в себя текст программы большего размера области объявления сущности. В частности область сущности может содержать объявления, которые вводят новые области объявлений, содержащие сущности с тем же именем. Такие объявления вызывают исходная сущность становится ***скрытые***. И наоборот, сущность считается ***видимым*** если он не скрыт.

Скрытие имен происходит, когда перекрываются областей через вложений и при перекрытии областей через наследование. В следующих разделах описываются характеристики двух типов скрытия.

#### <a name="hiding-through-nesting"></a>Скрытие помощью вложения

Скрытие имен через вложенности может произойти в результате вложения пространств имен или типов в пространствах имен, в результате вложения типов внутри классов или структур, а также из-за параметра и объявлений локальных переменных.

В примере
```csharp
class A
{
    int i = 0;

    void F() {
        int i = 1;
    }

    void G() {
        i = 1;
    }
}
```
в рамках `F` метода, переменной экземпляра `i` скрыт локальной переменной `i`, но в `G` метод, `i` по-прежнему ссылается на переменную экземпляра.

Когда имя во внутренней области скрывает имя во внешней области, он скрывает все перегруженные вхождения этого имени. В примере
```csharp
class Outer
{
    static void F(int i) {}

    static void F(string s) {}

    class Inner
    {
        void G() {
            F(1);              // Invokes Outer.Inner.F
            F("Hello");        // Error
        }

        static void F(long l) {}
    }
}
```
вызов `F(1)` вызывает `F` объявленные в `Inner` так как все внешние вхождения `F` скрыты по внутренним объявлением. По этой же причине, вызов `F("Hello")` приводит к ошибке времени компиляции.

#### <a name="hiding-through-inheritance"></a>Скрытие через наследование

Скрытие имен через наследование происходит, когда классы или структуры повторного объявления имен, унаследованные от базовых классов. Этот тип скрытии имен принимает одно из следующих форм:

*  Константа, поле, свойство, событие или тип, представленный в классе или структуре, скрывает все члены базового класса с тем же именем.
*  Метод, представленный в классе или структуре, скрывает все члены базового класса не метод с тем же именем, а также все методы базового класса с такой же сигнатурой (имя метода и число параметров, модификаторы и типы).
*  Индексатор, представленный в классе или структуре, скрывает все индексаторы базового класса с такой же сигнатурой (число параметров и типы).

Правила, управляющие оператор объявления ([операторы](classes.md#operators)) сделать невозможным для производного класса для объявления оператора с одинаковой сигнатурой как оператор в базовом классе. Таким образом операторы никогда не скрывать друг с другом.

В отличие от скрытие имя из внешней области, скрытие допустимого имени из наследуемой области вызывает предупреждение. В примере
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    public void F() {}        // Warning, hiding an inherited name
}
```
объявление `F` в `Derived` вызывает предупреждение. Скрытие унаследованного имени специально не является ошибкой, поскольку это препятствует отдельному развитию базовых классов. Например, выше ситуация может возникнуть, поскольку более поздней версии `Base` появился `F` метод, который не был представлен в более ранней версии класса. Бы выше ситуация была ошибка, затем любых изменений, внесенных в базовый класс в библиотеке класса отдельной версии может привести к производным классам становятся недействительными.

Предупреждение, вызванное скрытии унаследованного имени можно устранить с помощью `new` модификатор:
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    new public void F() {}
}
```

`new` Модификатор указывает, что `F` в `Derived` «new», и что она действительно должна скрыть наследуемый член.

Объявление нового члена скрывает унаследованный член только в пределах нового члена.

```csharp
class Base
{
    public static void F() {}
}

class Derived: Base
{
    new private static void F() {}    // Hides Base.F in Derived only
}

class MoreDerived: Derived
{
    static void G() { F(); }          // Invokes Base.F
}
```

В примере выше объявление `F` в `Derived` скрывает `F` , унаследованный от `Base`, но так как новый `F` в `Derived` закрытый доступ к ее область не распространяется на `MoreDerived` . Таким образом, вызов `F()` в `MoreDerived.G` является допустимым и будет вызывать `Base.F`.

## <a name="namespace-and-type-names"></a>Пространства имен и тип

Некоторые контексты в программе на C# требует *namespace_name* или *type_name* указывать.

```antlr
namespace_name
    : namespace_or_type_name
    ;

type_name
    : namespace_or_type_name
    ;

namespace_or_type_name
    : identifier type_argument_list?
    | namespace_or_type_name '.' identifier type_argument_list?
    | qualified_alias_member
    ;
```

Объект *namespace_name* — *namespace_or_type_name* , ссылается на пространство имен. Следующее разрешение, как описано ниже, *namespace_or_type_name* из *namespace_name* должно ссылаться на пространство имен, или в противном случае возникает ошибка времени компиляции. Аргументы типа ([аргументы типа](types.md#type-arguments)) могут быть представлены в *namespace_name* (только типы могут иметь аргументов типа).

Объект *type_name* — *namespace_or_type_name* , ссылается на тип. Следующее разрешение, как описано ниже, *namespace_or_type_name* из *type_name* должен ссылаться на тип, или в противном случае возникает ошибка времени компиляции.

Если *namespace_or_type_name* входит указанием псевдоним-его значение соответствует описанной в [Квалификаторы псевдонима пространства имен](namespaces.md#namespace-alias-qualifiers). В противном случае *namespace_or_type_name* имеет одно из четырех форм:

*  `I`
*  `I<A1, ..., Ak>`
*  `N.I`
*  `N.I<A1, ..., Ak>`

где `I` — отдельный идентификатор, `N` — *namespace_or_type_name* и `<A1, ..., Ak>` не является обязательной *type_argument_list*. Если аргумент *type_argument_list* будет указано, рассмотрите возможность `k` должно быть равно нулю.

Значение *namespace_or_type_name* определяется следующим образом:

*   Если *namespace_or_type_name* имеет форму `I` или формы `I<A1, ..., Ak>`:
    * Если `K` равно нулю и *namespace_or_type_name* появляется в объявлении универсального метода ([методы](classes.md#methods)) и если это объявление включает параметр типа ([типа Параметры](classes.md#type-parameters)) с именем `I`, а затем *namespace_or_type_name* ссылается на этот параметр типа.
    * В противном случае, если *namespace_or_type_name* появляется в объявлении типа, а затем для каждого типа экземпляра `T` ([тип экземпляра](classes.md#the-instance-type)), начиная с типом экземпляра этого типа объявление и продолжить с типом экземпляра каждого включающего объявления класса или структуры (если таковые имеются):
        * Если `K` равно нулю и объявление `T` включает параметр типа с именем `I`, а затем *namespace_or_type_name* ссылается на этот параметр типа.
        * В противном случае, если *namespace_or_type_name* находится внутри объявления типа, и `T` или какой-либо из его базовых типов содержит вложенный доступный тип с именем `I` и `K` параметры типа , а затем *namespace_or_type_name* ссылается на этот тип, сформированный с заданными аргументами типа. Если имеется более одного типа, выбирается тип, объявленный внутри более производный тип. Обратите внимание, что элементы не являющегося типом (константы, поля, методы, свойства, индексаторы, операторы, конструкторы экземпляров, деструкторы и статические конструкторы) и членов типов с Разное количество параметров типа учитываются при определении значения *namespace_or_type_name*.
    * Если предыдущие действия были успешно выполнены, для каждого пространства имен `N`, начиная с пространством имен, в котором *namespace_or_type_name* происходит, продолжая каждого вмещающего пространства имен (если таковые имеются) и заканчивая глобальное пространство имен, вычисляются следующие действия, пока не будет обнаружена сущность:
        * Если `K` равно нулю и `I` имя пространства имен в `N`, затем:
            * Если расположение где *namespace_or_type_name* происходит заключен в объявление пространства имен для `N` и содержит объявление пространства имен *extern_alias_directive* или *using_alias_directive* , связывает имя `I` пространства имен или тип, а затем *namespace_or_type_name* является неоднозначным и возникает ошибка времени компиляции.
            * В противном случае *namespace_or_type_name* ссылается на пространство имен с именем `I` в `N`.
        * В противном случае, если `N` содержит доступный тип с именем `I` и `K` параметрами типа, то:
            * Если `K` равно нулю и расположение где *namespace_or_type_name* происходит заключен в объявление пространства имен для `N` и содержит объявление пространства имен *extern_alias_directive*  или *using_alias_directive* , связывает имя `I` пространства имен или тип, а затем *namespace_or_type_name* является неоднозначным, а во время компиляции возникает ошибка.
            * В противном случае *namespace_or_type_name* ссылается на тип, сформированный с заданными аргументами типа.
        * В противном случае, если расположение где *namespace_or_type_name* происходит заключен в объявление пространства имен для `N`:
            * Если `K` равен нулю и содержит объявление пространства имен *extern_alias_directive* или *using_alias_directive* , связывает имя `I` с импортированное пространство имен или тип, а затем *namespace_or_type_name* ссылается на это пространство имен или тип.
            * В противном случае, если объявления типов и пространств имен, импортированные с *using_namespace_directive*s и *using_alias_directive*объявления пространства имен содержат ровно один доступный тип с именем `I` и `K` параметры типа, а затем *namespace_or_type_name* ссылается на этот тип, сформированный с заданными аргументами типа.
            * В противном случае, если объявления типов и пространств имен, импортированные с *using_namespace_directive*s и *using_alias_directive*объявления пространства имен содержат более чем один доступный тип с именем `I` и `K` параметры типа, а затем *namespace_or_type_name* является неоднозначным и возникает ошибка.
    * В противном случае *namespace_or_type_name* — не определено и возникает ошибка времени компиляции.
*  В противном случае *namespace_or_type_name* имеет форму `N.I` или формы `N.I<A1, ..., Ak>`. `N` предпринимается попытка рассмотреть его как *namespace_or_type_name*. Если разрешение `N` прошла неудачно, то возникает ошибка времени компиляции. В противном случае `N.I` или `N.I<A1, ..., Ak>` разрешается следующим образом:
    * Если `K` равно нулю и `N` ссылается на пространство имен и `N` содержит вложенное пространство имен с именем `I`, а затем *namespace_or_type_name* ссылается на это вложенное пространство имен.
    * В противном случае, если `N` ссылается на пространство имен и `N` содержит доступный тип с именем `I` и `K` параметры типа, а затем *namespace_or_type_name* ссылается на этот тип создан с заданными аргументами типа.
    * В противном случае, если `N` ссылается на тип класса или структуры (возможно, сконструированный) и `N` или какой-либо из его базовых классов содержит вложенный доступный тип с именем `I` и `K` параметры типа, а затем *пространства имен _or_type_name* ссылается на этот тип, сформированный с заданными аргументами типа. Если имеется более одного типа, выбирается тип, объявленный внутри более производный тип. Обратите внимание: Если значение `N.I` определяется как часть разрешения спецификация базового класса `N` затем прямой базовый класс для `N` считается объекта ([базовые классы](classes.md#base-classes)).
    * В противном случае `N.I` не является допустимым *namespace_or_type_name*, и возникает ошибка времени компиляции.

Объект *namespace_or_type_name* может ссылаться на статический класс ([статические классы](classes.md#static-classes)) только если

*  *Namespace_or_type_name* — `T` в *namespace_or_type_name* формы `T.I`, или
*  *Namespace_or_type_name* — `T` в *typeof_expression* ([списки аргументов](expressions.md#argument-lists)1) формы `typeof(T)`.

### <a name="fully-qualified-names"></a>Полные имена

Каждая пространства имен и тип имеет ***полное имя***, который уникальным образом идентифицирует пространство имен или тип среди других. Полное имя пространства имен или тип `N` определяется следующим образом:

*  Если `N` является членом глобального пространства имен, его полное доменное имя выглядит `N`.
*  В противном случае его полное доменное имя выглядит `S.N`, где `S` полное имя пространства имен или тип, в которой `N` объявлен.

Другими словами, полное имя `N` — это полный путь иерархических идентификаторов, которые приводят к `N`, начиная от глобального пространства имен. Так как каждый член пространства имен или типа должен иметь уникальное имя, следует, что полное имя пространства имен или тип всегда является уникальным.

В приведенном ниже примере показано несколько объявлений пространства имен и типов вместе с их соответствующими полными именами.
```csharp
class A {}                // A

namespace X               // X
{
    class B               // X.B
    {
        class C {}        // X.B.C
    }

    namespace Y           // X.Y
    {
        class D {}        // X.Y.D
    }
}

namespace X.Y             // X.Y
{
    class E {}            // X.Y.E
}
```

## <a name="automatic-memory-management"></a>Автоматическое управление памятью

C# использует автоматическое управление памятью, что освобождает разработчиков от ручного выделения и освобождения памяти, занятых объектами. Политики управления памятью автоматического реализуются ***сборщик мусора***. Жизненный цикл управления памяти объекта выглядит следующим образом:

1. При создании объекта, выделить память для него, выполняется конструктор и объект считается в реальном времени.
2. Если объект или любую часть, недоступны для любого продолжения выполнения, отличный от выполнения деструкторов, объект считается больше не используется, и он становится пригодным для уничтожения. Компилятор C# и сборщик мусора, можно проанализировать код, чтобы определить, какие ссылки на объект может использоваться в будущем. Например если локальной переменной, которая находится в области только существующую ссылку на объект, но локальная переменная никогда не упоминается в любой продолжения выполнения из текущего выполнения, укажите в процедуре, сборщик мусора может (но не требуется) рассматривать объект как больше не используется.
3. Как только объект требует уничтожения, через некоторое указанное время деструктор ([деструкторы](classes.md#destructors)) (если таковые имеются) для запуска объекта. В обычных условиях деструктор для объекта выполняется только один раз на то, что API-интерфейсам конкретной реализации может разрешить это поведение можно переопределить.
4. После запуска деструктор для объекта, если данный объект или любой ее части может быть недоступна для любого продолжения выполнения, включая выполнение деструкторов, объект считается недоступным и становится доступным для коллекции.
5. Наконец через некоторое время после объект становится доступным для коллекции, сборщик мусора освобождает память, связанную с этим объектом.

Сборщик мусора сохраняет сведения об использовании объекта и использует эти сведения для принятия решений управления, памяти, таких как where в памяти, чтобы найти вновь созданного объекта, если переместить объект и когда объект больше не используется или недоступен.

Как и других языков, которые предполагается, что сборщик мусора, C# предназначен, чтобы сборщик мусора может реализовать широкий спектр политики управления памятью. Например C# не требует выполнение деструкторов или подборка объектов как только они становятся доступными, или выполнение деструкторов в определенном порядке или в любом определенном потоке.

Можно управлять поведением сборщик мусора в определенной степени, с помощью статических методов класса `System.GC`. Этот класс может быть использован для запроса мусора деструкторы запуска (или не запускать) и так далее.

Так как сборщик мусора может широкую степень свободы в выборе времени уничтожения объектов и вызова деструкторов, соответствующая реализация могут давать выходные данные, которые отличаются от показанных в следующем примере кода. Программа
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }
}

class B
{
    object Ref;

    public B(object o) {
        Ref = o;
    }

    ~B() {
        Console.WriteLine("Destruct instance of B");
    }
}

class Test
{
    static void Main() {
        B b = new B(new A());
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
}
```
Создает экземпляр класса `A` и экземпляр класса `B`. Эти объекты станут доступны для сборки мусора при переменной `b` присваивается значение `null`, поскольку после этого невозможно для любой код, написанный пользователем, для доступа к ним. Результат может быть либо
```
Destruct instance of A
Destruct instance of B
```
или
```
Destruct instance of B
Destruct instance of A
```
так как язык не налагает ограничений на порядок, в котором объекты удалялись сборщиком мусора.

В особых случаях может понадобиться различие между «пригодным для уничтожения» и «доступным для коллекции». Например, примененная к объекту директива
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }

    public void F() {
        Console.WriteLine("A.F");
        Test.RefA = this;
    }
}

class B
{
    public A Ref;

    ~B() {
        Console.WriteLine("Destruct instance of B");
        Ref.F();
    }
}

class Test
{
    public static A RefA;
    public static B RefB;

    static void Main() {
        RefB = new B();
        RefA = new A();
        RefB.Ref = RefA;
        RefB = null;
        RefA = null;

        // A and B now eligible for destruction
        GC.Collect();
        GC.WaitForPendingFinalizers();

        // B now eligible for collection, but A is not
        if (RefA != null)
            Console.WriteLine("RefA is not null");
    }
}
```

В программе выше, если сборщик мусора выбирает выполнение деструктора `A` до деструктора `B`, то выходные данные этой программы может быть:
```
Destruct instance of A
Destruct instance of B
A.F
RefA is not null
```

Обратите внимание, что хотя экземпляр `A` не используется и `A`в запускался деструктор, по-прежнему возможно, для методов `A` (в этом случае `F`) для вызова из другого деструктора. Кроме того Обратите внимание на то, что выполнение деструктора может привести к объекту станет доступным для использования из основной программы снова. В этом случае выполнение `B`деструктор, вызвавшего экземпляр `A` , был ранее не используется стал доступен из существующей ссылки `Test.RefA`. После вызова `WaitForPendingFinalizers`, экземпляр `B` подходит для коллекции, но экземпляр `A` не из-за ссылки `Test.RefA`.

Чтобы избежать путаницы и непредвиденное поведение, он обычно является хорошей идеей деструкторы только выполнить очистку данных в их собственных полей объекта, а не выполнять любые действия на ссылочные объекты или статические поля.

Является альтернативой использованию деструкторы классом реализации `System.IDisposable` интерфейс. Это позволяет клиенту определить, когда нужно освободить ресурсы объекта, как правило, доступ к объекту в качестве ресурса объекта `using` инструкции ([инструкцией](statements.md#the-using-statement)).

## <a name="execution-order"></a>Порядок выполнения

Выполнение программы на C# продолжается таким образом, что побочные эффекты каждого выполняемого потока сохраняются в критических точках выполнения. Объект ***побочный эффект*** определяется как чтение или запись поле с модификатором volatile, запись в энергонезависимой переменную, запись внешнего ресурса и возникновение исключения. Критические точки выполнения в которых должен сохраняться порядок этих побочные эффекты являются ссылками на изменяемые поля ([изменяемые поля](classes.md#volatile-fields)), `lock` инструкций ([инструкция lock](statements.md#the-lock-statement)), и Создание потока и порядок прекращения. Среда выполнения может свободно изменять порядок выполнения программы на C#, распространяются следующие ограничения:

*  Зависимости данных сохраняются в рамках потока выполнения. То есть значение каждой переменной вычисляется так, как если бы были выполнены все инструкции в потоке в первоначальном порядке программы.
*  Порядок инициализации сохраняются правил ([инициализацию поля](classes.md#field-initialization) и [инициализаторы переменных](classes.md#variable-initializers)).
*  Упорядочивание побочных эффектов сохраняется по отношению к volatile операций чтения и записи ([изменяемые поля](classes.md#volatile-fields)). Кроме того среда выполнения не должна вычислять часть выражения, если он может вывести, что значение этого выражения не используется, и что необходимые побочные эффекты создаются (включая, вызванное при вызове метода или доступе к поле с модификатором volatile). Когда выполнение программы прерывается асинхронным событием (например, исключения, созданного другим потоком), не гарантируется, наблюдаемые побочные эффекты являются видимыми в первоначальном порядке программы.
