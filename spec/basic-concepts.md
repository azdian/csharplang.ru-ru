# <a name="basic-concepts"></a><span data-ttu-id="a8f02-101">Основные понятия</span><span class="sxs-lookup"><span data-stu-id="a8f02-101">Basic concepts</span></span>

## <a name="application-startup"></a><span data-ttu-id="a8f02-102">Запуск приложения</span><span class="sxs-lookup"><span data-stu-id="a8f02-102">Application Startup</span></span>

<span data-ttu-id="a8f02-103">Сборка, ***точки входа*** называется ***приложения***.</span><span class="sxs-lookup"><span data-stu-id="a8f02-103">An assembly that has an ***entry point*** is called an ***application***.</span></span> <span data-ttu-id="a8f02-104">При запуске нового приложения ***домена приложения*** создается.</span><span class="sxs-lookup"><span data-stu-id="a8f02-104">When an application is run, a new ***application domain*** is created.</span></span> <span data-ttu-id="a8f02-105">Несколько различных экземпляров приложения могут существовать на одном компьютере, в то же время, и каждый из них имеет свой собственный домен приложения.</span><span class="sxs-lookup"><span data-stu-id="a8f02-105">Several different instantiations of an application may exist on the same machine at the same time, and each has its own application domain.</span></span>

<span data-ttu-id="a8f02-106">Домен приложения обеспечивает изоляцию приложения в качестве контейнера для состояния приложения.</span><span class="sxs-lookup"><span data-stu-id="a8f02-106">An application domain enables application isolation by acting as a container for application state.</span></span> <span data-ttu-id="a8f02-107">Домен приложения выступает в качестве контейнера и границы для типов, определенных в приложении и библиотеки классов, используемые в нем.</span><span class="sxs-lookup"><span data-stu-id="a8f02-107">An application domain acts as a container and boundary for the types defined in the application and the class libraries it uses.</span></span> <span data-ttu-id="a8f02-108">Типы, загружаемые в один домен приложения отличаются от аналогичных типов, загруженных в другой домен приложения, и экземпляры объектов не применяются напрямую между доменами приложений.</span><span class="sxs-lookup"><span data-stu-id="a8f02-108">Types loaded into one application domain are distinct from the same type loaded into another application domain, and instances of objects are not directly shared between application domains.</span></span> <span data-ttu-id="a8f02-109">Например каждый домен приложения имеет свою собственную копию статических переменных для этих типов, а статический конструктор для типа выполняется не более одного раза каждого домена приложения.</span><span class="sxs-lookup"><span data-stu-id="a8f02-109">For instance, each application domain has its own copy of static variables for these types, and a static constructor for a type is run at most once per application domain.</span></span> <span data-ttu-id="a8f02-110">Реализации могут использовать реализации политики или механизмы для создания и удаления доменов приложений.</span><span class="sxs-lookup"><span data-stu-id="a8f02-110">Implementations are free to provide implementation-specific policy or mechanisms for the creation and destruction of application domains.</span></span>

<span data-ttu-id="a8f02-111">***Запуск приложения*** возникает, когда среда выполнения вызывает указанный метод, который упоминается как точка входа приложения.</span><span class="sxs-lookup"><span data-stu-id="a8f02-111">***Application startup*** occurs when the execution environment calls a designated method, which is referred to as the application's entry point.</span></span> <span data-ttu-id="a8f02-112">Этот метод точки входа всегда имеет имя `Main`и может иметь одно из следующих сигнатур:</span><span class="sxs-lookup"><span data-stu-id="a8f02-112">This entry point method is always named `Main`, and can have one of the following signatures:</span></span>

```csharp
static void Main() {...}

static void Main(string[] args) {...}

static int Main() {...}

static int Main(string[] args) {...}
```

<span data-ttu-id="a8f02-113">Как показано, точка входа может при необходимости вернуть `int` значение.</span><span class="sxs-lookup"><span data-stu-id="a8f02-113">As shown, the entry point may optionally return an `int` value.</span></span> <span data-ttu-id="a8f02-114">Эта команда вернуть значение используется в завершение работы приложения ([завершение работы приложения](basic-concepts.md#application-termination)).</span><span class="sxs-lookup"><span data-stu-id="a8f02-114">This return value is used in application termination ([Application termination](basic-concepts.md#application-termination)).</span></span>

<span data-ttu-id="a8f02-115">Точка входа может иметь один формальный параметр.</span><span class="sxs-lookup"><span data-stu-id="a8f02-115">The entry point may optionally have one formal parameter.</span></span> <span data-ttu-id="a8f02-116">Параметр может иметь любое имя, но тип параметра должен быть `string[]`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-116">The parameter may have any name, but the type of the parameter must be `string[]`.</span></span> <span data-ttu-id="a8f02-117">Если этот формальный параметр присутствует, среда выполнения создает и передает `string[]` аргумент, содержащий аргументы командной строки, которые были указано время запуска приложения.</span><span class="sxs-lookup"><span data-stu-id="a8f02-117">If the formal parameter is present, the execution environment creates and passes a `string[]` argument containing the command-line arguments that were specified when the application was started.</span></span> <span data-ttu-id="a8f02-118">`string[]` Аргумент никогда не имеет значение null, но он может иметь нулевую длину, если указаны аргументы командной строки.</span><span class="sxs-lookup"><span data-stu-id="a8f02-118">The `string[]` argument is never null, but it may have a length of zero if no command-line arguments were specified.</span></span>

<span data-ttu-id="a8f02-119">Так как C# поддерживает перегрузку методов, класс или структура может содержать несколько определений какого-либо метода предоставляемые каждый имеет другую подпись.</span><span class="sxs-lookup"><span data-stu-id="a8f02-119">Since C# supports method overloading, a class or struct may contain multiple definitions of some method, provided each has a different signature.</span></span> <span data-ttu-id="a8f02-120">Тем не менее, в одной программе, класс или структура может содержать более чем один метод под названием `Main` , определение которого позволяет квалифицировать его для использования в качестве точки входа приложения.</span><span class="sxs-lookup"><span data-stu-id="a8f02-120">However, within a single program, no class or struct may contain more than one method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="a8f02-121">Другие перегруженные версии `Main` разрешены, тем не менее, если они имеют более одного параметра, или их единственного параметра отличается от типа `string[]`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-121">Other overloaded versions of `Main` are permitted, however, provided they have more than one parameter, or their only parameter is other than type `string[]`.</span></span>

<span data-ttu-id="a8f02-122">Приложение может состоять из нескольких классов или структур.</span><span class="sxs-lookup"><span data-stu-id="a8f02-122">An application can be made up of multiple classes or structs.</span></span> <span data-ttu-id="a8f02-123">Это возможно для более чем одного из этих классов или структур, должен содержать метод с именем `Main` , определение которого позволяет квалифицировать его для использования в качестве точки входа приложения.</span><span class="sxs-lookup"><span data-stu-id="a8f02-123">It is possible for more than one of these classes or structs to contain a method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="a8f02-124">В таких случаях внешнего механизма (например, параметр командной строки компилятора) должен использоваться для выбора одного из этих `Main` методы в качестве точки входа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-124">In such cases, an external mechanism (such as a command-line compiler option) must be used to select one of these `Main` methods as the entry point.</span></span>

<span data-ttu-id="a8f02-125">В C# каждый метод должен быть определен как член класса или структуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-125">In C#, every method must be defined as a member of a class or struct.</span></span> <span data-ttu-id="a8f02-126">Как правило, объявленный уровень доступности ([объявленную доступность](basic-concepts.md#declared-accessibility)) метода определяется модификаторы доступа ([модификаторы доступа](classes.md#access-modifiers)) в его объявлении и аналогичным образом объявленный доступность типа определяется модификаторы доступа, указанной в его объявлении.</span><span class="sxs-lookup"><span data-stu-id="a8f02-126">Ordinarily, the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of a method is determined by the access modifiers ([Access modifiers](classes.md#access-modifiers)) specified in its declaration, and similarly the declared accessibility of a type is determined by the access modifiers specified in its declaration.</span></span> <span data-ttu-id="a8f02-127">В порядке для данного метода заданного типа быть вызван тип и элемент должны быть доступны.</span><span class="sxs-lookup"><span data-stu-id="a8f02-127">In order for a given method of a given type to be callable, both the type and the member must be accessible.</span></span> <span data-ttu-id="a8f02-128">Тем не менее точку входа приложения является особым случаем.</span><span class="sxs-lookup"><span data-stu-id="a8f02-128">However, the application entry point is a special case.</span></span> <span data-ttu-id="a8f02-129">В частности среду выполнения можно получить доступ к точке входа приложения, независимо от его объявленный уровень доступности и независимо от того, объявленный уровень доступности его включающего объявлений типов.</span><span class="sxs-lookup"><span data-stu-id="a8f02-129">Specifically, the execution environment can access the application's entry point regardless of its declared accessibility and regardless of the declared accessibility of its enclosing type declarations.</span></span>

<span data-ttu-id="a8f02-130">Метод точки входа приложения может оказаться в универсальном объявлении класса.</span><span class="sxs-lookup"><span data-stu-id="a8f02-130">The application entry point method may not be in a generic class declaration.</span></span>

<span data-ttu-id="a8f02-131">Во всех прочих отношениях методах точек входа ведут себя как те, которые не являются точками входа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-131">In all other respects, entry point methods behave like those that are not entry points.</span></span>

## <a name="application-termination"></a><span data-ttu-id="a8f02-132">Завершение работы приложения</span><span class="sxs-lookup"><span data-stu-id="a8f02-132">Application termination</span></span>

<span data-ttu-id="a8f02-133">***Завершение работы приложения*** возвращает элемент управления в среду выполнения.</span><span class="sxs-lookup"><span data-stu-id="a8f02-133">***Application termination*** returns control to the execution environment.</span></span>

<span data-ttu-id="a8f02-134">Если тип возврата приложения ***точки входа*** метод `int`, возвращаемое значение служит в качестве приложения ***код состояния завершения***.</span><span class="sxs-lookup"><span data-stu-id="a8f02-134">If the return type of the application's ***entry point*** method is `int`, the value returned serves as the application's ***termination status code***.</span></span> <span data-ttu-id="a8f02-135">Этот код предназначен для того, чтобы обеспечить обмен данными об успехе или неудаче в среду выполнения.</span><span class="sxs-lookup"><span data-stu-id="a8f02-135">The purpose of this code is to allow communication of success or failure to the execution environment.</span></span>

<span data-ttu-id="a8f02-136">Если тип возвращаемого значения метода точки входа — `void`, достижение закрывающая фигурная скобка (`}`), завершающий метод или выполнение `return` инструкцию, которая не имеет выражения, приводит код состояния завершения `0`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-136">If the return type of the entry point method is `void`, reaching the right brace (`}`) which terminates that method, or executing a `return` statement that has no expression, results in a termination status code of `0`.</span></span>

<span data-ttu-id="a8f02-137">Перед завершением работы приложения, вызываются деструкторы для всех объектов, которые еще не был удален сборщиком мусора, если такая очистка не была отключена (путем вызова метода библиотеки `GC.SuppressFinalize`, например).</span><span class="sxs-lookup"><span data-stu-id="a8f02-137">Prior to an application's termination, destructors for all of its objects that have not yet been garbage collected are called, unless such cleanup has been suppressed (by a call to the library method `GC.SuppressFinalize`, for example).</span></span>

## <a name="declarations"></a><span data-ttu-id="a8f02-138">Объявления</span><span class="sxs-lookup"><span data-stu-id="a8f02-138">Declarations</span></span>

<span data-ttu-id="a8f02-139">Объявления в программе на C# определяют составные элементы программы.</span><span class="sxs-lookup"><span data-stu-id="a8f02-139">Declarations in a C# program define the constituent elements of the program.</span></span> <span data-ttu-id="a8f02-140">C#, структуре программ с помощью пространств имен ([пространства имен](namespaces.md)), который может содержать тип объявления и объявления вложенного пространства имен.</span><span class="sxs-lookup"><span data-stu-id="a8f02-140">C# programs are organized using namespaces ([Namespaces](namespaces.md)), which can contain type declarations and nested namespace declarations.</span></span> <span data-ttu-id="a8f02-141">Объявления типов ([объявления типов](namespaces.md#type-declarations)) используются для определения классов ([классы](classes.md)), структуры ([структуры](structs.md)), интерфейсы ([интерфейсы](interfaces.md) ), перечислений ([перечисления](enums.md)) и делегатов ([делегаты](delegates.md)).</span><span class="sxs-lookup"><span data-stu-id="a8f02-141">Type declarations ([Type declarations](namespaces.md#type-declarations)) are used to define classes ([Classes](classes.md)), structs ([Structs](structs.md)), interfaces ([Interfaces](interfaces.md)), enums ([Enums](enums.md)), and delegates ([Delegates](delegates.md)).</span></span> <span data-ttu-id="a8f02-142">Типы членов, разрешенных в объявлении типа, зависят от формы объявления типа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-142">The kinds of members permitted in a type declaration depend on the form of the type declaration.</span></span> <span data-ttu-id="a8f02-143">Например, класс объявления могут содержать объявления для констант ([константы](classes.md#constants)), поля ([поля](classes.md#fields)), методы ([методы](classes.md#methods)), свойства ([ Свойства](classes.md#properties)), события ([события](classes.md#events)), индексаторов ([индексаторы](classes.md#indexers)), операторы ([операторы](classes.md#operators)), конструкторы экземпляров ([ Конструкторы экземпляров](classes.md#instance-constructors)), статические конструкторы ([статические конструкторы](classes.md#static-constructors)), деструкторы ([деструкторы](classes.md#destructors)) и вложенные типы ([вложенные типы](classes.md#nested-types)).</span><span class="sxs-lookup"><span data-stu-id="a8f02-143">For instance, class declarations can contain declarations for constants ([Constants](classes.md#constants)), fields ([Fields](classes.md#fields)), methods ([Methods](classes.md#methods)), properties ([Properties](classes.md#properties)), events ([Events](classes.md#events)), indexers ([Indexers](classes.md#indexers)), operators ([Operators](classes.md#operators)), instance constructors ([Instance constructors](classes.md#instance-constructors)), static constructors ([Static constructors](classes.md#static-constructors)), destructors ([Destructors](classes.md#destructors)), and nested types ([Nested types](classes.md#nested-types)).</span></span>

<span data-ttu-id="a8f02-144">Объявление определяет имя в ***объявления*** , которому принадлежит объявление.</span><span class="sxs-lookup"><span data-stu-id="a8f02-144">A declaration defines a name in the ***declaration space*** to which the declaration belongs.</span></span> <span data-ttu-id="a8f02-145">За исключением перегруженных членов ([сигнатуры и перегрузка](basic-concepts.md#signatures-and-overloading)), произошла ошибка во время компиляции, чтобы иметь два или несколько объявлений, представляющих члены с тем же именем в области объявления.</span><span class="sxs-lookup"><span data-stu-id="a8f02-145">Except for overloaded members ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)), it is a compile-time error to have two or more declarations that introduce members with the same name in a declaration space.</span></span> <span data-ttu-id="a8f02-146">Никогда не бывает возможных область объявления для хранения различных видов членов с таким именем.</span><span class="sxs-lookup"><span data-stu-id="a8f02-146">It is never possible for a declaration space to contain different kinds of members with the same name.</span></span> <span data-ttu-id="a8f02-147">Например, объявление область может не содержать поле и метод с тем же именем.</span><span class="sxs-lookup"><span data-stu-id="a8f02-147">For example, a declaration space can never contain a field and a method by the same name.</span></span>

<span data-ttu-id="a8f02-148">Существует несколько разных типов областей объявлений, как описано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="a8f02-148">There are several different types of declaration spaces, as described in the following.</span></span>

*  <span data-ttu-id="a8f02-149">В рамках всех исходных файлов программы *namespace_member_declaration*s с без заключения *namespace_declaration* являются членами одной комбинированной области объявления вызывается ***глобального область объявления***.</span><span class="sxs-lookup"><span data-stu-id="a8f02-149">Within all source files of a program, *namespace_member_declaration*s with no enclosing *namespace_declaration* are members of a single combined declaration space called the ***global declaration space***.</span></span>
*  <span data-ttu-id="a8f02-150">В рамках всех исходных файлов программы *namespace_member_declaration*s в *namespace_declaration*, иметь то же имя полного пространства имен являются членами одно объединенное объявление пространство.</span><span class="sxs-lookup"><span data-stu-id="a8f02-150">Within all source files of a program, *namespace_member_declaration*s within *namespace_declaration*s that have the same fully qualified namespace name are members of a single combined declaration space.</span></span>
*  <span data-ttu-id="a8f02-151">Каждого класса, структуры или интерфейса объявление создает новую область объявления.</span><span class="sxs-lookup"><span data-stu-id="a8f02-151">Each class, struct, or interface declaration creates a new declaration space.</span></span> <span data-ttu-id="a8f02-152">Имена вводятся в эту область объявления через *class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s, или *параметр_типа*s.</span><span class="sxs-lookup"><span data-stu-id="a8f02-152">Names are introduced into this declaration space through *class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s, or *type_parameter*s.</span></span> <span data-ttu-id="a8f02-153">За исключением экземпляра перегруженный конструктор объявления и статический конструктор, объявления, класс или структура не может содержать объявление члена с тем же именем, что класс или структура.</span><span class="sxs-lookup"><span data-stu-id="a8f02-153">Except for overloaded instance constructor declarations and static constructor declarations, a class or struct cannot contain a member declaration with the same name as the class or struct.</span></span> <span data-ttu-id="a8f02-154">Класс, структура или интерфейс допускает объявление перегруженных методов и индексаторов.</span><span class="sxs-lookup"><span data-stu-id="a8f02-154">A class, struct, or interface permits the declaration of overloaded methods and indexers.</span></span> <span data-ttu-id="a8f02-155">Кроме того класс или структура допускает объявление перегруженных конструкторов экземпляров и операторов.</span><span class="sxs-lookup"><span data-stu-id="a8f02-155">Furthermore, a class or struct permits the declaration of overloaded instance constructors and operators.</span></span> <span data-ttu-id="a8f02-156">Например, класса, структуры или интерфейса может содержать несколько объявлений методов с тем же именем, предоставляемых эти объявления методов отличаются по сигнатуре ([сигнатуры и перегрузка](basic-concepts.md#signatures-and-overloading)).</span><span class="sxs-lookup"><span data-stu-id="a8f02-156">For example, a class, struct, or interface may contain multiple method declarations with the same name, provided these method declarations differ in their signature ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)).</span></span> <span data-ttu-id="a8f02-157">Обратите внимание, что базовые классы не включаются в области объявления класса базовые интерфейсы не включаются в области объявления интерфейса.</span><span class="sxs-lookup"><span data-stu-id="a8f02-157">Note that base classes do not contribute to the declaration space of a class, and base interfaces do not contribute to the declaration space of an interface.</span></span> <span data-ttu-id="a8f02-158">Таким образом производный класс или интерфейс может объявить элемент с таким именем наследуемого члена.</span><span class="sxs-lookup"><span data-stu-id="a8f02-158">Thus, a derived class or interface is allowed to declare a member with the same name as an inherited member.</span></span> <span data-ttu-id="a8f02-159">Такой элемент считается ***скрыть*** наследуемый член.</span><span class="sxs-lookup"><span data-stu-id="a8f02-159">Such a member is said to ***hide*** the inherited member.</span></span>
*  <span data-ttu-id="a8f02-160">Каждое объявление делегата создает новую область объявления.</span><span class="sxs-lookup"><span data-stu-id="a8f02-160">Each delegate declaration creates a new declaration space.</span></span> <span data-ttu-id="a8f02-161">Имена вводятся в эту область объявления через формальных параметров (*fixed_parameter*s и *parameter_array*s) и *параметр_типа*s.</span><span class="sxs-lookup"><span data-stu-id="a8f02-161">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span>
*  <span data-ttu-id="a8f02-162">Каждое объявление перечисления создает новую область объявления.</span><span class="sxs-lookup"><span data-stu-id="a8f02-162">Each enumeration declaration creates a new declaration space.</span></span> <span data-ttu-id="a8f02-163">Имена вводятся в эту область объявления через *enum_member_declarations*.</span><span class="sxs-lookup"><span data-stu-id="a8f02-163">Names are introduced into this declaration space through *enum_member_declarations*.</span></span>
*  <span data-ttu-id="a8f02-164">Каждый объявление метода, объявление индексатора, объявление оператора, объявление конструктора экземпляра и анонимная функция создает новую область объявления вызывается ***области объявления локальных переменных***.</span><span class="sxs-lookup"><span data-stu-id="a8f02-164">Each method declaration, indexer declaration, operator declaration, instance constructor declaration and anonymous function creates a new declaration space called a ***local variable declaration space***.</span></span> <span data-ttu-id="a8f02-165">Имена вводятся в эту область объявления через формальных параметров (*fixed_parameter*s и *parameter_array*s) и *параметр_типа*s.</span><span class="sxs-lookup"><span data-stu-id="a8f02-165">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span> <span data-ttu-id="a8f02-166">Тело функции-члена или анонимной функции, если таковые имеются, считается вкладываются в области объявления локальных переменных.</span><span class="sxs-lookup"><span data-stu-id="a8f02-166">The body of the function member or anonymous function, if any, is considered to be nested within the local variable declaration space.</span></span> <span data-ttu-id="a8f02-167">Это ошибка для области объявления локальных переменных и вложенных в объявлении локальной переменной пробел будет содержать элементы с одинаковым именем.</span><span class="sxs-lookup"><span data-stu-id="a8f02-167">It is an error for a local variable declaration space and a nested local variable declaration space to contain elements with the same name.</span></span> <span data-ttu-id="a8f02-168">Таким образом внутри вложенной области объявления он не поддерживается для объявления локальной переменной или константы с тем же именем, как локальная переменная или константа в родительской области объявления.</span><span class="sxs-lookup"><span data-stu-id="a8f02-168">Thus, within a nested declaration space it is not possible to declare a local variable or constant with the same name as a local variable or constant in an enclosing declaration space.</span></span> <span data-ttu-id="a8f02-169">Это возможно для двух пространств объявления могут содержать элементы с тем же именем, до тех пор, пока ни одна из области объявления содержит другой.</span><span class="sxs-lookup"><span data-stu-id="a8f02-169">It is possible for two declaration spaces to contain elements with the same name as long as neither declaration space contains the other.</span></span>
*  <span data-ttu-id="a8f02-170">Каждый *блок* или *switch_block* , а также *для*, *foreach* и *с помощью* создает инструкцию, в объявлении локальной переменной пространства для локальных переменных и локальные константы.</span><span class="sxs-lookup"><span data-stu-id="a8f02-170">Each *block* or *switch_block* , as well as a *for*, *foreach* and *using* statement, creates a local variable declaration space for local variables and local constants .</span></span> <span data-ttu-id="a8f02-171">Имена вводятся в эту область объявления через *local_variable_declaration*s и *local_constant_declaration*s.</span><span class="sxs-lookup"><span data-stu-id="a8f02-171">Names are introduced into this declaration space through *local_variable_declaration*s and *local_constant_declaration*s.</span></span> <span data-ttu-id="a8f02-172">Обратите внимание, что блоки, возникающие в качестве или в теле функции-члена или анонимной функции вложены в области объявления локальных переменных, объявленных этими функциями для соответствующих параметров.</span><span class="sxs-lookup"><span data-stu-id="a8f02-172">Note that blocks that occur as or within the body of a function member or anonymous function are nested within the local variable declaration space declared by those functions for their parameters.</span></span> <span data-ttu-id="a8f02-173">Таким образом, это ошибка, например с помощью метода с локальной переменной и параметр с тем же именем.</span><span class="sxs-lookup"><span data-stu-id="a8f02-173">Thus it is an error to have e.g. a method with a local variable and a parameter of the same name.</span></span>
*  <span data-ttu-id="a8f02-174">Каждый *блок* или *switch_block* создает отдельную область объявления для меток.</span><span class="sxs-lookup"><span data-stu-id="a8f02-174">Each *block* or *switch_block* creates a separate declaration space for labels.</span></span> <span data-ttu-id="a8f02-175">Имена вводятся в эту область объявления через *labeled_statement*s и имена указаны через *goto_statement*s.</span><span class="sxs-lookup"><span data-stu-id="a8f02-175">Names are introduced into this declaration space through *labeled_statement*s, and the names are referenced through *goto_statement*s.</span></span> <span data-ttu-id="a8f02-176">***Метки объявления*** блока содержит любые вложенные блоки.</span><span class="sxs-lookup"><span data-stu-id="a8f02-176">The ***label declaration space*** of a block includes any nested blocks.</span></span> <span data-ttu-id="a8f02-177">Таким образом внутри вложенного блока не невозможно объявить метку с тем же именем, как метка во внешнем блоке.</span><span class="sxs-lookup"><span data-stu-id="a8f02-177">Thus, within a nested block it is not possible to declare a label with the same name as a label in an enclosing block.</span></span>

<span data-ttu-id="a8f02-178">Текстовом порядке, в котором объявлены имен обычно является не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="a8f02-178">The textual order in which names are declared is generally of no significance.</span></span> <span data-ttu-id="a8f02-179">В частности текстовый порядок не имеет значения для объявления и использования пространств имен, константы, методы, свойства, события, индексаторы, операторы, конструкторы экземпляров, деструкторы, статических конструкторов и типов.</span><span class="sxs-lookup"><span data-stu-id="a8f02-179">In particular, textual order is not significant for the declaration and use of namespaces, constants, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors, and types.</span></span> <span data-ttu-id="a8f02-180">Порядок объявления имеет одним из следующих способов:</span><span class="sxs-lookup"><span data-stu-id="a8f02-180">Declaration order is significant in the following ways:</span></span>

*  <span data-ttu-id="a8f02-181">Порядок объявления поля и локальных переменных определяет порядок, в котором выполняются их инициализаторы (если таковые имеются).</span><span class="sxs-lookup"><span data-stu-id="a8f02-181">Declaration order for field declarations and local variable declarations determines the order in which their initializers (if any) are executed.</span></span>
*  <span data-ttu-id="a8f02-182">Локальные переменные должны быть определены, до их использования ([областей](basic-concepts.md#scopes)).</span><span class="sxs-lookup"><span data-stu-id="a8f02-182">Local variables must be defined before they are used ([Scopes](basic-concepts.md#scopes)).</span></span>
*  <span data-ttu-id="a8f02-183">Порядок объявления членов перечисления ([члены перечисления](enums.md#enum-members)) действителен, когда *constant_expression* значения опускаются.</span><span class="sxs-lookup"><span data-stu-id="a8f02-183">Declaration order for enum member declarations ([Enum members](enums.md#enum-members)) is significant when *constant_expression* values are omitted.</span></span>

<span data-ttu-id="a8f02-184">Объявление пространства имен является «Многовариантный формат» и два пространства имен, объявления с тем же полным именем размещаются в одном пространстве объявлений.</span><span class="sxs-lookup"><span data-stu-id="a8f02-184">The declaration space of a namespace is "open ended", and two namespace declarations with the same fully qualified name contribute to the same declaration space.</span></span> <span data-ttu-id="a8f02-185">Пример</span><span class="sxs-lookup"><span data-stu-id="a8f02-185">For example</span></span>
```csharp
namespace Megacorp.Data
{
    class Customer
    {
        ...
    }
}

namespace Megacorp.Data
{
    class Order
    {
        ...
    }
}
```

<span data-ttu-id="a8f02-186">Два объявления пространства имен выше, размещаются в одной области объявления, в этом случае объявляются два класса с полными доменными именами `Megacorp.Data.Customer` и `Megacorp.Data.Order`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-186">The two namespace declarations above contribute to the same declaration space, in this case declaring two classes with the fully qualified names `Megacorp.Data.Customer` and `Megacorp.Data.Order`.</span></span> <span data-ttu-id="a8f02-187">Поскольку два объявления размещаются в одном пространстве объявлений, происходит ошибка времени компиляции, если каждый содержащийся в объявлении класса с тем же именем.</span><span class="sxs-lookup"><span data-stu-id="a8f02-187">Because the two declarations contribute to the same declaration space, it would have caused a compile-time error if each contained a declaration of a class with the same name.</span></span>

<span data-ttu-id="a8f02-188">Как указано выше в области объявления блока включает любые вложенные блоки.</span><span class="sxs-lookup"><span data-stu-id="a8f02-188">As specified above, the declaration space of a block includes any nested blocks.</span></span> <span data-ttu-id="a8f02-189">Таким образом, в следующем примере `F` и `G` методы к ошибке во время компиляции, так как имя `i` объявляется во внешнем блоке и не может быть повторно объявлена во внутреннем блоке.</span><span class="sxs-lookup"><span data-stu-id="a8f02-189">Thus, in the following example, the `F` and `G` methods result in a compile-time error because the name `i` is declared in the outer block and cannot be redeclared in the inner block.</span></span> <span data-ttu-id="a8f02-190">Тем не менее `H` и `I` методы являются допустимыми, так как два `i`объявляются в отдельных блоках невложенными.</span><span class="sxs-lookup"><span data-stu-id="a8f02-190">However, the `H` and `I` methods are valid since the two `i`'s are declared in separate non-nested blocks.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        if (true) {
            int i = 1;            
        }
    }

    void G() {
        if (true) {
            int i = 0;
        }
        int i = 1;                
    }

    void H() {
        if (true) {
            int i = 0;
        }
        if (true) {
            int i = 1;
        }
    }

    void I() {
        for (int i = 0; i < 10; i++)
            H();
        for (int i = 0; i < 10; i++)
            H();
    }
}
```

## <a name="members"></a><span data-ttu-id="a8f02-191">Участники</span><span class="sxs-lookup"><span data-stu-id="a8f02-191">Members</span></span>

<span data-ttu-id="a8f02-192">Пространства имен и типы имеют ***члены***.</span><span class="sxs-lookup"><span data-stu-id="a8f02-192">Namespaces and types have ***members***.</span></span> <span data-ttu-id="a8f02-193">Элементы сущности являются общедоступными при помощи полного имени, начинающийся со ссылкой на сущность, а затем "`.`" маркеров, а затем имя члена.</span><span class="sxs-lookup"><span data-stu-id="a8f02-193">The members of an entity are generally available through the use of a qualified name that starts with a reference to the entity, followed by a "`.`" token, followed by the name of the member.</span></span>

<span data-ttu-id="a8f02-194">Члены типа либо объявляются в объявлении типа или ***наследуется*** от базового класса типа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-194">Members of a type are either declared in the type declaration or ***inherited*** from the base class of the type.</span></span> <span data-ttu-id="a8f02-195">Если тип наследуется от базового класса, все члены базового класса, за исключением конструкторы экземпляров, деструкторы и статические конструкторы, становятся членами производного типа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-195">When a type inherits from a base class, all members of the base class, except instance constructors, destructors and static constructors, become members of the derived type.</span></span> <span data-ttu-id="a8f02-196">Объявленный уровень доступности члена базового класса не контролирует, наследуется ли член — наследование распространяется на любой элемент, который не конструктор экземпляра, статический конструктор или деструктор.</span><span class="sxs-lookup"><span data-stu-id="a8f02-196">The declared accessibility of a base class member does not control whether the member is inherited—inheritance extends to any member that isn't an instance constructor, static constructor, or destructor.</span></span> <span data-ttu-id="a8f02-197">Тем не менее, унаследованный член могут оказаться недоступным в производном типе, либо из-за его объявленный уровень доступности ([объявленную доступность](basic-concepts.md#declared-accessibility)) либо потому, что он скрыт путем объявления в самом типе ([скрытие через наследование](basic-concepts.md#hiding-through-inheritance)).</span><span class="sxs-lookup"><span data-stu-id="a8f02-197">However, an inherited member may not be accessible in a derived type, either because of its declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) or because it is hidden by a declaration in the type itself ([Hiding through inheritance](basic-concepts.md#hiding-through-inheritance)).</span></span>

### <a name="namespace-members"></a><span data-ttu-id="a8f02-198">Члены пространства имен</span><span class="sxs-lookup"><span data-stu-id="a8f02-198">Namespace members</span></span>

<span data-ttu-id="a8f02-199">Пространства имен и типов, имеющих без вмещающего пространства имен являются членами ***глобальное пространство имен***.</span><span class="sxs-lookup"><span data-stu-id="a8f02-199">Namespaces and types that have no enclosing namespace are members of the ***global namespace***.</span></span> <span data-ttu-id="a8f02-200">Это непосредственно соответствует именам, объявленным в глобальной области объявления.</span><span class="sxs-lookup"><span data-stu-id="a8f02-200">This corresponds directly to the names declared in the global declaration space.</span></span>

<span data-ttu-id="a8f02-201">Пространства имен и типы, объявленные в пространстве имен являются членами этого пространства имен.</span><span class="sxs-lookup"><span data-stu-id="a8f02-201">Namespaces and types declared within a namespace are members of that namespace.</span></span> <span data-ttu-id="a8f02-202">Это соответствует непосредственно имена, объявленные в области объявления пространства имен.</span><span class="sxs-lookup"><span data-stu-id="a8f02-202">This corresponds directly to the names declared in the declaration space of the namespace.</span></span>

<span data-ttu-id="a8f02-203">Пространства имен не имеют ограничений доступа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-203">Namespaces have no access restrictions.</span></span> <span data-ttu-id="a8f02-204">Невозможно объявить закрытого, защищенного или внутреннего пространства имен и пространств имен всегда являются общедоступными.</span><span class="sxs-lookup"><span data-stu-id="a8f02-204">It is not possible to declare private, protected, or internal namespaces, and namespace names are always publicly accessible.</span></span>

### <a name="struct-members"></a><span data-ttu-id="a8f02-205">Члены структуры</span><span class="sxs-lookup"><span data-stu-id="a8f02-205">Struct members</span></span>

<span data-ttu-id="a8f02-206">Члены структуры — члены, объявленные в структуре и члены, унаследованные от структуры прямой базовый класс `System.ValueType` и косвенный базовый класс `object`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-206">The members of a struct are the members declared in the struct and the members inherited from the struct's direct base class `System.ValueType` and the indirect base class `object`.</span></span>

<span data-ttu-id="a8f02-207">Элементы простого типа непосредственно соответствуют члены типа структуры с псевдонимами по простому типу.</span><span class="sxs-lookup"><span data-stu-id="a8f02-207">The members of a simple type correspond directly to the members of the struct type aliased by the simple type:</span></span>

*  <span data-ttu-id="a8f02-208">Члены `sbyte` являются членами `System.SByte` структуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-208">The members of `sbyte` are the members of the `System.SByte` struct.</span></span>
*  <span data-ttu-id="a8f02-209">Члены `byte` являются членами `System.Byte` структуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-209">The members of `byte` are the members of the `System.Byte` struct.</span></span>
*  <span data-ttu-id="a8f02-210">Члены `short` являются членами `System.Int16` структуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-210">The members of `short` are the members of the `System.Int16` struct.</span></span>
*  <span data-ttu-id="a8f02-211">Члены `ushort` являются членами `System.UInt16` структуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-211">The members of `ushort` are the members of the `System.UInt16` struct.</span></span>
*  <span data-ttu-id="a8f02-212">Члены `int` являются членами `System.Int32` структуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-212">The members of `int` are the members of the `System.Int32` struct.</span></span>
*  <span data-ttu-id="a8f02-213">Члены `uint` являются членами `System.UInt32` структуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-213">The members of `uint` are the members of the `System.UInt32` struct.</span></span>
*  <span data-ttu-id="a8f02-214">Члены `long` являются членами `System.Int64` структуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-214">The members of `long` are the members of the `System.Int64` struct.</span></span>
*  <span data-ttu-id="a8f02-215">Члены `ulong` являются членами `System.UInt64` структуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-215">The members of `ulong` are the members of the `System.UInt64` struct.</span></span>
*  <span data-ttu-id="a8f02-216">Члены `char` являются членами `System.Char` структуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-216">The members of `char` are the members of the `System.Char` struct.</span></span>
*  <span data-ttu-id="a8f02-217">Члены `float` являются членами `System.Single` структуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-217">The members of `float` are the members of the `System.Single` struct.</span></span>
*  <span data-ttu-id="a8f02-218">Члены `double` являются членами `System.Double` структуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-218">The members of `double` are the members of the `System.Double` struct.</span></span>
*  <span data-ttu-id="a8f02-219">Члены `decimal` являются членами `System.Decimal` структуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-219">The members of `decimal` are the members of the `System.Decimal` struct.</span></span>
*  <span data-ttu-id="a8f02-220">Члены `bool` являются членами `System.Boolean` структуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-220">The members of `bool` are the members of the `System.Boolean` struct.</span></span>

### <a name="enumeration-members"></a><span data-ttu-id="a8f02-221">Члены перечисления</span><span class="sxs-lookup"><span data-stu-id="a8f02-221">Enumeration members</span></span>

<span data-ttu-id="a8f02-222">Члены перечисления — константы, объявленные в перечислении и члены, унаследованные от прямого базового класса перечисления `System.Enum` и косвенных базовых классов `System.ValueType` и `object`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-222">The members of an enumeration are the constants declared in the enumeration and the members inherited from the enumeration's direct base class `System.Enum` and the indirect base classes `System.ValueType` and `object`.</span></span>

### <a name="class-members"></a><span data-ttu-id="a8f02-223">Члены класса</span><span class="sxs-lookup"><span data-stu-id="a8f02-223">Class members</span></span>

<span data-ttu-id="a8f02-224">Члены класса — члены, объявленные в классе и члены, унаследованные от базового класса (за исключением класса `object` которого не имеет базового класса).</span><span class="sxs-lookup"><span data-stu-id="a8f02-224">The members of a class are the members declared in the class and the members inherited from the base class (except for class `object` which has no base class).</span></span> <span data-ttu-id="a8f02-225">Члены, унаследованные от базового класса включают константы, поля, методы, свойства, события, индексаторы, операторы и типы базового класса, но не конструкторы экземпляров, деструкторы и статические конструкторы базового класса.</span><span class="sxs-lookup"><span data-stu-id="a8f02-225">The members inherited from the base class include the constants, fields, methods, properties, events, indexers, operators, and types of the base class, but not the instance constructors, destructors and static constructors of the base class.</span></span> <span data-ttu-id="a8f02-226">Члены базового класса наследуются вне зависимости от их доступности.</span><span class="sxs-lookup"><span data-stu-id="a8f02-226">Base class members are inherited without regard to their accessibility.</span></span>

<span data-ttu-id="a8f02-227">Объявление класса может содержать объявления константы, поля, методы, свойства, события, индексаторы, операторы, конструкторы экземпляров, деструкторы, статических конструкторов и типов.</span><span class="sxs-lookup"><span data-stu-id="a8f02-227">A class declaration may contain declarations of constants, fields, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors and types.</span></span>

<span data-ttu-id="a8f02-228">Члены `object` и `string` напрямую соответствуют члены класса типов они псевдоним:</span><span class="sxs-lookup"><span data-stu-id="a8f02-228">The members of `object` and `string` correspond directly to the members of the class types they alias:</span></span>

*  <span data-ttu-id="a8f02-229">Члены `object` являются членами `System.Object` класса.</span><span class="sxs-lookup"><span data-stu-id="a8f02-229">The members of `object` are the members of the `System.Object` class.</span></span>
*  <span data-ttu-id="a8f02-230">Члены `string` являются членами `System.String` класса.</span><span class="sxs-lookup"><span data-stu-id="a8f02-230">The members of `string` are the members of the `System.String` class.</span></span>

### <a name="interface-members"></a><span data-ttu-id="a8f02-231">Члены интерфейса</span><span class="sxs-lookup"><span data-stu-id="a8f02-231">Interface members</span></span>

<span data-ttu-id="a8f02-232">Члены интерфейса являются члены, объявленные в интерфейсе и во всех интерфейсах базового интерфейса.</span><span class="sxs-lookup"><span data-stu-id="a8f02-232">The members of an interface are the members declared in the interface and in all base interfaces of the interface.</span></span> <span data-ttu-id="a8f02-233">Члены в классе `object` — нет, строго говоря, членами какого-либо интерфейса ([члены интерфейса](interfaces.md#interface-members)).</span><span class="sxs-lookup"><span data-stu-id="a8f02-233">The members in class `object` are not, strictly speaking, members of any interface ([Interface members](interfaces.md#interface-members)).</span></span> <span data-ttu-id="a8f02-234">Тем не менее элементы в классе `object` доступны через поиск члена в любой другой тип интерфейса ([поиск члена](expressions.md#member-lookup)).</span><span class="sxs-lookup"><span data-stu-id="a8f02-234">However, the members in class `object` are available via member lookup in any interface type ([Member lookup](expressions.md#member-lookup)).</span></span>

### <a name="array-members"></a><span data-ttu-id="a8f02-235">Члены массива</span><span class="sxs-lookup"><span data-stu-id="a8f02-235">Array members</span></span>

<span data-ttu-id="a8f02-236">Элементы массива являются члены, унаследованные от класса `System.Array`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-236">The members of an array are the members inherited from class `System.Array`.</span></span>

### <a name="delegate-members"></a><span data-ttu-id="a8f02-237">Члены делегата</span><span class="sxs-lookup"><span data-stu-id="a8f02-237">Delegate members</span></span>

<span data-ttu-id="a8f02-238">Членами делегата являются члены, унаследованные от класса `System.Delegate`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-238">The members of a delegate are the members inherited from class `System.Delegate`.</span></span>

## <a name="member-access"></a><span data-ttu-id="a8f02-239">Доступ к членам</span><span class="sxs-lookup"><span data-stu-id="a8f02-239">Member access</span></span>

<span data-ttu-id="a8f02-240">Объявления членов позволяют контролировать доступ к членам.</span><span class="sxs-lookup"><span data-stu-id="a8f02-240">Declarations of members allow control over member access.</span></span> <span data-ttu-id="a8f02-241">Доступность члена устанавливается посредством объявленный уровень доступности ([объявленную доступность](basic-concepts.md#declared-accessibility)) члена в сочетании с доступности непосредственно вмещающего его типа, если таковые имеются.</span><span class="sxs-lookup"><span data-stu-id="a8f02-241">The accessibility of a member is established by the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of the member combined with the accessibility of the immediately containing type, if any.</span></span>

<span data-ttu-id="a8f02-242">Если разрешен доступ к конкретному элементу, элемент считается ***доступный***.</span><span class="sxs-lookup"><span data-stu-id="a8f02-242">When access to a particular member is allowed, the member is said to be ***accessible***.</span></span> <span data-ttu-id="a8f02-243">И наоборот, если запрещен доступ к конкретному элементу, элемент считается ***недоступным***.</span><span class="sxs-lookup"><span data-stu-id="a8f02-243">Conversely, when access to a particular member is disallowed, the member is said to be ***inaccessible***.</span></span> <span data-ttu-id="a8f02-244">Доступ к члену разрешен при фактическом, в котором происходит доступ в домен доступности ([области доступности](basic-concepts.md#accessibility-domains)) элемента.</span><span class="sxs-lookup"><span data-stu-id="a8f02-244">Access to a member is permitted when the textual location in which the access takes place is included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>

### <a name="declared-accessibility"></a><span data-ttu-id="a8f02-245">Объявленная доступность</span><span class="sxs-lookup"><span data-stu-id="a8f02-245">Declared accessibility</span></span>

<span data-ttu-id="a8f02-246">***Объявленную доступность*** члена может принимать одно из следующих:</span><span class="sxs-lookup"><span data-stu-id="a8f02-246">The ***declared accessibility*** of a member can be one of the following:</span></span>

*  <span data-ttu-id="a8f02-247">Public, который можно выбрать, включив `public` модификатор в объявлении члена.</span><span class="sxs-lookup"><span data-stu-id="a8f02-247">Public, which is selected by including a `public` modifier in the member declaration.</span></span> <span data-ttu-id="a8f02-248">Интуитивно понятный значение `public` «доступ не ограничен».</span><span class="sxs-lookup"><span data-stu-id="a8f02-248">The intuitive meaning of `public` is "access not limited".</span></span>
*  <span data-ttu-id="a8f02-249">Защищенные, который выбран, включив `protected` модификатор в объявлении члена.</span><span class="sxs-lookup"><span data-stu-id="a8f02-249">Protected, which is selected by including a `protected` modifier in the member declaration.</span></span> <span data-ttu-id="a8f02-250">Интуитивно понятный значение `protected` является «доступ ограничен содержащим классом или типами производным от содержащего класса».</span><span class="sxs-lookup"><span data-stu-id="a8f02-250">The intuitive meaning of `protected` is "access limited to the containing class or types derived from the containing class".</span></span>
*  <span data-ttu-id="a8f02-251">Внутренний, который можно выбрать, включив `internal` модификатор в объявлении члена.</span><span class="sxs-lookup"><span data-stu-id="a8f02-251">Internal, which is selected by including an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="a8f02-252">Интуитивно понятный значение `internal` является «доступ возможен только из этой программы».</span><span class="sxs-lookup"><span data-stu-id="a8f02-252">The intuitive meaning of `internal` is "access limited to this program".</span></span>
*  <span data-ttu-id="a8f02-253">Защищенный внутренний (то есть защищенные или внутренние), который выбран, включая `protected` и `internal` модификатор в объявлении члена.</span><span class="sxs-lookup"><span data-stu-id="a8f02-253">Protected internal (meaning protected or internal), which is selected by including both a `protected` and an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="a8f02-254">Интуитивно понятный значение `protected internal` «доступ возможен только из этой программы или типам, производным от содержащего класса».</span><span class="sxs-lookup"><span data-stu-id="a8f02-254">The intuitive meaning of `protected internal` is "access limited to this program or types derived from the containing class".</span></span>
*  <span data-ttu-id="a8f02-255">Private, который можно выбрать, включив `private` модификатор в объявлении члена.</span><span class="sxs-lookup"><span data-stu-id="a8f02-255">Private, which is selected by including a `private` modifier in the member declaration.</span></span> <span data-ttu-id="a8f02-256">Интуитивно понятный значение `private` является «доступ возможен только из содержащего типа».</span><span class="sxs-lookup"><span data-stu-id="a8f02-256">The intuitive meaning of `private` is "access limited to the containing type".</span></span>

<span data-ttu-id="a8f02-257">В зависимости от контекста, в котором происходит объявление члена поместить, разрешены только определенные типы объявленный уровень доступности.</span><span class="sxs-lookup"><span data-stu-id="a8f02-257">Depending on the context in which a member declaration takes place, only certain types of declared accessibility are permitted.</span></span> <span data-ttu-id="a8f02-258">Кроме того при объявлении члена не включает модификаторы доступа, контекст, в котором происходит объявление определяет объявленную доступность по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="a8f02-258">Furthermore, when a member declaration does not include any access modifiers, the context in which the declaration takes place determines the default declared accessibility.</span></span>

*  <span data-ttu-id="a8f02-259">Пространства имен неявно имеют `public` объявленную доступность.</span><span class="sxs-lookup"><span data-stu-id="a8f02-259">Namespaces implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="a8f02-260">Модификаторы доступа не разрешены в объявлениях пространств имен.</span><span class="sxs-lookup"><span data-stu-id="a8f02-260">No access modifiers are allowed on namespace declarations.</span></span>
*  <span data-ttu-id="a8f02-261">Типы, объявленные в единицах компиляции или пространства имен могут иметь `public` или `internal` объявлен специальных возможностей и по умолчанию `internal` объявленную доступность.</span><span class="sxs-lookup"><span data-stu-id="a8f02-261">Types declared in compilation units or namespaces can have `public` or `internal` declared accessibility and default to `internal` declared accessibility.</span></span>
*  <span data-ttu-id="a8f02-262">Члены класса могут иметь любые пять видов объявленный уровень доступности и по умолчанию `private` объявленную доступность.</span><span class="sxs-lookup"><span data-stu-id="a8f02-262">Class members can have any of the five kinds of declared accessibility and default to `private` declared accessibility.</span></span> <span data-ttu-id="a8f02-263">(Обратите внимание, что тип, объявленный как член класса могут содержать любой из пяти типов объявленный уровень доступности, в то время как тип объявлен как члена пространства имен может иметь только `public` или `internal` объявленную доступность.)</span><span class="sxs-lookup"><span data-stu-id="a8f02-263">(Note that a type declared as a member of a class can have any of the five kinds of declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="a8f02-264">Члены структуры могут иметь `public`, `internal`, или `private` объявлен специальных возможностей и по умолчанию `private` объявленную доступность, поскольку структуры неявно запечатаны.</span><span class="sxs-lookup"><span data-stu-id="a8f02-264">Struct members can have `public`, `internal`, or `private` declared accessibility and default to `private` declared accessibility because structs are implicitly sealed.</span></span> <span data-ttu-id="a8f02-265">Члены структуры, размещенные в структуре (который не наследуется эта структура) не может иметь `protected` или `protected internal` объявленную доступность.</span><span class="sxs-lookup"><span data-stu-id="a8f02-265">Struct members introduced in a struct (that is, not inherited by that struct) cannot have `protected` or `protected internal` declared accessibility.</span></span> <span data-ttu-id="a8f02-266">(Обратите внимание, что тип, объявленный член структуры могут иметь `public`, `internal`, или `private` объявленную доступность, тогда как тип объявлен как члена пространства имен может иметь только `public` или `internal` объявленную доступность.)</span><span class="sxs-lookup"><span data-stu-id="a8f02-266">(Note that a type declared as a member of a struct can have `public`, `internal`, or `private` declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="a8f02-267">Члены интерфейса неявно имеют `public` объявленную доступность.</span><span class="sxs-lookup"><span data-stu-id="a8f02-267">Interface members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="a8f02-268">Модификаторы доступа не разрешены в объявлениях членов интерфейса.</span><span class="sxs-lookup"><span data-stu-id="a8f02-268">No access modifiers are allowed on interface member declarations.</span></span>
*  <span data-ttu-id="a8f02-269">Члены перечисления неявно имеют `public` объявленную доступность.</span><span class="sxs-lookup"><span data-stu-id="a8f02-269">Enumeration members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="a8f02-270">Модификаторы доступа не разрешены в объявлениях членов перечислений.</span><span class="sxs-lookup"><span data-stu-id="a8f02-270">No access modifiers are allowed on enumeration member declarations.</span></span>

### <a name="accessibility-domains"></a><span data-ttu-id="a8f02-271">Области доступности</span><span class="sxs-lookup"><span data-stu-id="a8f02-271">Accessibility domains</span></span>

<span data-ttu-id="a8f02-272">***Домен доступности*** члена состоит из (возможно, не связанных) разделов текста программы, в которой разрешен доступ к члену.</span><span class="sxs-lookup"><span data-stu-id="a8f02-272">The ***accessibility domain*** of a member consists of the (possibly disjoint) sections of program text in which access to the member is permitted.</span></span> <span data-ttu-id="a8f02-273">В целях определения область доступности члена считается членом ***верхнего уровня*** если он не объявлен внутри типа и члена считается ***вложенных*** если он объявлен внутри другого типа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-273">For purposes of defining the accessibility domain of a member, a member is said to be ***top-level*** if it is not declared within a type, and a member is said to be ***nested*** if it is declared within another type.</span></span> <span data-ttu-id="a8f02-274">Кроме того ***программы текст*** программы определяется, как все программы текст, содержащийся во всех исходных файлах программы, а текст программы типа определяется как все программы текст, содержащийся в *type_declaration*s этого типа (включая, возможно, типы, вложенные в тип).</span><span class="sxs-lookup"><span data-stu-id="a8f02-274">Furthermore, the ***program text*** of a program is defined as all program text contained in all source files of the program, and the program text of a type is defined as all program text contained in the *type_declaration*s of that type (including, possibly, types that are nested within the type).</span></span>

<span data-ttu-id="a8f02-275">Домен доступности предопределенного типа (например, `object`, `int`, или `double`) не ограничено.</span><span class="sxs-lookup"><span data-stu-id="a8f02-275">The accessibility domain of a predefined type (such as `object`, `int`, or `double`) is unlimited.</span></span>

<span data-ttu-id="a8f02-276">Домен доступности верхнего уровня, не привязанный тип `T` ([привязан и несвязанные типы](types.md#bound-and-unbound-types)), объявленным в программе `P` определяется следующим образом:</span><span class="sxs-lookup"><span data-stu-id="a8f02-276">The accessibility domain of a top-level unbound type `T` ([Bound and unbound types](types.md#bound-and-unbound-types)) that is declared in a program `P` is defined as follows:</span></span>

*  <span data-ttu-id="a8f02-277">Если объявленный уровень доступности `T` — `public`, то домен доступности `T` — это текст программы `P` и любой программы, которая ссылается на `P`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-277">If the declared accessibility of `T` is `public`, the accessibility domain of `T` is the program text of `P` and any program that references `P`.</span></span>
*  <span data-ttu-id="a8f02-278">Если объявленный уровень доступности `T` — `internal`, то домен доступности `T` совпадает с текстом программы `P`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-278">If the declared accessibility of `T` is `internal`, the accessibility domain of `T` is the program text of `P`.</span></span>

<span data-ttu-id="a8f02-279">Из этих определений следует, что область доступности типа верхнего уровня свободной всегда является по крайней мере текст программы, программы, в которой данный тип объявлен.</span><span class="sxs-lookup"><span data-stu-id="a8f02-279">From these definitions it follows that the accessibility domain of a top-level unbound type is always at least the program text of the program in which that type is declared.</span></span>

<span data-ttu-id="a8f02-280">Домен доступности для сконструированного типа `T<A1, ..., An>` представляет собой пересечение домена доступности несвязанного универсального типа `T` и доменов доступности аргументов типа `A1, ..., An`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-280">The accessibility domain for a constructed type `T<A1, ..., An>` is the intersection of the accessibility domain of the unbound generic type `T` and the accessibility domains of the type arguments `A1, ..., An`.</span></span>

<span data-ttu-id="a8f02-281">Домен доступности вложенного члена `M` , объявленного в типе `T` в рамках программы `P` определяется следующим образом (отметить, что `M` сам может являться типом):</span><span class="sxs-lookup"><span data-stu-id="a8f02-281">The accessibility domain of a nested member `M` declared in a type `T` within a program `P` is defined as follows (noting that `M` itself may possibly be a type):</span></span>

*  <span data-ttu-id="a8f02-282">Если объявленный уровень доступности `M` — `public`, то домен доступности `M` совпадает с доменом доступности `T`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-282">If the declared accessibility of `M` is `public`, the accessibility domain of `M` is the accessibility domain of `T`.</span></span>
*  <span data-ttu-id="a8f02-283">Если объявленный уровень доступности `M` — `protected internal`, позволяют `D` объединяются с текстом программы `P` и текстом программы любого типа, производный от `T`, который объявляется за пределами `P`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-283">If the declared accessibility of `M` is `protected internal`, let `D` be the union of the program text of `P` and the program text of any type derived from `T`, which is declared outside `P`.</span></span> <span data-ttu-id="a8f02-284">Домен доступности `M` представляет собой пересечение домена доступности `T` с `D`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-284">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="a8f02-285">Если объявленный уровень доступности `M` — `protected`, позволяют `D` объединяются с текстом программы `T` и текстом программы любого типа, производный от `T`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-285">If the declared accessibility of `M` is `protected`, let `D` be the union of the program text of `T` and the program text of any type derived from `T`.</span></span> <span data-ttu-id="a8f02-286">Домен доступности `M` представляет собой пересечение домена доступности `T` с `D`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-286">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="a8f02-287">Если объявленный уровень доступности `M` — `internal`, то домен доступности `M` представляет собой пересечение домена доступности `T` с текстом программы `P`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-287">If the declared accessibility of `M` is `internal`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `P`.</span></span>
*  <span data-ttu-id="a8f02-288">Если объявленный уровень доступности `M` — `private`, то домен доступности `M` совпадает с текстом программы `T`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-288">If the declared accessibility of `M` is `private`, the accessibility domain of `M` is the program text of `T`.</span></span>

<span data-ttu-id="a8f02-289">Из этих определений следует, что домен доступности вложенного члена всегда является по крайней мере текст программы типа, в котором объявлен этот элемент.</span><span class="sxs-lookup"><span data-stu-id="a8f02-289">From these definitions it follows that the accessibility domain of a nested member is always at least the program text of the type in which the member is declared.</span></span> <span data-ttu-id="a8f02-290">Кроме того следует, что область доступности члена никогда не является больше объектов, чем область доступности типа, в котором объявлен этот элемент.</span><span class="sxs-lookup"><span data-stu-id="a8f02-290">Furthermore, it follows that the accessibility domain of a member is never more inclusive than the accessibility domain of the type in which the member is declared.</span></span>

<span data-ttu-id="a8f02-291">Интуитивно понятно когда тип или член `M` имеет доступ, чтобы убедиться, что доступ разрешается вычисляются следующие шаги:</span><span class="sxs-lookup"><span data-stu-id="a8f02-291">In intuitive terms, when a type or member `M` is accessed, the following steps are evaluated to ensure that the access is permitted:</span></span>

*  <span data-ttu-id="a8f02-292">Во-первых, если `M` объявлены внутри типа (в отличие от единице компиляции или пространстве имен), ошибка времени компиляции возникает, если этот тип не является доступным.</span><span class="sxs-lookup"><span data-stu-id="a8f02-292">First, if `M` is declared within a type (as opposed to a compilation unit or a namespace), a compile-time error occurs if that type is not accessible.</span></span>
*  <span data-ttu-id="a8f02-293">Затем, если `M` является `public`, доступ разрешается.</span><span class="sxs-lookup"><span data-stu-id="a8f02-293">Then, if `M` is `public`, the access is permitted.</span></span>
*  <span data-ttu-id="a8f02-294">В противном случае, если `M` — `protected internal`, доступ разрешается в том случае, если он встречается в программе, в которой `M` был объявлен, или если он встречается в класс, производный от класса, в котором `M` объявлен и осуществляется через производные тип класса ([защищенного доступа для экземпляра к членам](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="a8f02-294">Otherwise, if `M` is `protected internal`, the access is permitted if it occurs within the program in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="a8f02-295">В противном случае, если `M` — `protected`, доступ разрешается в том случае, если он встречается в класс, в котором `M` был объявлен, или если он встречается в класс, производный от класса, в котором `M` объявлен и осуществляется через производные тип класса ([защищенного доступа для экземпляра к членам](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="a8f02-295">Otherwise, if `M` is `protected`, the access is permitted if it occurs within the class in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="a8f02-296">В противном случае, если `M` — `internal`, доступ разрешается в том случае, если он встречается в программе, в которой `M` объявлен.</span><span class="sxs-lookup"><span data-stu-id="a8f02-296">Otherwise, if `M` is `internal`, the access is permitted if it occurs within the program in which `M` is declared.</span></span>
*  <span data-ttu-id="a8f02-297">В противном случае, если `M` — `private`, доступ разрешается в том случае, если он встречается в тип, в которой `M` объявлен.</span><span class="sxs-lookup"><span data-stu-id="a8f02-297">Otherwise, if `M` is `private`, the access is permitted if it occurs within the type in which `M` is declared.</span></span>
*  <span data-ttu-id="a8f02-298">В противном случае тип или член недоступен, и возникает ошибка времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="a8f02-298">Otherwise, the type or member is inaccessible, and a compile-time error occurs.</span></span>

<span data-ttu-id="a8f02-299">В примере</span><span class="sxs-lookup"><span data-stu-id="a8f02-299">In the example</span></span>
```csharp
public class A
{
    public static int X;
    internal static int Y;
    private static int Z;
}

internal class B
{
    public static int X;
    internal static int Y;
    private static int Z;

    public class C
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }

    private class D
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }
}
```
<span data-ttu-id="a8f02-300">классы и члены имеют следующие области доступности:</span><span class="sxs-lookup"><span data-stu-id="a8f02-300">the classes and members have the following accessibility domains:</span></span>

*  <span data-ttu-id="a8f02-301">Домен доступности `A` и `A.X` не ограничено.</span><span class="sxs-lookup"><span data-stu-id="a8f02-301">The accessibility domain of `A` and `A.X` is unlimited.</span></span>
*  <span data-ttu-id="a8f02-302">Домен доступности `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X`, и `B.C.Y` совпадает с текстом программы содержания программы.</span><span class="sxs-lookup"><span data-stu-id="a8f02-302">The accessibility domain of `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X`, and `B.C.Y` is the program text of the containing program.</span></span>
*  <span data-ttu-id="a8f02-303">Домен доступности `A.Z` — это текст программы `A`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-303">The accessibility domain of `A.Z` is the program text of `A`.</span></span>
*  <span data-ttu-id="a8f02-304">Домен доступности `B.Z` и `B.D` — это текст программы `B`, включая текст программы `B.C` и `B.D`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-304">The accessibility domain of `B.Z` and `B.D` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="a8f02-305">Домен доступности `B.C.Z` — это текст программы `B.C`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-305">The accessibility domain of `B.C.Z` is the program text of `B.C`.</span></span>
*  <span data-ttu-id="a8f02-306">Домен доступности `B.D.X` и `B.D.Y` — это текст программы `B`, включая текст программы `B.C` и `B.D`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-306">The accessibility domain of `B.D.X` and `B.D.Y` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="a8f02-307">Домен доступности `B.D.Z` — это текст программы `B.D`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-307">The accessibility domain of `B.D.Z` is the program text of `B.D`.</span></span>

<span data-ttu-id="a8f02-308">Как показано в примере, то домен доступности члена никогда не должен превышать, содержащего типа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-308">As the example illustrates, the accessibility domain of a member is never larger than that of a containing type.</span></span> <span data-ttu-id="a8f02-309">Например несмотря на то что все `X` члены имеют открытый объявленный уровень доступности, все, кроме `A.X` имеют области доступности, ограниченные содержащего типа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-309">For example, even though all `X` members have public declared accessibility, all but `A.X` have accessibility domains that are constrained by a containing type.</span></span>

<span data-ttu-id="a8f02-310">Как описано в разделе [члены](basic-concepts.md#members), все члены базового класса, за исключением случаев, например, конструкторы, деструкторы и статические конструкторы, наследуются производными типами.</span><span class="sxs-lookup"><span data-stu-id="a8f02-310">As described in [Members](basic-concepts.md#members), all members of a base class, except for instance constructors, destructors and static constructors, are inherited by derived types.</span></span> <span data-ttu-id="a8f02-311">Это касается даже закрытых членов базового класса.</span><span class="sxs-lookup"><span data-stu-id="a8f02-311">This includes even private members of a base class.</span></span> <span data-ttu-id="a8f02-312">Однако домен доступности закрытого члена содержит только текст программы типа, в котором объявлен этот элемент.</span><span class="sxs-lookup"><span data-stu-id="a8f02-312">However, the accessibility domain of a private member includes only the program text of the type in which the member is declared.</span></span> <span data-ttu-id="a8f02-313">В примере</span><span class="sxs-lookup"><span data-stu-id="a8f02-313">In the example</span></span>
```csharp
class A
{
    int x;

    static void F(B b) {
        b.x = 1;        // Ok
    }
}

class B: A
{
    static void F(B b) {
        b.x = 1;        // Error, x not accessible
    }
}
```
<span data-ttu-id="a8f02-314">`B` класс наследует закрытый член `x` из `A` класса.</span><span class="sxs-lookup"><span data-stu-id="a8f02-314">the `B` class inherits the private member `x` from the `A` class.</span></span> <span data-ttu-id="a8f02-315">Так как член является закрытым, он был доступен только в пределах *class_body* из `A`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-315">Because the member is private, it is only accessible within the *class_body* of `A`.</span></span> <span data-ttu-id="a8f02-316">Таким образом, доступ к `b.x` успешно `A.F` метод, но завершается с ошибкой `B.F` метод.</span><span class="sxs-lookup"><span data-stu-id="a8f02-316">Thus, the access to `b.x` succeeds in the `A.F` method, but fails in the `B.F` method.</span></span>

### <a name="protected-access-for-instance-members"></a><span data-ttu-id="a8f02-317">Защищенный доступ для членов экземпляров.</span><span class="sxs-lookup"><span data-stu-id="a8f02-317">Protected access for instance members</span></span>

<span data-ttu-id="a8f02-318">Когда `protected` доступ к члену экземпляра вне класса, в котором он объявлен, текста и когда `protected internal` доступ к члену экземпляра вне текста программы, в котором он объявлен, доступ должен осуществляться в объявление класса, производного от класса, в котором она объявлена.</span><span class="sxs-lookup"><span data-stu-id="a8f02-318">When a `protected` instance member is accessed outside the program text of the class in which it is declared, and when a `protected internal` instance member is accessed outside the program text of the program in which it is declared, the access must take place within a class declaration that derives from the class in which it is declared.</span></span> <span data-ttu-id="a8f02-319">Кроме того должно выполняться через экземпляр производного типа класса или типа класса, созданный из них необходим доступ.</span><span class="sxs-lookup"><span data-stu-id="a8f02-319">Furthermore, the access is required to take place through an instance of that derived class type or a class type constructed from it.</span></span> <span data-ttu-id="a8f02-320">Это ограничение предотвращает доступ к защищенным членам другого производного класса, даже в том случае, если члены наследуются от одного базового класса одного производного класса.</span><span class="sxs-lookup"><span data-stu-id="a8f02-320">This restriction prevents one derived class from accessing protected members of other derived classes, even when the members are inherited from the same base class.</span></span>

<span data-ttu-id="a8f02-321">Позвольте `B` быть базовым классом, который объявляет член защищенный экземпляр `M`и позволить `D` быть класс, производный от `B`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-321">Let `B` be a base class that declares a protected instance member `M`, and let `D` be a class that derives from `B`.</span></span> <span data-ttu-id="a8f02-322">В рамках *class_body* из `D`, доступ к `M` может принимать одно из следующих форм:</span><span class="sxs-lookup"><span data-stu-id="a8f02-322">Within the *class_body* of `D`, access to `M` can take one of the following forms:</span></span>

*  <span data-ttu-id="a8f02-323">Неопределенного *type_name* или *primary_expression* формы `M`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-323">An unqualified *type_name* or *primary_expression* of the form `M`.</span></span>
*  <span data-ttu-id="a8f02-324">Объект *primary_expression* формы `E.M`, предоставленный тип `E` — `T` или класс, производный от `T`, где `T` является типом класса `D`, или тип класса создан на основе `D`</span><span class="sxs-lookup"><span data-stu-id="a8f02-324">A *primary_expression* of the form `E.M`, provided the type of `E` is `T` or a class derived from `T`, where `T` is the class type `D`, or a class type constructed from `D`</span></span>
*  <span data-ttu-id="a8f02-325">Объект *primary_expression* формы `base.M`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-325">A *primary_expression* of the form `base.M`.</span></span>

<span data-ttu-id="a8f02-326">Помимо этих форм доступа производный класс может обращаться к защищенный экземпляр конструктора базового класса в *constructor_initializer* ([инициализаторы конструктора](classes.md#constructor-initializers)).</span><span class="sxs-lookup"><span data-stu-id="a8f02-326">In addition to these forms of access, a derived class can access a protected instance constructor of a base class in a *constructor_initializer* ([Constructor initializers](classes.md#constructor-initializers)).</span></span>

<span data-ttu-id="a8f02-327">В примере</span><span class="sxs-lookup"><span data-stu-id="a8f02-327">In the example</span></span>
```csharp
public class A
{
    protected int x;

    static void F(A a, B b) {
        a.x = 1;        // Ok
        b.x = 1;        // Ok
    }
}

public class B: A
{
    static void F(A a, B b) {
        a.x = 1;        // Error, must access through instance of B
        b.x = 1;        // Ok
    }
}
```
<span data-ttu-id="a8f02-328">в рамках `A`, имеется возможность доступа `x` через экземпляры оба `A` и `B`, так как в любом случае доступ осуществляется через экземпляр `A` или класс, производный от `A`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-328">within `A`, it is possible to access `x` through instances of both `A` and `B`, since in either case the access takes place through an instance of `A` or a class derived from `A`.</span></span> <span data-ttu-id="a8f02-329">Тем не менее, в пределах `B`, невозможно получить доступ к `x` через экземпляр `A`, так как `A` является производным от `B`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-329">However, within `B`, it is not possible to access `x` through an instance of `A`, since `A` does not derive from `B`.</span></span>

<span data-ttu-id="a8f02-330">В примере</span><span class="sxs-lookup"><span data-stu-id="a8f02-330">In the example</span></span>
```csharp
class C<T>
{
    protected T x;
}

class D<T>: C<T>
{
    static void F() {
        D<T> dt = new D<T>();
        D<int> di = new D<int>();
        D<string> ds = new D<string>();
        dt.x = default(T);
        di.x = 123;
        ds.x = "test";
    }
}
```
<span data-ttu-id="a8f02-331">три присваивания `x` разрешены, так как они все осуществляются через экземпляры типов классов, созданный из универсального типа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-331">the three assignments to `x` are permitted because they all take place through instances of class types constructed from the generic type.</span></span>

### <a name="accessibility-constraints"></a><span data-ttu-id="a8f02-332">Ограничения доступности</span><span class="sxs-lookup"><span data-stu-id="a8f02-332">Accessibility constraints</span></span>

<span data-ttu-id="a8f02-333">Несколько конструкций на языке C# требуют, чтобы быть ***по крайней мере такой же уровень доступности, как*** члена или другого типа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-333">Several constructs in the C# language require a type to be ***at least as accessible as*** a member or another type.</span></span> <span data-ttu-id="a8f02-334">Тип `T` говорят, что по крайней мере такой же уровень доступности, как член или тип `M` Если домен доступности `T` является надмножеством то домен доступности `M`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-334">A type `T` is said to be at least as accessible as a member or type `M` if the accessibility domain of `T` is a superset of the accessibility domain of `M`.</span></span> <span data-ttu-id="a8f02-335">Другими словами `T` — по крайней мере такой же уровень доступности, как `M` Если `T` доступен во всех контекстах, в котором `M` доступен.</span><span class="sxs-lookup"><span data-stu-id="a8f02-335">In other words, `T` is at least as accessible as `M` if `T` is accessible in all contexts in which `M` is accessible.</span></span>

<span data-ttu-id="a8f02-336">Существуют следующие ограничения доступности:</span><span class="sxs-lookup"><span data-stu-id="a8f02-336">The following accessibility constraints exist:</span></span>

*  <span data-ttu-id="a8f02-337">Прямой базовый класс для типа класса должен иметь по крайней мере такой же уровень доступности, как и сам тип класса.</span><span class="sxs-lookup"><span data-stu-id="a8f02-337">The direct base class of a class type must be at least as accessible as the class type itself.</span></span>
*  <span data-ttu-id="a8f02-338">Явные базовые интерфейсы для типа интерфейса должны иметь по крайней мере такой же уровень доступности, как и сам тип интерфейса.</span><span class="sxs-lookup"><span data-stu-id="a8f02-338">The explicit base interfaces of an interface type must be at least as accessible as the interface type itself.</span></span>
*  <span data-ttu-id="a8f02-339">Тип возвращаемого значения и типы параметров для типа делегата должны иметь по крайней мере такой же уровень доступности, как и сам тип делегата.</span><span class="sxs-lookup"><span data-stu-id="a8f02-339">The return type and parameter types of a delegate type must be at least as accessible as the delegate type itself.</span></span>
*  <span data-ttu-id="a8f02-340">Тип константы должен иметь по крайней мере такой же уровень доступности, как и сама константа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-340">The type of a constant must be at least as accessible as the constant itself.</span></span>
*  <span data-ttu-id="a8f02-341">Тип поля должен иметь по крайней мере такой же уровень доступности, как и само поле.</span><span class="sxs-lookup"><span data-stu-id="a8f02-341">The type of a field must be at least as accessible as the field itself.</span></span>
*  <span data-ttu-id="a8f02-342">Тип возвращаемого значения и типы параметров для метода должны иметь по крайней мере такой же уровень доступности, как и сам метод.</span><span class="sxs-lookup"><span data-stu-id="a8f02-342">The return type and parameter types of a method must be at least as accessible as the method itself.</span></span>
*  <span data-ttu-id="a8f02-343">Тип свойства должен иметь по крайней мере такой же уровень доступности, как и само свойство.</span><span class="sxs-lookup"><span data-stu-id="a8f02-343">The type of a property must be at least as accessible as the property itself.</span></span>
*  <span data-ttu-id="a8f02-344">Тип события должен иметь по крайней мере такой же уровень доступности, как и само событие.</span><span class="sxs-lookup"><span data-stu-id="a8f02-344">The type of an event must be at least as accessible as the event itself.</span></span>
*  <span data-ttu-id="a8f02-345">Тип и типы параметров для индексатора должны иметь по крайней мере такой же уровень доступности, как и сам индексатор.</span><span class="sxs-lookup"><span data-stu-id="a8f02-345">The type and parameter types of an indexer must be at least as accessible as the indexer itself.</span></span>
*  <span data-ttu-id="a8f02-346">Тип возвращаемого значения и типы параметров для оператора должны иметь по крайней мере такой же уровень доступности, как и сам оператор.</span><span class="sxs-lookup"><span data-stu-id="a8f02-346">The return type and parameter types of an operator must be at least as accessible as the operator itself.</span></span>
*  <span data-ttu-id="a8f02-347">Типы параметров конструктора экземпляра должно быть по крайней мере такой же уровень доступности, как и сам конструктор экземпляра.</span><span class="sxs-lookup"><span data-stu-id="a8f02-347">The parameter types of an instance constructor must be at least as accessible as the instance constructor itself.</span></span>

<span data-ttu-id="a8f02-348">В примере</span><span class="sxs-lookup"><span data-stu-id="a8f02-348">In the example</span></span>
```csharp
class A {...}

public class B: A {...}
```
<span data-ttu-id="a8f02-349">`B` класса приводит к ошибке времени компиляции, так как `A` не является по крайней мере такой же уровень доступности, как `B`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-349">the `B` class results in a compile-time error because `A` is not at least as accessible as `B`.</span></span>

<span data-ttu-id="a8f02-350">Аналогичным образом в примере</span><span class="sxs-lookup"><span data-stu-id="a8f02-350">Likewise, in the example</span></span>
```csharp
class A {...}

public class B
{
    A F() {...}

    internal A G() {...}

    public A H() {...}
}
```
<span data-ttu-id="a8f02-351">`H` метод в `B` приводит к ошибке времени компиляции, так как тип возвращаемого значения, `A` не является по крайней мере такой же уровень доступности, что и метод.</span><span class="sxs-lookup"><span data-stu-id="a8f02-351">the `H` method in `B` results in a compile-time error because the return type `A` is not at least as accessible as the method.</span></span>

## <a name="signatures-and-overloading"></a><span data-ttu-id="a8f02-352">Сигнатуры и перегрузка</span><span class="sxs-lookup"><span data-stu-id="a8f02-352">Signatures and overloading</span></span>

<span data-ttu-id="a8f02-353">Методы, конструкторы экземпляров, индексаторы и операторы характеризуются их ***подписи***:</span><span class="sxs-lookup"><span data-stu-id="a8f02-353">Methods, instance constructors, indexers, and operators are characterized by their ***signatures***:</span></span>

*  <span data-ttu-id="a8f02-354">Сигнатура метода состоит из имени метода, количество параметров типа и типа и вида (значение, ссылку или вывод) каждого из своих формальных параметров, считается в порядке слева направо.</span><span class="sxs-lookup"><span data-stu-id="a8f02-354">The signature of a method consists of the name of the method, the number of type parameters and the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="a8f02-355">Для этих целей любого параметра типа метода, который происходит в тип формального параметра идентифицируется не по имени, а также по ее порядковому номеру в списке аргументов типа метода.</span><span class="sxs-lookup"><span data-stu-id="a8f02-355">For these purposes, any type parameter of the method that occurs in the type of a formal parameter is identified not by its name, but by its ordinal position in the type argument list of the method.</span></span> <span data-ttu-id="a8f02-356">Сигнатура метода специально не поддерживает тип возвращаемого значения, `params` модификатор, который может быть указан для параметра справа, а также дополнительных ограничений параметра типа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-356">The signature of a method specifically does not include the return type, the `params` modifier that may be specified for the right-most parameter, nor the optional type parameter constraints.</span></span>
*  <span data-ttu-id="a8f02-357">Сигнатура конструктора экземпляра состоит из типа и вида (значение, ссылку или вывод) каждого из своих формальных параметров, считается в порядке слева направо.</span><span class="sxs-lookup"><span data-stu-id="a8f02-357">The signature of an instance constructor consists of the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="a8f02-358">Сигнатура конструктора экземпляра специально не содержит `params` модификатор, который может быть указан для параметра крайнее правое.</span><span class="sxs-lookup"><span data-stu-id="a8f02-358">The signature of an instance constructor specifically does not include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="a8f02-359">Сигнатура индексатора состоит из типа каждого из своих формальных параметров, считается в порядке слева направо.</span><span class="sxs-lookup"><span data-stu-id="a8f02-359">The signature of an indexer consists of the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="a8f02-360">Сигнатура индексатора специально не содержит тип элемента, а также `params` модификатор, который может быть указан для параметра крайнее правое.</span><span class="sxs-lookup"><span data-stu-id="a8f02-360">The signature of an indexer specifically does not include the element type, nor does it include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="a8f02-361">Сигнатура оператора состоит из имени оператора и типа каждого из своих формальных параметров, считается в порядке слева направо.</span><span class="sxs-lookup"><span data-stu-id="a8f02-361">The signature of an operator consists of the name of the operator and the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="a8f02-362">Сигнатура оператора специально не поддерживает тип результата.</span><span class="sxs-lookup"><span data-stu-id="a8f02-362">The signature of an operator specifically does not include the result type.</span></span>

<span data-ttu-id="a8f02-363">Использование механизма имеют сигнатуры ***перегрузка*** членов классов, структур и интерфейсов:</span><span class="sxs-lookup"><span data-stu-id="a8f02-363">Signatures are the enabling mechanism for ***overloading*** of members in classes, structs, and interfaces:</span></span>

*  <span data-ttu-id="a8f02-364">Перегрузка методов позволяет класса, структуры или интерфейса, чтобы объявить несколько методов с тем же именем, предоставляемые их подписи должны быть уникальными в пределах этого класса, структуры или интерфейса.</span><span class="sxs-lookup"><span data-stu-id="a8f02-364">Overloading of methods permits a class, struct, or interface to declare multiple methods with the same name, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="a8f02-365">Перегрузка конструкторов экземпляров позволяет класса или структуры, чтобы объявить несколько конструкторов экземпляров, при условии, что их сигнатуры являются уникальными в пределах класса или структуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-365">Overloading of instance constructors permits a class or struct to declare multiple instance constructors, provided their signatures are unique within that class or struct.</span></span>
*  <span data-ttu-id="a8f02-366">Перегрузка индексаторов позволяет класса, структуры или интерфейса, чтобы объявить несколько индексаторов, при условии, что их сигнатуры являются уникальными в пределах этого класса, структуры или интерфейса.</span><span class="sxs-lookup"><span data-stu-id="a8f02-366">Overloading of indexers permits a class, struct, or interface to declare multiple indexers, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="a8f02-367">Перегрузка операторов позволяет классу или структуре объявить несколько операторов с тем же именем, предоставляемые их подписи должны быть уникальными в пределах класса или структуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-367">Overloading of operators permits a class or struct to declare multiple operators with the same name, provided their signatures are unique within that class or struct.</span></span>

<span data-ttu-id="a8f02-368">Несмотря на то что `out` и `ref` модификаторов параметров, считаются частью сигнатуры, члены, объявленные в одном типе не могут различаться в сигнатуре исключительно записью `ref` и `out`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-368">Although `out` and `ref` parameter modifiers are considered part of a signature, members declared in a single type cannot differ in signature solely by `ref` and `out`.</span></span> <span data-ttu-id="a8f02-369">Ошибка времени компиляции возникает, если два объявления членов в тот же тип, с сигнатурами, которые бы прежним, если все параметры в обоих методах с `out` модификаторы были изменены для `ref` модификаторы.</span><span class="sxs-lookup"><span data-stu-id="a8f02-369">A compile-time error occurs if two members are declared in the same type with signatures that would be the same if all parameters in both methods with `out` modifiers were changed to `ref` modifiers.</span></span> <span data-ttu-id="a8f02-370">Для других целей соответствия сигнатур (например, скрытие или переопределение), `ref` и `out` считаются частью сигнатуры и не соответствуют друг другу.</span><span class="sxs-lookup"><span data-stu-id="a8f02-370">For other purposes of signature matching (e.g., hiding or overriding), `ref` and `out` are considered part of the signature and do not match each other.</span></span> <span data-ttu-id="a8f02-371">(Это ограничение является возможность C# программами легко перевести для запуска на Common Language Infrastructure (CLI), который не предоставляет способ определения методов, которые отличаются только в `ref` и `out`.)</span><span class="sxs-lookup"><span data-stu-id="a8f02-371">(This restriction is to allow C#  programs to be easily translated to run on the Common Language Infrastructure (CLI), which does not provide a way to define methods that differ solely in `ref` and `out`.)</span></span>

<span data-ttu-id="a8f02-372">В рамках подписи, типы `object` и `dynamic` считаются одинаковыми.</span><span class="sxs-lookup"><span data-stu-id="a8f02-372">For the purposes of signatures, the types `object` and `dynamic` are considered the same.</span></span> <span data-ttu-id="a8f02-373">Члены, объявленные в одном типе, могут не отличаться в сигнатуре исключительно записью `object` и `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-373">Members declared in a single type can therefore not differ in signature solely by `object` and `dynamic`.</span></span>

<span data-ttu-id="a8f02-374">Следующий пример показывает набор объявлений перегруженных методов с их сигнатурами.</span><span class="sxs-lookup"><span data-stu-id="a8f02-374">The following example shows a set of overloaded method declarations along with their signatures.</span></span>
```csharp
interface ITest
{
    void F();                        // F()

    void F(int x);                   // F(int)

    void F(ref int x);               // F(ref int)

    void F(out int x);               // F(out int)      error

    void F(int x, int y);            // F(int, int)

    int F(string s);                 // F(string)

    int F(int x);                    // F(int)          error

    void F(string[] a);              // F(string[])

    void F(params string[] a);       // F(string[])     error
}
```

<span data-ttu-id="a8f02-375">Обратите внимание, что все `ref` и `out` модификаторов параметров ([параметры метода](classes.md#method-parameters)) являются частью сигнатуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-375">Note that any `ref` and `out` parameter modifiers ([Method parameters](classes.md#method-parameters)) are part of a signature.</span></span> <span data-ttu-id="a8f02-376">Таким образом `F(int)` и `F(ref int)` являются уникальные сигнатуры.</span><span class="sxs-lookup"><span data-stu-id="a8f02-376">Thus, `F(int)` and `F(ref int)` are unique signatures.</span></span> <span data-ttu-id="a8f02-377">Тем не менее `F(ref int)` и `F(out int)` нельзя объявлять в тот же интерфейс, так как их сигнатуры разные исключительно записью `ref` и `out`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-377">However, `F(ref int)` and `F(out int)` cannot be declared within the same interface because their signatures differ solely by `ref` and `out`.</span></span> <span data-ttu-id="a8f02-378">Кроме того, обратите внимание, что тип возвращаемого значения и `params` модификатор не являются частью сигнатуры, поэтому невозможно перегружать исключительно на основе, тип возвращаемого значения или включение или исключение `params` модификатор.</span><span class="sxs-lookup"><span data-stu-id="a8f02-378">Also, note that the return type and the `params` modifier are not part of a signature, so it is not possible to overload solely based on return type or on the inclusion or exclusion of the `params` modifier.</span></span> <span data-ttu-id="a8f02-379">Таким образом, объявления методов `F(int)` и `F(params string[])` указанных выше приводят к ошибке времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="a8f02-379">As such, the declarations of the methods `F(int)` and `F(params string[])` identified above result in a compile-time error.</span></span>

## <a name="scopes"></a><span data-ttu-id="a8f02-380">Области</span><span class="sxs-lookup"><span data-stu-id="a8f02-380">Scopes</span></span>

<span data-ttu-id="a8f02-381">***Область*** имени является область текста программы, в течение которого можно будет ссылаться на сущность, объявленное имя без уточнения имени.</span><span class="sxs-lookup"><span data-stu-id="a8f02-381">The ***scope*** of a name is the region of program text within which it is possible to refer to the entity declared by the name without qualification of the name.</span></span> <span data-ttu-id="a8f02-382">Области могут быть ***вложенных***, и внутренней области может повторно объявить значение имени из внешней области (это не так, однако удалить ограничение, наложенное [объявления](basic-concepts.md#declarations) внутри вложенного блока не Возможно, чтобы объявить локальную переменную с тем же именем, как локальную переменную во внешнем блоке).</span><span class="sxs-lookup"><span data-stu-id="a8f02-382">Scopes can be ***nested***, and an inner scope may redeclare the meaning of a name from an outer scope (this does not, however, remove the restriction imposed by [Declarations](basic-concepts.md#declarations) that within a nested block it is not possible to declare a local variable with the same name as a local variable in an enclosing block).</span></span> <span data-ttu-id="a8f02-383">Имя из внешней области затем считается ***скрытые*** в регионе программы текста, связанная с внутренней области, и доступ к внешним именем возможна только путем указания имени.</span><span class="sxs-lookup"><span data-stu-id="a8f02-383">The name from the outer scope is then said to be ***hidden*** in the region of program text covered by the inner scope, and access to the outer name is only possible by qualifying the name.</span></span>

*  <span data-ttu-id="a8f02-384">Областью члена пространства имен, объявленного *namespace_member_declaration* ([члены пространства имен](namespaces.md#namespace-members)) с без заключения *namespace_declaration* является всей программе текст.</span><span class="sxs-lookup"><span data-stu-id="a8f02-384">The scope of a namespace member declared by a *namespace_member_declaration* ([Namespace members](namespaces.md#namespace-members)) with no enclosing *namespace_declaration* is the entire program text.</span></span>
*  <span data-ttu-id="a8f02-385">Областью члена пространства имен, объявленного *namespace_member_declaration* в *namespace_declaration* полное имя которого является `N` — *namespace_body*  из каждого *namespace_declaration* полное имя которого является `N` или начинается с `N`, а затем по периоду.</span><span class="sxs-lookup"><span data-stu-id="a8f02-385">The scope of a namespace member declared by a *namespace_member_declaration* within a *namespace_declaration* whose fully qualified name is `N` is the *namespace_body* of every *namespace_declaration* whose fully qualified name is `N` or starts with `N`, followed by a period.</span></span>
*  <span data-ttu-id="a8f02-386">Область определяется *extern_alias_directive* распространяется *using_directive*s, *global_attributes* и *namespace_member_ объявление*s его непосредственно вмещающего компиляции единицы или пространства имен текста.</span><span class="sxs-lookup"><span data-stu-id="a8f02-386">The scope of name defined by an *extern_alias_directive* extends over the *using_directive*s, *global_attributes* and *namespace_member_declaration*s of its immediately containing compilation unit or namespace body.</span></span> <span data-ttu-id="a8f02-387">*Extern_alias_directive* не размещает новые члены в основной области объявления.</span><span class="sxs-lookup"><span data-stu-id="a8f02-387">An *extern_alias_directive* does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="a8f02-388">Другими словами *extern_alias_directive* не является транзитивным, но, скорее, влияет только на компиляцию единицы или пространства имен тело в которой оно встречается.</span><span class="sxs-lookup"><span data-stu-id="a8f02-388">In other words, an *extern_alias_directive* is not transitive, but, rather, affects only the compilation unit or namespace body in which it occurs.</span></span>
*  <span data-ttu-id="a8f02-389">Область имени определен и не импортирован *using_directive* ([директив Using](namespaces.md#using-directives)) распространяется *namespace_member_declaration*s из  *compilation_unit* или *namespace_body* в котором *using_directive* происходит.</span><span class="sxs-lookup"><span data-stu-id="a8f02-389">The scope of a name defined or imported by a *using_directive* ([Using directives](namespaces.md#using-directives)) extends over the *namespace_member_declaration*s of the *compilation_unit* or *namespace_body* in which the *using_directive* occurs.</span></span> <span data-ttu-id="a8f02-390">Объект *using_directive* можно освободить ноль или несколько имен пространства имен, типа или члена в пределах определенного *compilation_unit* или *namespace_body*, в отличие от размещает новые члены в основной области объявления.</span><span class="sxs-lookup"><span data-stu-id="a8f02-390">A *using_directive* may make zero or more namespace, type or member names available within a particular *compilation_unit* or *namespace_body*, but does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="a8f02-391">Другими словами *using_directive* не является транзитивным, а скорее влияет только *compilation_unit* или *namespace_body* в котором он используется.</span><span class="sxs-lookup"><span data-stu-id="a8f02-391">In other words, a *using_directive* is not transitive but rather affects only the *compilation_unit* or *namespace_body* in which it occurs.</span></span>
*  <span data-ttu-id="a8f02-392">Областью параметра типа, объявленного *type_parameter_list* на *class_declaration* ([объявлений классов](classes.md#class-declarations)) является *class_base*, *type_parameter_constraints_clause*s, и *class_body* , *class_declaration*.</span><span class="sxs-lookup"><span data-stu-id="a8f02-392">The scope of a type parameter declared by a *type_parameter_list* on a *class_declaration* ([Class declarations](classes.md#class-declarations)) is the *class_base*, *type_parameter_constraints_clause*s, and *class_body* of that *class_declaration*.</span></span>
*  <span data-ttu-id="a8f02-393">Областью параметра типа, объявленного *type_parameter_list* на *struct_declaration* ([объявления структур](structs.md#struct-declarations)) является *struct_interfaces* , *type_parameter_constraints_clause*s, и *struct_body* , *struct_declaration*.</span><span class="sxs-lookup"><span data-stu-id="a8f02-393">The scope of a type parameter declared by a *type_parameter_list* on a *struct_declaration* ([Struct declarations](structs.md#struct-declarations)) is the *struct_interfaces*, *type_parameter_constraints_clause*s, and *struct_body* of that *struct_declaration*.</span></span>
*  <span data-ttu-id="a8f02-394">Областью параметра типа, объявленного *type_parameter_list* на *interface_declaration* ([объявления интерфейсов](interfaces.md#interface-declarations)) является *interface_base* , *type_parameter_constraints_clause*s, и *interface_body* , *interface_declaration*.</span><span class="sxs-lookup"><span data-stu-id="a8f02-394">The scope of a type parameter declared by a *type_parameter_list* on an *interface_declaration* ([Interface declarations](interfaces.md#interface-declarations)) is the *interface_base*, *type_parameter_constraints_clause*s, and *interface_body* of that *interface_declaration*.</span></span>
*  <span data-ttu-id="a8f02-395">Областью параметра типа, объявленного *type_parameter_list* на *delegate_declaration* ([объявления делегатов](delegates.md#delegate-declarations)) является *return_type*, *formal_parameter_list*, и *type_parameter_constraints_clause*s, *delegate_declaration*.</span><span class="sxs-lookup"><span data-stu-id="a8f02-395">The scope of a type parameter declared by a *type_parameter_list* on a *delegate_declaration* ([Delegate declarations](delegates.md#delegate-declarations)) is the *return_type*, *formal_parameter_list*, and *type_parameter_constraints_clause*s of that *delegate_declaration*.</span></span>
*  <span data-ttu-id="a8f02-396">Областью члена, объявленного *class_member_declaration* ([класса текст](classes.md#class-body)) является *class_body* в котором содержится объявление.</span><span class="sxs-lookup"><span data-stu-id="a8f02-396">The scope of a member declared by a *class_member_declaration* ([Class body](classes.md#class-body)) is the *class_body* in which the declaration occurs.</span></span> <span data-ttu-id="a8f02-397">Кроме того, область члена класса расширяется до *class_body* из этих производных классов, включенных в домен доступности ([области доступности](basic-concepts.md#accessibility-domains)) элемента.</span><span class="sxs-lookup"><span data-stu-id="a8f02-397">In addition, the scope of a class member extends to the *class_body* of those derived classes that are included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>
*  <span data-ttu-id="a8f02-398">Областью члена, объявленного *struct_member_declaration* ([члены структуры](structs.md#struct-members)) является *struct_body* в котором содержится объявление.</span><span class="sxs-lookup"><span data-stu-id="a8f02-398">The scope of a member declared by a *struct_member_declaration* ([Struct members](structs.md#struct-members)) is the *struct_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="a8f02-399">Областью члена, объявленного *enum_member_declaration* ([члены перечисления](enums.md#enum-members)) является *enum_body* в котором содержится объявление.</span><span class="sxs-lookup"><span data-stu-id="a8f02-399">The scope of a member declared by an *enum_member_declaration*  ([Enum members](enums.md#enum-members)) is the *enum_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="a8f02-400">Областью параметра, объявленного в *method_declaration* ([методы](classes.md#methods)) является *method_body* , *method_declaration*.</span><span class="sxs-lookup"><span data-stu-id="a8f02-400">The scope of a parameter declared in a *method_declaration* ([Methods](classes.md#methods)) is the *method_body* of that *method_declaration*.</span></span>
*  <span data-ttu-id="a8f02-401">Областью параметра, объявленного в *indexer_declaration* ([индексаторы](classes.md#indexers)) является *accessor_declarations* , *indexer_declaration*.</span><span class="sxs-lookup"><span data-stu-id="a8f02-401">The scope of a parameter declared in an *indexer_declaration* ([Indexers](classes.md#indexers)) is the *accessor_declarations* of that *indexer_declaration*.</span></span>
*  <span data-ttu-id="a8f02-402">Областью параметра, объявленного в *operator_declaration* ([операторы](classes.md#operators)) является *блок* , *operator_declaration*.</span><span class="sxs-lookup"><span data-stu-id="a8f02-402">The scope of a parameter declared in an *operator_declaration* ([Operators](classes.md#operators)) is the *block* of that *operator_declaration*.</span></span>
*  <span data-ttu-id="a8f02-403">Областью параметра, объявленного в *constructor_declaration* ([конструкторы экземпляров](classes.md#instance-constructors)) является *constructor_initializer* и *блок* , *constructor_declaration*.</span><span class="sxs-lookup"><span data-stu-id="a8f02-403">The scope of a parameter declared in a *constructor_declaration* ([Instance constructors](classes.md#instance-constructors)) is the *constructor_initializer* and *block* of that *constructor_declaration*.</span></span>
*  <span data-ttu-id="a8f02-404">Областью параметра, объявленного в *lambda_expression* ([выражения анонимных функций](expressions.md#anonymous-function-expressions)) является *anonymous_function_body* , *lambda_ выражение*</span><span class="sxs-lookup"><span data-stu-id="a8f02-404">The scope of a parameter declared in a *lambda_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *anonymous_function_body* of that *lambda_expression*</span></span>
*  <span data-ttu-id="a8f02-405">Областью параметра, объявленного в *anonymous_method_expression* ([выражения анонимных функций](expressions.md#anonymous-function-expressions)) является *блок* , *anonymous_method _expression*.</span><span class="sxs-lookup"><span data-stu-id="a8f02-405">The scope of a parameter declared in an *anonymous_method_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *block* of that *anonymous_method_expression*.</span></span>
*  <span data-ttu-id="a8f02-406">Областью метки, объявленной в *labeled_statement* ([с меткой инструкции](statements.md#labeled-statements)) является *блок* в котором содержится объявление.</span><span class="sxs-lookup"><span data-stu-id="a8f02-406">The scope of a label declared in a *labeled_statement* ([Labeled statements](statements.md#labeled-statements)) is the *block* in which the declaration occurs.</span></span>
*  <span data-ttu-id="a8f02-407">Локальная переменная, объявленная в области *local_variable_declaration* ([объявления локальных переменных](statements.md#local-variable-declarations)) представляет собой блок, в котором содержится объявление.</span><span class="sxs-lookup"><span data-stu-id="a8f02-407">The scope of a local variable declared in a *local_variable_declaration* ([Local variable declarations](statements.md#local-variable-declarations)) is the block in which the declaration occurs.</span></span>
*  <span data-ttu-id="a8f02-408">Локальная переменная, объявленная в области *switch_block* из `switch` инструкции ([оператора switch](statements.md#the-switch-statement)) является *switch_block*.</span><span class="sxs-lookup"><span data-stu-id="a8f02-408">The scope of a local variable declared in a *switch_block* of a `switch` statement ([The switch statement](statements.md#the-switch-statement)) is the *switch_block*.</span></span>
*  <span data-ttu-id="a8f02-409">Локальная переменная, объявленная в области *for_initializer* из `for` инструкции ([для инструкции](statements.md#the-for-statement)) является *for_initializer*,  *for_condition*, *for_iterator*и содержащиеся в нем *инструкции* из `for` инструкции.</span><span class="sxs-lookup"><span data-stu-id="a8f02-409">The scope of a local variable declared in a *for_initializer* of a `for` statement ([The for statement](statements.md#the-for-statement)) is the *for_initializer*, the *for_condition*, the *for_iterator*, and the contained *statement* of the `for` statement.</span></span>
*  <span data-ttu-id="a8f02-410">Областью локальной константы, объявленной в *local_constant_declaration* ([локального объявления констант](statements.md#local-constant-declarations)) представляет собой блок, в котором содержится объявление.</span><span class="sxs-lookup"><span data-stu-id="a8f02-410">The scope of a local constant declared in a *local_constant_declaration* ([Local constant declarations](statements.md#local-constant-declarations)) is the block in which the declaration occurs.</span></span> <span data-ttu-id="a8f02-411">Произошла ошибка во время компиляции, для ссылки на локальную константу в позиции текста, который предшествует его *constant_declarator*.</span><span class="sxs-lookup"><span data-stu-id="a8f02-411">It is a compile-time error to refer to a local constant in a textual position that precedes its *constant_declarator*.</span></span>
*  <span data-ttu-id="a8f02-412">Областью переменной, объявленной как часть *foreach_statement*, *using_statement*, *lock_statement* или *query_expression* — определить с помощью расширения заданной конструкции.</span><span class="sxs-lookup"><span data-stu-id="a8f02-412">The scope of a variable declared as part of a *foreach_statement*, *using_statement*, *lock_statement* or *query_expression* is determined by the expansion of the given construct.</span></span>

<span data-ttu-id="a8f02-413">В пределах пространства имен, класса, структуры или перечисления элементов можно ссылаться на элемент в позиции текста, который предшествует объявление члена.</span><span class="sxs-lookup"><span data-stu-id="a8f02-413">Within the scope of a namespace, class, struct, or enumeration member it is possible to refer to the member in a textual position that precedes the declaration of the member.</span></span> <span data-ttu-id="a8f02-414">Пример</span><span class="sxs-lookup"><span data-stu-id="a8f02-414">For example</span></span>
```csharp
class A
{
    void F() {
        i = 1;
    }

    int i = 0;
}
```
<span data-ttu-id="a8f02-415">Здесь, он является действительным для `F` для ссылки на `i` до ее объявления.</span><span class="sxs-lookup"><span data-stu-id="a8f02-415">Here, it is valid for `F` to refer to `i` before it is declared.</span></span>

<span data-ttu-id="a8f02-416">В области локальной переменной, это ошибка времени компиляции для ссылки на локальную переменную в позиции текста, который предшествует *local_variable_declarator* локальной переменной.</span><span class="sxs-lookup"><span data-stu-id="a8f02-416">Within the scope of a local variable, it is a compile-time error to refer to the local variable in a textual position that precedes the *local_variable_declarator* of the local variable.</span></span> <span data-ttu-id="a8f02-417">Пример</span><span class="sxs-lookup"><span data-stu-id="a8f02-417">For example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        i = 1;                  // Error, use precedes declaration
        int i;
        i = 2;
    }

    void G() {
        int j = (j = 1);        // Valid
    }

    void H() {
        int a = 1, b = ++a;    // Valid
    }
}
```

<span data-ttu-id="a8f02-418">В `F` описанный выше метод, первое присваивание `i` специально не ссылается на поле, объявленное во внешней области.</span><span class="sxs-lookup"><span data-stu-id="a8f02-418">In the `F` method above, the first assignment to `i` specifically does not refer to the field declared in the outer scope.</span></span> <span data-ttu-id="a8f02-419">Вместо этого он ссылается на локальную переменную, и он приводит к ошибке компиляции, так как присваивание предшествует объявление переменной.</span><span class="sxs-lookup"><span data-stu-id="a8f02-419">Rather, it refers to the local variable and it results in a compile-time error because it textually precedes the declaration of the variable.</span></span> <span data-ttu-id="a8f02-420">В `G` метод, использование `j` в инициализаторе для объявления `j` является допустимым, поскольку использование не предшествует *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="a8f02-420">In the `G` method, the use of `j` in the initializer for the declaration of `j` is valid because the use does not precede the *local_variable_declarator*.</span></span> <span data-ttu-id="a8f02-421">В `H` метод, последующая *local_variable_declarator* правильно ссылается локальная переменная, объявленная в предыдущем шаге *local_variable_declarator* внутри того же  *local_variable_declaration*.</span><span class="sxs-lookup"><span data-stu-id="a8f02-421">In the `H` method, a subsequent *local_variable_declarator* correctly refers to a local variable declared in an earlier *local_variable_declarator* within the same *local_variable_declaration*.</span></span>

<span data-ttu-id="a8f02-422">Правила выбора области для локальных переменных разработаны для того, что значение имени, используемого в контексте выражения остается неизменным в пределах блока.</span><span class="sxs-lookup"><span data-stu-id="a8f02-422">The scoping rules for local variables are designed to guarantee that the meaning of a name used in an expression context is always the same within a block.</span></span> <span data-ttu-id="a8f02-423">Если область локальной переменной расширить только из ее объявления в конце блока, в приведенном выше примере первое присваивание будет назначен переменной экземпляра и второе назначение будет присвоен локальной переменной, может привести к ошибки времени компиляции, если были более поздней версии, изменять порядок инструкций блока.</span><span class="sxs-lookup"><span data-stu-id="a8f02-423">If the scope of a local variable were to extend only from its declaration to the end of the block, then in the example above, the first assignment would assign to the instance variable and the second assignment would assign to the local variable, possibly leading to compile-time errors if the statements of the block were later to be rearranged.</span></span>

<span data-ttu-id="a8f02-424">Значение имени в пределах блока может отличаться в зависимости от контекста, в котором используется имя.</span><span class="sxs-lookup"><span data-stu-id="a8f02-424">The meaning of a name within a block may differ based on the context in which the name is used.</span></span> <span data-ttu-id="a8f02-425">В примере</span><span class="sxs-lookup"><span data-stu-id="a8f02-425">In the example</span></span>
```csharp
using System;

class A {}

class Test
{
    static void Main() {
        string A = "hello, world";
        string s = A;                            // expression context

        Type t = typeof(A);                      // type context

        Console.WriteLine(s);                    // writes "hello, world"
        Console.WriteLine(t);                    // writes "A"
    }
}
```
<span data-ttu-id="a8f02-426">имя `A` используется в контексте выражения для ссылки на локальную переменную `A` и в контексте типа для ссылки на класс `A`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-426">the name `A` is used in an expression context to refer to the local variable `A` and in a type context to refer to the class `A`.</span></span>

### <a name="name-hiding"></a><span data-ttu-id="a8f02-427">Скрытие имен</span><span class="sxs-lookup"><span data-stu-id="a8f02-427">Name hiding</span></span>

<span data-ttu-id="a8f02-428">Область сущности обычно включает в себя текст программы большего размера области объявления сущности.</span><span class="sxs-lookup"><span data-stu-id="a8f02-428">The scope of an entity typically encompasses more program text than the declaration space of the entity.</span></span> <span data-ttu-id="a8f02-429">В частности область сущности может содержать объявления, которые вводят новые области объявлений, содержащие сущности с тем же именем.</span><span class="sxs-lookup"><span data-stu-id="a8f02-429">In particular, the scope of an entity may include declarations that introduce new declaration spaces containing entities of the same name.</span></span> <span data-ttu-id="a8f02-430">Такие объявления вызывают исходная сущность становится ***скрытые***.</span><span class="sxs-lookup"><span data-stu-id="a8f02-430">Such declarations cause the original entity to become ***hidden***.</span></span> <span data-ttu-id="a8f02-431">И наоборот, сущность считается ***видимым*** если он не скрыт.</span><span class="sxs-lookup"><span data-stu-id="a8f02-431">Conversely, an entity is said to be ***visible*** when it is not hidden.</span></span>

<span data-ttu-id="a8f02-432">Скрытие имен происходит, когда перекрываются областей через вложений и при перекрытии областей через наследование.</span><span class="sxs-lookup"><span data-stu-id="a8f02-432">Name hiding occurs when scopes overlap through nesting and when scopes overlap through inheritance.</span></span> <span data-ttu-id="a8f02-433">В следующих разделах описываются характеристики двух типов скрытия.</span><span class="sxs-lookup"><span data-stu-id="a8f02-433">The characteristics of the two types of hiding are described in the following sections.</span></span>

#### <a name="hiding-through-nesting"></a><span data-ttu-id="a8f02-434">Скрытие помощью вложения</span><span class="sxs-lookup"><span data-stu-id="a8f02-434">Hiding through nesting</span></span>

<span data-ttu-id="a8f02-435">Скрытие имен через вложенности может произойти в результате вложения пространств имен или типов в пространствах имен, в результате вложения типов внутри классов или структур, а также из-за параметра и объявлений локальных переменных.</span><span class="sxs-lookup"><span data-stu-id="a8f02-435">Name hiding through nesting can occur as a result of nesting namespaces or types within namespaces, as a result of nesting types within classes or structs, and as a result of parameter and local variable declarations.</span></span>

<span data-ttu-id="a8f02-436">В примере</span><span class="sxs-lookup"><span data-stu-id="a8f02-436">In the example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        int i = 1;
    }

    void G() {
        i = 1;
    }
}
```
<span data-ttu-id="a8f02-437">в рамках `F` метода, переменной экземпляра `i` скрыт локальной переменной `i`, но в `G` метод, `i` по-прежнему ссылается на переменную экземпляра.</span><span class="sxs-lookup"><span data-stu-id="a8f02-437">within the `F` method, the instance variable `i` is hidden by the local variable `i`, but within the `G` method, `i` still refers to the instance variable.</span></span>

<span data-ttu-id="a8f02-438">Когда имя во внутренней области скрывает имя во внешней области, он скрывает все перегруженные вхождения этого имени.</span><span class="sxs-lookup"><span data-stu-id="a8f02-438">When a name in an inner scope hides a name in an outer scope, it hides all overloaded occurrences of that name.</span></span> <span data-ttu-id="a8f02-439">В примере</span><span class="sxs-lookup"><span data-stu-id="a8f02-439">In the example</span></span>
```csharp
class Outer
{
    static void F(int i) {}

    static void F(string s) {}

    class Inner
    {
        void G() {
            F(1);              // Invokes Outer.Inner.F
            F("Hello");        // Error
        }

        static void F(long l) {}
    }
}
```
<span data-ttu-id="a8f02-440">вызов `F(1)` вызывает `F` объявленные в `Inner` так как все внешние вхождения `F` скрыты по внутренним объявлением.</span><span class="sxs-lookup"><span data-stu-id="a8f02-440">the call `F(1)` invokes the `F` declared in `Inner` because all outer occurrences of `F` are hidden by the inner declaration.</span></span> <span data-ttu-id="a8f02-441">По этой же причине, вызов `F("Hello")` приводит к ошибке времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="a8f02-441">For the same reason, the call `F("Hello")` results in a compile-time error.</span></span>

#### <a name="hiding-through-inheritance"></a><span data-ttu-id="a8f02-442">Скрытие через наследование</span><span class="sxs-lookup"><span data-stu-id="a8f02-442">Hiding through inheritance</span></span>

<span data-ttu-id="a8f02-443">Скрытие имен через наследование происходит, когда классы или структуры повторного объявления имен, унаследованные от базовых классов.</span><span class="sxs-lookup"><span data-stu-id="a8f02-443">Name hiding through inheritance occurs when classes or structs redeclare names that were inherited from base classes.</span></span> <span data-ttu-id="a8f02-444">Этот тип скрытии имен принимает одно из следующих форм:</span><span class="sxs-lookup"><span data-stu-id="a8f02-444">This type of name hiding takes one of the following forms:</span></span>

*  <span data-ttu-id="a8f02-445">Константа, поле, свойство, событие или тип, представленный в классе или структуре, скрывает все члены базового класса с тем же именем.</span><span class="sxs-lookup"><span data-stu-id="a8f02-445">A constant, field, property, event, or type introduced in a class or struct hides all base class members with the same name.</span></span>
*  <span data-ttu-id="a8f02-446">Метод, представленный в классе или структуре, скрывает все члены базового класса не метод с тем же именем, а также все методы базового класса с такой же сигнатурой (имя метода и число параметров, модификаторы и типы).</span><span class="sxs-lookup"><span data-stu-id="a8f02-446">A method introduced in a class or struct hides all non-method base class members with the same name, and all base class methods with the same signature (method name and parameter count, modifiers, and types).</span></span>
*  <span data-ttu-id="a8f02-447">Индексатор, представленный в классе или структуре, скрывает все индексаторы базового класса с такой же сигнатурой (число параметров и типы).</span><span class="sxs-lookup"><span data-stu-id="a8f02-447">An indexer introduced in a class or struct hides all base class indexers with the same signature (parameter count and types).</span></span>

<span data-ttu-id="a8f02-448">Правила, управляющие оператор объявления ([операторы](classes.md#operators)) сделать невозможным для производного класса для объявления оператора с одинаковой сигнатурой как оператор в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="a8f02-448">The rules governing operator declarations ([Operators](classes.md#operators)) make it impossible for a derived class to declare an operator with the same signature as an operator in a base class.</span></span> <span data-ttu-id="a8f02-449">Таким образом операторы никогда не скрывать друг с другом.</span><span class="sxs-lookup"><span data-stu-id="a8f02-449">Thus, operators never hide one another.</span></span>

<span data-ttu-id="a8f02-450">В отличие от скрытие имя из внешней области, скрытие допустимого имени из наследуемой области вызывает предупреждение.</span><span class="sxs-lookup"><span data-stu-id="a8f02-450">Contrary to hiding a name from an outer scope, hiding an accessible name from an inherited scope causes a warning to be reported.</span></span> <span data-ttu-id="a8f02-451">В примере</span><span class="sxs-lookup"><span data-stu-id="a8f02-451">In the example</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    public void F() {}        // Warning, hiding an inherited name
}
```
<span data-ttu-id="a8f02-452">объявление `F` в `Derived` вызывает предупреждение.</span><span class="sxs-lookup"><span data-stu-id="a8f02-452">the declaration of `F` in `Derived` causes a warning to be reported.</span></span> <span data-ttu-id="a8f02-453">Скрытие унаследованного имени специально не является ошибкой, поскольку это препятствует отдельному развитию базовых классов.</span><span class="sxs-lookup"><span data-stu-id="a8f02-453">Hiding an inherited name is specifically not an error, since that would preclude separate evolution of base classes.</span></span> <span data-ttu-id="a8f02-454">Например, выше ситуация может возникнуть, поскольку более поздней версии `Base` появился `F` метод, который не был представлен в более ранней версии класса.</span><span class="sxs-lookup"><span data-stu-id="a8f02-454">For example, the above situation might have come about because a later version of `Base` introduced an `F` method that wasn't present in an earlier version of the class.</span></span> <span data-ttu-id="a8f02-455">Бы выше ситуация была ошибка, затем любых изменений, внесенных в базовый класс в библиотеке класса отдельной версии может привести к производным классам становятся недействительными.</span><span class="sxs-lookup"><span data-stu-id="a8f02-455">Had the above situation been an error, then any change made to a base class in a separately versioned class library could potentially cause derived classes to become invalid.</span></span>

<span data-ttu-id="a8f02-456">Предупреждение, вызванное скрытии унаследованного имени можно устранить с помощью `new` модификатор:</span><span class="sxs-lookup"><span data-stu-id="a8f02-456">The warning caused by hiding an inherited name can be eliminated through use of the `new` modifier:</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    new public void F() {}
}
```

<span data-ttu-id="a8f02-457">`new` Модификатор указывает, что `F` в `Derived` «new», и что она действительно должна скрыть наследуемый член.</span><span class="sxs-lookup"><span data-stu-id="a8f02-457">The `new` modifier indicates that the `F` in `Derived` is "new", and that it is indeed intended to hide the inherited member.</span></span>

<span data-ttu-id="a8f02-458">Объявление нового члена скрывает унаследованный член только в пределах нового члена.</span><span class="sxs-lookup"><span data-stu-id="a8f02-458">A declaration of a new member hides an inherited member only within the scope of the new member.</span></span>

```csharp
class Base
{
    public static void F() {}
}

class Derived: Base
{
    new private static void F() {}    // Hides Base.F in Derived only
}

class MoreDerived: Derived
{
    static void G() { F(); }          // Invokes Base.F
}
```

<span data-ttu-id="a8f02-459">В примере выше объявление `F` в `Derived` скрывает `F` , унаследованный от `Base`, но так как новый `F` в `Derived` закрытый доступ к ее область не распространяется на `MoreDerived` .</span><span class="sxs-lookup"><span data-stu-id="a8f02-459">In the example above, the declaration of `F` in `Derived` hides the `F` that was inherited from `Base`, but since the new `F` in `Derived` has private access, its scope does not extend to `MoreDerived`.</span></span> <span data-ttu-id="a8f02-460">Таким образом, вызов `F()` в `MoreDerived.G` является допустимым и будет вызывать `Base.F`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-460">Thus, the call `F()` in `MoreDerived.G` is valid and will invoke `Base.F`.</span></span>

## <a name="namespace-and-type-names"></a><span data-ttu-id="a8f02-461">Пространства имен и тип</span><span class="sxs-lookup"><span data-stu-id="a8f02-461">Namespace and type names</span></span>

<span data-ttu-id="a8f02-462">Некоторые контексты в программе на C# требует *namespace_name* или *type_name* указывать.</span><span class="sxs-lookup"><span data-stu-id="a8f02-462">Several contexts in a C# program require a *namespace_name* or a *type_name* to be specified.</span></span>

```antlr
namespace_name
    : namespace_or_type_name
    ;

type_name
    : namespace_or_type_name
    ;

namespace_or_type_name
    : identifier type_argument_list?
    | namespace_or_type_name '.' identifier type_argument_list?
    | qualified_alias_member
    ;
```

<span data-ttu-id="a8f02-463">Объект *namespace_name* — *namespace_or_type_name* , ссылается на пространство имен.</span><span class="sxs-lookup"><span data-stu-id="a8f02-463">A *namespace_name* is a *namespace_or_type_name* that refers to a namespace.</span></span> <span data-ttu-id="a8f02-464">Следующее разрешение, как описано ниже, *namespace_or_type_name* из *namespace_name* должно ссылаться на пространство имен, или в противном случае возникает ошибка времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="a8f02-464">Following resolution as described below, the *namespace_or_type_name* of a *namespace_name* must refer to a namespace, or otherwise a compile-time error occurs.</span></span> <span data-ttu-id="a8f02-465">Аргументы типа ([аргументы типа](types.md#type-arguments)) могут быть представлены в *namespace_name* (только типы могут иметь аргументов типа).</span><span class="sxs-lookup"><span data-stu-id="a8f02-465">No type arguments ([Type arguments](types.md#type-arguments)) can be present in a *namespace_name* (only types can have type arguments).</span></span>

<span data-ttu-id="a8f02-466">Объект *type_name* — *namespace_or_type_name* , ссылается на тип.</span><span class="sxs-lookup"><span data-stu-id="a8f02-466">A *type_name* is a *namespace_or_type_name* that refers to a type.</span></span> <span data-ttu-id="a8f02-467">Следующее разрешение, как описано ниже, *namespace_or_type_name* из *type_name* должен ссылаться на тип, или в противном случае возникает ошибка времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="a8f02-467">Following resolution as described below, the *namespace_or_type_name* of a *type_name* must refer to a type, or otherwise a compile-time error occurs.</span></span>

<span data-ttu-id="a8f02-468">Если *namespace_or_type_name* входит указанием псевдоним-его значение соответствует описанной в [Квалификаторы псевдонима пространства имен](namespaces.md#namespace-alias-qualifiers).</span><span class="sxs-lookup"><span data-stu-id="a8f02-468">If the *namespace_or_type_name* is a qualified-alias-member its meaning is as described in [Namespace alias qualifiers](namespaces.md#namespace-alias-qualifiers).</span></span> <span data-ttu-id="a8f02-469">В противном случае *namespace_or_type_name* имеет одно из четырех форм:</span><span class="sxs-lookup"><span data-stu-id="a8f02-469">Otherwise, a *namespace_or_type_name* has one of four forms:</span></span>

*  `I`
*  `I<A1, ..., Ak>`
*  `N.I`
*  `N.I<A1, ..., Ak>`

<span data-ttu-id="a8f02-470">где `I` — отдельный идентификатор, `N` — *namespace_or_type_name* и `<A1, ..., Ak>` не является обязательной *type_argument_list*.</span><span class="sxs-lookup"><span data-stu-id="a8f02-470">where `I` is a single identifier, `N` is a *namespace_or_type_name* and `<A1, ..., Ak>` is an optional *type_argument_list*.</span></span> <span data-ttu-id="a8f02-471">Если аргумент *type_argument_list* будет указано, рассмотрите возможность `k` должно быть равно нулю.</span><span class="sxs-lookup"><span data-stu-id="a8f02-471">When no *type_argument_list* is specified, consider `k` to be zero.</span></span>

<span data-ttu-id="a8f02-472">Значение *namespace_or_type_name* определяется следующим образом:</span><span class="sxs-lookup"><span data-stu-id="a8f02-472">The meaning of a *namespace_or_type_name* is determined as follows:</span></span>

*   <span data-ttu-id="a8f02-473">Если *namespace_or_type_name* имеет форму `I` или формы `I<A1, ..., Ak>`:</span><span class="sxs-lookup"><span data-stu-id="a8f02-473">If the *namespace_or_type_name* is of the form `I` or of the form `I<A1, ..., Ak>`:</span></span>
    * <span data-ttu-id="a8f02-474">Если `K` равно нулю и *namespace_or_type_name* появляется в объявлении универсального метода ([методы](classes.md#methods)) и если это объявление включает параметр типа ([типа Параметры](classes.md#type-parameters)) с именем `I`, а затем *namespace_or_type_name* ссылается на этот параметр типа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-474">If `K` is zero and the *namespace_or_type_name* appears within a generic method declaration ([Methods](classes.md#methods)) and if that declaration includes a type parameter ([Type parameters](classes.md#type-parameters)) with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
    * <span data-ttu-id="a8f02-475">В противном случае, если *namespace_or_type_name* появляется в объявлении типа, а затем для каждого типа экземпляра `T` ([тип экземпляра](classes.md#the-instance-type)), начиная с типом экземпляра этого типа объявление и продолжить с типом экземпляра каждого включающего объявления класса или структуры (если таковые имеются):</span><span class="sxs-lookup"><span data-stu-id="a8f02-475">Otherwise, if the *namespace_or_type_name* appears within a type declaration, then for each instance type `T` ([The instance type](classes.md#the-instance-type)), starting with the instance type of that type declaration and continuing with the instance type of each enclosing class or struct declaration (if any):</span></span>
        * <span data-ttu-id="a8f02-476">Если `K` равно нулю и объявление `T` включает параметр типа с именем `I`, а затем *namespace_or_type_name* ссылается на этот параметр типа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-476">If `K` is zero and the declaration of `T` includes a type parameter with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
        * <span data-ttu-id="a8f02-477">В противном случае, если *namespace_or_type_name* находится внутри объявления типа, и `T` или какой-либо из его базовых типов содержит вложенный доступный тип с именем `I` и `K` параметры типа , а затем *namespace_or_type_name* ссылается на этот тип, сформированный с заданными аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-477">Otherwise, if the *namespace_or_type_name* appears within the body of the type declaration, and `T` or any of its base types contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="a8f02-478">Если имеется более одного типа, выбирается тип, объявленный внутри более производный тип.</span><span class="sxs-lookup"><span data-stu-id="a8f02-478">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="a8f02-479">Обратите внимание, что элементы не являющегося типом (константы, поля, методы, свойства, индексаторы, операторы, конструкторы экземпляров, деструкторы и статические конструкторы) и членов типов с Разное количество параметров типа учитываются при определении значения *namespace_or_type_name*.</span><span class="sxs-lookup"><span data-stu-id="a8f02-479">Note that non-type members (constants, fields, methods, properties, indexers, operators, instance constructors, destructors, and static constructors) and type members with a different number of type parameters are ignored when determining the meaning of the *namespace_or_type_name*.</span></span>
    * <span data-ttu-id="a8f02-480">Если предыдущие действия были успешно выполнены, для каждого пространства имен `N`, начиная с пространством имен, в котором *namespace_or_type_name* происходит, продолжая каждого вмещающего пространства имен (если таковые имеются) и заканчивая глобальное пространство имен, вычисляются следующие действия, пока не будет обнаружена сущность:</span><span class="sxs-lookup"><span data-stu-id="a8f02-480">If the previous steps were unsuccessful then, for each namespace `N`, starting with the namespace in which the *namespace_or_type_name* occurs, continuing with each enclosing namespace (if any), and ending with the global namespace, the following steps are evaluated until an entity is located:</span></span>
        * <span data-ttu-id="a8f02-481">Если `K` равно нулю и `I` имя пространства имен в `N`, затем:</span><span class="sxs-lookup"><span data-stu-id="a8f02-481">If `K` is zero and `I` is the name of a namespace in `N`, then:</span></span>
            * <span data-ttu-id="a8f02-482">Если расположение где *namespace_or_type_name* происходит заключен в объявление пространства имен для `N` и содержит объявление пространства имен *extern_alias_directive* или *using_alias_directive* , связывает имя `I` пространства имен или тип, а затем *namespace_or_type_name* является неоднозначным и возникает ошибка времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="a8f02-482">If the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="a8f02-483">В противном случае *namespace_or_type_name* ссылается на пространство имен с именем `I` в `N`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-483">Otherwise, the *namespace_or_type_name* refers to the namespace named `I` in `N`.</span></span>
        * <span data-ttu-id="a8f02-484">В противном случае, если `N` содержит доступный тип с именем `I` и `K` параметрами типа, то:</span><span class="sxs-lookup"><span data-stu-id="a8f02-484">Otherwise, if `N` contains an accessible type having name `I` and `K` type parameters, then:</span></span>
            * <span data-ttu-id="a8f02-485">Если `K` равно нулю и расположение где *namespace_or_type_name* происходит заключен в объявление пространства имен для `N` и содержит объявление пространства имен *extern_alias_directive*  или *using_alias_directive* , связывает имя `I` пространства имен или тип, а затем *namespace_or_type_name* является неоднозначным, а во время компиляции возникает ошибка.</span><span class="sxs-lookup"><span data-stu-id="a8f02-485">If `K` is zero and the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="a8f02-486">В противном случае *namespace_or_type_name* ссылается на тип, сформированный с заданными аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-486">Otherwise, the *namespace_or_type_name* refers to the type constructed with the given type arguments.</span></span>
        * <span data-ttu-id="a8f02-487">В противном случае, если расположение где *namespace_or_type_name* происходит заключен в объявление пространства имен для `N`:</span><span class="sxs-lookup"><span data-stu-id="a8f02-487">Otherwise, if the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N`:</span></span>
            * <span data-ttu-id="a8f02-488">Если `K` равен нулю и содержит объявление пространства имен *extern_alias_directive* или *using_alias_directive* , связывает имя `I` с импортированное пространство имен или тип, а затем *namespace_or_type_name* ссылается на это пространство имен или тип.</span><span class="sxs-lookup"><span data-stu-id="a8f02-488">If `K` is zero and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with an imported namespace or type, then the *namespace_or_type_name* refers to that namespace or type.</span></span>
            * <span data-ttu-id="a8f02-489">В противном случае, если объявления типов и пространств имен, импортированные с *using_namespace_directive*s и *using_alias_directive*объявления пространства имен содержат ровно один доступный тип с именем `I` и `K` параметры типа, а затем *namespace_or_type_name* ссылается на этот тип, сформированный с заданными аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-489">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain exactly one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
            * <span data-ttu-id="a8f02-490">В противном случае, если объявления типов и пространств имен, импортированные с *using_namespace_directive*s и *using_alias_directive*объявления пространства имен содержат более чем один доступный тип с именем `I` и `K` параметры типа, а затем *namespace_or_type_name* является неоднозначным и возникает ошибка.</span><span class="sxs-lookup"><span data-stu-id="a8f02-490">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain more than one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* is ambiguous and an error occurs.</span></span>
    * <span data-ttu-id="a8f02-491">В противном случае *namespace_or_type_name* — не определено и возникает ошибка времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="a8f02-491">Otherwise, the *namespace_or_type_name* is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="a8f02-492">В противном случае *namespace_or_type_name* имеет форму `N.I` или формы `N.I<A1, ..., Ak>`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-492">Otherwise, the *namespace_or_type_name* is of the form `N.I` or of the form `N.I<A1, ..., Ak>`.</span></span> <span data-ttu-id="a8f02-493">`N` предпринимается попытка рассмотреть его как *namespace_or_type_name*.</span><span class="sxs-lookup"><span data-stu-id="a8f02-493">`N` is first resolved as a *namespace_or_type_name*.</span></span> <span data-ttu-id="a8f02-494">Если разрешение `N` прошла неудачно, то возникает ошибка времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="a8f02-494">If the resolution of `N` is not successful, a compile-time error occurs.</span></span> <span data-ttu-id="a8f02-495">В противном случае `N.I` или `N.I<A1, ..., Ak>` разрешается следующим образом:</span><span class="sxs-lookup"><span data-stu-id="a8f02-495">Otherwise, `N.I` or `N.I<A1, ..., Ak>` is resolved as follows:</span></span>
    * <span data-ttu-id="a8f02-496">Если `K` равно нулю и `N` ссылается на пространство имен и `N` содержит вложенное пространство имен с именем `I`, а затем *namespace_or_type_name* ссылается на это вложенное пространство имен.</span><span class="sxs-lookup"><span data-stu-id="a8f02-496">If `K` is zero and `N` refers to a namespace and `N` contains a nested namespace with name `I`, then the *namespace_or_type_name* refers to that nested namespace.</span></span>
    * <span data-ttu-id="a8f02-497">В противном случае, если `N` ссылается на пространство имен и `N` содержит доступный тип с именем `I` и `K` параметры типа, а затем *namespace_or_type_name* ссылается на этот тип создан с заданными аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-497">Otherwise, if `N` refers to a namespace and `N` contains an accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
    * <span data-ttu-id="a8f02-498">В противном случае, если `N` ссылается на тип класса или структуры (возможно, сконструированный) и `N` или какой-либо из его базовых классов содержит вложенный доступный тип с именем `I` и `K` параметры типа, а затем *пространства имен _or_type_name* ссылается на этот тип, сформированный с заданными аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="a8f02-498">Otherwise, if `N` refers to a (possibly constructed) class or struct type and `N` or any of its base classes contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="a8f02-499">Если имеется более одного типа, выбирается тип, объявленный внутри более производный тип.</span><span class="sxs-lookup"><span data-stu-id="a8f02-499">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="a8f02-500">Обратите внимание: Если значение `N.I` определяется как часть разрешения спецификация базового класса `N` затем прямой базовый класс для `N` считается объекта ([базовые классы](classes.md#base-classes)).</span><span class="sxs-lookup"><span data-stu-id="a8f02-500">Note that if the meaning of `N.I` is being determined as part of resolving the base class specification of `N` then the direct base class of `N` is considered to be object ([Base classes](classes.md#base-classes)).</span></span>
    * <span data-ttu-id="a8f02-501">В противном случае `N.I` не является допустимым *namespace_or_type_name*, и возникает ошибка времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="a8f02-501">Otherwise, `N.I` is an invalid *namespace_or_type_name*, and a compile-time error occurs.</span></span>

<span data-ttu-id="a8f02-502">Объект *namespace_or_type_name* может ссылаться на статический класс ([статические классы](classes.md#static-classes)) только если</span><span class="sxs-lookup"><span data-stu-id="a8f02-502">A *namespace_or_type_name* is permitted to reference a static class ([Static classes](classes.md#static-classes)) only if</span></span>

*  <span data-ttu-id="a8f02-503">*Namespace_or_type_name* — `T` в *namespace_or_type_name* формы `T.I`, или</span><span class="sxs-lookup"><span data-stu-id="a8f02-503">The *namespace_or_type_name* is the `T` in a *namespace_or_type_name* of the form `T.I`, or</span></span>
*  <span data-ttu-id="a8f02-504">*Namespace_or_type_name* — `T` в *typeof_expression* ([списки аргументов](expressions.md#argument-lists)1) формы `typeof(T)`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-504">The *namespace_or_type_name* is the `T` in a *typeof_expression* ([Argument lists](expressions.md#argument-lists)1) of the form `typeof(T)`.</span></span>

### <a name="fully-qualified-names"></a><span data-ttu-id="a8f02-505">Полные имена</span><span class="sxs-lookup"><span data-stu-id="a8f02-505">Fully qualified names</span></span>

<span data-ttu-id="a8f02-506">Каждая пространства имен и тип имеет ***полное имя***, который уникальным образом идентифицирует пространство имен или тип среди других.</span><span class="sxs-lookup"><span data-stu-id="a8f02-506">Every namespace and type has a ***fully qualified name***, which uniquely identifies the namespace or type amongst all others.</span></span> <span data-ttu-id="a8f02-507">Полное имя пространства имен или тип `N` определяется следующим образом:</span><span class="sxs-lookup"><span data-stu-id="a8f02-507">The fully qualified name of a namespace or type `N` is determined as follows:</span></span>

*  <span data-ttu-id="a8f02-508">Если `N` является членом глобального пространства имен, его полное доменное имя выглядит `N`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-508">If `N` is a member of the global namespace, its fully qualified name is `N`.</span></span>
*  <span data-ttu-id="a8f02-509">В противном случае его полное доменное имя выглядит `S.N`, где `S` полное имя пространства имен или тип, в которой `N` объявлен.</span><span class="sxs-lookup"><span data-stu-id="a8f02-509">Otherwise, its fully qualified name is `S.N`, where `S` is the fully qualified name of the namespace or type in which `N` is declared.</span></span>

<span data-ttu-id="a8f02-510">Другими словами, полное имя `N` — это полный путь иерархических идентификаторов, которые приводят к `N`, начиная от глобального пространства имен.</span><span class="sxs-lookup"><span data-stu-id="a8f02-510">In other words, the fully qualified name of `N` is the complete hierarchical path of identifiers that lead to `N`, starting from the global namespace.</span></span> <span data-ttu-id="a8f02-511">Так как каждый член пространства имен или типа должен иметь уникальное имя, следует, что полное имя пространства имен или тип всегда является уникальным.</span><span class="sxs-lookup"><span data-stu-id="a8f02-511">Because every member of a namespace or type must have a unique name, it follows that the fully qualified name of a namespace or type is always unique.</span></span>

<span data-ttu-id="a8f02-512">В приведенном ниже примере показано несколько объявлений пространства имен и типов вместе с их соответствующими полными именами.</span><span class="sxs-lookup"><span data-stu-id="a8f02-512">The example below shows several namespace and type declarations along with their associated fully qualified names.</span></span>
```csharp
class A {}                // A

namespace X               // X
{
    class B               // X.B
    {
        class C {}        // X.B.C
    }

    namespace Y           // X.Y
    {
        class D {}        // X.Y.D
    }
}

namespace X.Y             // X.Y
{
    class E {}            // X.Y.E
}
```

## <a name="automatic-memory-management"></a><span data-ttu-id="a8f02-513">Автоматическое управление памятью</span><span class="sxs-lookup"><span data-stu-id="a8f02-513">Automatic memory management</span></span>

<span data-ttu-id="a8f02-514">C# использует автоматическое управление памятью, что освобождает разработчиков от ручного выделения и освобождения памяти, занятых объектами.</span><span class="sxs-lookup"><span data-stu-id="a8f02-514">C# employs automatic memory management, which frees developers from manually allocating and freeing the memory occupied by objects.</span></span> <span data-ttu-id="a8f02-515">Политики управления памятью автоматического реализуются ***сборщик мусора***.</span><span class="sxs-lookup"><span data-stu-id="a8f02-515">Automatic memory management policies are implemented by a ***garbage collector***.</span></span> <span data-ttu-id="a8f02-516">Жизненный цикл управления памяти объекта выглядит следующим образом:</span><span class="sxs-lookup"><span data-stu-id="a8f02-516">The memory management life cycle of an object is as follows:</span></span>

1. <span data-ttu-id="a8f02-517">При создании объекта, выделить память для него, выполняется конструктор и объект считается в реальном времени.</span><span class="sxs-lookup"><span data-stu-id="a8f02-517">When the object is created, memory is allocated for it, the constructor is run, and the object is considered live.</span></span>
2. <span data-ttu-id="a8f02-518">Если объект или любую часть, недоступны для любого продолжения выполнения, отличный от выполнения деструкторов, объект считается больше не используется, и он становится пригодным для уничтожения.</span><span class="sxs-lookup"><span data-stu-id="a8f02-518">If the object, or any part of it, cannot be accessed by any possible continuation of execution, other than the running of destructors, the object is considered no longer in use, and it becomes eligible for destruction.</span></span> <span data-ttu-id="a8f02-519">Компилятор C# и сборщик мусора, можно проанализировать код, чтобы определить, какие ссылки на объект может использоваться в будущем.</span><span class="sxs-lookup"><span data-stu-id="a8f02-519">The C# compiler and the garbage collector may choose to analyze code to determine which references to an object may be used in the future.</span></span> <span data-ttu-id="a8f02-520">Например если локальной переменной, которая находится в области только существующую ссылку на объект, но локальная переменная никогда не упоминается в любой продолжения выполнения из текущего выполнения, укажите в процедуре, сборщик мусора может (но не требуется) рассматривать объект как больше не используется.</span><span class="sxs-lookup"><span data-stu-id="a8f02-520">For instance, if a local variable that is in scope is the only existing reference to an object, but that local variable is never referred to in any possible continuation of execution from the current execution point in the procedure, the garbage collector may (but is not required to) treat the object as no longer in use.</span></span>
3. <span data-ttu-id="a8f02-521">Как только объект требует уничтожения, через некоторое указанное время деструктор ([деструкторы](classes.md#destructors)) (если таковые имеются) для запуска объекта.</span><span class="sxs-lookup"><span data-stu-id="a8f02-521">Once the object is eligible for destruction, at some unspecified later time the destructor ([Destructors](classes.md#destructors)) (if any) for the object is run.</span></span> <span data-ttu-id="a8f02-522">В обычных условиях деструктор для объекта выполняется только один раз на то, что API-интерфейсам конкретной реализации может разрешить это поведение можно переопределить.</span><span class="sxs-lookup"><span data-stu-id="a8f02-522">Under normal circumstances the destructor for the object is run once only, though implementation-specific APIs may allow this behavior to be overridden.</span></span>
4. <span data-ttu-id="a8f02-523">После запуска деструктор для объекта, если данный объект или любой ее части может быть недоступна для любого продолжения выполнения, включая выполнение деструкторов, объект считается недоступным и становится доступным для коллекции.</span><span class="sxs-lookup"><span data-stu-id="a8f02-523">Once the destructor for an object is run, if that object, or any part of it, cannot be accessed by any possible continuation of execution, including the running of destructors, the object is considered inaccessible and the object becomes eligible for collection.</span></span>
5. <span data-ttu-id="a8f02-524">Наконец через некоторое время после объект становится доступным для коллекции, сборщик мусора освобождает память, связанную с этим объектом.</span><span class="sxs-lookup"><span data-stu-id="a8f02-524">Finally, at some time after the object becomes eligible for collection, the garbage collector frees the memory associated with that object.</span></span>

<span data-ttu-id="a8f02-525">Сборщик мусора сохраняет сведения об использовании объекта и использует эти сведения для принятия решений управления, памяти, таких как where в памяти, чтобы найти вновь созданного объекта, если переместить объект и когда объект больше не используется или недоступен.</span><span class="sxs-lookup"><span data-stu-id="a8f02-525">The garbage collector maintains information about object usage, and uses this information to make memory management decisions, such as where in memory to locate a newly created object, when to relocate an object, and when an object is no longer in use or inaccessible.</span></span>

<span data-ttu-id="a8f02-526">Как и других языков, которые предполагается, что сборщик мусора, C# предназначен, чтобы сборщик мусора может реализовать широкий спектр политики управления памятью.</span><span class="sxs-lookup"><span data-stu-id="a8f02-526">Like other languages that assume the existence of a garbage collector, C# is designed so that the garbage collector may implement a wide range of memory management policies.</span></span> <span data-ttu-id="a8f02-527">Например C# не требует выполнение деструкторов или подборка объектов как только они становятся доступными, или выполнение деструкторов в определенном порядке или в любом определенном потоке.</span><span class="sxs-lookup"><span data-stu-id="a8f02-527">For instance, C# does not require that destructors be run or that objects be collected as soon as they are eligible, or that destructors be run in any particular order, or on any particular thread.</span></span>

<span data-ttu-id="a8f02-528">Можно управлять поведением сборщик мусора в определенной степени, с помощью статических методов класса `System.GC`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-528">The behavior of the garbage collector can be controlled, to some degree, via static methods on the class `System.GC`.</span></span> <span data-ttu-id="a8f02-529">Этот класс может быть использован для запроса мусора деструкторы запуска (или не запускать) и так далее.</span><span class="sxs-lookup"><span data-stu-id="a8f02-529">This class can be used to request a collection to occur, destructors to be run (or not run), and so forth.</span></span>

<span data-ttu-id="a8f02-530">Так как сборщик мусора может широкую степень свободы в выборе времени уничтожения объектов и вызова деструкторов, соответствующая реализация могут давать выходные данные, которые отличаются от показанных в следующем примере кода.</span><span class="sxs-lookup"><span data-stu-id="a8f02-530">Since the garbage collector is allowed wide latitude in deciding when to collect objects and run destructors, a conforming implementation may produce output that differs from that shown by the following code.</span></span> <span data-ttu-id="a8f02-531">Программа</span><span class="sxs-lookup"><span data-stu-id="a8f02-531">The program</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }
}

class B
{
    object Ref;

    public B(object o) {
        Ref = o;
    }

    ~B() {
        Console.WriteLine("Destruct instance of B");
    }
}

class Test
{
    static void Main() {
        B b = new B(new A());
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
}
```
<span data-ttu-id="a8f02-532">Создает экземпляр класса `A` и экземпляр класса `B`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-532">creates an instance of class `A` and an instance of class `B`.</span></span> <span data-ttu-id="a8f02-533">Эти объекты станут доступны для сборки мусора при переменной `b` присваивается значение `null`, поскольку после этого невозможно для любой код, написанный пользователем, для доступа к ним.</span><span class="sxs-lookup"><span data-stu-id="a8f02-533">These objects become eligible for garbage collection when the variable `b` is assigned the value `null`, since after this time it is impossible for any user-written code to access them.</span></span> <span data-ttu-id="a8f02-534">Результат может быть либо</span><span class="sxs-lookup"><span data-stu-id="a8f02-534">The output could be either</span></span>
```
Destruct instance of A
Destruct instance of B
```
<span data-ttu-id="a8f02-535">или</span><span class="sxs-lookup"><span data-stu-id="a8f02-535">or</span></span>
```
Destruct instance of B
Destruct instance of A
```
<span data-ttu-id="a8f02-536">так как язык не налагает ограничений на порядок, в котором объекты удалялись сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="a8f02-536">because the language imposes no constraints on the order in which objects are garbage collected.</span></span>

<span data-ttu-id="a8f02-537">В особых случаях может понадобиться различие между «пригодным для уничтожения» и «доступным для коллекции».</span><span class="sxs-lookup"><span data-stu-id="a8f02-537">In subtle cases, the distinction between "eligible for destruction" and "eligible for collection" can be important.</span></span> <span data-ttu-id="a8f02-538">Например, примененная к объекту директива</span><span class="sxs-lookup"><span data-stu-id="a8f02-538">For example,</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }

    public void F() {
        Console.WriteLine("A.F");
        Test.RefA = this;
    }
}

class B
{
    public A Ref;

    ~B() {
        Console.WriteLine("Destruct instance of B");
        Ref.F();
    }
}

class Test
{
    public static A RefA;
    public static B RefB;

    static void Main() {
        RefB = new B();
        RefA = new A();
        RefB.Ref = RefA;
        RefB = null;
        RefA = null;

        // A and B now eligible for destruction
        GC.Collect();
        GC.WaitForPendingFinalizers();

        // B now eligible for collection, but A is not
        if (RefA != null)
            Console.WriteLine("RefA is not null");
    }
}
```

<span data-ttu-id="a8f02-539">В программе выше, если сборщик мусора выбирает выполнение деструктора `A` до деструктора `B`, то выходные данные этой программы может быть:</span><span class="sxs-lookup"><span data-stu-id="a8f02-539">In the above program, if the garbage collector chooses to run the destructor of `A` before the destructor of `B`, then the output of this program might be:</span></span>
```
Destruct instance of A
Destruct instance of B
A.F
RefA is not null
```

<span data-ttu-id="a8f02-540">Обратите внимание, что хотя экземпляр `A` не используется и `A`в запускался деструктор, по-прежнему возможно, для методов `A` (в этом случае `F`) для вызова из другого деструктора.</span><span class="sxs-lookup"><span data-stu-id="a8f02-540">Note that although the instance of `A` was not in use and `A`'s destructor was run, it is still possible for methods of `A` (in this case, `F`) to be called from another destructor.</span></span> <span data-ttu-id="a8f02-541">Кроме того Обратите внимание на то, что выполнение деструктора может привести к объекту станет доступным для использования из основной программы снова.</span><span class="sxs-lookup"><span data-stu-id="a8f02-541">Also, note that running of a destructor may cause an object to become usable from the mainline program again.</span></span> <span data-ttu-id="a8f02-542">В этом случае выполнение `B`деструктор, вызвавшего экземпляр `A` , был ранее не используется стал доступен из существующей ссылки `Test.RefA`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-542">In this case, the running of `B`'s destructor caused an instance of `A` that was previously not in use to become accessible from the live reference `Test.RefA`.</span></span> <span data-ttu-id="a8f02-543">После вызова `WaitForPendingFinalizers`, экземпляр `B` подходит для коллекции, но экземпляр `A` не из-за ссылки `Test.RefA`.</span><span class="sxs-lookup"><span data-stu-id="a8f02-543">After the call to `WaitForPendingFinalizers`, the instance of `B` is eligible for collection, but the instance of `A` is not, because of the reference `Test.RefA`.</span></span>

<span data-ttu-id="a8f02-544">Чтобы избежать путаницы и непредвиденное поведение, он обычно является хорошей идеей деструкторы только выполнить очистку данных в их собственных полей объекта, а не выполнять любые действия на ссылочные объекты или статические поля.</span><span class="sxs-lookup"><span data-stu-id="a8f02-544">To avoid confusion and unexpected behavior, it is generally a good idea for destructors to only perform cleanup on data stored in their object's own fields, and not to perform any actions on referenced objects or static fields.</span></span>

<span data-ttu-id="a8f02-545">Является альтернативой использованию деструкторы классом реализации `System.IDisposable` интерфейс.</span><span class="sxs-lookup"><span data-stu-id="a8f02-545">An alternative to using destructors is to let a class implement the `System.IDisposable` interface.</span></span> <span data-ttu-id="a8f02-546">Это позволяет клиенту определить, когда нужно освободить ресурсы объекта, как правило, доступ к объекту в качестве ресурса объекта `using` инструкции ([инструкцией](statements.md#the-using-statement)).</span><span class="sxs-lookup"><span data-stu-id="a8f02-546">This allows the client of the object to determine when to release the resources of the object, typically by accessing the object as a resource in a `using` statement ([The using statement](statements.md#the-using-statement)).</span></span>

## <a name="execution-order"></a><span data-ttu-id="a8f02-547">Порядок выполнения</span><span class="sxs-lookup"><span data-stu-id="a8f02-547">Execution order</span></span>

<span data-ttu-id="a8f02-548">Выполнение программы на C# продолжается таким образом, что побочные эффекты каждого выполняемого потока сохраняются в критических точках выполнения.</span><span class="sxs-lookup"><span data-stu-id="a8f02-548">Execution of a C# program proceeds such that the side effects of each executing thread are preserved at critical execution points.</span></span> <span data-ttu-id="a8f02-549">Объект ***побочный эффект*** определяется как чтение или запись поле с модификатором volatile, запись в энергонезависимой переменную, запись внешнего ресурса и возникновение исключения.</span><span class="sxs-lookup"><span data-stu-id="a8f02-549">A ***side effect*** is defined as a read or write of a volatile field, a write to a non-volatile variable, a write to an external resource, and the throwing of an exception.</span></span> <span data-ttu-id="a8f02-550">Критические точки выполнения в которых должен сохраняться порядок этих побочные эффекты являются ссылками на изменяемые поля ([изменяемые поля](classes.md#volatile-fields)), `lock` инструкций ([инструкция lock](statements.md#the-lock-statement)), и Создание потока и порядок прекращения.</span><span class="sxs-lookup"><span data-stu-id="a8f02-550">The critical execution points at which the order of these side effects must be preserved are references to volatile fields ([Volatile fields](classes.md#volatile-fields)), `lock` statements ([The lock statement](statements.md#the-lock-statement)), and thread creation and termination.</span></span> <span data-ttu-id="a8f02-551">Среда выполнения может свободно изменять порядок выполнения программы на C#, распространяются следующие ограничения:</span><span class="sxs-lookup"><span data-stu-id="a8f02-551">The execution environment is free to change the order of execution of a C# program, subject to the following constraints:</span></span>

*  <span data-ttu-id="a8f02-552">Зависимости данных сохраняются в рамках потока выполнения.</span><span class="sxs-lookup"><span data-stu-id="a8f02-552">Data dependence is preserved within a thread of execution.</span></span> <span data-ttu-id="a8f02-553">То есть значение каждой переменной вычисляется так, как если бы были выполнены все инструкции в потоке в первоначальном порядке программы.</span><span class="sxs-lookup"><span data-stu-id="a8f02-553">That is, the value of each variable is computed as if all statements in the thread were executed in original program order.</span></span>
*  <span data-ttu-id="a8f02-554">Порядок инициализации сохраняются правил ([инициализацию поля](classes.md#field-initialization) и [инициализаторы переменных](classes.md#variable-initializers)).</span><span class="sxs-lookup"><span data-stu-id="a8f02-554">Initialization ordering rules are preserved ([Field initialization](classes.md#field-initialization) and [Variable initializers](classes.md#variable-initializers)).</span></span>
*  <span data-ttu-id="a8f02-555">Упорядочивание побочных эффектов сохраняется по отношению к volatile операций чтения и записи ([изменяемые поля](classes.md#volatile-fields)).</span><span class="sxs-lookup"><span data-stu-id="a8f02-555">The ordering of side effects is preserved with respect to volatile reads and writes ([Volatile fields](classes.md#volatile-fields)).</span></span> <span data-ttu-id="a8f02-556">Кроме того среда выполнения не должна вычислять часть выражения, если он может вывести, что значение этого выражения не используется, и что необходимые побочные эффекты создаются (включая, вызванное при вызове метода или доступе к поле с модификатором volatile).</span><span class="sxs-lookup"><span data-stu-id="a8f02-556">Additionally, the execution environment need not evaluate part of an expression if it can deduce that that expression's value is not used and that no needed side effects are produced (including any caused by calling a method or accessing a volatile field).</span></span> <span data-ttu-id="a8f02-557">Когда выполнение программы прерывается асинхронным событием (например, исключения, созданного другим потоком), не гарантируется, наблюдаемые побочные эффекты являются видимыми в первоначальном порядке программы.</span><span class="sxs-lookup"><span data-stu-id="a8f02-557">When program execution is interrupted by an asynchronous event (such as an exception thrown by another thread), it is not guaranteed that the observable side effects are visible in the original program order.</span></span>
