# <a name="classes"></a>Классы

Класс является структурой данных, которая может содержать данные членов (константы и поля), функции-члены (методы, свойства, события, индексаторы, операторы, конструкторы экземпляров, деструкторы и статические конструкторы) и вложенные типы. Типы классов поддерживают наследование — механизм, посредством которого производный класс может расширяющие и уточняющие определения базового класса.

## <a name="class-declarations"></a>Объявления классов

Объект *class_declaration* — *type_declaration* ([объявления типов](namespaces.md#type-declarations)), объявляет новый класс.

```antlr
class_declaration
    : attributes? class_modifier* 'partial'? 'class' identifier type_parameter_list?
      class_base? type_parameter_constraints_clause* class_body ';'?
    ;
```

Объект *class_declaration* состоит из необязательного набора *атрибуты* ([атрибуты](attributes.md)), а затем необязательный набор *class_modifier*s ([класса модификаторы](classes.md#class-modifiers)), а затем использовать необязательный `partial` модификатор, а затем с помощью ключевого слова `class` и *идентификатор* , которая содержит название класса, за которым следует Необязательный *type_parameter_list* ([параметры типа](classes.md#type-parameters)), а затем использовать необязательный *class_base* спецификации ([базового класса Спецификация](classes.md#class-base-specification)), а затем необязательный набор *type_parameter_constraints_clause*s ([ограничения параметров типа](classes.md#type-parameter-constraints)), за которым следует *class_body*  ([Класса текст](classes.md#class-body)), при необходимости, а затем точкой с запятой.

Объявление класса не может предоставить *type_parameter_constraints_clause*s Если не предоставляется *type_parameter_list*.

Объявление класса, который предоставляет *type_parameter_list* — ***объявление универсального класса***. Кроме того любой класс, вложенный в объявлении универсального класса или объявлении универсального структуры является объявление универсального класса, так как параметры типа для содержащего типа должен быть введен для создания сконструированного типа.

### <a name="class-modifiers"></a>Модификаторы класса

Объект *class_declaration* может включать последовательность модификаторов класса:

```antlr
class_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'abstract'
    | 'sealed'
    | 'static'
    | class_modifier_unsafe
    ;
```

Это ошибка времени компиляции для один и тот же модификатор встречается несколько раз в объявлении класса.

`new` Модификатор может применяться для вложенных классов. Он указывает, что класс скрывает унаследованный член с тем же именем, как описано в разделе [Модификатор new](classes.md#the-new-modifier). Произошла ошибка во время компиляции для `new` появление в объявлении класса, который не является объявление вложенного класса модификатора.

`public`, `protected`, `internal`, И `private` модификаторы определяют доступность класса. В зависимости от контекста, в котором производится объявление класса, некоторые из этих модификаторов запрещены ([объявленную доступность](basic-concepts.md#declared-accessibility)).

`abstract`, `sealed` И `static` модификаторы рассматриваются в следующих разделах.

#### <a name="abstract-classes"></a>Абстрактные классы

`abstract` Модификатор используется для указания, что класс является неполным и что она должна использоваться только в качестве базового класса. Абстрактный класс отличается от неабстрактного класса следующим образом:

*  Абстрактный класс не может быть создан напрямую, и произошла ошибка во время компиляции, чтобы использовать `new` оператор для абстрактного класса. Хотя можно иметь переменные и значения, типы которых во время компиляции являются абстрактными, такие переменные и значения обязательно будет `null` или содержать ссылки на экземпляры неабстрактных классов, производных от абстрактных типов.
*  Абстрактный класс разрешены (но не требуются) содержать абстрактные члены.
*  Абстрактный класс не может быть запечатанным.

Если неабстрактный класс является производным от абстрактного класса, неабстрактный класс должен включать фактические реализации всех наследуемых абстрактных членов, тем самым переопределив эти абстрактные члены. В примере
```csharp
abstract class A
{
    public abstract void F();
}

abstract class B: A
{
    public void G() {}
}

class C: B
{
    public override void F() {
        // actual implementation of F
    }
}
```
Абстрактный класс `A` представляет абстрактный метод `F`. Класс `B` представляет дополнительный метод `G`, но так как он не предоставляет реализацию `F`, `B` должен также быть объявлен как абстрактный. Класс `C` переопределяет `F` и предоставляет фактическую реализацию. Так как нет ни одного абстрактного члена в `C`, `C` разрешены (но не требуются) быть абстрактным.

#### <a name="sealed-classes"></a>Запечатанные классы

`sealed` Модификатор используется для предотвращения создания производных от класса. Ошибка времени компиляции возникает, если указаны запечатанный класс как базовый класс другого класса.

Запечатанный класс не может также быть абстрактным классом.

`sealed` Модификатор используется главным образом для предотвращения случайного наследования, но она также позволяет определенные оптимизации во время выполнения. В частности поскольку известно, что запечатанный класс не имеет производных классов, возможна для преобразования вызовов виртуальных функций-членов экземпляров запечатанного класса в невиртуальные вызовы.

#### <a name="static-classes"></a>Статические классы

`static` Модификатор используется для пометки класса, объявленного как ***статический класс***. Статический класс не может быть создан, нельзя использовать в качестве типа и может содержать только статические члены. Только статический класс может содержать объявления методов расширения ([методы расширения](classes.md#extension-methods)).

Объявление статического класса, со следующими ограничениями:

*  Статический класс не может содержать `sealed` или `abstract` модификатор. Обратите внимание, что так как нельзя создать экземпляр или производным от статического класса, он ведет себя как если бы он был запечатанный и абстрактный.
*  Статический класс не может содержать *class_base* спецификации ([класса базовой спецификации](classes.md#class-base-specification)) и явно указать базовый класс или списка реализованных интерфейсов. Статический класс неявно наследуется от типа `object`.
*  Статический класс может содержать только статические члены ([экземпляра и статические члены](classes.md#static-and-instance-members)). Обратите внимание на то, что константы и вложенные типы классифицируются как статические члены.
*  Статический класс не может иметь члены с `protected` или `protected internal` объявленную доступность.

Это ошибка времени компиляции, чтобы нарушить эти ограничения.

Статический класс не имеет конструкторов экземпляров. Невозможно объявить конструктор экземпляров в статическом классе и нет конструктора по умолчанию экземпляр ([конструкторы по умолчанию](classes.md#default-constructors)) предоставляется для статического класса.

Члены статического класса автоматически не являются статическими, а объявления членов необходимо явно включить `static` модификатор (за исключением константы и вложенные типы). Если класс является вложенным внутри статического внешнего класса, вложенный класс не статический класс пока явно не включен `static` модификатор.

__Ссылки на типы статического класса__

Объект *namespace_or_type_name* ([пространства имен и тип](basic-concepts.md#namespace-and-type-names)) может ссылаться на статический класс, если

*  *Namespace_or_type_name* — `T` в *namespace_or_type_name* формы `T.I`, или
*  *Namespace_or_type_name* — `T` в *typeof_expression* ([списки аргументов](expressions.md#argument-lists)1) формы `typeof(T)`.

Объект *primary_expression* ([функции-члены](expressions.md#function-members)) может ссылаться на статический класс, если

*  *Primary_expression* — `E` в *member_access* ([Проверка динамического разрешения перегрузки во время компиляции](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) формы `E.I`.

В любом другом контексте является ошибкой во время компиляции для ссылки на статический класс. Например, это ошибка для статического класса для использования в качестве базового класса, составного типа ([вложенные типы](classes.md#nested-types)) члена, аргумента универсального типа или ограничения параметра типа. Аналогичным образом, статический класс не может использоваться в тип массива, тип указателя, `new` выражения, выражения приведения, `is` выражения, `as` выражения, `sizeof` выражение или выражение значения по умолчанию.

### <a name="partial-modifier"></a>Модификатор partial

`partial` Модификатор позволяет указать, что этот *class_declaration* является объявлением разделяемого типа. Несколько объявлений разделяемого типа с тем же именем в едином объявлении пространства имен или тип объединения для объявления одного типа формы, следуя правилам указан в [разделяемых типов](classes.md#partial-types).

Наличие объявление класса, распределенные по отдельные сегменты текста программы, может быть полезным, если эти сегменты производятся или изменяются в разных контекстах. Например одной части объявления класса может быть компьютером, в то время как другой создается вручную. Текстовое разделение двух запрещает обновление конфликт с обновлениями по другому.

### <a name="type-parameters"></a>Параметры типа

Параметр типа является простой идентификатор, обозначающий заполнитель для аргумент типа, предоставленный для создания сконструированного типа. Параметр типа является формальный заполнитель для типа, который будет выдавать более поздней версии. В отличие от этого, аргумент типа ([аргументы типа](types.md#type-arguments)) — фактический тип, который подставляется для параметра типа, когда создается сконструированный тип.

```antlr
type_parameter_list
    : '<' type_parameters '>'
    ;

type_parameters
    : attributes? type_parameter
    | type_parameters ',' attributes? type_parameter
    ;

type_parameter
    : identifier
    ;
```

Каждый параметр типа в объявлении класса определяет имя в области объявления ([объявления](basic-concepts.md#declarations)) этого класса. Таким образом он не может иметь имя, совпадающее с именем другого параметра типа, или член объявлен в этом классе. Параметр типа не может иметь имя, совпадающее с именем самого типа.

### <a name="class-base-specification"></a>Спецификация базового класса

Объявление класса может содержать *class_base* спецификации, которая определяет прямой базовый класс классов и интерфейсов ([интерфейсы](interfaces.md)) непосредственно, реализуемый классом.

```antlr
class_base
    : ':' class_type
    | ':' interface_type_list
    | ':' class_type ',' interface_type_list
    ;

interface_type_list
    : interface_type (',' interface_type)*
    ;
```

Базовый класс, указанный в объявлении класса не может быть типом сконструированного класса ([создан типы](types.md#constructed-types)). Базовый класс не может быть параметром типа сам по себе, хотя он может включать параметры типа, которые находятся в области действия.

```csharp
class Extend<V>: V {}            // Error, type parameter used as base class
```

#### <a name="base-classes"></a>базовых классов;

Когда *class_type* включается в *class_base*, он указывает прямой базовый класс для класса, объявленного в. Если в объявлении класса нет *class_base*, или если *class_base* списки только типы интерфейса, прямой базовый класс считается `object`. Класс наследует члены от прямого базового класса, как описано в разделе [наследования](classes.md#inheritance).

В примере
```csharp
class A {}

class B: A {}
```
Класс `A` считается прямой базовый класс для `B`, и `B` говорят, что быть производным от `A`. Так как `A` does явно не указать прямой базовый класс, его непосредственный базовый класс является неявно `object`.

Для типа сконструированного класса, если базовый класс указывается в объявлении универсального класса, базовый класс сконструированного типа будет получен путем замены для каждого *параметр_типа* в объявлении базовый класс, соответствующий *type_argument* сконструированного типа. В объявлениях универсального класса
```csharp
class B<U,V> {...}

class G<T>: B<string,T[]> {...}
```
базовый класс сконструированного типа `G<int>` бы `B<string,int[]>`.

Прямой базовый класс типа класса должен быть по крайней мере такой же уровень доступности, как и сам тип класса ([области доступности](basic-concepts.md#accessibility-domains)). Например, это ошибка времени компиляции для `public` класса для наследования от `private` или `internal` класса.

Прямой базовый класс типа класса не должно быть следующих типов: `System.Array`, `System.Delegate`, `System.MulticastDelegate`, `System.Enum`, или `System.ValueType`. Кроме того, нельзя использовать объявление универсального класса `System.Attribute` как прямой или косвенный базовый класс.

При определении значения в спецификации прямой базовый класс `A` класса `B`, прямой базовый класс для `B` временно предполагается, что `object`. Это означает, что значение спецификации базового класса не может рекурсивно зависеть от самого себя. Пример:
```csharp
class A<T> {
   public class B {}
}

class C : A<C.B> {}
```
является ошибочным, поскольку в спецификации базового класса `A<C.B>` прямой базовый класс для `C` считается `object`и, следовательно (согласно правилам [пространства имен и тип](basic-concepts.md#namespace-and-type-names)) `C` не считается член `B`.

Эти базовые классы типа класса являются прямой базовый класс и его базовых классов. Другими словами набор базовых классов является транзитивное замыкание связи прямой базовый класс. Ссылаясь на пример выше, базовые классы для `B` являются `A` и `object`. В примере
```csharp
class A {...}

class B<T>: A {...}

class C<T>: B<IComparable<T>> {...}

class D<T>: C<T[]> {...}
```
базовые классы для `D<int>` являются `C<int[]>`, `B<IComparable<int[]>>`, `A`, и `object`.

За исключением класса `object`, каждый тип класс имеет только один прямой базовый класс. `object` Класс не имеет прямого базового класса и является исходным базовым классом для всех других классов.

Если в классе `B` является производным от класса `A`, это ошибка времени компиляции для `A` зависят от `B`. Класс ***напрямую зависит от*** прямого базового класса (если таковые имеются) и ***напрямую зависит от*** класса, в течение которого он немедленно вложен (если таковые имеются). Рассмотрим следующее определение, полный набор классов, от которых зависит класс является рефлексивным и транзитивным замыканием ***напрямую зависит от*** связи.

Пример
```csharp
class A: A {}
```
является ошибочным, поскольку класс зависит сам от себя. Аналогично в примере
```csharp
class A: B {}
class B: C {}
class C: A {}
```
не ошибка, так как классы циклически зависят сами. Наконец пример
```csharp
class A: B.C {}

class B: A
{
    public class C {}
}
```
приводит к ошибке времени компиляции, так как `A` зависит от `B.C` (его непосредственный базовый класс), который зависит от `B` (немедленно включающего его класса), которые циклически зависят от `A`.

Обратите внимание на то, что класс не зависит от классов, вложенных в него. В примере
```csharp
class A
{
    class B: A {}
}
```
`B` зависит от `A` (так как `A` его непосредственный базовый класс и немедленно включающего его класса), но `A` не зависит от `B` (так как `B` не является ни базовым классом, ни включающего класса `A` ). Таким образом пример является допустимым.

Невозможно выполнять наследование `sealed` класса. В примере
```csharp
sealed class A {}

class B: A {}            // Error, cannot derive from a sealed class
```
Класс `B` является ошибочным, так как оно пытается являются производными от `sealed` класс `A`.

#### <a name="interface-implementations"></a>Реализации интерфейсов

Объект *class_base* спецификация может включать список типов интерфейсов, в которых случай класса говорят, что прямая реализация заданные типы интерфейса. Реализация интерфейсов рассматривается далее в [реализации интерфейсов](interfaces.md#interface-implementations).

### <a name="type-parameter-constraints"></a>Ограничения параметров типа

Универсальный тип и объявлениях метода при необходимости можно указать ограничения параметра типа, включив *type_parameter_constraints_clause*s.

```antlr
type_parameter_constraints_clause
    : 'where' type_parameter ':' type_parameter_constraints
    ;

type_parameter_constraints
    : primary_constraint
    | secondary_constraints
    | constructor_constraint
    | primary_constraint ',' secondary_constraints
    | primary_constraint ',' constructor_constraint
    | secondary_constraints ',' constructor_constraint
    | primary_constraint ',' secondary_constraints ',' constructor_constraint
    ;

primary_constraint
    : class_type
    | 'class'
    | 'struct'
    ;

secondary_constraints
    : interface_type
    | type_parameter
    | secondary_constraints ',' interface_type
    | secondary_constraints ',' type_parameter
    ;

constructor_constraint
    : 'new' '(' ')'
    ;
```

Каждый *type_parameter_constraints_clause* состоит из маркера `where`, за которым следует имя параметра типа, за которым следует двоеточие и список ограничений для данного параметра типа. Допускается не более одного `where` предложение для каждого параметра типа и `where` предложения могут быть перечислены в любом порядке. Как и `get` и `set` токенов в метод доступа к свойству `where` токен не является ключевым словом.

Список ограничений в `where` предложение может включать любые из следующих компонентов, в следующем порядке: ограничение одного первичного, один или несколько вторичных ограничения и ограничение конструктора, `new()`.

Ограничение первичного может быть типом класса или ***ссылаются на ограничение типа*** `class` или ***значение ограничения типа*** `struct`. Вторичное ограничение может быть *параметр_типа* или *interface_type*.

Ограничение ссылочного типа указывает, что аргумент типа, используемый для параметра типа должен быть ссылочным типом. Все типы классов, типы интерфейсов, типы делегатов, типы массивов и параметры типа, известные как ссылочный тип (как определено ниже) удовлетворяет этому ограничению.

Ограничение типа значения указывает, что аргумент типа, используемый для параметра типа должен быть типом значения, не допускающие значения NULL. Все типы структуры не поддерживают значение NULL, типы перечисления и параметры типа с ограничением до значимого типа удовлетворяет этому ограничению. Обратите внимание, что, несмотря на то, что классифицировано как тип значения, допускающие значения NULL типа ([обнуляемые типы](types.md#nullable-types)) не удовлетворяет ограничению типа значения. Параметр типа с ограничением типа значения не может также иметь *constructor_constraint*.

Типы указателей никогда не могут иметь аргументы типа и не считаются соответствует либо ссылку типа или значения ограничениям типа.

Если ограничение является типом класса, тип интерфейса или параметр типа, этот тип указывает минимальный «базовый тип», должен поддерживать каждый аргумент типа для этого параметра типа. При каждом использовании сконструированного типа или универсального метода, аргумент типа проверяются на соответствие ограничениям параметра типа во время компиляции. Аргумент типа, предоставленный должны удовлетворять условиям, описанным в [удовлетворяющий ограничениям](types.md#satisfying-constraints).

Объект *class_type* ограничение должно удовлетворять следующим правилам:

*  Тип должен быть типом класса.
*  Тип не должен быть `sealed`.
*  Тип не должен быть одним из следующих типов: `System.Array`, `System.Delegate`, `System.Enum`, или `System.ValueType`.
*  Тип не должен быть `object`. Так как все типы являются производными от `object`, такое ограничение не окажет никакого влияния, если бы оно было разрешено.
*  Не более одного ограничения для данного параметра типа может быть типом класса.

Тип, указанный как *interface_type* ограничение должно удовлетворять следующим правилам:

*  Тип должен быть типом интерфейса.
*  Тип не должен быть указан более одного раза в заданной `where` предложение.

В любом случае ограничение может включать любые параметры типа связанный тип или объявление метода в рамках сконструированного типа и может включать в себя объявляемый тип.

Любой тип класса или интерфейса, указанный как ограничения параметра типа должен быть по крайней мере такой же уровень доступности ([ограничения доступности](basic-concepts.md#accessibility-constraints)) как универсальный тип или метод объявляется.

Тип, указанный как *параметр_типа* ограничение должно удовлетворять следующим правилам:

*  Тип должен быть параметром типа.
*  Тип не должен быть указан более одного раза в заданной `where` предложение.

Кроме должна существовать не было циклов в графе зависимостей параметров типа, где зависимостью является транзитивное отношение, заданное по:

*  Если параметр типа `T` используется в качестве ограничения для параметра типа `S` затем `S` ***зависит от*** `T`.
*  Если параметр типа `S` зависит от параметра типа `T` и `T` зависит от параметра типа `U` затем `S` ***зависит от*** `U`.

Учитывая это отношение, является ошибкой во время компиляции для параметра типа зависеть от самого себя (прямо или косвенно).

Все ограничения должны быть согласованы среди зависимых параметров типа. Если параметр типа `S` зависит от параметра типа `T` затем:

*  `T` не должен иметь ограничение типа значения. В противном случае `T` эффективно запечатан, поэтому `S` будет вынужден иметь тот же тип, что `T`, устраняя необходимость в два параметра типа.
*  Если `S` имеет ограничение типа значения, то `T` не должен иметь *class_type* ограничение.
*  Если `S` имеет *class_type* ограничение `A` и `T` имеет *class_type* ограничение `B` то должно быть преобразование идентификации или неявные преобразование из ссылок `A` для `B` или и неявное ссылочное преобразование из `B` для `A`.
*  Если `S` также зависит от параметра типа `U` и `U` имеет *class_type* ограничение `A` и `T` имеет *class_type* ограничение `B` то должно быть преобразование идентификации или неявное преобразование ссылок из `A` для `B` или и неявное ссылочное преобразование из `B` для `A`.

Он является действительным для `S` иметь ограничение типа значения и `T` иметь ограничение ссылочного типа. Фактически это ограничивает `T` типам `System.Object`, `System.ValueType`, `System.Enum`и любой другой тип интерфейса.

Если `where` предложение для параметра типа включает ограничение конструктора (который имеет форму `new()`), можно использовать `new` оператор для создания экземпляров типа ([выражения созданияобъектов](expressions.md#object-creation-expressions)). Любой аргумент типа, используемый для параметра типа с ограничением конструктора должен иметь открытый конструктор без параметров (данный конструктор неявно существует для любого типа значения), или быть параметром типа с ограничением до значимого типа или ограничение конструктора (см. [Ограничения параметров типа](classes.md#type-parameter-constraints) сведения).

Ниже приведены примеры ограничений:
```csharp
interface IPrintable
{
    void Print();
}

interface IComparable<T>
{
    int CompareTo(T value);
}

interface IKeyProvider<T>
{
    T GetKey();
}

class Printer<T> where T: IPrintable {...}

class SortedList<T> where T: IComparable<T> {...}

class Dictionary<K,V>
    where K: IComparable<K>
    where V: IPrintable, IKeyProvider<K>, new()
{
    ...
}
```

Следующий пример является по ошибке, так как он вызывает цикличность в графе зависимостей параметров типа:
```csharp
class Circular<S,T>
    where S: T
    where T: S                // Error, circularity in dependency graph
{
    ...
}
```

В следующих примерах показаны некоторые недопустимые ситуации:
```csharp
class Sealed<S,T>
    where S: T
    where T: struct        // Error, T is sealed
{
    ...
}

class A {...}

class B {...}

class Incompat<S,T>
    where S: A, T
    where T: B                // Error, incompatible class-type constraints
{
    ...
}

class StructWithClass<S,T,U>
    where S: struct, T
    where T: U
    where U: A                // Error, A incompatible with struct
{
    ...
}
```

***Эффективным базовым классом*** параметра типа `T` определяется следующим образом:

*  Если `T` без ограничения первичного или ограничения параметра типа, его эффективным базовым классом `object`.
*  Если `T` имеет ограничение типа значения, его эффективным базовым классом является `System.ValueType`.
*  Если `T` имеет *class_type* ограничение `C` , но не *параметр_типа* ограничения, его эффективным базовым классом является `C`.
*  Если `T` не имеет *class_type* ограничение, но имеет один или несколько *параметр_типа* ограничения, его эффективным базовым классом является включаемый тип ([ликвидированный преобразования операторы](conversions.md#lifted-conversion-operators)) в набор эффективных базовых классов его *параметр_типа* ограничения. Правила целостности убедитесь в наличии включаемый тип.
*  Если `T` имеет оба *class_type* ограничения и один или несколько *параметр_типа* ограничения, его эффективным базовым классом является включаемый тип ([ликвидированный преобразования операторы](conversions.md#lifted-conversion-operators)) в набор, состоящий из *class_type* ограничение `T` и эффективных базовых классов его *параметр_типа* ограничения. Правила целостности убедитесь в наличии включаемый тип.
*  Если `T` имеет ограничение ссылочного типа, но не *class_type* ограничения, его эффективным базовым классом является `object`.

Для выполнения этих правил, если T имеет ограничение `V` то есть *value_type*, вместо этого используйте наиболее конкретный базовый тип `V` то есть *class_type*. Это не может произойти в явно заданной ограничением, но может возникнуть, когда ограничения универсального метода неявным образом наследуются объявлением метода переопределения или явной реализации метода интерфейса.

Эти правила гарантируют эффективное базового класса, всегда *class_type*.

***Эффективным набором интерфейса*** параметра типа `T` определяется следующим образом:

*  Если `T` не имеет *secondary_constraints*, его эффективным набором интерфейса является пустым.
*  Если `T` имеет *interface_type* ограничения, но не *параметр_типа* ограничения, его эффективным набором интерфейса является его набор *interface_type* ограничения.
*  Если `T` не имеет *interface_type* ограничения, но имеет *параметр_типа* ограничения, его эффективным набором интерфейса — это объединение наборов эффективный интерфейс его *type_ параметр* ограничения.
*  Если `T` имеет оба *interface_type* ограничения и *параметр_типа* ограничения, его эффективным набором интерфейса — это объединение свой набор *interface_type* ограничения и эффективный интерфейс наборы его *параметр_типа* ограничения.

Параметр типа является ***известно, быть ссылочным типом*** если он имеет ограничение ссылочного типа или его эффективным базовым классом не `object` или `System.ValueType`.

Значения с ограничением типа параметра типа могут использоваться для доступа к членам экземпляра, который содержится в разрешении ограничения. В примере
```csharp
interface IPrintable
{
    void Print();
}

class Printer<T> where T: IPrintable
{
    void PrintOne(T x) {
        x.Print();
    }
}
```
методы `IPrintable` могут вызываться непосредственно на `x` поскольку `T` ограничен для реализации всегда `IPrintable`.

### <a name="class-body"></a>Тело класса

*Class_body* класса определяет члены этого класса.

```antlr
class_body
    : '{' class_member_declaration* '}'
    ;
```

## <a name="partial-types"></a>Разделяемые типы

Объявление типа могут быть разбиты на несколько ***объявления разделяемого типа***. Объявление типа создается из его частей путем согласно правилам, описанным в этом разделе, после чего он рассматривается как одно объявление течение оставшегося времени обработки во время компиляции и во время выполнения программы.

Объект *class_declaration*, *struct_declaration* или *interface_declaration* представляет объявление разделяемого типа, если он включает `partial` модификатор. `partial` не является ключевым словом и действует только в качестве модификатора, если он отображается непосредственно перед ключевое слово `class`, `struct` или `interface` в объявлении типа или перед типом `void` в объявлении метода. В других контекстах он может использоваться в качестве обычного идентификатора.

Каждая часть объявления разделяемого типа должна включать `partial` модификатор. Она должна иметь то же имя и быть объявлен в том же пространстве имен или объявление типа, что и другие части. `partial` Модификатор указывает, что могут существовать дополнительные части объявления типа, но наличие таких дополнительных компонентов не является обязательным; это недопустимо для типа с одним объявлением для включения `partial` модификатор.

Все части разделяемого типа должны быть скомпилированы вместе, таким образом, чтобы компоненты могут быть объединены во время компиляции в объявления одного типа. Разделяемые типы специально не позволяют расширить уже скомпилированных типов.

Вложенные типы могут быть объявлены в несколько частей с помощью `partial` модификатор. Как правило, содержащий тип объявляется с помощью `partial` объявив также и каждая часть вложенного типа в другой части содержащего его типа.

`partial` Модификатора не допускается в объявлениях делегатов или перечислений.

### <a name="attributes"></a>Атрибуты

Атрибуты разделяемого типа определяются путем объединения в неопределенном порядке, атрибуты каждой части. Если атрибут помещается на несколько частей, это эквивалентно указании несколько раз для типа атрибута. Например две части:

```csharp
[Attr1, Attr2("hello")]
partial class A {}

[Attr3, Attr2("goodbye")]
partial class A {}
```
Например, эквивалентны к объявлению:
```csharp
[Attr1, Attr2("hello"), Attr3, Attr2("goodbye")]
class A {}
```

Аналогичным образом объединить атрибуты параметров типа.

### <a name="modifiers"></a>Модификаторы

Если объявление разделяемого типа содержит спецификацию доступности ( `public`, `protected`, `internal`, и `private` модификаторы) оно должно быть согласовано с все остальные составляющие, которые включают спецификацию доступности. Если ни одна часть разделяемого типа включает спецификацию доступности, типу задается соответствующая доступность по умолчанию ([объявленную доступность](basic-concepts.md#declared-accessibility)).

Если один или более частичных объявлениях вложенного типа включают `new` модификатор, предупреждение не передается в том случае, если вложенный тип скрывает унаследованный член ([скрытие через наследование](basic-concepts.md#hiding-through-inheritance)).

Если включить один или более частичных объявлениях класса `abstract` модификатор класса будет считаться абстрактным ([абстрактные классы](classes.md#abstract-classes)). В противном случае класс считается абстрактным.

Если включить один или более частичных объявлениях класса `sealed` модификатор класса будет считаться запечатанным ([запечатанных классов](classes.md#sealed-classes)). В противном случае класс считается незапечатанный.

Обратите внимание на то, что класс не может быть одновременно абстрактным и запечатанным.

Когда `unsafe` модификатор используется в объявлении разделяемого типа только соответствующая часть считается небезопасным контекстом ([небезопасных контекстах](unsafe-code.md#unsafe-contexts)).

### <a name="type-parameters-and-constraints"></a>Тип параметров и ограничений

Если универсальный тип объявлен в нескольких частей, каждая часть должна формулировать параметры типа. Каждая часть должна иметь одинаковое число параметров типа и то же имя для каждого параметра типа в порядке.

Если объявление разделяемого универсального типа содержит ограничения (`where` предложений), ограничения должны быть согласованы со всеми другими частями, которые включают ограничения. В частности каждая часть, содержащая ограничения должны иметь ограничения для одного набора параметров типа, и для каждого параметра типа наборы первичных, вторичная реплика и ограничений конструктора должно изменяться. Два набора ограничений эквивалентны, если они содержат те же элементы. Если ни одна часть разделяемого типа универсальный тип ограничения параметра типа, параметры считаются без ограничений.

Пример
```csharp
partial class Dictionary<K,V>
    where K: IComparable<K>
    where V: IKeyProvider<K>, IPersistable
{
    ...
}

partial class Dictionary<K,V>
    where V: IPersistable, IKeyProvider<K>
    where K: IComparable<K>
{
    ...
}

partial class Dictionary<K,V>
{
    ...
}
```
используется правильная так, как части, включающие ограничения (первые две) эффективно укажите же набор основной, дополнительный и ограничений конструктора для одного набора параметров типа, соответственно.

### <a name="base-class"></a>Базовый класс

Если объявление разделяемого класса содержит базовый класс должен соответствовать все остальные составляющие, которые включают спецификации базового класса. Если никакая часть разделяемый класс содержит спецификацию базового класса, базовый класс становится `System.Object` ([базовые классы](classes.md#base-classes)).

### <a name="base-interfaces"></a>Базовые интерфейсы

Набор базовых интерфейсов для типа, объявленного в нескольких частях является объединение базовые интерфейсы, указанные на каждой из них. Определенный базовый интерфейс может быть имя на каждой из них только один раз, но разрешено несколько частей имени же базовых интерфейсов. Должно существовать только одна реализация члены любого заданного базового интерфейса.

В примере
```csharp
partial class C: IA, IB {...}

partial class C: IC {...}

partial class C: IA, IB {...}
```
набор базовых интерфейсов для класса `C` — `IA`, `IB`, и `IC`.

Как правило каждая часть предоставляет реализацию интерфейсов, объявленных в соответствующей стороной; Тем не менее это не является обязательным. Одна часть может предоставлять реализацию для интерфейса, объявленного в другой части:
```csharp
partial class X
{
    int IComparable.CompareTo(object o) {...}
}

partial class X: IComparable
{
    ...
}
```

### <a name="members"></a>Участники

За исключением разделяемые методы ([разделяемые методы](classes.md#partial-methods)), набор элементов типа, объявленного в нескольких частях представляет собой просто объединение набора элементов, объявленных в каждой части. Тела все части объявления типа совместно используют одно и то же пространство объявления ([объявления](basic-concepts.md#declarations)) и область каждого элемента ([областей](basic-concepts.md#scopes)) распространяется на все части тела. Домен доступности любого члена всегда содержит все части вмещающего типа; `private` член, объявленный в одной из частей, свободно доступен из другой части. Это ошибка времени компиляции, чтобы объявить один и тот же элемент в более чем одной части типа, если этот член является типом с `partial` модификатор.

```csharp
partial class A
{
    int x;                     // Error, cannot declare x more than once

    partial class Inner        // Ok, Inner is a partial type
    {
        int y;
    }
}

partial class A
{
    int x;                     // Error, cannot declare x more than once

    partial class Inner        // Ok, Inner is a partial type
    {
        int z;
    }
}
```

Порядок членов типа редко важен для кода C#, но может оказаться слишком дорогим при взаимодействии с другими языками и средами. В таких случаях порядок членов типа, объявленного в нескольких частях не определено.

### <a name="partial-methods"></a>Разделяемые методы

Разделяемые методы могут быть определены в одной части объявления типа и реализованы в другой. Реализация является необязательной. Если ни одна частей реализует разделяемого метода, объявления разделяемого метода и все вызовы к нему удаляются из объявления типа, полученного из комбинации из частей.

Разделяемые методы не удается определить модификаторы доступа, но являются неявно `private`. Возвращаемый тип должен быть `void`, и их параметры не могут иметь `out` модификатор. Идентификатор `partial` распознается как специальное ключевое слово в объявлении метода только в том случае, если он отображается прямо перед `void` типа; в противном случае его можно использовать в качестве обычного идентификатора. Разделяемый метод не может явно реализовывать методы интерфейсов.

Существует два вида объявления разделяемого метода: Если текст объявления метода точки с запятой, объявление считается ***определяющее объявление разделяемого метода***. Если текст задается как *блок*, объявление считается ***реализующего объявления разделяемого метода***. Между частями объявление типа может существовать только одно определяющее объявление разделяемого метода с указанным кодом и может использоваться только один, реализующего объявления разделяемого метода с указанным кодом. Если предоставляется реализующего объявления разделяемого метода, соответствующее определяющее объявление разделяемого метода должна существовать и объявления должны соответствовать как указано ниже:

* Объявления должны иметь одинаковые модификаторы (не обязательно в том же порядке), имя метода, количество параметров типа и количество параметров.
* Соответствующие параметры в объявлениях должны иметь одинаковые модификаторы (не обязательно в том же порядке) и те же типы (остаток от деления различия в именах параметров типа).
* Соответствующие параметры типа в объявлениях должны иметь те же ограничения (остаток от деления различия в именах параметров типа).

Реализующего объявления разделяемого метода могут отображаться в той же части как соответствующие определяющее объявление разделяемого метода.

Определение разделяемого метода участвует в разрешении перегрузки. Таким образом независимо от того, имеется ли реализующего объявления задан, то выражения вызова могут обращаться к вызовам разделяемого метода. Так как разделяемый метод всегда возвращает `void`, такие выражения вызова всегда будет операторы выражений. Кроме того так как разделяемый метод является неявно `private`, такие инструкции будет всегда находятся в одной из частей объявления типа, в котором объявлен разделяемого метода.

Если ни одна часть объявления разделяемого типа содержит реализующее объявление для заданного разделяемого метода, любой оператор выражения вызова этого метода просто удаляется из комбинированного объявления типа. Таким образом, выражение вызова, включая любые групповые выражения, не оказывает влияния во время выполнения. Разделяемый метод сам также удаляется и не будет членом комбинированного объявления типа.

Если реализующее объявление существует для заданного разделяемого метода, вызовы методов разделяемых методов, будут сохранены. Разделяемый метод приводит к возникновению объявление метода, аналогичную реализующего объявления разделяемого метода, за исключением следующих:

* `partial` Модификатор не включено
* Атрибуты в полученный объявление метода, которые объединенный определяющего и реализующего объявления разделяемого метода в неопределенном порядке. Не удалять дубликаты.
* Атрибуты параметров итоговый объявление метода, которые объединенный соответствующих параметров определяющего и реализующего объявления разделяемого метода в неопределенном порядке. Не удалять дубликаты.

Если определяющее объявление, но не реализующего объявления указан для разделяемого метода M, применяются следующие ограничения:

* Произошла ошибка во время компиляции, для создания делегата к методу ([выражения создания делегата](expressions.md#delegate-creation-expressions)).
* Произошла ошибка во время компиляции, для ссылки на `M` внутри анонимную функцию, которая преобразуется в тип дерева выражения ([вычисление анонимной функции преобразования к типы дерева выражений](conversions.md#evaluation-of-anonymous-function-conversions-to-expression-tree-types)).
* Выражения, возникающие как часть вызова `M` не влияют на состояние определенного присваивания ([определенного присваивания](variables.md#definite-assignment)), которое может привести к ошибкам во время компиляции.
* `M` не может быть точкой входа для приложения ([запуск приложения](basic-concepts.md#application-startup)).

Разделяемые методы можно использовать для разрешения одной части объявления типа, для настройки поведения другой части, например, один, который создается с помощью средства. Рассмотрим следующее объявление разделяемого класса:
```csharp
partial class Customer
{
    string name;

    public string Name {
        get { return name; }
        set {
            OnNameChanging(value);
            name = value;
            OnNameChanged();
        }

    }

    partial void OnNameChanging(string newName);

    partial void OnNameChanged();
}
```

Если этот класс будет скомпилирован без любого из других частей, определяющие объявления разделяемого метода и их вызовы будут удалены, и результирующее комбинированное объявление класса будет эквивалентно следующему:
```csharp
class Customer
{
    string name;

    public string Name {
        get { return name; }
        set { name = value; }
    }
}
```

Предположим, что задана другая часть, тем не менее, который предоставляет реализующего объявления разделяемых методов:
```csharp
partial class Customer
{
    partial void OnNameChanging(string newName)
    {
        Console.WriteLine("Changing " + name + " to " + newName);
    }

    partial void OnNameChanged()
    {
        Console.WriteLine("Changed to " + name);
    }
}
```

Затем полученный комбинированное объявление класса будет эквивалентно следующему:
```csharp
class Customer
{
    string name;

    public string Name {
        get { return name; }
        set {
            OnNameChanging(value);
            name = value;
            OnNameChanged();
        }

    }

    void OnNameChanging(string newName)
    {
        Console.WriteLine("Changing " + name + " to " + newName);
    }

    void OnNameChanged()
    {
        Console.WriteLine("Changed to " + name);
    }
}
```

### <a name="name-binding"></a>Имя привязки

Несмотря на то, что каждая часть расширяемого типа должен быть объявлен в том же пространстве имен, части обычно записывается в различных объявлений пространств имен. Таким образом разные `using` директивы ([директив Using](namespaces.md#using-directives)) могут присутствовать для каждой части. При интерпретации простые имена ([вывод типа](expressions.md#type-inference)) в рамках одной части, только `using` директивы из объявлений пространства имен, содержащего той части считаются. Это может привести к тому же идентификатор, имеет разные значения в различных частей:
```csharp
namespace N
{
    using List = System.Collections.ArrayList;

    partial class A
    {
        List x;                // x has type System.Collections.ArrayList
    }
}

namespace N
{
    using List = Widgets.LinkedList;

    partial class A
    {
        List y;                // y has type Widgets.LinkedList
    }
}
```

## <a name="class-members"></a>Члены класса

Члены класса состоят из членов, представленных его *class_member_declaration*s и члены, унаследованные от прямого базового класса.

```antlr
class_member_declaration
    : constant_declaration
    | field_declaration
    | method_declaration
    | property_declaration
    | event_declaration
    | indexer_declaration
    | operator_declaration
    | constructor_declaration
    | destructor_declaration
    | static_constructor_declaration
    | type_declaration
    ;
```

Члены типа класса можно разделить на следующие категории:

*  Константы, представляющие постоянные значения, связанные с классом ([константы](classes.md#constants)).
*  Поля, являющиеся переменные класса ([поля](classes.md#fields)).
*  Методы, реализующие вычисления и действия, которые могут быть выполнены с помощью класса ([методы](classes.md#methods)).
*  Свойства, определяющие именованные характеристики и действия, связанные с чтением и записью данных характеристик ([свойства](classes.md#properties)).
*  События, которые определяют уведомления, которые могут быть созданы с помощью класса ([события](classes.md#events)).
*  Индексаторы, которые допускают экземпляры класса для индексирования таким же образом (синтаксически), как массивы ([индексаторы](classes.md#indexers)).
*  Операторы, которые определяют операторы выражений, которые могут быть применены к экземплярам класса ([операторы](classes.md#operators)).
*  Конструкторы экземпляров, которые реализуют действия, необходимые для инициализации экземпляров класса ([конструкторы экземпляров](classes.md#instance-constructors))
*  Деструкторы, реализующие действия, выполняемые перед окончательным удалением экземпляров класса ([деструкторы](classes.md#destructors)).
*  Статические конструкторы, которые реализуют действия, необходимые для инициализации самого класса ([статические конструкторы](classes.md#static-constructors)).
*  Типы, представляющие типы, которые являются локальными для класса ([вложенные типы](classes.md#nested-types)).

Члены, которые могут содержать исполняемый код, совокупно называются *функции-члены* типа класса. Функции-члены типа класса имеют методы, свойства, события, индексаторы, операторы, конструкторы экземпляров, деструкторы и статические конструкторы этого типа класса.

Объект *class_declaration* создает новую область объявления ([объявления](basic-concepts.md#declarations)) и *class_member_declaration*s, непосредственно содержащиеся в *класса _declaration* представляют новые члены в этой области объявления. Следующие правила применяются к *class_member_declaration*s:

*  Конструкторы экземпляров, деструкторы и статические конструкторы должны иметь то же имя, что немедленно включающего класса. Все остальные элементы должны иметь имена, которые отличаются от имени немедленно включающего класса.
*  Имя константы, поля, свойства, события или тип должны отличаться от имен всех остальных членов, объявленных в том же классе.
*  Имя метода должно отличаться от имен всех остальных не методов, объявленных в том же классе. Кроме того, подпись ([сигнатуры и перегрузка](basic-concepts.md#signatures-and-overloading)) из метода должны отличаться от сигнатур всех других методов, объявленных в том же классе, и двух методов, объявленных в том же классе не могут иметь сигнатуры, отличающихся только по `ref` и `out`.
*  Сигнатура конструктора экземпляра должна отличаться от сигнатур всех других конструкторов экземпляров, объявленных в том же классе, и двух конструкторов, объявленных в том же классе может не иметь подписи, которые отличаются только модификаторами `ref` и `out`.
*  Сигнатура индексатора должна отличаться от сигнатур любых других индексаторов, объявленных в том же классе.
*  Сигнатура оператора должна отличаться от сигнатур всех других операторов, объявленных в том же классе.

Наследуемые члены типа класса ([наследования](classes.md#inheritance)) не являются частью области объявления класса. Таким образом производный класс может объявить элемент с тем же именем или сигнатурой, наследуемого члена (что приводит к скрытию унаследованного члена).

### <a name="the-instance-type"></a>Тип экземпляра

Каждое объявление класса имеет связанный привязанный тип ([привязан и несвязанные типы](types.md#bound-and-unbound-types)), ***тип экземпляра***. Для объявления универсального типа, тип экземпляра формируется путем создания сконструированного типа ([создан типы](types.md#constructed-types)) из объявления типа, с каждым из указанного типа аргументов которого соответствующий параметр типа. Так как тип экземпляра использует параметры типа, он может использоваться только где параметров типа находятся в области действия; то есть внутри объявления класса. Тип экземпляра является типом `this` для кода, написанного внутри объявления класса. Для неуниверсальных классов тип экземпляра является просто объявленный класс. Ниже представлено несколько объявлений класса вместе с их типами экземпляр: 
```csharp
class A<T>                           // instance type: A<T>
{
    class B {}                       // instance type: A<T>.B
    class C<U> {}                    // instance type: A<T>.C<U>
}

class D {}                           // instance type: D
```

### <a name="members-of-constructed-types"></a>Членами сконструированные типы

Члены Ненаследуемые сконструированного типа получаются путем замещения для каждого *параметр_типа* в объявлении члена, соответствующего *type_argument* сконструированного типа. Процесс подстановки основан на семантическое значение объявлений типов и не является простым текстовым подстановки.

Например при объявлении универсального класса
```csharp
class Gen<T,U>
{
    public T[,] a;
    public void G(int i, T t, Gen<U,T> gt) {...}
    public U Prop { get {...} set {...} }
    public int H(double d) {...}
}
```
сконструированный тип `Gen<int[],IComparable<string>>` имеет следующие члены:
```csharp
public int[,][] a;
public void G(int i, int[] t, Gen<IComparable<string>,int[]> gt) {...}
public IComparable<string> Prop { get {...} set {...} }
public int H(double d) {...}
```

Тип члена `a` в объявлении универсального класса `Gen` является «двухмерный массив `T`«, поэтому тип члена `a` в сконструированном типе выше является «двухмерный массив одномерный массив `int`«, или `int[,][]`.

В функции-члены экземпляра, тип `this` является тип экземпляра ([тип экземпляра](classes.md#the-instance-type)) в содержащем объявлении.

Все члены универсального класса можно использовать параметры типа из включающего класса, либо непосредственно, либо в рамках сконструированного типа. При закрытии конкретного сконструированного типа ([открытые и закрытые типы](types.md#open-and-closed-types)) используется во время выполнения, каждое использование параметра типа заменяется фактическим типом аргумент, предоставленный для сконструированного типа. Пример:
```csharp
class C<V>
{
    public V f1;
    public C<V> f2 = null;

    public C(V x) {
        this.f1 = x;
        this.f2 = this;
    }
}

class Application
{
    static void Main() {
        C<int> x1 = new C<int>(1);
        Console.WriteLine(x1.f1);        // Prints 1

        C<double> x2 = new C<double>(3.1415);
        Console.WriteLine(x2.f1);        // Prints 3.1415
    }
}
```

### <a name="inheritance"></a>Наследование

Класс ***наследует*** члены типа его прямой базовый класс. Наследование означает, что класс неявно содержит все члены его прямой базовый класс типа, за исключением конструкторы экземпляров, деструкторы и статические конструкторы базового класса. Ниже приведены некоторые важные аспекты наследования.

*  Наследование является транзитивным. Если `C` является производным от `B`, и `B` является производным от `A`, затем `C` наследует члены, объявленные в `B` а также членов, объявленных в `A`.
*  Производный класс расширяет его непосредственный базовый класс. Производный класс может дополнить наследуемые элементы новыми элементами, но он не может удалить определение для наследуемого члена.
*  Конструкторы экземпляров, деструкторы и статические конструкторы не наследуются, но все другие члены, независимо от их объявленный уровень доступности ([доступ к членам](basic-concepts.md#member-access)). Тем не менее в зависимости от их объявленный уровень доступности, унаследованные члены могут оказаться недоступными в производном классе.
*  Производный класс может ***скрыть*** ([скрытие через наследование](basic-concepts.md#hiding-through-inheritance)) унаследованные члены путем объявления новых членов с тем же именем или сигнатурой. Обратите внимание на то, тем не менее, скрытие унаследованного члена не приводит к удалению этого элемента — просто становятся этот член недоступен напрямую с помощью производного класса.
*  Экземпляр класса содержит набор всех полей экземпляра, объявленных в классе и его базовых классов и неявное преобразование ([неявные преобразования ссылочных типов](conversions.md#implicit-reference-conversions)) существует тип производного класса на любой из типов соответствующего базового класса. Таким образом ссылку на экземпляр некоторого производного класса может рассматриваться как ссылку на экземпляр любого из его базовых классов.
*  Класс может объявить виртуальные методы, свойства и индексаторы и производные классы могли переопределять реализацию этих функций-членов. Это позволяет классам реализовывать полиморфное поведение, при котором действиям, выполняемым с вызова функции-члена, зависит от типа времени выполнения экземпляра, через который вызывается функция-член.

Наследуемый член типа сконструированного класса являются членами типа непосредственный базовый класс ([базовые классы](classes.md#base-classes)), который обеспечивается путем замены аргументов типа сконструированного типа для каждого вхождения соответствующего типа параметры в *class_base* спецификации. Эти элементы, в свою очередь, преобразование выполняется путем замены для каждого *параметр_типа* в объявлении члена, соответствующего *type_argument* из *class_base* Спецификация.

```csharp
class B<U>
{
    public U F(long index) {...}
}

class D<T>: B<T[]>
{
    public T G(string s) {...}
}
```

В приведенном выше примере, сконструированного типа `D<int>` имеет член Ненаследуемые `public int G(string s)` получен путем замены аргумент типа `int` для параметра типа `T`. `D<int>` также имеет наследуемый член из объявления класса `B`. Этот унаследованный член определяется путем определения типа базового класса `B<int[]>` из `D<int>` , подставляя `int` для `T` в спецификации базового класса `B<T[]>`. А затем в качестве аргумента типа для `B`, `int[]` заменяется `U` в `public U F(long index)`, давая наследуемый член `public int[] F(long index)`.

### <a name="the-new-modifier"></a>Модификатор new

Объект *class_member_declaration* может объявить элемент с тем же именем или сигнатурой, наследуемого члена. Если в этом случае члена производного класса называется ***скрыть*** член базового класса. Скрытие унаследованного члена не считается ошибкой, но он приводит к компилятор выдаст предупреждение. Чтобы подавить предупреждение, можно включить объявление члена производного класса `new` модификатор, чтобы указать, что производный член должен скрыть базовый член. Эта тема будет рассматриваться далее в [скрытие через наследование](basic-concepts.md#hiding-through-inheritance).

Если `new` модификатор включен в объявление, которое не скрывает унаследованный член, соответствующее предупреждение. Это предупреждение можно отключить путем удаления `new` модификатор.

### <a name="access-modifiers"></a>Модификаторы доступа

Объект *class_member_declaration* может иметь одно из пяти возможных типов объявленный уровень доступности ([объявленную доступность](basic-concepts.md#declared-accessibility)): `public`, `protected internal`, `protected`, `internal` , или `private`. За исключением `protected internal` сочетания, это ошибка времени компиляции, чтобы указать несколько модификаторов доступа. Когда *class_member_declaration* не поддерживает модификаторы доступа `private` предполагается, что.

### <a name="constituent-types"></a>Составные типы

Типы, используемые в объявлении члена, называются составные типы этого члена. Возможные типы составных: тип константы, поля, свойства, события или индексатора, тип возвращаемого значения метода или оператора и типы параметров метода, индексатора, оператор или конструктор экземпляра. Составные типы член должен быть по крайней мере такой же уровень доступности, чем сам член ([ограничения доступности](basic-concepts.md#accessibility-constraints)).

### <a name="static-and-instance-members"></a>Экземпляра и статические члены

Члены класса являются либо ***статические члены*** или ***члены экземпляра***. Вообще говоря это можно представить статические члены принадлежат к типам классов и члены экземпляра принадлежат к объектам (экземпляры типов классов).

Если объявление поля, метода, свойства, события, оператора или конструктора содержит `static` модификатор, он объявляет статический член. Кроме того объявление константы или типа неявно объявляет статический член. Статические члены имеют следующие характеристики:

*  Когда статический член `M` указывается в *member_access* ([доступ к членам](expressions.md#member-access)) формы `E.M`, `E` необходимо обозначить тип, содержащий `M`. Произошла ошибка во время компиляции для `E` для обозначения экземпляра.
*  Статическое поле определяет строго одно место хранения для совместного использования все вхождения заданного закрытого типа класса. Независимо от того, сколько экземпляров заданного закрытого типа класса создаются имеется только одна копия статического поля.
*  Статические функции-члена (метода, свойства, события, оператор или конструктор) не работает в определенном экземпляре, и это ошибка времени компиляции для ссылки на `this` в такой функции-члена.

Если объявление поля, метода, свойства, события, индексатора, конструктор или деструктор не содержит `static` модификатор, объявляет член экземпляра. (Член экземпляра иногда называется нестатический член). Члены экземпляра имеют следующие характеристики:

*  Если член экземпляра `M` указывается в *member_access* ([доступ к членам](expressions.md#member-access)) формы `E.M`, `E` должно означать экземпляр типа, содержащее `M`. Произошла ошибка во время привязки для `E` для обозначения типа.
*  Каждый экземпляр класса содержит отдельный набор всех полей экземпляра класса.
*  Функцией-членом экземпляра (метод, свойство, индексатор, конструктор экземпляра или деструктор) работает на данном экземпляре класса, и этот экземпляр может быть доступен как `this` ([такой доступ](expressions.md#this-access)).

Правила доступа к статическим и члены экземпляра в следующем примере:
```csharp
class Test
{
    int x;
    static int y;

    void F() {
        x = 1;            // Ok, same as this.x = 1
        y = 1;            // Ok, same as Test.y = 1
    }

    static void G() {
        x = 1;            // Error, cannot access this.x
        y = 1;            // Ok, same as Test.y = 1
    }

    static void Main() {
        Test t = new Test();
        t.x = 1;          // Ok
        t.y = 1;          // Error, cannot access static member through instance
        Test.x = 1;       // Error, cannot access instance member through type
        Test.y = 1;       // Ok
    }
}
```

`F` Метод показывает, что в функции-члене экземпляра, *simple_name* ([простые имена](expressions.md#simple-names)) может использоваться для доступа к членам экземпляра и статические члены. `G` Метод видно, что в статической функцией-членом, ошибка времени компиляции для доступа к члену экземпляра через *simple_name*. `Main` Метод показывает, что в *member_access* ([доступ к членам](expressions.md#member-access)), члены экземпляра должен осуществляться через экземпляров и статические члены должны осуществляться через типы.

### <a name="nested-types"></a>Вложенные типы

Вызов метода типа, объявленные в объявлении класса или структуры ***вложенный тип***. Тип, объявленный в блоке компиляции или пространстве имен, называется ***невложенными тип***.

В примере
```csharp
using System;

class A
{
    class B
    {
        static void F() {
            Console.WriteLine("A.B.F");
        }
    }
}
```
Класс `B` является вложенным типом, поскольку он объявлен внутри класса `A`и класс `A` является типом, невложенными, поскольку он объявлен в единице компиляции.

#### <a name="fully-qualified-name"></a>Полное имя

Полное доменное имя ([полные имена](basic-concepts.md#fully-qualified-names)) является вложенным типом `S.N` где `S` полное имя типа в тип `N` объявлен.

#### <a name="declared-accessibility"></a>Объявленная доступность

Не вложенные типы могут иметь `public` или `internal` объявленную доступность и иметь `internal` объявленную доступность по умолчанию. Вложенные типы могут иметь эти формы объявленный уровень доступности, плюс один или несколько видов объявленный уровень доступности, в зависимости от того, является ли вмещающий тип класса или структуры:

*  Вложенный тип, который объявлен в классе могут содержать любой из пяти форм объявленный уровень доступности (`public`, `protected internal`, `protected`, `internal`, или `private`) и, как и другие члены класса, по умолчанию `private` объявлен специальные возможности.
*  Вложенный тип, который объявлен в структуре могут содержать любой из трех видов объявленный уровень доступности (`public`, `internal`, или `private`) и, как и другие члены структуры, по умолчанию `private` объявленную доступность.

Пример
```csharp
public class List
{
    // Private data structure
    private class Node
    { 
        public object Data;
        public Node Next;

        public Node(object data, Node next) {
            this.Data = data;
            this.Next = next;
        }
    }

    private Node first = null;
    private Node last = null;

    // Public interface
    public void AddToFront(object o) {...}
    public void AddToBack(object o) {...}
    public object RemoveFromFront() {...}
    public object RemoveFromBack() {...}
    public int Count { get {...} }
}
```
Объявляет закрытым вложенным классом `Node`.

#### <a name="hiding"></a>Скрытие

Вложенный тип может быть скрыта ([Сокрытие имен](basic-concepts.md#name-hiding)) базовый член. `new` Модификатор может применяться в объявлениях вложенных типов, таким образом, чтобы скрытие можно выразить явно. Пример
```csharp
using System;

class Base
{
    public static void M() {
        Console.WriteLine("Base.M");
    }
}

class Derived: Base 
{
    new public class M 
    {
        public static void F() {
            Console.WriteLine("Derived.M.F");
        }
    }
}

class Test 
{
    static void Main() {
        Derived.M.F();
    }
}
```
Показывает вложенный класс `M` , скрывает метод `M` определенные в `Base`.

#### <a name="this-access"></a>Такой доступ

Вложенный тип и его содержащий тип имеют особая связь относится к *this_access* ([такой доступ](expressions.md#this-access)). В частности `this` изнутри вложенного типа не может использоваться для обращения к членам экземпляра содержащего типа. В случаях, где вложенный тип требуется доступ к членам экземпляра его содержащего типа, будет предоставлен доступ, предоставляя `this` для экземпляра типа, содержащего аргумента конструктора для вложенного типа. Следующий пример
```csharp
using System;

class C
{
    int i = 123;

    public void F() {
        Nested n = new Nested(this);
        n.G();
    }

    public class Nested
    {
        C this_c;

        public Nested(C c) {
            this_c = c;
        }

        public void G() {
            Console.WriteLine(this_c.i);
        }
    }
}

class Test
{
    static void Main() {
        C c = new C();
        c.F();
    }
}
```
показан этот способ. Экземпляр `C` создает экземпляр класса `Nested` и передает свой собственный `this` для `Nested`в конструктор, чтобы предоставить последующий доступ к `C`его члены экземпляров.

#### <a name="access-to-private-and-protected-members-of-the-containing-type"></a>Доступ к закрытым и защищенным членам содержащего типа

Вложенный тип имеет доступ ко всем членов, которые доступны вмещающему типу, включая элементы содержащего его типа, имеющие `private` и `protected` объявленную доступность. Пример
```csharp
using System;

class C 
{
    private static void F() {
        Console.WriteLine("C.F");
    }

    public class Nested 
    {
        public static void G() {
            F();
        }
    }
}

class Test 
{
    static void Main() {
        C.Nested.G();
    }
}
```
показан класс `C` , содержащий вложенный класс `Nested`. В рамках `Nested`, метод `G` вызывает статический метод `F` определенные в `C`, и `F` private объявило специальных возможностей.

Вложенный тип также может получить доступ к защищенные члены, определенные в базовом типе его содержащего типа. В примере
```csharp
using System;

class Base 
{
    protected void F() {
        Console.WriteLine("Base.F");
    }
}

class Derived: Base 
{
    public class Nested 
    {
        public void G() {
            Derived d = new Derived();
            d.F();        // ok
        }
    }
}

class Test 
{
    static void Main() {
        Derived.Nested n = new Derived.Nested();
        n.G();
    }
}
```
вложенный класс `Derived.Nested` обращается к защищенный метод `F` определенные в `Derived`его базового класса, `Base`, по через экземпляр `Derived`.

#### <a name="nested-types-in-generic-classes"></a>Вложенные типы в универсальных классах

Объявление универсального класса может содержать объявления вложенных типов. Параметры типа включающего класса можно использовать внутри вложенных типов. Объявление вложенного типа может содержать дополнительные параметры типа, которые применяются только к вложенного типа.

Каждое объявление типа, содержащихся в универсальном объявлении класса неявно является объявлением универсального типа. При записи ссылки на тип вложенным в универсальный тип, сформированный тип, включая его аргументы типа должны быть именованными. Тем не менее с внутри внешнего класса, вложенный тип может использоваться без уточнения; Тип экземпляра внешнего класса неявно используется при создании вложенного типа. В следующем примере показано три разных правильных способа для ссылки на сконструированный тип, созданный из `Inner`; первые два эквивалентны:
```csharp
class Outer<T>
{
    class Inner<U>
    {
        public static void F(T t, U u) {...}
    }

    static void F(T t) {
        Outer<T>.Inner<string>.F(t, "abc");      // These two statements have
        Inner<string>.F(t, "abc");               // the same effect

        Outer<int>.Inner<string>.F(3, "abc");    // This type is different

        Outer.Inner<string>.F(t, "abc");         // Error, Outer needs type arg
    }
}
```

Несмотря на то, что это плохо стиль программирования, параметр типа во вложенном типе можно скрыть член или параметр типа, объявленный во внешнем типе:
```csharp
class Outer<T>
{
    class Inner<T>        // Valid, hides Outer's T
    {
        public T t;       // Refers to Inner's T
    }
}
```

### <a name="reserved-member-names"></a>Зарезервированные имена членов

Для упрощения базовой реализации C# во время выполнения, для каждого объявления члена источника, это свойство, событие или индексатора, реализации необходимо зарезервировать два сигнатуры методов в зависимости от типа в объявлении члена, его имя и его тип. Произошла ошибка во время компиляции, для программы для объявления член, сигнатура которого совпадает с одним из этих зарезервированных сигнатур, даже если не вносит в базовой реализации среды выполнения использует эти резервирования.

Зарезервированные имена не вводят объявления, поэтому они не участвуют в поиске элемента. Тем не менее, связанные с объявлением зарезервированного метод подписи участвуют в наследовании ([наследования](classes.md#inheritance)) и могут быть скрыты с помощью `new` модификатор ([Модификатор new](classes.md#the-new-modifier)).

Резервирование этих имен служит трем целям:

*  Чтобы разрешить базовой реализации использовать обычный идентификатор в качестве имени метода для получения или установки доступа к средствам языка C#.
*  Чтобы разрешить другие языки, для взаимодействия, используя обычный идентификатор в качестве имени метода для получения или задания доступа к средствам языка C#.
*  Чтобы убедиться, что источник принятые одним соответствующим компилятором принимается на другое, сделав особенности зарезервированных элемента имена согласованность во всех реализациях C#.

Объявление деструктора ([деструкторы](classes.md#destructors)) также приводит к сигнатуре резервируемые ([имена членов, зарезервированные для деструкторов](classes.md#member-names-reserved-for-destructors)).

#### <a name="member-names-reserved-for-properties"></a>Имена членов, зарезервированные для свойств

Для свойства `P` ([свойства](classes.md#properties)) типа `T`, зарезервированы следующие сигнатуры:

```csharp
T get_P();
void set_P(T value);
```

Зарезервированы обе сигнатуры, даже если свойство доступно только для чтения или только для записи.

В примере
```csharp
using System;

class A
{
    public int P {
        get { return 123; }
    }
}

class B: A
{
    new public int get_P() {
        return 456;
    }

    new public void set_P(int value) {
    }
}

class Test
{
    static void Main() {
        B b = new B();
        A a = b;
        Console.WriteLine(a.P);
        Console.WriteLine(b.P);
        Console.WriteLine(b.get_P());
    }
}
```
Класс `A` определяет свойство только для чтения `P`, резервируя тем самым подписи для `get_P` и `set_P` методы. Класс `B` является производным от `A` и скрывает обе эти зарезервированные сигнатуры. В примере получался результат:
```
123
123
456
```

#### <a name="member-names-reserved-for-events"></a>Имена членов, зарезервированные для событий

Для события `E` ([события](classes.md#events)) типа делегата `T`, зарезервированы следующие сигнатуры:
```csharp
void add_E(T handler);
void remove_E(T handler);
```

#### <a name="member-names-reserved-for-indexers"></a>Имена членов, зарезервированные для индексаторов

Для индексатора ([индексаторы](classes.md#indexers)) типа `T` со списком параметров `L`, зарезервированы следующие сигнатуры:
```csharp
T get_Item(L);
void set_Item(L, T value);
```

Зарезервированы обе сигнатуры, даже если индексатор доступен только для чтения или только для записи.

Кроме того имя члена `Item` зарезервирован.

#### <a name="member-names-reserved-for-destructors"></a>Имена членов, зарезервированные для деструкторов

Для класса с деструктором ([деструкторы](classes.md#destructors)), зарезервирован следующую сигнатуру:
```csharp
void Finalize();
```

## <a name="constants"></a>Константы

Объект ***константы*** является членом класса, который представляет значение константы: значение, которое может быть вычислено во время компиляции. Объект *constant_declaration* представлены одной или нескольких констант данного типа.

```antlr
constant_declaration
    : attributes? constant_modifier* 'const' type constant_declarators ';'
    ;

constant_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    ;

constant_declarators
    : constant_declarator (',' constant_declarator)*
    ;

constant_declarator
    : identifier '=' constant_expression
    ;
```

Объект *constant_declaration* может включать набор *атрибуты* ([атрибуты](attributes.md)), `new` модификатор ([Модификатор new](classes.md#the-new-modifier)), и является допустимой комбинацией четырех модификаторов доступа ([модификаторы доступа](classes.md#access-modifiers)). Атрибуты и модификаторы применяются ко всем членам, объявленным с *constant_declaration*. Несмотря на то, что константы, считаются статические члены *constant_declaration* не требуется ни позволяет `static` модификатор. Является ошибкой один и тот же модификатор встречается несколько раз в объявлении константы.

*Тип* из *constant_declaration* указывает тип членов, представленных в объявлении. Тип сопровождается список *constant_declarator*s, каждый из которых вводит новый член. Объект *constant_declarator* состоит из *идентификатор* , которая содержит название члена, за которым следует "`=`" токена, за которым следует *constant_expression* ([ Константные выражения](expressions.md#constant-expressions)), задающее значение члена.

*Тип* указан в константе объявление должно быть `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal`, `bool`, `string`, *enum_type*, или *reference_type*. Каждый *constant_expression* должно выдавать значение целевого типа или типа, который может быть преобразован в целевой тип путем неявного преобразования ([неявные преобразования](conversions.md#implicit-conversions)).

*Тип* константы должен быть по крайней мере такой же уровень доступности, как и сама константа ([ограничения доступности](basic-concepts.md#accessibility-constraints)).

Значение константы получается в выражение, использующее *simple_name* ([простые имена](expressions.md#simple-names)) или *member_access* ([доступ к членам](expressions.md#member-access)).

Константа сама может участвовать в *constant_expression*. Таким образом, можно использовать в любой конструкции, которая требует константа *constant_expression*. Примеры таких конструкций `case` метки, `goto case` инструкций, `enum` объявления элементов, атрибутов и другие объявления констант.

Как описано в разделе [константные выражения](expressions.md#constant-expressions), *constant_expression* выражение, которое можно полностью вычислить во время компиляции. Так как единственный способ создать отличное от null значение *reference_type* отличное от `string` заключается в применении `new` оператор и с момента `new` оператор является недопустимым в *constant_ выражение*, единственным возможным значением для констант *reference_type*s, отличных от `string` является `null`.

При необходимости символическое имя для значения константы, но когда тип этого значения не допускается в объявлении константы или если значение не может вычислить во время компиляции, *constant_expression*, `readonly` поле () [Поля только для чтения](classes.md#readonly-fields)) вместо него можно использовать.

Использовать в объявлении константы, объявляющее несколько констант соответствует несколько объявлений одиночных констант с атрибутами, модификаторы и тип. Пример
```csharp
class A
{
    public const double X = 1.0, Y = 2.0, Z = 3.0;
}
```
эквивалентно
```csharp
class A
{
    public const double X = 1.0;
    public const double Y = 2.0;
    public const double Z = 3.0;
}
```

Константы могут зависеть другие константы в той же программе, до тех пор, пока зависимости не являются циклическими. Компилятор автоматически располагает вычисления объявления констант в соответствующем порядке. В примере
```csharp
class A
{
    public const int X = B.Z + 1;
    public const int Y = 10;
}

class B
{
    public const int Z = A.Y + 1;
}
```
Во-первых, компилятор вычисляет `A.Y`, затем вычисляет `B.Z`и наконец оценивает `A.X`, создавая значения `10`, `11`, и `12`. Объявления констант может зависеть от константы из других программ, но такие зависимости возможны только в одном направлении. Задав в примере выше, в том случае, если `A` и `B` были объявлены в отдельных программ, можно было бы для `A.X` зависят от `B.Z`, но `B.Z` затем может одновременно не зависящие от `A.Y`.

## <a name="fields"></a>Поля

Объект ***поле*** — это член, представляющий переменную, связанную с объектом или классом. Объект *field_declaration* представляет одно или несколько полей заданного типа.

```antlr
field_declaration
    : attributes? field_modifier* type variable_declarators ';'
    ;

field_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'static'
    | 'readonly'
    | 'volatile'
    | field_modifier_unsafe
    ;

variable_declarators
    : variable_declarator (',' variable_declarator)*
    ;

variable_declarator
    : identifier ('=' variable_initializer)?
    ;

variable_initializer
    : expression
    | array_initializer
    ;
```

Объект *field_declaration* может включать набор *атрибуты* ([атрибуты](attributes.md)), `new` модификатор ([Модификатор new](classes.md#the-new-modifier)), допустимое сочетание из четырех модификаторов доступа ([модификаторы доступа](classes.md#access-modifiers)) и `static` модификатор ([экземпляра и статические поля](classes.md#static-and-instance-fields)). Кроме того *field_declaration* может включать `readonly` модификатор ([поля только для чтения](classes.md#readonly-fields)) или `volatile` модификатор ([изменяемые поля](classes.md#volatile-fields)), но не оба. Атрибуты и модификаторы применяются ко всем членам, объявленным с *field_declaration*. Является ошибкой один и тот же модификатор встречается несколько раз в объявлении поля.

*Тип* из *field_declaration* указывает тип членов, представленных в объявлении. Тип сопровождается список *variable_declarator*s, каждый из которых вводит новый член. Объект *variable_declarator* состоит из *идентификатор* , которая содержит название члена, за которыми необязательно следует "`=`" токена и *variable_initializer* ([ Инициализаторы переменных](classes.md#variable-initializers)), задающий начальное значение этого члена.

*Тип* поля должно быть по крайней мере такой же уровень доступности, как и само поле ([ограничения доступности](basic-concepts.md#accessibility-constraints)).

Получено значение поля в выражение, использующее *simple_name* ([простые имена](expressions.md#simple-names)) или *member_access* ([доступ к членам](expressions.md#member-access)). Значение поля не только для чтения, изменяется с помощью *назначения* ([операторы присваивания](expressions.md#assignment-operators)). Значение поля не только для чтения могут быть получены и изменены с помощью постфиксных инкремента и декремента ([постфиксных инкремента и декремента](expressions.md#postfix-increment-and-decrement-operators)) и префиксный инкремент и декремента ([префикс Операторы инкремента и декремента](expressions.md#prefix-increment-and-decrement-operators)).

Объявление поля, который объявляет несколько полей соответствует несколько объявлений из одного поля с атрибутами, модификаторы и тип. Пример
```csharp
class A
{
    public static int X = 1, Y, Z = 100;
}
```
эквивалентно
```csharp
class A
{
    public static int X = 1;
    public static int Y;
    public static int Z = 100;
}
```

### <a name="static-and-instance-fields"></a>Экземпляра и статические поля

Если объявление поля содержит `static` модификатор, поля, представленные этим определением являются ***статические поля***. Если аргумент `static` модификатора, представленные этим определением поля являются ***полей экземпляра***. Статические поля и поля экземпляра — это два из нескольких видов переменных ([переменных](variables.md)) поддерживается в C#, и в некоторых случаях они называются ***статические переменные*** и ***переменные экземпляра*** , соответственно.

Статическое поле не является частью определенного экземпляра; Вместо этого он совместно используют все экземпляры закрытого типа ([открытые и закрытые типы](types.md#open-and-closed-types)). Независимо от того, сколько экземпляров закрытого типа класса создаются имеется только одна копия статического поля для домена связанные приложения.

Пример:
```csharp
class C<V>
{
    static int count = 0;

    public C() {
        count++;
    }

    public static int Count {
        get { return count; }
    }
}

class Application
{
    static void Main() {
        C<int> x1 = new C<int>();
        Console.WriteLine(C<int>.Count);        // Prints 1

        C<double> x2 = new C<double>();
        Console.WriteLine(C<int>.Count);        // Prints 1

        C<int> x3 = new C<int>();
        Console.WriteLine(C<int>.Count);        // Prints 2
    }
}
```

Поле экземпляра принадлежит экземпляру. В частности каждый экземпляр класса содержит отдельный набор всех полей экземпляра этого класса.

Если ссылка на поле в *member_access* ([доступ к членам](expressions.md#member-access)) формы `E.M`, если `M` является статическим полем, `E` необходимо обозначить тип, содержащий `M` Если `M` является полем экземпляра E должно означать экземпляр типа, содержащего `M`.

Различия между статическими и члены экземпляра рассматриваются далее в [экземпляра и статические члены](classes.md#static-and-instance-members).

### <a name="readonly-fields"></a>Поля только для чтения

Когда *field_declaration* включает в себя `readonly` модификатор, поля, представленные этим определением являются ***поля только для чтения***. Прямые назначения только для чтения полям может происходить только как часть этого объявления или в конструкторе экземпляра или статический конструктор, в том же классе. (Только для чтения поля могут быть назначены несколько раз в следующих контекстах.) В частности, прямые назначения для `readonly` поля разрешены только в следующих контекстах:

*  В *variable_declarator* , в которой вводятся поле (путем включения *variable_initializer* в объявлении).
*  Для поля экземпляра — в конструкторах экземпляров класса, содержащего объявление поля; для статического поля, в статическом конструкторе класса, содержащего объявление поля. Это единственно возможные контексты, в которых допускается передача `readonly` как `out` или `ref` параметра.

Пытается присвоить `readonly` поле или передать в качестве `out` или `ref` в любом другом контексте является ошибка времени компиляции.

#### <a name="using-static-readonly-fields-for-constants"></a>С помощью статических только для чтения поля для констант

Объект `static readonly` поле используется, когда требуется символическое имя для значения константы, но когда тип значения не допускается в `const` объявление, или если значение не может вычислить во время компиляции. В примере
```csharp
public class Color
{
    public static readonly Color Black = new Color(0, 0, 0);
    public static readonly Color White = new Color(255, 255, 255);
    public static readonly Color Red = new Color(255, 0, 0);
    public static readonly Color Green = new Color(0, 255, 0);
    public static readonly Color Blue = new Color(0, 0, 255);

    private byte red, green, blue;

    public Color(byte r, byte g, byte b) {
        red = r;
        green = g;
        blue = b;
    }
}
```
`Black`, `White`, `Red`, `Green`, и `Blue` члены не могут объявляться как `const` членов так, как их значения не может быть вычислено во время компиляции. Тем не менее, их объявления `static readonly` вместо имеет точно такой же эффект.

#### <a name="versioning-of-constants-and-static-readonly-fields"></a>Управление версиями, константы и статические только для чтения полей

Константы и поля только для чтения имеют разные двоичных управление версиями семантику. Если выражение ссылается на константу, значение константы получается во время компиляции, но если выражение ссылается на поле только для чтения, значение поля не получается до времени выполнения. Рассмотрим приложение, которое состоит из двух отдельных программ:
```csharp
using System;

namespace Program1
{
    public class Utils
    {
        public static readonly int X = 1;
    }
}

namespace Program2
{
    class Test
    {
        static void Main() {
            Console.WriteLine(Program1.Utils.X);
        }
    }
}
```

`Program1` И `Program2` пространства имен указывают две программы, которые компилируются отдельно. Так как `Program1.Utils.X` объявлен как статический только для чтения поле, выходное значение `Console.WriteLine` инструкции не известна во время компиляции, но получается во время выполнения. Таким образом Если значение `X` изменяется и `Program1` перекомпилируется, `Console.WriteLine` выведет новый значение, даже если `Program2` не компилируется повторно. Однако `X` является константой, значение `X` получается во время `Program2` был скомпилирован, а не изменится, изменяется в `Program1` пока `Program2` перекомпилируется.

### <a name="volatile-fields"></a>Изменяемые поля

Когда *field_declaration* включает в себя `volatile` модификатор, поля, представленное в этом объявлении являются ***изменяемые поля***.

Для долговременного поля, методы оптимизации, которые способен упорядочить инструкции может привести к непредвиденным и непредсказуемые результаты в многопоточных программах с доступом к полям без синхронизации, например за счет *lock_statement*  ([Инструкция lock](statements.md#the-lock-statement)). Эти оптимизации могут выполняться компилятором, система времени выполнения или оборудования. Для полей volatile такие изменения порядка оптимизации ограничены.

*  Успешное чтение поле с модификатором volatile называется ***чтения из временного***. Volatile чтения имеет «получить семантику»; то есть он гарантированно случаются до ссылок на память, происходящие после него в последовательности инструкций.
*  Операция записи поле с модификатором volatile называется ***записи***. Volatile записи имеет «release семантики»; то есть он гарантированно происходят после любой ссылки на память до инструкции по записи в последовательности инструкций.

Эти ограничения гарантируют, что все потоки будут видеть временные записи, выполняемые другим потоком, в порядке выполнения. Соответствующая реализация не требуется для предоставления единого общего упорядочения записей volatile материал из всех потоков выполнения. Поле с модификатором volatile тип должен быть одним из следующих:

*  Объект *reference_type*.
*  Тип `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `char`, `float`, `bool`, `System.IntPtr`, или` System.UIntPtr`.
*  *Enum_type* необходимости базовый тип перечисления из `byte`, `sbyte`, `short`, `ushort`, `int`, или `uint`.

Пример
```csharp
using System;
using System.Threading;

class Test
{
    public static int result;   
    public static volatile bool finished;

    static void Thread2() {
        result = 143;    
        finished = true; 
    }

    static void Main() {
        finished = false;

        // Run Thread2() in a new thread
        new Thread(new ThreadStart(Thread2)).Start();

        // Wait for Thread2 to signal that it has a result by setting
        // finished to true.
        for (;;) {
            if (finished) {
                Console.WriteLine("result = {0}", result);
                return;
            }
        }
    }
}
```
выводятся следующие выходные данные:
```
result = 143
```

В этом примере метод `Main` запускает новый поток, который выполняет метод `Thread2`. Этот метод сохраняет значение в поле с именем долговременного `result`, затем сохраняет `true` в поле с модификатором volatile `finished`. Основной поток ожидает поле `finished` будет присвоено `true`, затем считывает поле `result`. Так как `finished` был объявлен `volatile`, основной поток должен считать значение `143` из поля `result`. Если поле `finished` не было объявлено как `volatile`, то он будет то сохранение для `result` должен отображаться в основной поток после хранилище для `finished`и, следовательно для основного потока чтения значения `0` из поле `result`. Объявление `finished` как `volatile` поле предотвращает такие несоответствия.

### <a name="field-initialization"></a>Инициализация поля

Начальное значение поля, будь то статического поля или поля экземпляра, значение по умолчанию ([значения по умолчанию](variables.md#default-values)) в качестве типа. Определите значение атрибута поля, прежде чем этот инициализации по умолчанию и поля не таким образом никогда не «инициализирован» невозможна. Пример
```csharp
using System;

class Test
{
    static bool b;
    int i;

    static void Main() {
        Test t = new Test();
        Console.WriteLine("b = {0}, i = {1}", b, t.i);
    }
}
```
выводятся следующие выходные данные
```
b = False, i = 0
```
так как `b` и `i` автоматически инициализированы значениями по умолчанию.

### <a name="variable-initializers"></a>Инициализаторы переменных

Объявления полей могут включать *variable_initializer*s. Для статических полей инициализаторы переменных соответствуют операторы присваивания, которые выполняются во время инициализации класса. Для экземпляра поля, инициализаторы переменных соответствуют операторы присваивания, которые выполняются при создании экземпляра класса.

Пример
```csharp
using System;

class Test
{
    static double x = Math.Sqrt(2.0);
    int i = 100;
    string s = "Hello";

    static void Main() {
        Test a = new Test();
        Console.WriteLine("x = {0}, i = {1}, s = {2}", x, a.i, a.s);
    }
}
```
выводятся следующие выходные данные
```
x = 1.4142135623731, i = 100, s = Hello
```
так как назначение для `x` возникает при выполнении инициализаторов статического поля и назначений, `i` и `s` происходят при выполнении инициализаторы полей экземпляров.

Инициализация значения по умолчанию, описанные в [инициализацию поля](classes.md#field-initialization) происходит для всех полей, включая поля, имеющие инициализаторы переменных. Таким образом при инициализации класса, все статические поля в этом классе сначала инициализируются значениями по умолчанию, и затем выполняются инициализаторы статических полей в алфавитном порядке. Аналогичным образом когда создается экземпляр класса, все поля экземпляра в этом экземпляре сначала инициализируются значениями по умолчанию и затем инициализаторы полей экземпляров, выполняются в алфавитном порядке.

Это статические поля с инициализаторами переменных в их состоянии значения по умолчанию. Тем не менее это настоятельно не рекомендуется, вопрос стиля. Пример
```csharp
using System;

class Test
{
    static int a = b + 1;
    static int b = a + 1;

    static void Main() {
        Console.WriteLine("a = {0}, b = {1}", a, b);
    }
}
```
демонстрирует это расширение функциональности. Несмотря на циклические определения и b, программа является допустимым. Это приводит в выходных данных
```
a = 1, b = 2
```
так как статические поля `a` и `b` инициализируются `0` (значение по умолчанию для `int`) перед их инициализаторов. При инициализатор для `a` выполняется, значение `b` равен нулю и поэтому `a` инициализируется `1`. Когда инициализатор для `b` выполняется, значение `a` уже `1`и поэтому `b` инициализируется `2`.

#### <a name="static-field-initialization"></a>Инициализация статических полей

Инициализаторы переменных статических полей класса соответствуют последовательности назначений, которые выполняются в порядке, в котором они появляются в объявлении класса. Если статический конструктор ([статические конструкторы](classes.md#static-constructors)) существует в классе, выполнение Инициализаторы статических полей, происходит непосредственно перед выполнением этого статического конструктора. В противном случае статическое поле инициализаторов в время зависит от реализации перед первым использованием статического поля этого класса. Пример
```csharp
using System;

class Test 
{ 
    static void Main() {
        Console.WriteLine("{0} {1}", B.Y, A.X);
    }

    public static int F(string s) {
        Console.WriteLine(s);
        return 1;
    }
}

class A
{
    public static int X = Test.F("Init A");
}

class B
{
    public static int Y = Test.F("Init B");
}
```
может выдавать либо выходные данные:
```
Init A
Init B
1 1
```
или выходные данные:
```
Init B
Init A
1 1
```
так как выполнение `X`элемента инициализатора и `Y`в инициализатор может возникнуть в любом порядке; они ограничены только по до первого обращения к этим полям. Тем не менее в примере:
```csharp
using System;

class Test
{
    static void Main() {
        Console.WriteLine("{0} {1}", B.Y, A.X);
    }

    public static int F(string s) {
        Console.WriteLine(s);
        return 1;
    }
}

class A
{
    static A() {}

    public static int X = Test.F("Init A");
}

class B
{
    static B() {}

    public static int Y = Test.F("Init B");
}
```
результат должен быть:
```
Init B
Init A
1 1
```
так как правил для выполнения статических конструкторов (как определено в [статические конструкторы](classes.md#static-constructors)) предоставить ее в `B`в статический конструктор (и, следовательно `B`в статическое поле инициализаторы) должна быть запущена перед `A`в статическом конструкторе и инициализаторы полей.

#### <a name="instance-field-initialization"></a>Инициализация поля экземпляра

Инициализаторы полей экземпляров переменной класса соответствуют последовательности назначений, которые выполняются сразу же после входа в любой из конструкторов экземпляров ([инициализаторы конструктора](classes.md#constructor-initializers)) этого класса. Инициализаторы переменных выполняются в порядке, в котором они появляются в объявлении класса. Процесс создания и инициализации экземпляра класса описан далее в [конструкторы экземпляров](classes.md#instance-constructors).

Инициализатор переменной для поля экземпляра не может ссылаться на экземпляра. Таким образом, это ошибка времени компиляции для ссылки на `this` в инициализаторе переменной, так как он является ошибкой во время компиляции инициализатор переменной для ссылки на любой другой член экземпляра через *simple_name*. В примере
```csharp
class A
{
    int x = 1;
    int y = x + 1;        // Error, reference to instance member of this
}
```
инициализатор переменной для `y` приводит к ошибке времени компиляции, так как он ссылается на член экземпляра.

## <a name="methods"></a>Методы

***Метод*** — это член, реализующий вычисление или действие, которое может выполнять объект или класс. Методы объявляются с помощью *method_declaration*s:

```antlr
method_declaration
    : method_header method_body
    ;

method_header
    : attributes? method_modifier* 'partial'? return_type member_name type_parameter_list?
      '(' formal_parameter_list? ')' type_parameter_constraints_clause*
    ;

method_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'static'
    | 'virtual'
    | 'sealed'
    | 'override'
    | 'abstract'
    | 'extern'
    | 'async'
    | method_modifier_unsafe
    ;

return_type
    : type
    | 'void'
    ;

member_name
    : identifier
    | interface_type '.' identifier
    ;

method_body
    : block
    | '=>' expression ';'
    | ';'
    ;
```

Объект *method_declaration* может включать набор *атрибуты* ([атрибуты](attributes.md)) и является допустимой комбинацией четырех модификаторов доступа ([модификаторы доступа ](classes.md#access-modifiers)), `new` ([Модификатор new](classes.md#the-new-modifier)), `static` ([экземпляра и статические методы](classes.md#static-and-instance-methods)), `virtual` ([виртуальных методов](classes.md#virtual-methods)), `override` ([Переопределять методы](classes.md#override-methods)), `sealed` ([запечатанные методы](classes.md#sealed-methods)), `abstract` ([абстрактные методы](classes.md#abstract-methods)), и `extern` ([Внешние методы](classes.md#external-methods)) модификаторы.

Объявление имеет допустимое сочетание модификаторов, если выполняются все следующие условия:

*  Объявление включает является допустимым сочетанием модификаторы доступа ([модификаторы доступа](classes.md#access-modifiers)).
*  Объявление содержит тот же модификатор несколько раз.
*  Объявление включает не более одного из следующих модификаторов: `static`, `virtual`, и `override`.
*  Объявление включает не более одного из следующих модификаторов: `new` и `override`.
*  Если объявление включает `abstract` модификатор, то объявление не поддерживает ни один из следующих модификаторов: `static`, `virtual`, `sealed` или `extern`.
*  Если объявление включает `private` модификатор, то объявление не поддерживает ни один из следующих модификаторов: `virtual`, `override`, или `abstract`.
*  Если объявление включает `sealed` модификатор, то объявление также включает в себя `override` модификатор.
*  Если объявление включает `partial` модификатор, то оно не поддерживает ни один из следующих модификаторов: `new`, `public`, `protected`, `internal`, `private`, `virtual`, `sealed`, `override` , `abstract`, или `extern`.

Метод, имеющий `async` модификатор является асинхронной функции и следует правилам, описанным в [асинхронные функции](classes.md#async-functions).

*Return_type* метода объявление указывает тип значения, вычисляемого и возвращаемого методом. *Return_type* является `void` Если метод не возвращает значение. Если объявление включает `partial` модификатор, то тип возвращаемого значения должен быть `void`.

*Member_name* задает имя метода. Если метод не явная реализация члена интерфейса ([явные реализации члена интерфейса](interfaces.md#explicit-interface-member-implementations)), *member_name* является просто *идентификатор*. Для явной реализации члена интерфейса *member_name* состоит из *interface_type* следуют "`.`" и *идентификатор*.

Необязательный *type_parameter_list* задает параметры типа метода ([параметры типа](classes.md#type-parameters)). Если *type_parameter_list* указан метод ***универсального метода***. Если метод имеет `extern` модификатор, *type_parameter_list* нельзя использовать.

Необязательный *formal_parameter_list* указывает параметры метода ([параметры метода](classes.md#method-parameters)).

Необязательный *type_parameter_constraints_clause*определяют ограничения параметров типа отдельных ([ограничения параметров типа](classes.md#type-parameter-constraints)) и может быть задан только если *type_parameter_ список* также предоставляется, и не содержит метод `override` модификатор.

*Return_type* и каждый из типов, на которые ссылается *formal_parameter_list* метода должен быть по крайней мере такой же уровень доступности, чем сам метод ([ограничения доступности](basic-concepts.md#accessibility-constraints)).

*Method_body* либо точкой с запятой, ***тела оператора*** или ***тело выражения***. Состоит из тела оператора *блок*, который задает операторы, выполняемые при вызове метода. Тело выражения состоит из `=>` следуют *выражение* используйте точку с запятой и обозначает одно выражение для выполнения при вызове метода. 

Для `abstract` и `extern` методы, *method_body* состоит просто из точки с запятой. Для `partial` методы *method_body* может состоять из точки с запятой, тело блока или тело выражения. Для всех других методов *method_body* тело блока или тело выражения.

Если *method_body* состоит из точки с запятой, то объявление не может включать `async` модификатор.

Имя, список параметров типа и список формальных параметров метода определить сигнатуру ([сигнатуры и перегрузка](basic-concepts.md#signatures-and-overloading)) метода. В частности сигнатура метода состоит из имени, количество параметров типа и числа, модификаторы и типы его формальных параметров. Для этих целей любого параметра типа метода, который происходит в тип формального параметра идентифицируется не по имени, а также по ее порядковому номеру в списке аргументов типа метода. Тип возвращаемого значения не является частью сигнатуры метода, как и имена параметров типа или формальных параметров.

Имя метода должно отличаться от имен всех остальных не методов, объявленных в том же классе. Кроме того, подпись метода должна отличаться от сигнатур всех других методов, объявленных в том же классе, и двух методов, объявленных в том же классе может не иметь подписи, которые отличаются только модификаторами `ref` и `out`.

Метод *параметр_типа*s находятся в области всего *method_declaration*и может использоваться для формирования типов в этой области в *return_type*, *method_body*, и *type_parameter_constraints_clause*s, но не в *атрибуты*.

Все формальные параметры и параметры типа должны иметь разные имена.

### <a name="method-parameters"></a>Параметры методов

Параметры метода, если таковые имеются, объявляются с помощью метода *formal_parameter_list*.

```antlr
formal_parameter_list
    : fixed_parameters
    | fixed_parameters ',' parameter_array
    | parameter_array
    ;

fixed_parameters
    : fixed_parameter (',' fixed_parameter)*
    ;

fixed_parameter
    : attributes? parameter_modifier? type identifier default_argument?
    ;

default_argument
    : '=' expression
    ;

parameter_modifier
    : 'ref'
    | 'out'
    | 'this'
    ;

parameter_array
    : attributes? 'params' array_type identifier
    ;
```

Список формальных параметров состоит из одного или нескольких разделенных запятыми параметров которых может быть только последний *parameter_array*.

Объект *fixed_parameter* состоит из необязательного набора *атрибуты* ([атрибуты](attributes.md)), необязательный `ref`, `out` или `this` модификатор, *тип*, *идентификатор* разделителя и необязательного *default_argument*. Каждый *fixed_parameter* объявляет параметр заданного типа с заданным именем. `this` Модификатор помечает метод как метод расширения, а допускается только для первого параметра статического метода. Методы расширения более подробно описаны в [методы расширения](classes.md#extension-methods).

Объект *fixed_parameter* с *default_argument* называется ***необязательный параметр***, тогда как *fixed_parameter* без *default_argument* — ***обязательный параметр***. Обязательный параметр может не отображаться после необязательного параметра в *formal_parameter_list*.

Объект `ref` или `out` параметр не может иметь *default_argument*. *Выражение* в *default_argument* должно быть одно из следующих:

*  *constant_expression*
*  выражение в форме `new S()` где `S` является типом значения
*  выражение в форме `default(S)` где `S` является типом значения

*Выражение* должно допускать неявное преобразование удостоверения или допускает значения NULL преобразование к типу параметра.

Появление в реализующего объявления разделяемого метода необязательные параметры ([разделяемые методы](classes.md#partial-methods)), явная реализация члена интерфейса ([явные реализации члена интерфейса](interfaces.md#explicit-interface-member-implementations)) или в объявление индексатора единственного параметра ([индексаторы](classes.md#indexers)) компилятор должен создать предупреждение, поскольку эти члены никогда не могут быть вызваны способом, в котором аргументы могут отсутствовать.

Объект *parameter_array* состоит из необязательного набора *атрибуты* ([атрибуты](attributes.md)), `params` модификатор, *array_type*, и *идентификатор*. Массив параметров объявляет один параметр типа заданного массива с заданным именем. *Array_type* параметра массив должен быть одномерным массивом ([типы массивов](arrays.md#array-types)). При вызове метода массив параметров позволяет либо один аргумент типа указывать заданного массива, или он разрешает ноль или более аргументов типа элемента массива должны быть указаны. Массивы параметров описаны далее в [массивы параметров](classes.md#parameter-arrays).

Объект *parameter_array* может возникнуть после необязательного параметра, но не может иметь значение по умолчанию — заменяют аргументы для *parameter_array* вместо бы привести к созданию пустого массива.

В следующем примере показано различных типов параметров:
```csharp
public void M(
    ref int      i,
    decimal      d,
    bool         b = false,
    bool?        n = false,
    string       s = "Hello",
    object       o = null,
    T            t = default(T),
    params int[] a
) { }
```

В *formal_parameter_list* для `M`, `i` является обязательным параметром, `d` является обязательным параметром, `b`, `s`, `o` и `t` необязательное значение параметров и `a` является массивом параметров.

Объявление метода создает отдельную область объявления для параметров, параметры типа и локальные переменные. Имена вводятся в эту область объявления, список параметров типа и список формальных параметров метода и объявлений локальных переменных в *блок* метода. Это ошибка для двух участников области объявления метода с одинаковыми именами. Это ошибка для области объявления метода и в объявлении локальной переменной пространство вложенной области объявления могут содержать элементы с тем же именем.

Вызов метода ([вызовы методов](expressions.md#method-invocations)) создает копию, предназначенную для вызова, формальные параметры и локальные переменные метода и список аргументов вызова назначает значения или ссылки на переменные вновь созданный формальных параметров. В рамках *блок* формальных параметров метода, можно ссылаться по их идентификаторам в *simple_name* выражения ([простые имена](expressions.md#simple-names)).

Существует четыре вида формальных параметров:

*  Параметры значений, которые объявлены без модификаторов.
*  Ссылаться на параметры, которые объявлены с `ref` модификатор.
*  Выходные параметры, которые объявлены с `out` модификатор.
*  Массивы параметров, которые объявлены с `params` модификатор.

Как описано в разделе [сигнатуры и перегрузка](basic-concepts.md#signatures-and-overloading), `ref` и `out` модификаторы являются частью сигнатуры метода, но `params` модификатор не.

#### <a name="value-parameters"></a>Параметры значения

Параметр, объявленный без модификаторов является параметром значения. Значение параметра соответствует локальной переменной, которая получит начальное значение из соответствующего аргумента, предоставленного при вызове метода.

Если формальный параметр является параметром значения, соответствующего аргумента в вызове метода должно быть выражение, которое может быть неявно преобразован ([неявные преобразования](conversions.md#implicit-conversions)) в тип формального параметра.

Метод разрешено присваивать новые значения для параметра значения. Такие присваивания влияют только на расположение локального хранилища, представленный параметром значения — они не оказывают влияния на фактический аргумент, заданный в вызове метода.

#### <a name="reference-parameters"></a>Параметры ссылок

Параметр, объявленный с `ref` модификатор — ссылочный параметр. В отличие от параметра значения ссылочного параметра не создает новое место хранения. Вместо этого параметр ссылки представляет то же место хранения переменной, заданной в качестве аргумента в вызове метода.

Если формальный параметр является ссылочный параметр, соответствующий аргумент в вызове метода должен состоять из ключевого слова `ref` следуют *variable_reference* ([точные правила определения определенного присваивания](variables.md#precise-rules-for-determining-definite-assignment)) того же типа как формальных параметров. Переменной должен быть явно присвоен, прежде чем их можно было передать в качестве ссылочного параметра.

Внутри метода ссылочный параметр всегда считается определенно присвоенной.

Метод, объявленный как итератор ([итераторы](classes.md#iterators)) не могут иметь ссылочные параметры.

Пример
```csharp
using System;

class Test
{
    static void Swap(ref int x, ref int y) {
        int temp = x;
        x = y;
        y = temp;
    }

    static void Main() {
        int i = 1, j = 2;
        Swap(ref i, ref j);
        Console.WriteLine("i = {0}, j = {1}", i, j);
    }
}
```
выводятся следующие выходные данные
```
i = 2, j = 1
```

Для вызова `Swap` в `Main`, `x` представляет `i` и `y` представляет `j`. Таким образом, вызов действует замену значений `i` и `j`.

В методе, который принимает ссылочные параметры, возможно несколько имен для представления в одно место хранения. В примере
```csharp
class A
{
    string s;

    void F(ref string a, ref string b) {
        s = "One";
        a = "Two";
        b = "Three";
    }

    void G() {
        F(ref s, ref s);
    }
}
```
вызов `F` в `G` передает ссылку на `s` для обоих `a` и `b`. Таким образом, для этого вызова имена `s`, `a`, и `b` ссылаются на том же месте хранения, и все три назначения изменения поля экземпляра `s`.

#### <a name="output-parameters"></a>Выходные параметры

Параметр, объявленный с `out` модификатор является выходным параметром. Как и ссылочный параметр, выходной параметр не создает новое место хранения. Вместо этого выходного параметра представляет то же место хранения переменной, заданной в качестве аргумента в вызове метода.

Если формальный параметр является выходным параметром, соответствующего аргумента в вызове метода должен состоять из ключевого слова `out` следуют *variable_reference* ([точные правила определения определенного присваивания](variables.md#precise-rules-for-determining-definite-assignment)) того же типа как формальных параметров. Переменная не нужно назначать определенно прежде, чем их можно передать в качестве выходного параметра, но вслед за вызовом, где переменная была передана в качестве выходного параметра, переменная считается определенно присвоенной.

Внутри метода, так же, как локальной переменной, параметром output изначально считается неназначенных и должен быть явно присвоен перед его значение используется.

Каждый выходной параметр метода должен быть явно присвоен перед возвращением метода.

Метод, объявленный как разделяемый метод ([разделяемые методы](classes.md#partial-methods)) или итератор ([итераторы](classes.md#iterators)) не может иметь выходных параметров.

Выходные параметры обычно используются в методах, которые создают несколькими возвращаемыми значениями. Пример:
```csharp
using System;

class Test
{
    static void SplitPath(string path, out string dir, out string name) {
        int i = path.Length;
        while (i > 0) {
            char ch = path[i - 1];
            if (ch == '\\' || ch == '/' || ch == ':') break;
            i--;
        }
        dir = path.Substring(0, i);
        name = path.Substring(i);
    }

    static void Main() {
        string dir, name;
        SplitPath("c:\\Windows\\System\\hello.txt", out dir, out name);
        Console.WriteLine(dir);
        Console.WriteLine(name);
    }
}
```

В примере получался результат:
```
c:\Windows\System\
hello.txt
```

Обратите внимание, что `dir` и `name` переменные могут быть неназначенные, прежде чем они будут переданы `SplitPath`, и что они считаются определенно присвоенной, что следующий за вызовом.

#### <a name="parameter-arrays"></a>Массивы параметров

Параметр, объявленный с `params` модификатор является массивом параметров. Если список формальных параметров включает массив параметров, он должен быть последним параметром в списке, и он должен иметь тип одномерного массива. Например, типы `string[]` и `string[][]` можно использовать в качестве типа массива параметров, но тип `string[,]` не может. Невозможно объединить `params` модификатор с модификаторами `ref` и `out`.

Массив параметров позволяет задать одним из двух способов вызова метода аргументы:

*  Аргумент, заданный для массива параметров может быть одно выражение, которое может быть неявно преобразован ([неявные преобразования](conversions.md#implicit-conversions)) в тип массива параметров. В этом случае в массиве параметров выступает точно параметра значения.
*  Кроме того, вызов можно указать ноль или более аргументов для массива параметров, где каждый аргумент является выражение, которое может быть неявно преобразован ([неявные преобразования](conversions.md#implicit-conversions)) к типу элемента в массиве параметров. В этом случае вызов создает экземпляр типа массив с длиной, соответствующей числу аргументов, инициализирует элементы экземпляра массива с заданными значениями аргументов и использует вновь созданный экземпляр массива в качестве фактического аргумент.

За исключением разрешение переменное число аргументов в вызове, массив параметров эквивалентен параметру значения ([параметры по значению](classes.md#value-parameters)) того же типа.

Пример
```csharp
using System;

class Test
{
    static void F(params int[] args) {
        Console.Write("Array contains {0} elements:", args.Length);
        foreach (int i in args) 
            Console.Write(" {0}", i);
        Console.WriteLine();
    }

    static void Main() {
        int[] arr = {1, 2, 3};
        F(arr);
        F(10, 20, 30, 40);
        F();
    }
}
```
выводятся следующие выходные данные
```
Array contains 3 elements: 1 2 3
Array contains 4 elements: 10 20 30 40
Array contains 0 elements:
```

Первый вызов `F` просто передает массив `a` как параметр значения. Второй вызов `F` автоматически создает элемент четырех `int[]` с заданными значениями элементов и передает этот экземпляр в качестве параметра значения массива. Аналогично, третий вызов `F` создает элемент нуля `int[]` и передает этот экземпляр в качестве значения параметра. Второй и третий вызовы будут точными эквивалентами записи:
```csharp
F(new int[] {10, 20, 30, 40});
F(new int[] {});
```

При разрешении перегрузки метода массив параметров могут применяться в нормальной форме или в расширенной форме ([применимого члена функции](expressions.md#applicable-function-member)). Расширенную форму метод доступен только в том случае, если обычной формой метод не применим и только в том случае, если метод применимо с ту же сигнатуру, что расширенная форма уже не объявлен в тот же тип.

Пример
```csharp
using System;

class Test
{
    static void F(params object[] a) {
        Console.WriteLine("F(object[])");
    }

    static void F() {
        Console.WriteLine("F()");
    }

    static void F(object a0, object a1) {
        Console.WriteLine("F(object,object)");
    }

    static void Main() {
        F();
        F(1);
        F(1, 2);
        F(1, 2, 3);
        F(1, 2, 3, 4);
    }
}
```
выводятся следующие выходные данные
```
F();
F(object[]);
F(object,object);
F(object[]);
F(object[]);
```

В примере две из возможных расширенных видов метода с массивом параметров уже включены в класс как обычные методы. Эти развернутой форм таким образом не учитываются при разрешении перегрузки и вызовы методов первый и третий таким образом выберите обычные методы. Когда класс объявляет метод с массивом параметров, нередко включают и некоторые расширенные формы как обычные методы. В результате можно избежать размещения массива вызывается экземпляр, который возникает при вызове расширенной формы метода массив параметров.

Если тип массива параметров — `object[]`, возникает потенциальная неоднозначность между обычной формой метода и расширенной формами для одного `object` параметра. Неоднозначность связано, `object[]` сам является неявно преобразовать в тип `object`. Неоднозначность нормально, тем не менее, так как может быть разрешена с помощью приведения, при необходимости.

Пример
```csharp
using System;

class Test
{
    static void F(params object[] args) {
        foreach (object o in args) {
            Console.Write(o.GetType().FullName);
            Console.Write(" ");
        }
        Console.WriteLine();
    }

    static void Main() {
        object[] a = {1, "Hello", 123.456};
        object o = a;
        F(a);
        F((object)a);
        F(o);
        F((object[])o);
    }
}
```
выводятся следующие выходные данные
```
System.Int32 System.String System.Double
System.Object[]
System.Object[]
System.Int32 System.String System.Double
```

В первый и последний вызовы `F`, обычной формой `F` применяется, так как существует неявное преобразование из типа аргумента в тип параметра (оба имеют тип `object[]`). Таким образом, механизм разрешения перегрузок выбирает обычной формой `F`, и аргумент, переданный как параметр регулярных значения. На второй и третий вызовы, обычной формой `F` неприменима, так как существует не неявное преобразование из типа аргумента в тип параметра (тип `object` не может быть неявно преобразован в тип `object[]`). Однако расширенную форму `F` применим, поэтому выбирается при разрешении перегрузки. В результате одного элемента `object[]` создается путем вызова, и единственный элемент массива инициализируется со значением данного аргумента (который сам является ссылкой на `object[]`).

### <a name="static-and-instance-methods"></a>Статические методы и методы экземпляра

Если объявление метода содержит `static` модификатора, что метод является статическим методом. Если аргумент `static` модификатора, считается, что метод является методом экземпляра.

Статический метод не работает в определенном экземпляре, и это ошибка времени компиляции для ссылки на `this` в статическом методе.

Метод экземпляра работает на данном экземпляре класса, и этот экземпляр может быть доступен как `this` ([такой доступ](expressions.md#this-access)).

Если ссылка на метод в *member_access* ([доступ к членам](expressions.md#member-access)) формы `E.M`, если `M` — это статический метод `E` необходимо обозначить тип, содержащий `M`и если `M` является методом экземпляра `E` должно означать экземпляр типа, содержащего `M`.

Различия между статическими и члены экземпляра рассматриваются далее в [экземпляра и статические члены](classes.md#static-and-instance-members).

### <a name="virtual-methods"></a>Виртуальные методы

Если объявление метода экземпляра включает `virtual` модификатора, что метод является виртуальным методом. Если аргумент `virtual` модификатора, считается, что метод является невиртуальный метод.

Реализация невиртуальный метод является инвариантным: это та же реализация ли метод вызван на экземпляр класса, в котором он объявлен, или экземпляр производного класса. Напротив производные классы могут быть заменены реализацию виртуального метода. Процесс замены реализации унаследованного виртуального метода называется ***переопределение*** этого метода ([переопределять методы](classes.md#override-methods)).

При вызове виртуального метода ***тип времени выполнения*** экземпляра, для которой вызов занимает место определяет фактическую реализацию метода для вызова. При вызове невиртуального метода ***типов во время компиляции*** экземпляра является определяющим фактором. Точнее говоря, когда метод с именем `N` вызывается со списком аргументов `A` в экземпляре с типом времени компиляции `C` и типом времени выполнения `R` (где `R` либо `C` или класс, производный из `C`), вызов обрабатывается следующим образом:

*  Во-первых, разрешение перегрузки применяется к `C`, `N`, и `A`, чтобы выбрать конкретный метод `M` из набора методов, объявленных и наследуются `C`. Это описывается в [вызовы методов](expressions.md#method-invocations).
*  Затем, если `M` — это невиртуальный метод `M` вызывается.
*  В противном случае `M` является виртуальным методом и наиболее производный реализация `M` по отношению к `R` вызывается.

Для каждого виртуального метода, объявленные в или наследуемого классом, существует ***самый производный реализации*** метода по отношению к этому классу. Наиболее производный реализацию виртуального метода `M` по отношению к класс `R` определяется следующим образом:

*  Если `R` содержит общие сведения о `virtual` объявление `M`, то это наиболее производный реализация `M`.
*  В противном случае, если `R` содержит `override` из `M`, то это наиболее производный реализация `M`.
*  В противном случае наиболее производный реализация `M` по отношению к `R` совпадает со значением в наиболее производного метода `M` по отношению к прямой базовый класс для `R`.

В следующем примере показано различия между виртуальные и невиртуальные методы:
```csharp
using System;

class A
{
    public void F() { Console.WriteLine("A.F"); }

    public virtual void G() { Console.WriteLine("A.G"); }
}

class B: A
{
    new public void F() { Console.WriteLine("B.F"); }

    public override void G() { Console.WriteLine("B.G"); }
}

class Test
{
    static void Main() {
        B b = new B();
        A a = b;
        a.F();
        b.F();
        a.G();
        b.G();
    }
}
```

В примере `A` представляет невиртуальный метод `F` и виртуальный метод `G`. Класс `B` появился новый невиртуальный метод `F`, таким образом скрытие наследуемых `F`, а также переопределяет унаследованный метод `G`. В примере получался результат:
```
A.F
B.F
B.G
B.G
```

Обратите внимание, что инструкция `a.G()` вызывает `B.G`, а не `A.G`. Это, так как тип времени выполнения экземпляра (который является `B`), не во время компиляции тип экземпляра (который является `A`), определяет фактическую реализацию метода для вызова.

Поскольку методы разрешено скрывать унаследованные методы, класс может содержать несколько виртуальных методов с одинаковыми сигнатурами. При этом не возникает проблема неоднозначности, так как все, кроме самый производный метод скрыты. В примере
```csharp
using System;

class A
{
    public virtual void F() { Console.WriteLine("A.F"); }
}

class B: A
{
    public override void F() { Console.WriteLine("B.F"); }
}

class C: B
{
    new public virtual void F() { Console.WriteLine("C.F"); }
}

class D: C
{
    public override void F() { Console.WriteLine("D.F"); }
}

class Test
{
    static void Main() {
        D d = new D();
        A a = d;
        B b = d;
        C c = d;
        a.F();
        b.F();
        c.F();
        d.F();
    }
}
```
`C` и `D` классы содержат два виртуальных метода с одинаковыми сигнатурами: один представлен `A` , а второй — с `C`. Метод, представленный `C` скрывает метод, унаследованный от `A`. Таким образом, объявление переопределения в `D` переопределяет метод, представленный `C`, и он не поддерживается для `D` в Переопределите метод, представленный `A`. В примере получался результат:
```
B.F
B.F
D.F
D.F
```

Обратите внимание, что можно вызвать скрытые виртуальный метод путем обращения к экземпляру `D` через менее производный тип, в котором метод не скрыт.

### <a name="override-methods"></a>Переопределение методов

Если объявление метода экземпляра включает `override` модификатор, метод считается ***переопределить метод***. Метод переопределяет унаследованный виртуальный метод с такой же сигнатурой. Изначальное объявление виртуального метода создает новый метод, а переопределение этого метода создает специализированный виртуальный метод с новой реализацией взамен унаследованного виртуального метода.

Метод переопределяется `override` объявление называется ***переопределенным базовым методом***. Для переопределения метода `M` объявлять в классе `C`, переопределенный базовый метод определяется путем проверки каждого типа базового класса `C`, начиная с типом прямой базовый класс `C` и продолжая с каждым последовательных Тип прямой базовый класс, до в типе некоторого базового класса находится по крайней мере один доступный метод является, который имеет ту же сигнатуру, что `M` после подстановки аргументов типа. В целях обнаружения переопределенным базовым методом, метод считается доступным, если это `public`, если оно уже `protected`, если оно уже `protected internal`, или если это `internal` и объявленные в той же программе, как `C`.

Если не выполняются все следующие условия для объявления переопределения, возникает ошибка времени компиляции:

*  Переопределенный базовый метод может быть размещена в том случае, как описано выше.
*  Имеется ровно один переопределенный базовый метод. Это ограничение действует только в том случае, если тип базового класса — сконструированный тип, в котором подстановки аргументов типа обеспечивает сигнатуры двух методов же.
*  Переопределенный базовый метод является виртуальным, абстрактным или переопределять метод. Другими словами переопределенный базовый метод не может быть статическим или невиртуальный.
*  Переопределенный базовый метод не является запечатанным методом.
*  Метод переопределения и переопределенным базовым методом имеют тот же тип возвращаемого значения.
*  Объявление переопределения и переопределенным базовым методом имеют же объявленный уровень доступности. Другими словами объявление переопределения не может изменить доступность виртуального метода. Тем не менее если переопределенный базовый метод protected internal, и он объявлен в другой сборке, не объявленные сборки, содержащей метод переопределения, а затем метод переопределения должны быть защищены специальных возможностей.
*  Объявление переопределения не задает тип параметра — ограничения предложения. Вместо этого ограничения наследуются от переопределенным базовым методом. Обратите внимание на то, что ограничения, которые являются параметрами типа в переопределенном методе может быть заменен аргументы типа в унаследованном ограничении. Это может привести к ограничениям, которые не являются законными при явном задании, например типы значений или запечатанные типы.

В следующем примере показано, как работают правил переопределения для универсальных классов:
```csharp
abstract class C<T>
{
    public virtual T F() {...}
    public virtual C<T> G() {...}
    public virtual void H(C<T> x) {...}
}

class D: C<string>
{
    public override string F() {...}            // Ok
    public override C<string> G() {...}         // Ok
    public override void H(C<T> x) {...}        // Error, should be C<string>
}

class E<T,U>: C<U>
{
    public override U F() {...}                 // Ok
    public override C<U> G() {...}              // Ok
    public override void H(C<T> x) {...}        // Error, should be C<U>
}
```

Объявление переопределения доступны переопределенным базовым методом с помощью *base_access* ([базового доступа](expressions.md#base-access)). В примере
```csharp
class A
{
    int x;

    public virtual void PrintFields() {
        Console.WriteLine("x = {0}", x);
    }
}

class B: A
{
    int y;

    public override void PrintFields() {
        base.PrintFields();
        Console.WriteLine("y = {0}", y);
    }
}
```
`base.PrintFields()` вызова в `B` вызывает `PrintFields` метод объявлен в `A`. Объект *base_access* отключает механизм виртуального вызова и просто рассматривает базовый метод как невиртуальный метод. Бы вызов `B` были записаны `((A)this).PrintFields()`, бы рекурсивно вызывать `PrintFields` метод объявлен в `B`, не объявлен в `A`, так как `PrintFields` является виртуальным и тип времени выполнения `((A)this)` — `B`.

Только включив `override` can модификатор метода переопределяющих другие методы. Во всех остальных случаях метод с сигнатурой унаследованный метод просто скрывает унаследованный метод. В примере
```csharp
class A
{
    public virtual void F() {}
}

class B: A
{
    public virtual void F() {}        // Warning, hiding inherited F()
}
```
`F` метод в `B` не включает `override` модификатор и поэтому не переопределяет `F` метод в `A`. Вместо этого `F` метод в `B` скрывает метод в `A`, и выводится предупреждение, поскольку объявление не содержит `new` модификатор.

В примере
```csharp
class A
{
    public virtual void F() {}
}

class B: A
{
    new private void F() {}        // Hides A.F within body of B
}

class C: B
{
    public override void F() {}    // Ok, overrides A.F
}
```
`F` метод в `B` скрывает виртуальный `F` метод наследуется от `A`. Так как новый `F` в `B` закрытый доступ к его область содержит только тело класса `B` и не распространяется на `C`. Таким образом, объявление `F` в `C` допускается переопределение `F` наследуется от `A`.

### <a name="sealed-methods"></a>Запечатанные методы

Если объявление метода экземпляра включает `sealed` модификатора, что метод считается ***запечатанные метод***. Если объявление метода экземпляра включает `sealed` модификатор, она должна также содержать `override` модификатор. Использование `sealed` модификатор препятствует дальнейшей переопределение метода производного класса.

В примере
```csharp
using System;

class A
{
    public virtual void F() {
        Console.WriteLine("A.F");
    }

    public virtual void G() {
        Console.WriteLine("A.G");
    }
}

class B: A
{
    sealed override public void F() {
        Console.WriteLine("B.F");
    } 

    override public void G() {
        Console.WriteLine("B.G");
    } 
}

class C: B
{
    override public void G() {
        Console.WriteLine("C.G");
    } 
}
```
Класс `B` предоставляет два переопределения методов: `F` метод, который имеет `sealed` модификатор и `G` метод, который не поддерживает. `B`на использование запечатанных `modifier` предотвращает `C` дальнейшей переопределять `F`.

### <a name="abstract-methods"></a>Абстрактные методы

Если объявление метода экземпляра включает `abstract` модификатора, что метод считается ***абстрактный метод***. Несмотря на то, что абстрактный метод неявно является также виртуальный метод, он не может иметь модификатор `virtual`.

Объявление абстрактного метода появился новый виртуальный метод, но не предоставляет реализацию этого метода. Вместо этого неабстрактные производные классы, обязаны предоставлять собственную реализацию путем переопределения этого метода. Так как абстрактный метод не предоставляет фактической реализации, *method_body* абстрактного метода состоит всего лишь из точки с запятой.

Объявления абстрактных методов допускаются только в абстрактных классах ([абстрактные классы](classes.md#abstract-classes)).

В примере
```csharp
public abstract class Shape
{
    public abstract void Paint(Graphics g, Rectangle r);
}

public class Ellipse: Shape
{
    public override void Paint(Graphics g, Rectangle r) {
        g.DrawEllipse(r);
    }
}

public class Box: Shape
{
    public override void Paint(Graphics g, Rectangle r) {
        g.DrawRect(r);
    }
}
```
`Shape` класс определяет абстрактное представление объекта геометрической фигуры для рисования самого. `Paint` Метод является абстрактным, так как нет смысл реализация по умолчанию. `Ellipse` И `Box` являются конкретными реализациями `Shape` реализаций. Так как эти классы являются не являющиеся абстрактными, должны переопределить `Paint` метод и предоставить фактическую реализацию.

Произошла ошибка во время компиляции для *base_access* ([базового доступа](expressions.md#base-access)) для ссылки на абстрактный метод. В примере
```csharp
abstract class A
{
    public abstract void F();
}

class B: A
{
    public override void F() {
        base.F();                        // Error, base.F is abstract
    }
}
```
выдается ошибка компиляции `base.F()` вызова, так как он ссылается на абстрактный метод.

Объявление абстрактного метода может переопределить виртуальный метод. Это позволяет абстрактный класс для принудительной повторной реализации метода в производных классах и делает недоступным исходной реализации метода. В примере
```csharp
using System;

class A
{
    public virtual void F() {
        Console.WriteLine("A.F");
    }
}

abstract class B: A
{
    public abstract override void F();
}

class C: B
{
    public override void F() {
        Console.WriteLine("C.F");
    }
}
```
Класс `A` объявляет виртуальный метод класса `B` переопределяется в абстрактный метод, а класс `C` переопределяет абстрактный метод, чтобы предоставить собственную реализацию.

### <a name="external-methods"></a>Внешние методы

Если объявление метода содержит `extern` модификатора, что метод считается ***внешнего метода***. Внешние методы реализуются во внешней системе, обычно с помощью языка, отличного от C#. Поскольку объявление внешнего метода не предоставляет фактической реализации, *method_body* внешнего метода состоит всего лишь из точки с запятой. Внешний метод не могут быть универсальными.

`extern` Модификатор обычно используется в сочетании с `DllImport` атрибут ([взаимодействие с компонентами COM и Win32](attributes.md#interoperation-with-com-and-win32-components)), позволяя внешние методы для реализации библиотеки DLL (библиотек динамической компоновки). Среда выполнения может поддерживать другие механизмы, при котором могут быть предоставлены реализации внешних методов.

Если внешний метод включает `DllImport` атрибут, в объявлении метода должен также содержать `static` модификатор. В этом примере демонстрируется использование `extern` модификатор и `DllImport` атрибут:
```csharp
using System.Text;
using System.Security.Permissions;
using System.Runtime.InteropServices;

class Path
{
    [DllImport("kernel32", SetLastError=true)]
    static extern bool CreateDirectory(string name, SecurityAttribute sa);

    [DllImport("kernel32", SetLastError=true)]
    static extern bool RemoveDirectory(string name);

    [DllImport("kernel32", SetLastError=true)]
    static extern int GetCurrentDirectory(int bufSize, StringBuilder buf);

    [DllImport("kernel32", SetLastError=true)]
    static extern bool SetCurrentDirectory(string name);
}
```

### <a name="partial-methods-recap"></a>Разделяемые методы (Обзор)

Если объявление метода содержит `partial` модификатора, что метод считается ***разделяемого метода***. Разделяемые методы можно объявлять только как члены разделяемых типов ([разделяемых типов](classes.md#partial-types)) и их использование регулируется ряд ограничений. Разделяемые методы более подробно описаны в [разделяемые методы](classes.md#partial-methods).

### <a name="extension-methods"></a>Методы расширения

Если первый параметр метода содержит `this` модификатора, что метод считается ***метод расширения***. Методы расширения могут объявляться только в статических классах, не являющегося универсальным, невложенными. Первый параметр метода расширения не может иметь модификаторы `this`, и тип параметра не может быть типом указателя.

Ниже приведен пример статического класса, который объявляет два метода расширения:
```csharp
public static class Extensions
{
    public static int ToInt32(this string s) {
        return Int32.Parse(s);
    }

    public static T[] Slice<T>(this T[] source, int index, int count) {
        if (index < 0 || count < 0 || source.Length - index < count)
            throw new ArgumentException();
        T[] result = new T[count];
        Array.Copy(source, index, result, 0, count);
        return result;
    }
}
```

Метод расширения — это обычный статический метод. Кроме того, когда в области включающего его статистического класса, метод расширения может вызываться с помощью синтаксиса вызова метода экземпляра ([вызовы методов расширения](expressions.md#extension-method-invocations)), используя выражение получателя в качестве первого аргумента.

В следующей программе используются методы расширения, объявленный над:
```csharp
static class Program
{
    static void Main() {
        string[] strings = { "1", "22", "333", "4444" };
        foreach (string s in strings.Slice(1, 2)) {
            Console.WriteLine(s.ToInt32());
        }
    }
}
```

`Slice` Метод доступен для `string[]`и `ToInt32` метод доступен для `string`, так как они были объявлены как методы расширения. Значение программы совпадает со значением ниже, с использованием обычный статический метод:
```csharp
static class Program
{
    static void Main() {
        string[] strings = { "1", "22", "333", "4444" };
        foreach (string s in Extensions.Slice(strings, 1, 2)) {
            Console.WriteLine(Extensions.ToInt32(s));
        }
    }
}
```

### <a name="method-body"></a>Тело метода

*Method_body* метода объявление состоит из тело блока, тело выражения или точкой с запятой.

***Тип результата*** метода является `void` если возвращаемый тип — `void`, или если метод является асинхронным и возвращаемый тип — `System.Threading.Tasks.Task`. В противном случае — тип результата метода синхронные — это тип его возвращаемого значения и тип результата асинхронного метода с типом возвращаемого значения `System.Threading.Tasks.Task<T>` является `T`.

Если метод имеет `void` привести тип и тело блока, `return` инструкций ([оператор return](statements.md#the-return-statement)) в блоке не могут указать выражение. Обычно если завершения выполнения блока метода типа void (т. е. управление передается из конечной точки тела метода), этот метод просто возвращается вызвавшему ее текущей.
    
Если метод имеет `void` результат и тело выражения, выражения `E` должно быть *statement_expression*, и тело полностью эквивалентен тело блока формы `{ E; }`.
    
Если метод имеет тип результата, отличный от void и блок текста, каждый `return` инструкции в блоке необходимо указать выражение, которое может быть неявно преобразован в тип результата. Конечная точка тело блока метода, возвращающего значение, не должен быть доступен. Другими словами в методе с тело блока, возвращающих значение, элемент управления не допускается для передачи из конечной точки тела метода.
    
Если метод имеет тип результата, отличный от void и тело выражения, выражения должны неявно преобразовываться в тип результата и текст полностью эквивалентен тело блока формы `{ return E; }`.
    
В примере
```csharp
class A
{
    public int F() {}            // Error, return value required

    public int G() {
        return 1;
    }

    public int H(bool b) {
        if (b) {
            return 1;
        }
        else {
            return 0;
        }
    }

    public int I(bool b) => b ? 1 : 0;
}
```
Возвращает значение `F` метод приводит к ошибке времени компиляции, так как поток управления можно из конечной точки тела метода. `G` И `H` методы верны, так как все возможные пути выполнения в оператор return, который указывает возвращаемое значение. `I` Метод указан правильно, поскольку его основной части эквивалентен блока инструкций с помощью только один оператор return в нем.

### <a name="method-overloading"></a>Перегрузка методов

Правила разрешения перегрузки метода описаны в [вывод типа](expressions.md#type-inference).

## <a name="properties"></a>Свойства

Объект ***свойство*** является членом, который предоставляет доступ к характеристикам объекта или класса. Примеры свойств включают длину строки, размер шрифта, заголовок окна, имя клиента и так далее. Свойства являются естественным расширением полей — другие являются именованными членами со связанными типами и используется одинаковый синтаксис для доступа к полям и свойствам. Однако свойства, в отличие от полей, не указывают места хранения. Вместо этого свойства содержат ***методы доступа***, в которых описаны инструкции для выполнения при чтении или записи значений. Свойства таким образом предоставляют механизм для связи действия с считывать и записывать атрибуты объекта; Кроме того разрешают такие атрибуты нужно вычислить.

Свойства объявляются с помощью *property_declaration*s:

```antlr
property_declaration
    : attributes? property_modifier* type member_name property_body
    ;

property_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'static'
    | 'virtual'
    | 'sealed'
    | 'override'
    | 'abstract'
    | 'extern'
    | property_modifier_unsafe
    ;

property_body
    : '{' accessor_declarations '}' property_initializer?
    | '=>' expression ';'
    ;

property_initializer
    : '=' variable_initializer ';'
    ;
```

Объект *property_declaration* может включать набор *атрибуты* ([атрибуты](attributes.md)) и является допустимой комбинацией четырех модификаторов доступа ([модификаторы доступа ](classes.md#access-modifiers)), `new` ([Модификатор new](classes.md#the-new-modifier)), `static` ([экземпляра и статические методы](classes.md#static-and-instance-methods)), `virtual` ([виртуальных методов](classes.md#virtual-methods)), `override` ([Переопределять методы](classes.md#override-methods)), `sealed` ([запечатанные методы](classes.md#sealed-methods)), `abstract` ([абстрактные методы](classes.md#abstract-methods)), и `extern` ([Внешние методы](classes.md#external-methods)) модификаторы.

Объявления свойств подчиняются тем же правилам, что и объявления методов ([методы](classes.md#methods)) по отношению к допустимые сочетания модификаторов.

*Тип* свойства объявление указывает тип свойства, представленные этим определением и *member_name* указывает имя свойства. Если свойство не явная реализация члена интерфейса, *member_name* является просто *идентификатор*. Для явной реализации члена интерфейса ([явные реализации члена интерфейса](interfaces.md#explicit-interface-member-implementations)), *member_name* состоит из *interface_type* следуют " `.`"и *идентификатор*.

*Тип* свойства должно быть по крайней мере такой же уровень доступности, как и само свойство ([ограничения доступности](basic-concepts.md#accessibility-constraints)).

Объект *property_body* может либо состоять из ***тела метода доступа*** или ***тело выражения***. В тело метода доступа *accessor_declarations*, которые должны быть заключены в "`{`«и»`}`" токены, объявите методы доступа ([методы доступа](classes.md#accessors)) свойства. Методы доступа укажите исполняемые операторы, связанные с чтением и записью свойство.

Тело выражения, состоящий из `=>` следуют *выражение* `E` и точку с запятой полностью эквивалентен тела оператора `{ get { return E; } }`и поэтому только можно указать только для считывания свойства, где результат метод считывания задается с помощью одного выражения.

Объект *property_initializer* может предоставляться только для автоматически реализованного свойства ([автоматически реализуемые свойства](classes.md#automatically-implemented-properties)) и приводит к инициализации базового поля таких свойства со значением, предоставленным выражением *выражение*.

Несмотря на то, что синтаксис доступ к свойству такой же, что и поле, свойство не классифицируется как переменная. Таким образом, он уже не сможете передать свойство в качестве `ref` или `out` аргумент.

Если объявление свойства содержит `extern` модификатор, свойство считается ***внешним свойством***. Поскольку объявление внешнего свойства не предоставляет фактической реализации, каждый из его *accessor_declarations* состоит из точки с запятой.

### <a name="static-and-instance-properties"></a>Экземпляра и статические свойства

Если объявление свойства содержит `static` модификатор, свойство считается ***статическое свойство***. Если аргумент `static` модификатор присутствует, свойство считается ***свойства экземпляра***.

Статическое свойство не связан с конкретным экземпляром, и произошла ошибка во время компиляции, для ссылки на `this` в методах доступа статического свойства.

Свойство экземпляра связан с данным экземпляром класса, и этот экземпляр может быть доступен как `this` ([такой доступ](expressions.md#this-access)) в методах доступа этого свойства.

Если ссылка на свойство в *member_access* ([доступ к членам](expressions.md#member-access)) формы `E.M`, если `M` является статическим свойством, `E` необходимо обозначить тип, содержащий `M`и если `M` является свойством экземпляра, E должно означать экземпляр типа, содержащего `M`.

Различия между статическими и члены экземпляра рассматриваются далее в [экземпляра и статические члены](classes.md#static-and-instance-members).

### <a name="accessors"></a>Методы доступа

*Accessor_declarations* свойства укажите исполняемые операторы, связанные с чтением и записью этого свойства.

```antlr
accessor_declarations
    : get_accessor_declaration set_accessor_declaration?
    | set_accessor_declaration get_accessor_declaration?
    ;

get_accessor_declaration
    : attributes? accessor_modifier? 'get' accessor_body
    ;

set_accessor_declaration
    : attributes? accessor_modifier? 'set' accessor_body
    ;

accessor_modifier
    : 'protected'
    | 'internal'
    | 'private'
    | 'protected' 'internal'
    | 'internal' 'protected'
    ;

accessor_body
    : block
    | ';'
    ;
```

Объявления методов доступа состоят из *get_accessor_declaration*, *set_accessor_declaration*, или оба. Каждое объявление метода доступа состоит из маркера `get` или `set` следуют необязательный *accessor_modifier* и *accessor_body*.

Использование *accessor_modifier*s регулируется следующими ограничениями:

*  *Accessor_modifier* не может использоваться в интерфейсе или явной реализации члена интерфейса.
*  Для свойства или индексатора, который не имеет `override` модификатор, *accessor_modifier* разрешался только в том случае, если свойство или индексатор имеет оба `get` и `set` метод доступа и применяется только к одному из них методы доступа.
*  Для свойства или индексатора, который включает в себя `override` , метод доступа должен соответствовать *accessor_modifier*, если таковое имеется, переопределение метода доступа.
*  *Accessor_modifier* должен объявлять, является более строгим, чем объявленный уровень доступности свойства или сам индексатор. Точнее:
   * Если свойство или индексатор имеет объявленный уровень доступности `public`, *accessor_modifier* может быть либо `protected internal`, `internal`, `protected`, или `private`.
   * Если свойство или индексатор имеет объявленный уровень доступности `protected internal`, *accessor_modifier* может быть либо `internal`, `protected`, или `private`.
   * Если свойство или индексатор имеет объявленный уровень доступности `internal` или `protected`, *accessor_modifier* должно быть `private`.
   * Если свойство или индексатор имеет объявленный уровень доступности `private`, не *accessor_modifier* может использоваться.

Для `abstract` и `extern` свойства, *accessor_body* для каждого метода доступа указан — только точку с запятой. Не являющиеся абстрактными, или внешними свойства могут иметь каждый *accessor_body* быть точкой с запятой, в противном случае это ***автоматически реализованное свойство*** ([автоматически реализуемые свойства ](classes.md#automatically-implemented-properties)). Автоматически реализуемого свойства должен иметь по крайней мере метод доступа get. Для любого другого неабстрактного, или внешними свойства, методы доступа *accessor_body* — *блок* определяющий операторы, которые будут выполняться при вызове соответствующего метода доступа.

Объект `get` метод доступа соответствует оформляется как метод с возвращаемым значением типа свойства. За исключением случаев, целевым объектом назначения, при ссылке на свойство в выражении, `get` для вычисления значения свойства вызывается метод доступа свойства ([значения выражений](expressions.md#values-of-expressions)). Тело `get` доступа должны соответствовать правилам для возвращающих значения методов, описанных в [тело метода](classes.md#method-body). В частности все `return` инструкции в теле `get` доступа необходимо указать выражение, которое может быть неявно преобразован в тип свойства. Кроме того конечная точка `get` метод доступа не должен быть доступен.

Объект `set` соответствует методу с параметром одиночное значение типа свойства метода доступа и `void` тип возвращаемого значения. Неявный параметр `set` доступа всегда имеет имя `value`. Если ссылка на свойство как целевым объектом назначения ([операторы присваивания](expressions.md#assignment-operators)), или в качестве операнда `++` или `--` ([постфиксных инкремента и декремента](expressions.md#postfix-increment-and-decrement-operators), [ Префиксный инкремент и декремент операторы](expressions.md#prefix-increment-and-decrement-operators)), `set` с аргументом вызывается метод доступа (значение которого равно правой части назначения или операнд `++` или `--` оператор), предоставляет новое значение ([простое присваивание](expressions.md#simple-assignment)). Тело `set` доступа должны соответствовать правилам для `void` методов, описанных в [тело метода](classes.md#method-body). В частности `return` инструкций в `set` тела метода доступа не допускаются и ввести выражение. Так как `set` доступа неявно имеет параметр с именем `value`, произошла ошибка во время компиляции, для объявления локальной переменной или константы в `set` метод доступа, такое имя.

Зависимости от наличия или отсутствия `get` и `set` методы доступа, свойство классифицируется следующим образом:

*  Свойство, которое включает в себя `get` метода доступа и `set` доступа считается ***чтения и записи*** свойство.
*  Свойство, имеющее только `get` доступа считается ***только для чтения*** свойство. Это ошибка времени компиляции для свойства только для чтения в качестве целевого назначения.
*  Свойство, имеющее только `set` доступа считается ***только для записи*** свойство. За исключением того, что целевым объектом назначения, это ошибка времени компиляции для ссылки на свойство только для записи в выражении.

В примере
```csharp
public class Button: Control
{
    private string caption;

    public string Caption {
        get {
            return caption;
        }
        set {
            if (caption != value) {
                caption = value;
                Repaint();
            }
        }
    }

    public override void Paint(Graphics g, Rectangle r) {
        // Painting code goes here
    }
}
```
`Button` управления объявляет открытое `Caption` свойство. `get` Метод доступа `Caption` свойство возвращает строку, хранится в закрытом `caption` поля. `set` Метод доступа, проверяет ли новое значение отличается от текущего значения, и если да, он сохраняет новое значение и обновляет элемент управления. Свойства часто следовать шаблону, приведенному выше: `get` доступа просто возвращает значение, хранящееся в скрытом поле и `set` доступа изменяет закрытого поля, а затем выполняет дополнительных действий, необходимых для полного обновления состояния объекта.

Учитывая `Button` класс выше, ниже приведен пример использования `Caption` свойство:
```csharp
Button okButton = new Button();
okButton.Caption = "OK";            // Invokes set accessor
string s = okButton.Caption;        // Invokes get accessor
```

Здесь `set` путем присвоения значения свойству вызывается метод доступа и `get` путем ссылки на свойство в выражении вызывается метод доступа.

`get` И `set` методы доступа свойства не являются различными членами, и невозможно объявить методы доступа свойства отдельно. Таким образом он не поддерживается для двух методов доступа свойства чтения и записи иметь разные уровни доступа. Пример
```csharp
class A
{
    private string name;

    public string Name {                // Error, duplicate member name
        get { return name; }
    }

    public string Name {                // Error, duplicate member name
        set { name = value; }
    }
}
```
не объявляет одно свойство чтения и записи. Вместо этого он объявляет два свойства с тем же именем, один только для чтения и только для записи. Поскольку двух членов, объявленных в том же классе, не могут иметь тем же именем, в примере возникает ошибка времени компиляции возникает.

Когда производный класс не объявляет свойство с тем же именем, что унаследованное свойство, производное свойство скрывает унаследованное свойство по отношению к операциям чтения и записи. В примере
```csharp
class A
{
    public int P {
        set {...}
    }
}

class B: A
{
    new public int P {
        get {...}
    }
}
```
`P` свойство в `B` скрывает `P` свойство в `A` по отношению к операциям чтения и записи. Таким образом в инструкциях
```csharp
B b = new B();
b.P = 1;          // Error, B.P is read-only
((A)b).P = 1;     // Ok, reference to A.P
```
Назначение `b.P` приводит к ошибке времени компиляции для включаются в отчет, так как только для чтения `P` свойство в `B` скрывает только запись `P` свойство в `A`. Обратите внимание, что приведение может использоваться для доступа к скрытого `P` свойство.

В отличие от открытых полей свойства обеспечивают разделение между внутреннее состояние объекта и его открытому интерфейсу. Рассмотрим пример:
```csharp
class Label
{
    private int x, y;
    private string caption;

    public Label(int x, int y, string caption) {
        this.x = x;
        this.y = y;
        this.caption = caption;
    }

    public int X {
        get { return x; }
    }

    public int Y {
        get { return y; }
    }

    public Point Location {
        get { return new Point(x, y); }
    }

    public string Caption {
        get { return caption; }
    }
}
```

Здесь `Label` класс использует два `int` поля, `x` и `y`для хранения его расположение. Расположение является публично доступны только в качестве `X` и `Y` свойства и в качестве `Location` свойство типа `Point`. Если в будущих версиях `Label`, он становится более удобным для хранения в расположении, что `Point` на внутреннем уровне можно произвести изменения без влияния на открытый интерфейс класса:
```csharp
class Label
{
    private Point location;
    private string caption;

    public Label(int x, int y, string caption) {
        this.location = new Point(x, y);
        this.caption = caption;
    }

    public int X {
        get { return location.x; }
    }

    public int Y {
        get { return location.y; }
    }

    public Point Location {
        get { return location; }
    }

    public string Caption {
        get { return caption; }
    }
}
```

Было `x` и `y` были `public readonly` поля, было бы невозможно внести изменения в `Label` класса.

Предоставление состояния с помощью свойства не обязательно менее эффективным, чем непосредственное предоставление полей. В частности Если свойство не является виртуальным и содержит только небольшой объем кода, среда выполнения может заменить вызовы методов доступа фактический код методов доступа. Этот процесс известен как ***встраивание***, и он обеспечивает доступ к свойству так эффективно, как доступ к полям, сохраняя при повышенную гибкость свойств.

С момента вызова `get` доступа концептуально эквивалентна считывания значения свойства поля, он считается плохим стилем программирования `get` наблюдаемый стороне-эффектов. В примере
```csharp
class Counter
{
    private int next;

    public int Next {
        get { return next++; }
    }
}
```
Значение `Next` свойства зависит от числа обращений свойство ранее. Таким образом обращение к свойству создает наблюдаемый побочный эффект, а свойство должен вместо этого реализован как метод.

Соглашение «без побочных эффектов», `get` методы доступа не означает, что `get` методы доступа всегда должны использоваться только для возвращения значений, хранящихся в полях. Действительно `get` методы доступа часто используются для вычисления значения свойства, доступ к нескольким полям или вызова методов. Тем не менее правильно спроектированное `get` метод доступа не выполняет действия, вызывающие заметные изменения в состоянии объекта.

Свойства можно отложить инициализацию ресурса вплоть до момента его первом обращении. Пример:
```csharp
using System.IO;

public class Console
{
    private static TextReader reader;
    private static TextWriter writer;
    private static TextWriter error;

    public static TextReader In {
        get {
            if (reader == null) {
                reader = new StreamReader(Console.OpenStandardInput());
            }
            return reader;
        }
    }

    public static TextWriter Out {
        get {
            if (writer == null) {
                writer = new StreamWriter(Console.OpenStandardOutput());
            }
            return writer;
        }
    }

    public static TextWriter Error {
        get {
            if (error == null) {
                error = new StreamWriter(Console.OpenStandardError());
            }
            return error;
        }
    }
}
```

`Console` Класс содержит три свойства `In`, `Out`, и `Error`, представляющие стандартного ввода, вывода и ошибка устройств, соответственно. Благодаря предоставлению этих членов, как свойства, `Console` класса можно отложить их инициализацию до их фактического использования. Например, при первой ссылке на `Out` свойства, как и в
```csharp
Console.Out.WriteLine("hello, world");
```
базовый `TextWriter` для созданных устройстве вывода. Но если приложение не ссылается на `In` и `Error` свойств, то объекты не создаются для этих устройств.

### <a name="automatically-implemented-properties"></a>Автоматически реализованные свойства

Автоматически реализуемое свойство (или ***автосвойств*** для краткости), не являющиеся абстрактными или внешними свойство с тела методов доступа только для точки с запятой. Автосвойства должен иметь метод доступа get и может иметь метод доступа set.

Когда свойство указано как автоматически реализуемое свойство, скрытое резервное поле автоматически доступен для свойства и реализуются методы доступа для чтения и записи к этому полю поддержки. Если автоматическое свойство без метода доступа set, считается резервное поле `readonly` ([поля только для чтения](classes.md#readonly-fields)). Так же, как `readonly` поля, автосвойства только для считывания могут также назначаться в теле конструктора включающего класса. Такое присваивание назначает непосредственно к резервному полю только для чтения свойства.

Автосвойства могут содержать *property_initializer*, который применяется непосредственно к резервному полю как *variable_initializer* ([инициализаторы переменных](classes.md#variable-initializers)) .

Следующий пример:
```csharp
public class Point {
    public int X { get; set; } = 0;
    public int Y { get; set; } = 0;
}
```
эквивалентно следующему объявлению:
```csharp
public class Point {
    private int __x = 0;
    private int __y = 0;
    public int X { get { return __x; } set { __x = value; } }
    public int Y { get { return __y; } set { __y = value; } }
}
```

Следующий пример:
```csharp
public class ReadOnlyPoint
{
    public int X { get; }
    public int Y { get; }
    public ReadOnlyPoint(int x, int y) { X = x; Y = y; }
}
```
эквивалентно следующему объявлению:
```csharp
public class ReadOnlyPoint
{
    private readonly int __x;
    private readonly int __y;
    public int X { get { return __x; } }
    public int Y { get { return __y; } }
    public ReadOnlyPoint(int x, int y) { __x = x; __y = y; }
}
```

Обратите внимание на то, что назначения, которые только для чтения поля допустимы, так как они встречаются в конструкторе.


### <a name="accessibility"></a>Специальные возможности

Если метод доступа *accessor_modifier*, то домен доступности ([области доступности](basic-concepts.md#accessibility-domains)) метода доступа определяется объявленным уровнем доступности *accessor_modifier* . Если метод доступа не является *accessor_modifier*, то домен доступности метода доступа определяется объявленным уровнем доступности свойства или индексатора.

Наличие *accessor_modifier* никогда не влияет на поиск члена ([операторы](expressions.md#operators)) или разрешение перегрузки ([разрешение перегрузки](expressions.md#overload-resolution)). Модификаторы для свойства или индексатора всегда определяют, какое свойство или индексатор связан, вне зависимости от контекста доступа.

После выбора конкретного свойства или индексатора области доступности для задействованных методов доступа, используемые для определения допустимости использования.

*  Если оно используется как значение ([значения выражений](expressions.md#values-of-expressions)), `get` метод доступа должен существовать и быть доступен.
*  Если оно используется в качестве целевого объекта простого присваивания ([простое присваивание](expressions.md#simple-assignment)), `set` метод доступа должен существовать и быть доступен.
*  Если оно используется как целевой составного оператора присваивания ([Составное присваивание](expressions.md#compound-assignment)), или в качестве целевого объекта `++` или `--` операторы ([функции-члены](expressions.md#function-members).9, [ Выражения вызова](expressions.md#invocation-expressions)), оба `get` методы доступа и `set` доступа должен существовать и быть доступен.

В следующем примере свойство `A.Text` скрыто свойством `B.Text`, даже в контекстах, где это только `set` вызывается метод доступа. В отличие от этого, свойство `B.Count` доступен не для класса `M`, поэтому доступное свойство `A.Count` вместо него используется.

```csharp
class A
{
    public string Text {
        get { return "hello"; }
        set { }
    }

    public int Count {
        get { return 5; }
        set { }
    }
}

class B: A
{
    private string text = "goodbye"; 
    private int count = 0;

    new public string Text {
        get { return text; }
        protected set { text = value; }
    }

    new protected int Count { 
        get { return count; }
        set { count = value; }
    }
}

class M
{
    static void Main() {
        B b = new B();
        b.Count = 12;             // Calls A.Count set accessor
        int i = b.Count;          // Calls A.Count get accessor
        b.Text = "howdy";         // Error, B.Text set accessor not accessible
        string s = b.Text;        // Calls B.Text get accessor
    }
}
```

Метод доступа, который используется для реализации интерфейса может не иметь *accessor_modifier*. Если только один метод доступа используется для реализации интерфейса, другой метод доступа может быть объявлен с *accessor_modifier*:
```csharp
public interface I
{
    string Prop { get; }
}

public class C: I
{
    public Prop {
        get { return "April"; }       // Must not have a modifier here
        internal set {...}            // Ok, because I.Prop has no set accessor
    }
}
```

### <a name="virtual-sealed-override-and-abstract-property-accessors"></a>Виртуальные, запечатанные, переопределяющие и абстрактные доступа к свойствам

Объект `virtual` объявление свойства указывает, что виртуальные методы доступа к свойству. `virtual` Модификатор применяется для обоих методов доступа свойства чтения и записи — это невозможно для только один метод доступа свойства чтения и записи, должен быть виртуальным.

`abstract` Объявление свойства задает, что виртуальные методы доступа к свойству, но не предоставляет фактической реализации методов доступа. Вместо этого неабстрактные производные классы, обязаны предоставлять собственную реализацию для методов доступа посредством переопределения свойства. Так как метод доступа для в объявлении абстрактного свойства не предоставляет фактической реализации, его *accessor_body* состоит всего лишь из точки с запятой.

Объявление свойства, которое включает в себя `abstract` и `override` модификаторов указывает, что свойство является абстрактным и переопределяет базовое свойство. Методы доступа такого свойства также являются абстрактными.

Абстрактное свойство объявления допускаются только в абстрактных классах ([абстрактные классы](classes.md#abstract-classes)). Методы доступа унаследованного виртуального свойства можно переопределить в производном классе путем включения объявления свойства, которое указывает `override` директива. Этот процесс называется ***переопределение объявление свойства***. Переопределяющее объявление свойства не объявляет новое свойство. Вместо этого он просто специализирует реализации методов доступа существующего виртуального свойства.

Переопределяющее объявление свойства необходимо указать в качестве унаследованного свойства точно такие же модификаторы доступа, тип и имя. Если наследуемое свойство имеет только один метод доступа (т. е. Если наследуемое свойство только для чтения или только для записи), переопределяющее свойство должно включать только этот метод доступа. Если унаследованное свойство содержит оба метода доступа (т. е. Если наследуемое свойство доступно для чтения записи), переопределяющее свойство может включать один или оба метода доступа.

Переопределяющее объявление свойства могут включать `sealed` модификатор. Использование этот модификатор предотвращает последующее переопределение свойства производного класса. Методы доступа запечатанного свойства также являются запечатанными.

За исключением отличий в объявление и вызов синтаксиса, виртуальных, запечатанных, переопределяющие и абстрактные методы доступа ведут себя так же, как виртуальный, запечатанных, переопределение и абстрактные методы. В частности, правила описываются в [виртуальных методов](classes.md#virtual-methods), [переопределять методы](classes.md#override-methods), [запечатанные методы](classes.md#sealed-methods), и [абстрактные методы](classes.md#abstract-methods) применяются так, как если методы доступа были методы из соответствующей формы:

*  Объект `get` метод доступа соответствует оформляется как метод с возвращаемым значением типа свойства и те же модификаторы, содержащего его свойства.
*  Объект `set` доступа соответствует методу с параметром одиночное значение типа свойства, `void` возвращают тип и одинаковые модификаторы содержащего его свойства.

В примере
```csharp
abstract class A
{
    int y;

    public virtual int X {
        get { return 0; }
    }

    public virtual int Y {
        get { return y; }
        set { y = value; }
    }

    public abstract int Z { get; set; }
}
```
`X` — это виртуальное свойство только для чтения, `Y` — это виртуальное свойство чтения и записи, и `Z` является абстрактным свойством чтения и записи. Так как `Z` является абстрактным, содержащего класса `A` должен также быть объявлен как абстрактный.

Класс, производный от `A` будет показано на следующем рисунке:
```csharp
class B: A
{
    int z;

    public override int X {
        get { return base.X + 1; }
    }

    public override int Y {
        set { base.Y = value < 0? 0: value; }
    }

    public override int Z {
        get { return z; }
        set { z = value; }
    }
}
```

В данном случае — объявления `X`, `Y`, и `Z` переопределяют объявления свойств. Каждое объявление свойства точно соответствует модификаторы доступа, тип и имя соответствующего наследуемого свойства. `get` Метод доступа `X` и `set` метод доступа `Y` использовать `base` ключевое слово для доступа к унаследованным методам доступа. Объявление `Z` переопределяет оба абстрактного метода доступа — таким образом, нет ожидающих абстрактной функции членов в `B`, и `B` , может быть неабстрактным классом.

Если свойство объявлено как `override`, все переопределенные методы доступа должны быть доступны коду переопределения. Кроме того объявленный уровень доступности свойства или сам индексатор и методы доступа, должна соответствовать переопределенному члену и методы доступа. Пример:
```csharp
public class B
{
    public virtual int P {
        protected set {...}
        get {...}
    }
}

public class D: B
{
    public override int P {
        protected set {...}            // Must specify protected here
        get {...}                      // Must not have a modifier here
    }
}
```

## <a name="events"></a>События

***Событий*** — это член, включает объект или класс для предоставления уведомления. Клиенты могли подключаться к событиям исполняемый код, указав ***обработчики событий***.

События объявляются с помощью *event_declaration*s:

```antlr
event_declaration
    : attributes? event_modifier* 'event' type variable_declarators ';'
    | attributes? event_modifier* 'event' type member_name '{' event_accessor_declarations '}'
    ;

event_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'static'
    | 'virtual'
    | 'sealed'
    | 'override'
    | 'abstract'
    | 'extern'
    | event_modifier_unsafe
    ;

event_accessor_declarations
    : add_accessor_declaration remove_accessor_declaration
    | remove_accessor_declaration add_accessor_declaration
    ;

add_accessor_declaration
    : attributes? 'add' block
    ;

remove_accessor_declaration
    : attributes? 'remove' block
    ;
```

*Event_declaration* может включать набор *атрибуты* ([атрибуты](attributes.md)) и является допустимой комбинацией четырех модификаторов доступа ([модификаторы доступа ](classes.md#access-modifiers)), `new` ([Модификатор new](classes.md#the-new-modifier)), `static` ([экземпляра и статические методы](classes.md#static-and-instance-methods)), `virtual` ([виртуальных методов](classes.md#virtual-methods)), `override` ([Переопределять методы](classes.md#override-methods)), `sealed` ([запечатанные методы](classes.md#sealed-methods)), `abstract` ([абстрактные методы](classes.md#abstract-methods)), и `extern` ([Внешние методы](classes.md#external-methods)) модификаторы.

Объявления событий подчиняются тем же правилам, что и объявления методов ([методы](classes.md#methods)) по отношению к допустимые сочетания модификаторов.

*Тип* события объявление должно быть *delegate_type* ([ссылочные типы](types.md#reference-types)) и что *delegate_type* необходимо по крайней мере как уровень доступности, как самого события ([ограничения доступности](basic-concepts.md#accessibility-constraints)).

Объявление события может включать *event_accessor_declarations*. Тем не менее, если это не так, для или внешними, не являющиеся абстрактными событий, компилятор автоматически предоставляет их ([подобные полям события](classes.md#field-like-events)); для внешних событий методы доступа предоставляются извне.

Объявление события, в котором пропущены *event_accessor_declarations* определяет одно или несколько событий — один для каждого из *variable_declarator*s. Атрибуты и модификаторы применяются ко всем членам, объявленным такой *event_declaration*.

Произошла ошибка во время компиляции для *event_declaration* обоих `abstract` модификатор и разделенных фигурную скобку *event_accessor_declarations*.

Если объявление события содержит `extern` модификатор, событие считается ***внешнее событие***. Поскольку объявления внешних событий не предоставляет фактической реализации, является ошибкой для включения оба `extern` модификатор и *event_accessor_declarations*.

Произошла ошибка во время компиляции для *variable_declarator* объявления события с `abstract` или `external` модификатор для включения *variable_initializer*.

События можно использовать как левый операнд `+=` и `-=` операторы ([назначения события](expressions.md#event-assignment)). Эти операторы используются, соответственно, чтобы присоединить обработчики событий или удаления обработчиков событий из события, и модификаторы доступа события управления контексты, в которых разрешены такие операции.

Так как `+=` и `-=` являются только операции, разрешенные для событий за пределами тип, объявляющий событие, внешний код можно добавить и удаления обработчиков событий, но нельзя любым другим способом получения или изменения базового списка событий обработчики.

В операции формы `x += y` или `x -= y`, когда `x` — это событие, а ссылки выполняется за пределами типа, содержащего объявление `x`, результат операции имеет тип `void` (в отличие от необходимости Тип `x`, со значением `x` после назначения). Это правило запрещает внешний код непосредственного просмотра базового делегата события.

В следующем примере показано, как обработчики событий можно подключать к экземплярам `Button` класса:
```csharp
public delegate void EventHandler(object sender, EventArgs e);

public class Button: Control
{
    public event EventHandler Click;
}

public class LoginDialog: Form
{
    Button OkButton;
    Button CancelButton;

    public LoginDialog() {
        OkButton = new Button(...);
        OkButton.Click += new EventHandler(OkButtonClick);
        CancelButton = new Button(...);
        CancelButton.Click += new EventHandler(CancelButtonClick);
    }

    void OkButtonClick(object sender, EventArgs e) {
        // Handle OkButton.Click event
    }

    void CancelButtonClick(object sender, EventArgs e) {
        // Handle CancelButton.Click event
    }
}
```

Здесь `LoginDialog` конструктор экземпляра создает два `Button` экземпляров и присоединяет обработчики событий к `Click` события.

### <a name="field-like-events"></a>Подобные полям события

В тексте программы элемента класса или структуры, который содержит объявление события определенные события, можно использовать как поля. Для использования таким образом, событие не должно быть `abstract` или `extern`и явным образом не должны содержать *event_accessor_declarations*. Такое событие может использоваться в любом контексте, который разрешает поле. Поле содержит делегат ([делегаты](delegates.md)) который ссылается на список обработчиков событий, которые были добавлены к событию. Если обработчики событий не будут добавлены, поле содержит `null`.

В примере
```csharp
public delegate void EventHandler(object sender, EventArgs e);

public class Button: Control
{
    public event EventHandler Click;

    protected void OnClick(EventArgs e) {
        if (Click != null) Click(this, e);
    }

    public void Reset() {
        Click = null;
    }
}
```
`Click` используется в качестве поля в `Button` класса. Как показано в примере, поле можно проверить, изменяется и используется в выражениях вызова делегата. `OnClick` Метод в `Button` класса «вызывает» `Click` событий. Концепция создания события в точности соответствует вызову делегата, представленного этим событием. Это позволяет обойтись без особой языковой конструкции для создания событий. Обратите внимание на то, что вызов делегата предшествует проверка, что делегат не равно null.

За пределами объявления `Button` класс, `Click` член может использоваться только в левой части `+=` и `-=` операторы, как и в
```csharp
b.Click += new EventHandler(...);
```
который добавляет делегат в список вызова `Click` событий, и
```csharp
b.Click -= new EventHandler(...);
```
который удаляет делегат из списка вызовов `Click` событий.

При компиляции события, подобного полю, компилятор автоматически создает хранилище для хранения делегата и создает методы доступа для события, которые добавляют или удаляют обработчики событий поля делегата. Операции добавления и удаления являются потокобезопасными и может (но не обязательно) быть выполняются при блокировке ([инструкция lock](statements.md#the-lock-statement)) на содержащего его объекта для события экземпляра, либо этого объекта типа ([анонимный доступ выражения создания объектов](expressions.md#anonymous-object-creation-expressions)) для статическое событие.

Таким образом объявление события экземпляра формы:
```csharp
class X
{
    public event D Ev;
}
```
компилируется в нечто, эквивалентное:
```csharp
class X
{
    private D __Ev;  // field to hold the delegate

    public event D Ev {
        add {
            /* add the delegate in a thread safe way */
        }

        remove {
            /* remove the delegate in a thread safe way */
        }
    }
}
```
В классе `X`, ссылки на `Ev` в левой части `+=` и `-=` операторы вызывают добавить и удалить методы доступа для вызова. Все ссылки на `Ev` компилируются для ссылки на скрытое поле `__Ev` вместо ([доступ к членам](expressions.md#member-access)). Имя "`__Ev`" может быть произвольным; скрытое поле может иметь любое имя или имя не вообще.

### <a name="event-accessors"></a>Методы доступа событий

Объявления событий обычно опускаются *event_accessor_declarations*, как в `Button` приведенном выше примере. Причин для этого входит случай, в котором стоимость хранения одного поля на событие не допускается. В таких случаях класс может содержать *event_accessor_declarations* и используют закрытый механизм для хранения списка обработчиков событий.

*Event_accessor_declarations* события укажите исполняемые операторы, связанные с добавления и удаления обработчиков событий.

Объявления методов доступа состоят из *add_accessor_declaration* и *remove_accessor_declaration*. Каждое объявление метода доступа состоит из маркера `add` или `remove` следуют *блок*. *Блок* связанные с *add_accessor_declaration* задает операторы, выполняемые при добавлении обработчика событий и *блок* связанных с *remove_accessor_declaration* задает операторы, выполняемые при удалении обработчика событий.

Каждый *add_accessor_declaration* и *remove_accessor_declaration* соответствует методу с параметром одиночное значение типа события и `void` тип возвращаемого значения. Неявный параметр метода доступа к событию называется `value`. Когда событие используется в назначении события, используется доступа соответствующего события. В частности Если оператор присваивания `+=` затем используется метод доступа add и оператор присваивания имеет `-=` затем используется метод доступа remove. В любом случае правый операнд оператора присваивания используется в качестве аргумента для доступа к событию. Блок *add_accessor_declaration* или *remove_accessor_declaration* должны соответствовать правилам для `void` методов, описанных в [тело метода](classes.md#method-body). В частности `return` инструкций в этот блок не допускаются и ввести выражение.

Так как метод доступа события неявно имеет параметр с именем `value`, возникает ошибка времени компиляции для локальной переменной или константы, объявленные в методе доступа к событию таким именем.

В примере
```csharp
class Control: Component
{
    // Unique keys for events
    static readonly object mouseDownEventKey = new object();
    static readonly object mouseUpEventKey = new object();

    // Return event handler associated with key
    protected Delegate GetEventHandler(object key) {...}

    // Add event handler associated with key
    protected void AddEventHandler(object key, Delegate handler) {...}

    // Remove event handler associated with key
    protected void RemoveEventHandler(object key, Delegate handler) {...}

    // MouseDown event
    public event MouseEventHandler MouseDown {
        add { AddEventHandler(mouseDownEventKey, value); }
        remove { RemoveEventHandler(mouseDownEventKey, value); }
    }

    // MouseUp event
    public event MouseEventHandler MouseUp {
        add { AddEventHandler(mouseUpEventKey, value); }
        remove { RemoveEventHandler(mouseUpEventKey, value); }
    }

    // Invoke the MouseUp event
    protected void OnMouseUp(MouseEventArgs args) {
        MouseEventHandler handler; 
        handler = (MouseEventHandler)GetEventHandler(mouseUpEventKey);
        if (handler != null)
            handler(this, args);
    }
}
```
`Control` класс реализует механизм внутреннего хранилища для событий. `AddEventHandler` Метод связывает значение делегата с ключом, `GetEventHandler` метод возвращает делегат, который сейчас связан с ключом и `RemoveEventHandler` метод удаляет делегат в качестве обработчика событий для указанного события. Предположительно, базовый механизм хранения разработан таким образом, что плата не для связывания `null` делегировать значение с ключом, и таким образом необработанные события использования места для хранения.

### <a name="static-and-instance-events"></a>Экземпляра и статические события

Если объявление события содержит `static` модификатор, событие считается ***статическое событие***. Если аргумент `static` модификатор присутствует, событие считается ***события экземпляра***.

Статическое событие не связан с конкретным экземпляром, и произошла ошибка во время компиляции, для ссылки на `this` в методах доступа статическое событие.

Событие экземпляра связан с данным экземпляром класса, и этот экземпляр может быть доступен как `this` ([такой доступ](expressions.md#this-access)) в методах доступа этого события.

Если ссылка на событие в *member_access* ([доступ к членам](expressions.md#member-access)) формы `E.M`, если `M` — это статическое событие, `E` необходимо обозначить тип, содержащий `M`и если `M` — это событие экземпляра E должно означать экземпляр типа, содержащего `M`.

Различия между статическими и члены экземпляра рассматриваются далее в [экземпляра и статические члены](classes.md#static-and-instance-members).

### <a name="virtual-sealed-override-and-abstract-event-accessors"></a>Виртуальные, запечатанные, переопределяющие и абстрактные доступа к событиям

Объект `virtual` объявление события указывает, что виртуальные методы доступа этого события. `virtual` Модификатор применяется к оба метода доступа события.

`abstract` Объявление события указывает, что виртуальные методы доступа события, но не предоставляет фактической реализации методов доступа. Вместо этого неабстрактные производные классы, обязаны предоставлять собственную реализацию для методов доступа посредством переопределения события. Поскольку объявление абстрактного события не предоставляет фактической реализации, он не может предоставить разделенный фигурную скобку *event_accessor_declarations*.

Объявление события, который включает в себя `abstract` и `override` модификаторов указывает, что событие является абстрактным и переопределяет базовое событие. Методы доступа такого события также являются абстрактными.

Объявления абстрактных событий разрешены только в абстрактных классах ([абстрактные классы](classes.md#abstract-classes)).

Методы доступа унаследованного виртуального события могут переопределяться в производном классе, включив объявление события, которое указывает `override` модификатор. Этот процесс называется ***переопределение объявление события***. Переопределяющее объявление события не объявляет новое событие. Вместо этого он просто специализирует реализации методов доступа существующего виртуального события.

Переопределяющее объявление событий необходимо указать точно такие же модификаторы доступа, тип и имя как переопределенный событие.

Переопределяющее объявление события может включать `sealed` модификатор. Использование этот модификатор препятствует дальнейшей переопределения события производном классе. Методы доступа запечатанного события также являются запечатанными.

Произошла ошибка во время компиляции для Переопределяющее объявление событий для включения `new` модификатор.

За исключением отличий в объявление и вызов синтаксиса, виртуальных, запечатанных, переопределяющие и абстрактные методы доступа ведут себя так же, как виртуальный, запечатанных, переопределение и абстрактные методы. В частности, правила описываются в [виртуальных методов](classes.md#virtual-methods), [переопределять методы](classes.md#override-methods), [запечатанные методы](classes.md#sealed-methods), и [абстрактные методы](classes.md#abstract-methods) применяются так, как если методы доступа были методы из соответствующей формы. Каждый метод доступа соответствует методу с параметром одиночное значение типа события `void` возвращают тип и модификаторов содержащего события.

## <a name="indexers"></a>Индексаторы

***Индексатора*** является членом, который позволяет объекту индексировать так же, как массив. Индексаторы объявляются с помощью *indexer_declaration*s:

```antlr
indexer_declaration
    : attributes? indexer_modifier* indexer_declarator indexer_body
    ;

indexer_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'virtual'
    | 'sealed'
    | 'override'
    | 'abstract'
    | 'extern'
    | indexer_modifier_unsafe
    ;

indexer_declarator
    : type 'this' '[' formal_parameter_list ']'
    | type interface_type '.' 'this' '[' formal_parameter_list ']'
    ;

indexer_body
    : '{' accessor_declarations '}' 
    | '=>' expression ';'
    ;
```

*Indexer_declaration* может включать набор *атрибуты* ([атрибуты](attributes.md)) и является допустимой комбинацией четырех модификаторов доступа ([модификаторы доступа ](classes.md#access-modifiers)), `new` ([Модификатор new](classes.md#the-new-modifier)), `virtual` ([виртуальных методов](classes.md#virtual-methods)), `override` ([переопределять методы](classes.md#override-methods) ), `sealed` ([Запечатанные методы](classes.md#sealed-methods)), `abstract` ([абстрактные методы](classes.md#abstract-methods)), и `extern` ([внешние методы](classes.md#external-methods)) модификаторы.

Объявления индексаторов подчиняются тем же правилам, что и объявления методов ([методы](classes.md#methods)) по отношению к допустимые сочетания модификаторов, за одним исключением, что модификатор static не допускается в объявлении индексатора.

Модификаторы `virtual`, `override`, и `abstract` являются взаимоисключающими, за исключением одного случая. `abstract` И `override` модификаторы могут быть использованы вместе, таким образом, абстрактный индексатор может переопределить виртуальный.

*Тип* индексатора объявление задает тип элемента индексатора, представленные этим определением. Если индексатор не явная реализация члена интерфейса, *тип* следовать ключевое слово `this`. Для явной реализации члена интерфейса *тип* следуют *interface_type*, "`.`«и ключевое слово `this`. В отличие от других членов индексаторы не имеют пользовательских имен.

*Formal_parameter_list* указывает параметры индексатора. Список формальных параметров индексатора соответствует сигнатуре метода ([параметры метода](classes.md#method-parameters)), за исключением того, что по крайней мере один параметр должен быть указан и что `ref` и `out` модификаторов параметров не разрешены. .

*Тип* индексатор, и каждый из типов, на которые ссылается *formal_parameter_list* должен иметь по крайней мере такой же уровень доступности, как и сам индексатор ([ограничения доступности](basic-concepts.md#accessibility-constraints)).

*Indexer_body* может либо состоять из ***тела метода доступа*** или ***тело выражения***. В тело метода доступа *accessor_declarations*, которые должны быть заключены в "`{`«и»`}`" токены, объявите методы доступа ([методы доступа](classes.md#accessors)) свойства. Методы доступа укажите исполняемые операторы, связанные с чтением и записью свойство.

Тело выражения, состоящий из "`=>`" за которым следует выражение `E` и точку с запятой полностью эквивалентен тела оператора `{ get { return E; } }`и поэтому только позволяют указать индексаторы только для считывания результат метода получения Указывает одно выражение.

Несмотря на то, что синтаксис для доступа к элементу индексатора такой же, что и элемент массива, элемент индексатора не классифицируется как переменная. Таким образом, он не поддерживается для передачи элемента индексатора в качестве `ref` или `out` аргумент.

Список формальных параметров индексатора определяет подпись ([сигнатуры и перегрузка](basic-concepts.md#signatures-and-overloading)) индексатора. В частности Сигнатура индексатора состоит из количество и типы его формальных параметров. Тип элементов и имена формальных параметров не являются частью сигнатуры индексатора.

Сигнатура индексатора должна отличаться от сигнатур любых других индексаторов, объявленных в том же классе.

Индексаторы и свойства очень похожи на концепцию, но отличаются следующими способами:

*  Свойство определяется по его имени, тогда как индексатор, который идентифицируется по его подпись.
*  Свойство осуществляется через *simple_name* ([простые имена](expressions.md#simple-names)) или *member_access* ([доступ к членам](expressions.md#member-access)), тогда как индексатор доступ к элементу через *element_access* ([доступа к индексатору](expressions.md#indexer-access)).
*  Свойство может быть `static` член, тогда как индексатор, который всегда является членом экземпляра.
*  Объект `get` метод доступа свойства соответствует методу без параметров, тогда как `get` метода доступа индексатора соответствует методу с тот же список формальных параметров, что и сам индексатор.
*  Объект `set` метод доступа свойства соответствует методу с одним параметром с именем `value`, тогда как `set` соответствует методу с такой же список формальных параметров, как индексатор, а также дополнительный параметр метода доступа индексатора с именем `value`.
*  Это ошибка времени компиляции для метода доступа индексатора для объявления локальной переменной с тем же именем, что и параметр индексатора.
*  В Переопределяющее объявление свойства, наследуемое свойство осуществляется с помощью синтаксиса `base.P`, где `P` является именем свойства. В индексатор объявление переопределения наследуемых индексатор осуществляется с помощью синтаксиса `base[E]`, где `E` — это список выражений с разделителями-запятыми.
*  Отсутствует понятие «автоматически реализованного индексатора». Является ошибкой иметь абстрактным, не внешние индексатора с помощью методов доступа точкой с запятой.

Помимо этих различий, все правила, определенные в [методы доступа](classes.md#accessors) и [автоматически реализуемые свойства](classes.md#automatically-implemented-properties) применяются к методам доступа индексаторов также для доступа к свойствам.

Если объявление индексатора содержит `extern` модификатор, индексатор считается ***внешних индексатора***. Поскольку объявление внешнего индексатора не предоставляет фактической реализации, каждый из его *accessor_declarations* состоит из точки с запятой.

В приведенном ниже примере объявляется `BitArray` класса, реализующего индексатор для доступа к отдельным битам в битовом массиве.
```csharp
using System;

class BitArray
{
    int[] bits;
    int length;

    public BitArray(int length) {
        if (length < 0) throw new ArgumentException();
        bits = new int[((length - 1) >> 5) + 1];
        this.length = length;
    }

    public int Length {
        get { return length; }
    }

    public bool this[int index] {
        get {
            if (index < 0 || index >= length) {
                throw new IndexOutOfRangeException();
            }
            return (bits[index >> 5] & 1 << index) != 0;
        }
        set {
            if (index < 0 || index >= length) {
                throw new IndexOutOfRangeException();
            }
            if (value) {
                bits[index >> 5] |= 1 << index;
            }
            else {
                bits[index >> 5] &= ~(1 << index);
            }
        }
    }
}
```

Экземпляр `BitArray` класса занимает значительно меньше памяти, чем соответствующий `bool[]` (так как каждое значение первого занимает только один бит, а не последнее – один байт), но позволяет выполнять те же операции `bool[]`.

Следующие `CountPrimes` класс использует `BitArray` и классические алгоритма «решето» для вычисления количества простых чисел от 1 до заданного максимального:
```csharp
class CountPrimes
{
    static int Count(int max) {
        BitArray flags = new BitArray(max + 1);
        int count = 1;
        for (int i = 2; i <= max; i++) {
            if (!flags[i]) {
                for (int j = i * 2; j <= max; j += i) flags[j] = true;
                count++;
            }
        }
        return count;
    }

    static void Main(string[] args) {
        int max = int.Parse(args[0]);
        int count = Count(max);
        Console.WriteLine("Found {0} primes between 1 and {1}", count, max);
    }
}
```

Обратите внимание, что синтаксис для доступа к элементам `BitArray` именно так же, как `bool[]`.

В следующем примере показан класс сетки 26 * 10 с индексатором с двумя параметрами. Первый параметр должен быть верхнего или нижнего регистра в диапазоне A-Z, а второй должен быть целым числом в диапазоне 0 – 9.

```csharp
using System;

class Grid
{
    const int NumRows = 26;
    const int NumCols = 10;

    int[,] cells = new int[NumRows, NumCols];

    public int this[char c, int col] {
        get {
            c = Char.ToUpper(c);
            if (c < 'A' || c > 'Z') {
                throw new ArgumentException();
            }
            if (col < 0 || col >= NumCols) {
                throw new IndexOutOfRangeException();
            }
            return cells[c - 'A', col];
        }

        set {
            c = Char.ToUpper(c);
            if (c < 'A' || c > 'Z') {
                throw new ArgumentException();
            }
            if (col < 0 || col >= NumCols) {
                throw new IndexOutOfRangeException();
            }
            cells[c - 'A', col] = value;
        }
    }
}
```

### <a name="indexer-overloading"></a>Перегрузка индексатора

Правила разрешения перегрузки индексаторов описаны в [вывод типа](expressions.md#type-inference).

## <a name="operators"></a>Операторы

***Оператор*** является членом, который определяет значение оператора выражения, которые могут применяться к экземплярам класса. Операторы объявляются с помощью *operator_declaration*s:

```antlr
operator_declaration
    : attributes? operator_modifier+ operator_declarator operator_body
    ;

operator_modifier
    : 'public'
    | 'static'
    | 'extern'
    | operator_modifier_unsafe
    ;

operator_declarator
    : unary_operator_declarator
    | binary_operator_declarator
    | conversion_operator_declarator
    ;

unary_operator_declarator
    : type 'operator' overloadable_unary_operator '(' type identifier ')'
    ;

overloadable_unary_operator
    : '+' | '-' | '!' | '~' | '++' | '--' | 'true' | 'false'
    ;

binary_operator_declarator
    : type 'operator' overloadable_binary_operator '(' type identifier ',' type identifier ')'
    ;

overloadable_binary_operator
    : '+'   | '-'   | '*'   | '/'   | '%'   | '&'   | '|'   | '^'   | '<<'
    | 'right_shift' | '=='  | '!='  | '>'   | '<'   | '>='  | '<='
    ;

conversion_operator_declarator
    : 'implicit' 'operator' type '(' type identifier ')'
    | 'explicit' 'operator' type '(' type identifier ')'
    ;

operator_body
    : block
    | '=>' expression ';'
    | ';'
    ;
```

Существует три категории перегружаемых операторов: унарные операторы ([унарные операторы](classes.md#unary-operators)), бинарные операторы ([бинарные операторы](classes.md#binary-operators)) и операторы преобразования ([операторы преобразования ](classes.md#conversion-operators)).

*Operator_body* либо точкой с запятой, ***тела оператора*** или ***тело выражения***. Состоит из тела оператора *блок*, который задает операторы, выполняемые при вызове оператора. *Блок* должны соответствовать правилам для возвращающих значения методов, описанных в [тело метода](classes.md#method-body). Тело выражения состоит из `=>` за которым следует выражение и точку с запятой и обозначает одно выражение для выполнения при вызове этого оператора.

Для `extern` операторы, *operator_body* состоит просто из точки с запятой. Для всех других операторов *operator_body* тело блока или тело выражения.

Следующие правила применяются ко всем объявлениям оператор.

*  В объявлении оператора должен содержать два `public` и `static` модификатор.
*  Параметры оператора должны быть параметрами значений ([параметры по значению](variables.md#value-parameters)). Произошла ошибка во время компиляции, оператор объявления для указания `ref` или `out` параметров.
*  Сигнатура оператора ([унарные операторы](classes.md#unary-operators), [бинарные операторы](classes.md#binary-operators), [операторы преобразования](classes.md#conversion-operators)) должен отличаться от сигнатур все операторы, объявленные в того же класса.
*  Все типы, упоминаемые в объявлении оператора должен быть по крайней мере такой же уровень доступности, как и сам оператор ([ограничения доступности](basic-concepts.md#accessibility-constraints)).
*  Является ошибкой один и тот же модификатор встречается несколько раз в объявлении оператора.

Каждая категория операторов налагаются дополнительные ограничения, как описано в следующих разделах.

Как и другие члены операторы, объявленные в базовом классе, наследуются производными классами. Поскольку объявления операторов всегда требуют класса или структуры, в котором объявлен оператор, для участия в сигнатуре оператор, он не поддерживается оператор объявлен в производном классе может скрыть оператор, объявленный в базовом классе. Таким образом `new` модификатор никогда не требуется и поэтому никогда не допускается в объявлении оператора.

Дополнительные сведения о унарные и бинарные операторы можно найти в [операторы](expressions.md#operators).

Дополнительные сведения об операторах преобразования можно найти в [заданные пользователем преобразования](conversions.md#user-defined-conversions).

### <a name="unary-operators"></a>Унарные операторы

Применяются следующие правила для унарного оператора объявления, где `T` обозначает тип экземпляра класса или структуры, который содержит объявление оператора:

*  Унарное `+`, `-`, `!`, или `~` оператор должен принимать один параметр типа `T` или `T?` и могут возвращать любой тип.
*  Унарное `++` или `--` оператор должен принимать один параметр типа `T` или `T?` и должен возвращать что же тип или тип, производный от него.
*  Унарное `true` или `false` оператор должен принимать один параметр типа `T` или `T?` и должен возвращать тип `bool`.

Подпись унарного оператора состоит из лексема оператора (`+`, `-`, `!`, `~`, `++`, `--`, `true`, или `false`) и одним формальным параметром типа. Тип возвращаемого значения не является частью сигнатуры унарного оператора, ни имя формального параметра.

`true` И `false` унарные операторы требуется попарное объявление. Ошибка времени компиляции возникает, если класс объявляет один из этих операторов без объявления другого. `true` И `false` операторы описаны далее в [пользовательские условные логические операторы](expressions.md#user-defined-conditional-logical-operators) и [логических выражений](expressions.md#boolean-expressions).

В следующем примере показано, реализация и последующее применение `operator ++` для класса целочисленного вектора:
```csharp
public class IntVector
{
    public IntVector(int length) {...}

    public int Length {...}                 // read-only property

    public int this[int index] {...}        // read-write indexer

    public static IntVector operator ++(IntVector iv) {
        IntVector temp = new IntVector(iv.Length);
        for (int i = 0; i < iv.Length; i++)
            temp[i] = iv[i] + 1;
        return temp;
    }
}

class Test
{
    static void Main() {
        IntVector iv1 = new IntVector(4);    // vector of 4 x 0
        IntVector iv2;

        iv2 = iv1++;    // iv2 contains 4 x 0, iv1 contains 4 x 1
        iv2 = ++iv1;    // iv2 contains 4 x 2, iv1 contains 4 x 2
    }
}
```

Обратите внимание на то, как метод оператора возвращает значение, полученное путем прибавления единицы к операнду, так же, как постфиксного инкремента и декремента ([постфиксных инкремента и декремента](expressions.md#postfix-increment-and-decrement-operators)) и префикс инкремента и декремента операторы ([префиксный инкремент и декремент операторы](expressions.md#prefix-increment-and-decrement-operators)). В отличие от в C++, этот метод нужен не изменяйте значение своего операнда напрямую. На самом деле изменение значения операнда нарушило бы стандартной семантики постфиксного оператора инкремента.

### <a name="binary-operators"></a>Бинарные операторы

Применяются следующие правила для бинарного оператора объявления, где `T` обозначает тип экземпляра класса или структуры, который содержит объявление оператора:

*  Бинарный оператор сдвига не должно принимать два параметра, по крайней мере один из которых должен иметь тип `T` или `T?`и могут возвращать любой тип.
*  Двоичный файл `<<` или `>>` оператор должен принимать два параметра, первая из которых должен иметь тип `T` или `T?` и второй из которых должен иметь тип `int` или `int?`и могут возвращать любой тип.

Подпись бинарного оператора состоит из лексема оператора (`+`, `-`, `*`, `/`, `%`, `&`, `|`, `^`, `<<`, `>>`, `==`, `!=`, `>`, `<`, `>=`, или `<=`) и типы двух формальных параметров. Тип возвращаемого значения и имена формальных параметров не являются частью сигнатуры бинарного оператора.

Для некоторых бинарных операторов требуется попарное объявление. Для каждого объявления одного из операторов пары необходимо соответствующее объявление оператора другие пары. Два объявления оператора совпадать, если они имеют тот же тип возвращаемого значения и тот же тип для каждого параметра. Следующие операторы требуется попарное объявление:

*  `operator ==` и `operator !=`
*  `operator >` и `operator <`
*  `operator >=` и `operator <=`

### <a name="conversion-operators"></a>Операторы преобразования

Объявление оператора преобразования вводит ***определенное пользователем преобразование*** ([заданные пользователем преобразования](conversions.md#user-defined-conversions)) которое дополняет предопределенные явные и неявные преобразования.

Объявление оператора преобразования, который включает в себя `implicit` ключевое слово представляет неявное преобразование, определяемые пользователем. Неявные преобразования могут происходить в разнообразных ситуациях, включая вызовы членов функций, выражения приведения и назначения. Это описано далее в [неявные преобразования](conversions.md#implicit-conversions).

Объявление оператора преобразования, который включает в себя `explicit` ключевое слово представляет явное преобразование, определяемые пользователем. Явные преобразования могут возникать в выражения приведения, а также описаны далее в [явные преобразования](conversions.md#explicit-conversions).

Оператор преобразования преобразует из исходного типа, указанного по типу параметра оператор преобразования в целевой тип, указанный типом возвращаемого значения оператора преобразования.

Для заданного исходного типа `S` и целевого типа `T`, если `S` или `T` являются обнуляемые типы позволяют `S0` и `T0` называть их базовые типы, в противном случае `S0` и `T0` являются равным `S` и `T` соответственно. Класс или структура может объявлять преобразование из типа источника `S` с целевым типом `T` только в том случае, если выполняются все следующие условия:

*  `S0` и `T0` различных типов.
*  Либо `S0` или `T0` — это тип класса или структуры, в котором происходит объявление оператора.
*  Ни `S0` , ни `T0` — *interface_type*.
*  За исключением определенных пользователем преобразований, не существует преобразования из `S` для `T` или из `T` для `S`.

В рамках этих правил, любой тип, параметры, связанные с `S` или `T` считаются уникальных типов, имеющих отсутствует отношение наследования с другими типами и все ограничения на тип, эти параметры игнорируются.

В примере
```csharp
class C<T> {...}

class D<T>: C<T>
{
    public static implicit operator C<int>(D<T> value) {...}      // Ok
    public static implicit operator C<string>(D<T> value) {...}   // Ok
    public static implicit operator C<T>(D<T> value) {...}        // Error
}
```
Первые два объявления операторов разрешены, так, как в рамках [индексаторы](classes.md#indexers).3, `T` и `int` и `string` соответственно, считаются уникальными типами без отношений. Тем не менее, третий оператор является ошибкой, так как `C<T>` является базовым классом для `D<T>`.

Из второго правила следует, что оператор преобразования необходимо преобразовать в или из типа класса или структуры, в котором объявлен оператор. К примеру, это возможно для типа класса или структуры `C` определить преобразование из `C` для `int` и из `int` для `C`, но не из `int` для `bool`.

Это не невозможно непосредственно переопределить предопределенное преобразование. Таким образом, операторы преобразования не допускаются для преобразования в или из него `object` так, как явные и неявные преобразования, уже существующих между `object` и всех других типов. Аналогичным образом ни источник, ни типы целевых объектов преобразования может быть базовый тип, поскольку преобразование уже существует.

Тем не менее можно объявить операторы в универсальных типах, которые для определенного типа аргументов, указать преобразования, которые уже существуют в качестве предварительно определенных преобразований. В примере
```csharp
struct Convertible<T>
{
    public static implicit operator Convertible<T>(T value) {...}
    public static explicit operator T(Convertible<T> value) {...}
}
```
Если тип `object` указывается как аргумент типа для `T`, второй оператор объявляет преобразование, которое уже существует (неявным и поэтому также явно, существует преобразования из любой тип `object`).

В случаях, где существует предопределенное преобразование между двумя типами пропускаются любые заданные пользователем преобразования между этими типами. В частности:

*  Если предопределенное неявное преобразование ([неявные преобразования](conversions.md#implicit-conversions)) из типа `S` ввода `T`, все заданные пользователем преобразования (неявные или явные) из `S` для `T` игнорируются.
*  Если предварительно определенных явное преобразование ([явные преобразования](conversions.md#explicit-conversions)) из типа `S` ввода `T`, пользовательские явные преобразования из `S` для `T` игнорируются. Более того:

Если `T` является типом интерфейса, определяемые пользователем неявные преобразования из `S` для `T` игнорируются.

В противном случае — определяемые пользователем неявные преобразования из `S` для `T` по-прежнему считаются.

Для всех типов, но `object`, операторы, объявленные `Convertible<T>` выше тип не конфликтуют с предварительно определенных преобразований. Пример:
```csharp
void F(int i, Convertible<int> n) {
    i = n;                          // Error
    i = (int)n;                     // User-defined explicit conversion
    n = i;                          // User-defined implicit conversion
    n = (Convertible<int>)i;        // User-defined implicit conversion
}
```

Тем не менее, для типа `object`, предопределенные преобразования скрывают пользовательские преобразования в случаях все, кроме одного:

```csharp
void F(object o, Convertible<object> n) {
    o = n;                         // Pre-defined boxing conversion
    o = (object)n;                 // Pre-defined boxing conversion
    n = o;                         // User-defined implicit conversion
    n = (Convertible<object>)o;    // Pre-defined unboxing conversion
}
```

Заданные пользователем преобразования не допускаются для преобразования в или из него *interface_type*s. В частности, это ограничение гарантирует, что без пользовательских преобразований возникают при преобразовании в *interface_type*и что преобразование *interface_type* завершается успешно только в том случае, если объект Преобразуемый действительно реализует указанный *interface_type*.

Сигнатура оператора преобразования состоит из типа источника и целевого типа. (Обратите внимание, что это единственная форма, для которого тип возвращаемого значения участвует в сигнатуре члена). `implicit` Или `explicit` классификации оператора преобразования не является частью сигнатуры оператора. Таким образом, класс или структура не допускает объявления обоих `implicit` и `explicit` оператор преобразования с теми же типами исходной и целевой.

Как правило определяемые пользователем неявные преобразования должны разрабатываться никогда не вызывать исключения и не должны терять данные. Если определенное пользователем преобразование может привести к появлению исключения (например, так как исходный аргумент выходит за пределы диапазона) или потере данных (например, Отмена старшие разряды), то такое преобразование должен быть определен как явное преобразование.

В примере
```csharp
using System;

public struct Digit
{
    byte value;

    public Digit(byte value) {
        if (value < 0 || value > 9) throw new ArgumentException();
        this.value = value;
    }

    public static implicit operator byte(Digit d) {
        return d.value;
    }

    public static explicit operator Digit(byte b) {
        return new Digit(b);
    }
}
```
преобразование из `Digit` для `byte` является неявным, так как она никогда не создает исключения или теряет информацию, но преобразование из `byte` для `Digit` является явным с момента `Digit` может представлять только подмножество возможных значения `byte`.

## <a name="instance-constructors"></a>Конструкторы экземпляров

***Конструктор экземпляра*** является членом, который реализует действия для инициализации нового экземпляра класса. Конструкторы экземпляров объявляются с помощью *constructor_declaration*s:

```antlr
constructor_declaration
    : attributes? constructor_modifier* constructor_declarator constructor_body
    ;

constructor_modifier
    : 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'extern'
    | constructor_modifier_unsafe
    ;

constructor_declarator
    : identifier '(' formal_parameter_list? ')' constructor_initializer?
    ;

constructor_initializer
    : ':' 'base' '(' argument_list? ')'
    | ':' 'this' '(' argument_list? ')'
    ;

constructor_body
    : block
    | ';'
    ;
```

Объект *constructor_declaration* может включать набор *атрибуты* ([атрибуты](attributes.md)), является допустимым сочетанием четырех модификаторов доступа ([модификаторы доступа ](classes.md#access-modifiers)) и `extern` ([внешние методы](classes.md#external-methods)) модификатор. Объявление конструктора запрещено включать один и тот же модификатор несколько раз.

*Идентификатор* из *constructor_declarator* должен указывать имя класса, в котором объявлен конструктор экземпляра. Если указано любое другое имя, происходит ошибка времени компиляции.

Необязательный *formal_parameter_list* экземпляра конструктор подчиняется тем же правилам, что *formal_parameter_list* метода ([методы](classes.md#methods)). Список формальных параметров определяет подпись ([сигнатуры и перегрузка](basic-concepts.md#signatures-and-overloading)) конструктора экземпляра и управляет процессом, при котором разрешение перегрузки ([вывод типа](expressions.md#type-inference)) выбирает определенный конструктор экземпляра в вызове.

Каждый из типов, на которые ссылается *formal_parameter_list* экземпляра конструктор не должен иметь по крайней мере такой же уровень доступности, как и сам конструктор ([ограничения доступности](basic-concepts.md#accessibility-constraints)).

Необязательный *constructor_initializer* указывает другой конструктор экземпляров для вызова перед выполнением инструкции, приведенные в *constructor_body* этого конструктора экземпляра. Это описано далее в [инициализаторы конструктора](classes.md#constructor-initializers).

Если объявление конструктора содержит `extern` модификатор, конструктор считается ***внешнего конструктора***. Поскольку объявление внешнего конструктора не предоставляет фактической реализации, его *constructor_body* состоит из точки с запятой. Для других конструкторов *constructor_body* состоит из *блок* которого указывает операторы для инициализации нового экземпляра класса. Это в точности соответствует *блок* экземпляр метода с `void` тип возвращаемого значения ([тело метода](classes.md#method-body)).

Конструкторы экземпляров не наследуются. Таким образом класс не имеет конструкторов экземпляров не фактически объявленных в классе. Если класс содержит объявления конструкторов не экземпляра, автоматически предоставляется конструктор экземпляра по умолчанию ([конструкторы по умолчанию](classes.md#default-constructors)).

Конструкторы экземпляров вызываются *object_creation_expression*s ([выражения создания объектов](expressions.md#object-creation-expressions)) и проходят через *constructor_initializer*s.

### <a name="constructor-initializers"></a>Инициализаторы конструктора

Все конструкторы экземпляров (за исключением тех, для класса `object`) непосредственно перед неявно включать вызов другого конструктора экземпляра *constructor_body*. Конструктор для вызова неявно определяется *constructor_initializer*:

*  Инициализатор конструктора экземпляра формы `base(argument_list)` или `base()` вызывает конструктор экземпляров от прямого базового класса для вызова. Этот конструктор выбирается с помощью *argument_list* Если присутствует и правил разрешения перегрузки [разрешение перегрузки](expressions.md#overload-resolution). Набор кандидатов конструкторов экземпляров содержит все доступные конструкторы экземпляров содержится в прямой базовый класс, или конструктор по умолчанию ([конструкторы по умолчанию](classes.md#default-constructors)), если конструкторы экземпляров не объявляются в прямой базовый класс. Если этот набор пуст или не может быть определен один лучший конструктор экземпляра, возникает ошибка времени компиляции.
*  Инициализатор конструктора экземпляра формы `this(argument-list)` или `this()` вызывает конструктор экземпляра непосредственно для вызова в классе. Конструктор выбирается с помощью *argument_list* Если присутствует и правил разрешения перегрузки [разрешение перегрузки](expressions.md#overload-resolution). Набор кандидатов конструкторов экземпляров состоит из всех доступный экземпляр конструкторов, объявленных в самом классе. Если этот набор пуст или не может быть определен один лучший конструктор экземпляра, возникает ошибка времени компиляции. Если объявление конструктора экземпляра включает инициализатор конструктора, который вызывает сам конструктор, возникает ошибка времени компиляции.

Если у конструктора экземпляра нет инициализатора конструктора, инициализатор конструктора формы `base()` неявно предоставляется. Таким образом объявление конструктора экземпляра формы
```csharp
C(...) {...}
```
полностью эквивалентен
```csharp
C(...): base() {...}
```

Область параметров, заданных *formal_parameter_list* конструктора экземпляра объявление включает в себя инициализатор конструктора этого объявления. Таким образом инициализатор конструктора разрешен доступ к параметрам вызываемого конструктора. Пример:
```csharp
class A
{
    public A(int x, int y) {}
}

class B: A
{
    public B(int x, int y): base(x + y, x - y) {}
}
```

Инициализатор конструктора экземпляров не может получить доступ к создаваемому экземпляру. Таким образом, является ошибкой во время компиляции для ссылки на `this` в выражении аргумента инициализатора конструктора, как это ошибка времени компиляции для при вычислении выражения аргумента для ссылки на любой другой член экземпляра через *simple_name*.

### <a name="instance-variable-initializers"></a>Инициализаторы переменных экземпляров

Когда у конструктора экземпляра нет инициализатора конструктора или содержит инициализатор конструктора формы `base(...)`, этот конструктор неявно выполняет операции инициализации, заданные по *variable_initializer*процесса поля экземпляра, объявленные в классе. Это соответствует последовательности назначений, которые выполняются сразу же после входа в конструктор и перед неявным вызовом конструктора прямого базового класса. Инициализаторы переменных выполняются в порядке, в котором они появляются в объявлении класса.

### <a name="constructor-execution"></a>Выполнение конструктора

Инициализаторы переменных преобразуются в операторы присваивания, и эти операторы присваивания выполняются перед вызовом конструктора базового класса экземпляра. Такой порядок гарантирует, что все поля экземпляра инициализируются их инициализаторами переменных до выполнения любых операторов, которые имеют доступ к этому экземпляру.

Пример
```csharp
using System;

class A
{
    public A() {
        PrintFields();
    }

    public virtual void PrintFields() {}
}

class B: A
{
    int x = 1;
    int y;

    public B() {
        y = -1;
    }

    public override void PrintFields() {
        Console.WriteLine("x = {0}, y = {1}", x, y);
    }
}
```
Когда `new B()` используется для создания экземпляра `B`, получается следующий результат:
```
x = 1, y = 0
```

Значение `x` -1, поскольку инициализатор переменной выполняется до вызова конструктора базового класса экземпляра. Тем не менее значение `y` равно 0 (значение по умолчанию `int`) так как назначение `y` не выполняется до после возвращения в конструктор базового класса.

Это можно представить инициализаторы переменных экземпляров и инициализаторы конструктора как операторы, которые автоматически вставляются перед *constructor_body*. Пример
```csharp
using System;
using System.Collections;

class A
{
    int x = 1, y = -1, count;

    public A() {
        count = 0;
    }

    public A(int n) {
        count = n;
    }
}

class B: A
{
    double sqrt2 = Math.Sqrt(2.0);
    ArrayList items = new ArrayList(100);
    int max;

    public B(): this(100) {
        items.Add("default");
    }

    public B(int n): base(n - 1) {
        max = n;
    }
}
```
содержит несколько инициализаторов переменных; Он также содержит инициализаторы конструктора в обеих формах (`base` и `this`). Этот пример соответствует код, показанный ниже, где каждый комментарий указывает автоматически вставленный оператор (синтаксис, используемый для вызовов автоматически вставленный конструктора является недопустимым, но служит только для иллюстрации механизма).

```csharp
using System.Collections;

class A
{
    int x, y, count;

    public A() {
        x = 1;                       // Variable initializer
        y = -1;                      // Variable initializer
        object();                    // Invoke object() constructor
        count = 0;
    }

    public A(int n) {
        x = 1;                       // Variable initializer
        y = -1;                      // Variable initializer
        object();                    // Invoke object() constructor
        count = n;
    }
}

class B: A
{
    double sqrt2;
    ArrayList items;
    int max;

    public B(): this(100) {
        B(100);                      // Invoke B(int) constructor
        items.Add("default");
    }

    public B(int n): base(n - 1) {
        sqrt2 = Math.Sqrt(2.0);      // Variable initializer
        items = new ArrayList(100);  // Variable initializer
        A(n - 1);                    // Invoke A(int) constructor
        max = n;
    }
}
```

### <a name="default-constructors"></a>Конструкторы по умолчанию

Если класс содержит объявления конструкторов не экземпляра, автоматически предоставляется конструктор экземпляра по умолчанию. Конструктор по умолчанию просто вызывает конструктор без параметров прямого базового класса. Если этот класс является абстрактным, защищена объявленный уровень доступности для конструктора по умолчанию. В противном случае объявленный уровень доступности для конструктора по умолчанию является открытым. Таким образом конструктор по умолчанию всегда указывается в формате

```csharp
protected C(): base() {}
```
или
```csharp
public C(): base() {}
```
где `C` — это имя класса. Если разрешение перегрузки не удалось определить уникальный лучшим кандидатом для инициализатора конструктора базового класса возникает ошибка времени компиляции.

В примере
```csharp
class Message
{
    object sender;
    string text;
}
```
конструктор по умолчанию предоставляется в том случае, поскольку класс не содержит экземпляр объявления конструкторов. Таким образом пример является точным эквивалентом
```csharp
class Message
{
    object sender;
    string text;

    public Message(): base() {}
}
```

### <a name="private-constructors"></a>Закрытые конструкторы

Если в классе `T` объявляет только закрытые конструкторы экземпляров, невозможно для классов за пределами текста программы `T` для наследования от `T` или напрямую создавать экземпляры `T`. Таким образом Если класс содержит только статические члены и не предназначен для создания экземпляра, Добавление пустой закрытый конструктор экземпляров предотвратит создание экземпляров. Пример:
```csharp
public class Trig
{
    private Trig() {}        // Prevent instantiation

    public const double PI = 3.14159265358979323846;

    public static double Sin(double x) {...}
    public static double Cos(double x) {...}
    public static double Tan(double x) {...}
}
```

`Trig` Класс группирует связанные методы и константы, но не предназначен для создания экземпляра. Поэтому он объявляет единственных пустой частный конструктор. Хотя бы один экземпляр конструктор должен быть объявлен таким образом, чтобы отключить автоматическое создание конструктора по умолчанию.

### <a name="optional-instance-constructor-parameters"></a>Необязательные параметры конструктора экземпляров

`this(...)` Инициализатора конструктора обычно используется в сочетании с перегрузкой для реализации необязательных параметров конструктора экземпляров. В примере
```csharp
class Text
{
    public Text(): this(0, 0, null) {}

    public Text(int x, int y): this(x, y, null) {}

    public Text(int x, int y, string s) {
        // Actual constructor implementation
    }
}
```
Первый конструкторы два экземпляра просто предоставить значения по умолчанию для отсутствующие аргументы. Используют `this(...)` инициализатора конструктора для вызова Третий конструктор экземпляра, который фактически выполняет работу по инициализации нового экземпляра. Это действие соответствует необязательных параметров конструктора:
```csharp
Text t1 = new Text();                    // Same as Text(0, 0, null)
Text t2 = new Text(5, 10);               // Same as Text(5, 10, null)
Text t3 = new Text(5, 20, "Hello");
```

## <a name="static-constructors"></a>Статические конструкторы

Объект ***статический конструктор*** является членом, который реализует действия, необходимые для инициализации закрытого типа класса. Статические конструкторы объявляются с помощью *static_constructor_declaration*s:

```antlr
static_constructor_declaration
    : attributes? static_constructor_modifiers identifier '(' ')' static_constructor_body
    ;

static_constructor_modifiers
    : 'extern'? 'static'
    | 'static' 'extern'?
    | static_constructor_modifiers_unsafe
    ;

static_constructor_body
    : block
    | ';'
    ;
```

Объект *static_constructor_declaration* может включать набор *атрибуты* ([атрибуты](attributes.md)) и `extern` модификатор ([внешние методы](classes.md#external-methods)).

*Идентификатор* из *static_constructor_declaration* должен указывать имя класса, в котором объявлен статический конструктор. Если указано любое другое имя, происходит ошибка времени компиляции.

Если объявление статического конструктора содержит `extern` модификатор, статический конструктор называется ***внешних статический конструктор***. Поскольку объявление внешнего статического конструктора не предоставляет фактической реализации, его *static_constructor_body* состоит из точки с запятой. Для всех объявлений статический конструктор *static_constructor_body* состоит из *блок* которого указывает операторы для инициализации класса. Это в точности соответствует *method_body* статического метода с `void` тип возвращаемого значения ([тело метода](classes.md#method-body)).

Статические конструкторы не наследуются и не может вызываться напрямую.

Статический конструктор для закрытого типа класса выполняет не более одного раза в домене данного приложения. Выполнение статического конструктора запускается первым из следующих событий в домене приложения:

*  Создать экземпляр типа класса.
*  Статические члены типа класса ссылки.

Если класс содержит `Main` метод ([запуск приложения](basic-concepts.md#application-startup)), в котором начинается исполнение, статический конструктор для этого класса выполняется перед `Main` вызывается метод.

Для инициализации нового закрытого типа класса, сначала новый набор статических полей ([экземпляра и статические поля](classes.md#static-and-instance-fields)) для создания этого закрытого типа. Все статические поля устанавливается равным значению по умолчанию ([значения по умолчанию](variables.md#default-values)). Далее, инициализаторы статических полей ([инициализации статического поля](classes.md#static-field-initialization)) выполняются этих статических полей. Наконец выполняется статический конструктор.

Пример
```csharp
using System;

class Test
{
    static void Main() {
        A.F();
        B.F();
    }
}

class A
{
    static A() {
        Console.WriteLine("Init A");
    }
    public static void F() {
        Console.WriteLine("A.F");
    }
}

class B
{
    static B() {
        Console.WriteLine("Init B");
    }
    public static void F() {
        Console.WriteLine("B.F");
    }
}
```
должен создавать выходные данные:
```
Init A
A.F
Init B
B.F
```
так как выполнение `A`в статический конструктор инициируется вызов `A.F`и выполнение `B`в статический конструктор инициируется вызов `B.F`.

Имеется возможность создать циклические зависимости, позволяющие статические поля с инициализаторами переменных в их состоянии значения по умолчанию.

Пример
```csharp
using System;

class A
{
    public static int X;

    static A() {
        X = B.Y + 1;
    }
}

class B
{
    public static int Y = A.X + 1;

    static B() {}

    static void Main() {
        Console.WriteLine("X = {0}, Y = {1}", A.X, B.Y);
    }
}
```
выводятся следующие выходные данные
```
X = 1, Y = 2
```

Для выполнения `Main` метода, система сначала выполняет инициализатор для `B.Y`до того, как класс `B`в статическом конструкторе. `Y`в инициализатор вызывает `A`в статический конструктор для запуска, так как значение `A.X` на который приведена ссылка. Статический конструктор `A` в свою очередь продолжает вычислять значение `X`и извлекает при этом значение по умолчанию `Y`, которое равно нулю. `A.X` При этом инициализируется значением 1. Процесс выполнения `A`Инициализаторы статических полей и статического конструктора, а затем завершается, возвращая к вычислению начальное значение `Y`, результат которого становится 2.

Так как статический конструктор выполняется только один раз для каждого закрыто сформированного типа класса, это удобно для принудительного применения проверки времени выполнения, которые не удается проверить во время компиляции с помощью ограничения параметра типа ([параметр типа ограничения](classes.md#type-parameter-constraints)). Например следующий тип использует статический конструктор для принудительного применения, что аргумент типа является перечислением:
```csharp
class Gen<T> where T: struct
{
    static Gen() {
        if (!typeof(T).IsEnum) {
            throw new ArgumentException("T must be an enum");
        }
    }
}
```

## <a name="destructors"></a>Деструкторы

Объект ***деструктор*** является членом, который реализует действия для уничтожения экземпляра класса. Деструктор был объявлен с помощью *destructor_declaration*:

```antlr
destructor_declaration
    : attributes? 'extern'? '~' identifier '(' ')' destructor_body
    | destructor_declaration_unsafe
    ;

destructor_body
    : block
    | ';'
    ;
```

Объект *destructor_declaration* может включать набор *атрибуты* ([атрибуты](attributes.md)).

*Идентификатор* из *destructor_declaration* должен указывать имя класса, в котором объявлен деструктор. Если указано любое другое имя, происходит ошибка времени компиляции.

Если объявление деструктора содержит `extern` модификатор, деструктор считается ***внешних деструктор***. Поскольку объявление внешнего деструктора не предоставляет фактической реализации, его *destructor_body* состоит из точки с запятой. Для всех других деструкторах *destructor_body* состоит из *блок* определяющий операторы, выполняемые для уничтожения экземпляра класса. Объект *destructor_body* в точности соответствует *method_body* экземпляр метода с `void` тип возвращаемого значения ([тело метода](classes.md#method-body)).

Деструкторы не наследуются. Таким образом класс имеет никакие деструкторы, отличном от того, который может быть объявлен в этом классе.

Так как деструктор должен не имеют параметров, не может быть перегружен, поэтому класс можно использовать максимум, один деструктор.

Деструкторы вызываются автоматически и не может вызываться явным образом. Экземпляр становится пригодным для уничтожения, когда он больше не любой код может использовать этот экземпляр. Выполнение деструктора для экземпляра может произойти в любое время после он становится пригодным для уничтожения. Если экземпляр уничтожается, вызываются деструкторы в цепочке наследования этого экземпляра, в порядке, от большинства производного к младшему. Деструктор может выполняться в любом потоке. Дальнейшее обсуждение правил, определяющих, когда и как выполняется деструктор, см. в разделе [автоматическое управление памятью](basic-concepts.md#automatic-memory-management).

Выходные данные примера
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("A's destructor");
    }
}

class B: A
{
    ~B() {
        Console.WriteLine("B's destructor");
    }
}

class Test
{
   static void Main() {
        B b = new B();
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
   }
}
```
является
```
B's destructor
A's destructor
```
Поскольку деструкторы в цепочке наследования вызываются в порядке, от большинства производного к младшему.

Деструкторы реализуются путем переопределения виртуального метода `Finalize` на `System.Object`. Программы на C# не могут переопределять этот метод или вызывать его (или его переопределения) непосредственно. Например программа
```csharp
class A 
{
    override protected void Finalize() {}    // error

    public void F() {
        this.Finalize();                     // error
    }
}
```
содержит две ошибки.

Компилятор действует так, будто этот метод и переопределений, вообще не существуют. Таким образом эта программа:
```csharp
class A 
{
    void Finalize() {}                            // permitted
}
```
является допустимым, и метод показано скрытие `System.Object` `Finalize` метод.

Описание поведения при возникновении исключения из деструктора, см. в разделе [обработке исключений](exceptions.md#how-exceptions-are-handled).

## <a name="iterators"></a>Итераторы

Функция-член ([функции-члены](expressions.md#function-members)) реализованы с помощью блока итератора ([блоки](statements.md#blocks)) называется ***итератор***.

Блока итератора может использоваться в теле функции-члена, до тех пор, пока тип возвращаемого значения соответствующего члена функции является одним из интерфейсов перечислителя ([интерфейсы перечислителя](classes.md#enumerator-interfaces)) или один из IEnumerable-интерфейс ([Перечисляемые интерфейсы](classes.md#enumerable-interfaces)). Он может использоваться как *method_body*, *operator_body* или *accessor_body*, тогда как события, конструкторы экземпляров, статические конструкторы и деструкторы не может быть реализованы как итераторы.

Когда функция-член реализуется с помощью блока итератора, это ошибка времени компиляции для списка формальных параметров функции-члена, задающих `ref` или `out` параметров.

### <a name="enumerator-interfaces"></a>Интерфейсы перечислителя

***Интерфейсы перечислителя*** являются неуниверсальный интерфейс `System.Collections.IEnumerator` и всех экземпляров универсального интерфейса `System.Collections.Generic.IEnumerator<T>`. Для краткости в этой главе эти интерфейсы ссылаются как на `IEnumerator` и `IEnumerator<T>`, соответственно.

### <a name="enumerable-interfaces"></a>IEnumerable-интерфейс

***Перечисляемые интерфейсы*** являются неуниверсальный интерфейс `System.Collections.IEnumerable` и всех экземпляров универсального интерфейса `System.Collections.Generic.IEnumerable<T>`. Для краткости в этой главе эти интерфейсы ссылаются как на `IEnumerable` и `IEnumerable<T>`, соответственно.

### <a name="yield-type"></a>Тип результата

Итератор, который создает последовательность значений одного типа. Этот тип называется ***yield тип*** итератора.

*  Тип итератора, который возвращает yield `IEnumerator` или `IEnumerable` является `object`.
*  Тип итератора, который возвращает yield `IEnumerator<T>` или `IEnumerable<T>` является `T`.

### <a name="enumerator-objects"></a>Объекты перечислителя

Когда функция-член, возвращающую перечислитель тип интерфейса реализуется с помощью блока итератора, вызова функции-члена не выполняется код в блоке итератора. Вместо этого ***объекта-перечислителя*** создается и возвращается. Этот объект инкапсулирует код, указанный в блоке итератора, а выполнение кода в блоке итератора происходит при объекта-перечислителя `MoveNext` вызывается метод. Объект перечислителя имеет следующие характеристики:

*  Он реализует `IEnumerator` и `IEnumerator<T>`, где `T` yield тип итератора.
*  Он реализует `System.IDisposable`.
*  Она инициализируется с копией значения аргументов (если таковые имеются) и экземпляр значение, передаваемое в функцию-член.
*  Он имеет четыре потенциальных состояний, ***перед***, ***под управлением***, ***приостановлено***, и ***после***и изначально находится в ***перед***  состояние.

Объект перечислителя, обычно является экземпляром класса перечислителя, созданного компилятором, который инкапсулирует код в блоке итератора и реализует интерфейсы перечислителя, но возможны и другие методы реализации. Если класс перечислителя, создается компилятором, этот класс будет вложен, прямо или косвенно, в класс, содержащий функцию-член, он будет иметь режим доступа private и он будет иметь имя зарезервировано для внутреннего использования компиляторами ([идентификаторы ](lexical-structure.md#identifiers)).

Объект перечислителя может реализовывать несколько интерфейсов, чем указано выше.

В следующих разделах описываются точное поведение `MoveNext`, `Current`, и `Dispose` членами `IEnumerable` и `IEnumerable<T>` объект перечислителя, предоставляемые реализации интерфейсов.

Обратите внимание, что объекты перечислителя не поддерживают `IEnumerator.Reset` метод. Вызов этого метода приводит к `System.NotSupportedException` исключение.

#### <a name="the-movenext-method"></a>Метод MoveNext

`MoveNext` Метод объекта перечислителя инкапсулирует код блока итератора. Вызов `MoveNext` метод выполняет код в блоке итератора и задает `Current` свойства объекта-перечислителя соответствующим образом. Точные действия `MoveNext` зависит от состояния объекта перечислителя при `MoveNext` вызывается:

*  Если состояние объекта перечислителя ***перед***, вызов `MoveNext`:
   * Задает состояние ***под управлением***.
   * Инициализирует параметры (включая `this`) итератора блока для значения аргументов и значением экземпляра, сохраненными при инициализации объекта-перечислителя.
   * Выполняет блок итератора с самого начала, пока выполнение прерывается (как описано ниже).
*  Если состояние объекта перечислителя ***под управлением***, в результате вызова `MoveNext` не определен.
*  Если состояние объекта перечислителя ***приостановлено***, вызов `MoveNext`:
   * Задает состояние ***под управлением***.
   * Восстанавливает значения по для всех локальных переменных и параметров (включая this) к значениям, сохраненным при последней приостановки выполнения блока итератора. Обратите внимание, что содержимое любые объекты, на которые ссылается эти переменные могут были изменены с момента предыдущего вызова MoveNext.
   * Возобновляет выполнение блока итератора сразу после `yield return` оператор, который вызвал приостановку выполнения и продолжается, пока выполнение прерывается (как описано ниже).
*  Если состояние объекта перечислителя ***после***, вызов `MoveNext` возвращает `false`.


При `MoveNext` выполняет блока итератора, выполнение может быть прервано четырьмя способами: С `yield return` инструкции, по `yield break` инструкции по концу блока итератора и это исключение исключение и распространяется из блока итератора.

*  Когда `yield return` встречается ([оператор yield](statements.md#the-yield-statement)):
   * Выражение, заданное в инструкции вычисляется, неявно преобразован в тип результата и назначенные `Current` свойство объекта перечислителя.
   * Выполнение тела итератора приостанавливается. Значения всех локальных переменных и параметров (включая `this`) сохраняются, как это расположение `yield return` инструкции. Если `yield return` оператор находится внутри одного или нескольких `try` блокирует, сопоставленного `finally` блоки не выполняются в данный момент.
   * Изменения состояния объекта перечислителя на ***приостановлено***.
   * `MoveNext` Возвращает метод `true` для своего вызывающего объекта, указывающее, что итерация успешно перемещен к следующему значению.
*  Когда `yield break` встречается ([оператор yield](statements.md#the-yield-statement)):
   * Если `yield break` оператор находится внутри одного или нескольких `try` блокирует, сопоставленного `finally` блоки выполняются.
   * Изменения состояния объекта перечислителя на ***после***.
   * `MoveNext` Возвращает метод `false` его вызывающему, в том, что итерации не полный.
*  При обнаружении конец тела итератора:
   * Изменения состояния объекта перечислителя на ***после***.
   * `MoveNext` Возвращает метод `false` его вызывающему, в том, что итерации не полный.
*  Если создаваемое исключение и отсылается из блока итератора:
   * Соответствующие `finally` будет, блоков в тела итератора были выполнены посредством распространение исключения.
   * Изменения состояния объекта перечислителя на ***после***.
   * Распространение исключения продолжается вызывающему объекту `MoveNext` метод.

#### <a name="the-current-property"></a>Свойство Current

Объект перечислителя `Current` влияет свойство `yield return` инструкций в блоке итератора.

Когда объект-перечислитель находится в ***приостановлено*** state, значение `Current` является значение, заданное параметром предыдущего вызова `MoveNext`. Когда объект-перечислитель находится в ***перед***, ***под управлением***, или ***после*** состояния, результат обращения к `Current` не определен.

Для итератора с yield типы, отличные от `object`, результат обращения к `Current` посредством объекта-перечислителя `IEnumerable` соответствующий доступ к реализации `Current` посредством объекта-перечислителя `IEnumerator<T>` Реализация, а также преобразование результата для `object`.

#### <a name="the-dispose-method"></a>Метод Dispose

`Dispose` Метод используется для очистки итерации, разместив объекта-перечислителя в ***после*** состояния.

*  Если состояние объекта перечислителя ***перед***, вызов `Dispose` изменяет состояние на ***после***.
*  Если состояние объекта перечислителя ***под управлением***, в результате вызова `Dispose` не определен.
*  Если состояние объекта перечислителя ***приостановлено***, вызов `Dispose`:
   * Задает состояние ***под управлением***.
   * Выполняет любую наконец блоки так, как если бы последнего выполненного `yield return` инструкции были `yield break` инструкции. Если это приводит к инициированию и распространению за пределами тела итератора исключения, состояние объекта-перечислителя присваивается ***после*** и исключение передается вызывающему объекту `Dispose` метод.
   * Задает состояние ***после***.
*  Если состояние объекта перечислителя ***после***, вызов `Dispose` не оказывает влияния.

### <a name="enumerable-objects"></a>Перечисляемые объекты

Когда функция-член, возвращая типа enumerable интерфейса реализуется с помощью блока итератора, вызова функции-члена не выполняется код в блоке итератора. Вместо этого ***перечисляемый объект*** создается и возвращается. Перечисляемый объект `GetEnumerator` метод возвращает объект перечислителя, который инкапсулирует код, указанный в блоке итератора, а выполнение кода в блоке итератора происходит при объекта-перечислителя `MoveNext` вызывается метод. Перечислимый объект имеет следующие характеристики:

*  Он реализует `IEnumerable` и `IEnumerable<T>`, где `T` yield тип итератора.
*  Она инициализируется с копией значения аргументов (если таковые имеются) и экземпляр значение, передаваемое в функцию-член.

Перечисляемый объект обычно является экземпляром созданного компилятором класса enumerable, который инкапсулирует код в блоке итератора и реализует IEnumerable-интерфейс, но возможны и другие методы реализации. Если перечислимый класс создан компилятором, этот класс будет вложен, прямо или косвенно, в класс, содержащий функцию-член, он будет иметь режим доступа private и он будет иметь имя зарезервировано для внутреннего использования компиляторами ([идентификаторы ](lexical-structure.md#identifiers)).

Перечислимый объект может реализовывать несколько интерфейсов, чем указано выше. В частности, перечислимый объект может также реализовать `IEnumerator` и `IEnumerator<T>`, позволяя ей обслуживать как перечислимый объект и перечислитель. В этом типе реализации первой перечисляемый объект `GetEnumerator` вызывается метод, возвращается сам перечислимый объект. Последующие вызовы функции перечисляемый объект `GetEnumerator`, если имеется, возвращает копию перечисляемый объект. Таким образом каждый возвращенный перечислитель имеет собственное состояние, и изменения в одном перечислителе не повлияет на другую.

#### <a name="the-getenumerator-method"></a>Метод GetEnumerator

Перечисляемый объект предоставляет реализацию `GetEnumerator` методы `IEnumerable` и `IEnumerable<T>` интерфейсов. Два `GetEnumerator` методы совместно используют общую реализацию, которая получает и возвращает доступный объект перечислителя. Объект перечислителя инициализируется со значениями аргументов и значением экземпляра, сохраненными при перечисляемый объект был инициализирован, но в других функций объект перечислителя, как описано в разделе [объекты перечислителя](classes.md#enumerator-objects).

### <a name="implementation-example"></a>Пример реализации

В этом разделе описывается возможная реализация итераторов с точки зрения стандартные конструкции C#. Описанные здесь реализация основана на принципах, используемых компилятором Microsoft C#, но это отнюдь не является обязательной или единственной возможной.

Следующие `Stack<T>` класс реализует его `GetEnumerator` метод, с помощью итератора. Итератор перечисляет элементы коллекции в стек в порядке сверху вниз.

```csharp
using System;
using System.Collections;
using System.Collections.Generic;

class Stack<T>: IEnumerable<T>
{
    T[] items;
    int count;

    public void Push(T item) {
        if (items == null) {
            items = new T[4];
        }
        else if (items.Length == count) {
            T[] newItems = new T[count * 2];
            Array.Copy(items, 0, newItems, 0, count);
            items = newItems;
        }
        items[count++] = item;
    }

    public T Pop() {
        T result = items[--count];
        items[count] = default(T);
        return result;
    }

    public IEnumerator<T> GetEnumerator() {
        for (int i = count - 1; i >= 0; --i) yield return items[i];
    }
}
```

`GetEnumerator` Метод может транслировать в экземпляр класса перечислителя, созданного компилятором, который инкапсулирует код в блоке итератора, как показано в следующем.

```csharp
class Stack<T>: IEnumerable<T>
{
    ...

    public IEnumerator<T> GetEnumerator() {
        return new __Enumerator1(this);
    }

    class __Enumerator1: IEnumerator<T>, IEnumerator
    {
        int __state;
        T __current;
        Stack<T> __this;
        int i;

        public __Enumerator1(Stack<T> __this) {
            this.__this = __this;
        }

        public T Current {
            get { return __current; }
        }

        object IEnumerator.Current {
            get { return __current; }
        }

        public bool MoveNext() {
            switch (__state) {
                case 1: goto __state1;
                case 2: goto __state2;
            }
            i = __this.count - 1;
        __loop:
            if (i < 0) goto __state2;
            __current = __this.items[i];
            __state = 1;
            return true;
        __state1:
            --i;
            goto __loop;
        __state2:
            __state = 2;
            return false;
        }

        public void Dispose() {
            __state = 2;
        }

        void IEnumerator.Reset() {
            throw new NotSupportedException();
        }
    }
}
```

В предыдущей трансляции включается в конечный автомат и поместить в код в блоке итератора `MoveNext` метод класса перечислителя. Кроме того локальной переменной `i` включен в поле объекта-перечислителя, чтобы оно могло продолжать существовать при последующих вызовах `MoveNext`.

В следующем примере выводится, простые таблицы умножения целых чисел от 1 до 10. `FromTo` Метод в этом примере Возвращает перечислимый объект и реализуется с помощью итератора.

```csharp
using System;
using System.Collections.Generic;

class Test
{
    static IEnumerable<int> FromTo(int from, int to) {
        while (from <= to) yield return from++;
    }

    static void Main() {
        IEnumerable<int> e = FromTo(1, 10);
        foreach (int x in e) {
            foreach (int y in e) {
                Console.Write("{0,3} ", x * y);
            }
            Console.WriteLine();
        }
    }
}
```

`FromTo` Метод, транслируются в экземпляр компилятором класса enumerable, который инкапсулирует код в блоке итератора, как показано в следующем.

```csharp
using System;
using System.Threading;
using System.Collections;
using System.Collections.Generic;

class Test
{
    ...

    static IEnumerable<int> FromTo(int from, int to) {
        return new __Enumerable1(from, to);
    }

    class __Enumerable1:
        IEnumerable<int>, IEnumerable,
        IEnumerator<int>, IEnumerator
    {
        int __state;
        int __current;
        int __from;
        int from;
        int to;
        int i;

        public __Enumerable1(int __from, int to) {
            this.__from = __from;
            this.to = to;
        }

        public IEnumerator<int> GetEnumerator() {
            __Enumerable1 result = this;
            if (Interlocked.CompareExchange(ref __state, 1, 0) != 0) {
                result = new __Enumerable1(__from, to);
                result.__state = 1;
            }
            result.from = result.__from;
            return result;
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return (IEnumerator)GetEnumerator();
        }

        public int Current {
            get { return __current; }
        }

        object IEnumerator.Current {
            get { return __current; }
        }

        public bool MoveNext() {
            switch (__state) {
            case 1:
                if (from > to) goto case 2;
                __current = from++;
                __state = 1;
                return true;
            case 2:
                __state = 2;
                return false;
            default:
                throw new InvalidOperationException();
            }
        }

        public void Dispose() {
            __state = 2;
        }

        void IEnumerator.Reset() {
            throw new NotSupportedException();
        }
    }
}
```

Класс enumerable реализует IEnumerable-интерфейс и интерфейсы перечислителя, позволяя ей обслуживать как перечислимый объект и перечислитель. В первый раз `GetEnumerator` вызывается метод, возвращается сам перечислимый объект. Последующие вызовы функции перечисляемый объект `GetEnumerator`, если имеется, возвращает копию перечисляемый объект. Таким образом каждый возвращенный перечислитель имеет собственное состояние, и изменения в одном перечислителе не повлияет на другую. `Interlocked.CompareExchange` Метод используется для работы с потоками.

`from` И `to` параметров преобразуются в поля в класс enumerable. Так как `from` изменяется в блоке итератора, дополнительный `__from` поле впервые появилось в начальное значение, присваиваемое `from` в каждого перечислителя.

`MoveNext` Вызывает метод `InvalidOperationException` если он вызывается, когда `__state` является `0`. Это обеспечивает защиту от использования перечислимого объекта в качестве объекта перечислителя без предварительного вызова функции `GetEnumerator`.

В следующем примере показан класс простого дерева. `Tree<T>` Класс реализует его `GetEnumerator` метод, с помощью итератора. Итератор перечисляет элементы дерева в порядке инфиксные.

```csharp
using System;
using System.Collections.Generic;

class Tree<T>: IEnumerable<T>
{
    T value;
    Tree<T> left;
    Tree<T> right;

    public Tree(T value, Tree<T> left, Tree<T> right) {
        this.value = value;
        this.left = left;
        this.right = right;
    }

    public IEnumerator<T> GetEnumerator() {
        if (left != null) foreach (T x in left) yield x;
        yield value;
        if (right != null) foreach (T x in right) yield x;
    }
}

class Program
{
    static Tree<T> MakeTree<T>(T[] items, int left, int right) {
        if (left > right) return null;
        int i = (left + right) / 2;
        return new Tree<T>(items[i], 
            MakeTree(items, left, i - 1),
            MakeTree(items, i + 1, right));
    }

    static Tree<T> MakeTree<T>(params T[] items) {
        return MakeTree(items, 0, items.Length - 1);
    }

    // The output of the program is:
    // 1 2 3 4 5 6 7 8 9
    // Mon Tue Wed Thu Fri Sat Sun

    static void Main() {
        Tree<int> ints = MakeTree(1, 2, 3, 4, 5, 6, 7, 8, 9);
        foreach (int i in ints) Console.Write("{0} ", i);
        Console.WriteLine();

        Tree<string> strings = MakeTree(
            "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun");
        foreach (string s in strings) Console.Write("{0} ", s);
        Console.WriteLine();
    }
}
```

`GetEnumerator` Метод может транслировать в экземпляр класса перечислителя, созданного компилятором, который инкапсулирует код в блоке итератора, как показано в следующем.

```csharp
class Tree<T>: IEnumerable<T>
{
    ...

    public IEnumerator<T> GetEnumerator() {
        return new __Enumerator1(this);
    }

    class __Enumerator1 : IEnumerator<T>, IEnumerator
    {
        Node<T> __this;
        IEnumerator<T> __left, __right;
        int __state;
        T __current;

        public __Enumerator1(Node<T> __this) {
            this.__this = __this;
        }

        public T Current {
            get { return __current; }
        }

        object IEnumerator.Current {
            get { return __current; }
        }

        public bool MoveNext() {
            try {
                switch (__state) {

                case 0:
                    __state = -1;
                    if (__this.left == null) goto __yield_value;
                    __left = __this.left.GetEnumerator();
                    goto case 1;

                case 1:
                    __state = -2;
                    if (!__left.MoveNext()) goto __left_dispose;
                    __current = __left.Current;
                    __state = 1;
                    return true;

                __left_dispose:
                    __state = -1;
                    __left.Dispose();

                __yield_value:
                    __current = __this.value;
                    __state = 2;
                    return true;

                case 2:
                    __state = -1;
                    if (__this.right == null) goto __end;
                    __right = __this.right.GetEnumerator();
                    goto case 3;

                case 3:
                    __state = -3;
                    if (!__right.MoveNext()) goto __right_dispose;
                    __current = __right.Current;
                    __state = 3;
                    return true;

                __right_dispose:
                    __state = -1;
                    __right.Dispose();

                __end:
                    __state = 4;
                    break;

                }
            }
            finally {
                if (__state < 0) Dispose();
            }
            return false;
        }

        public void Dispose() {
            try {
                switch (__state) {

                case 1:
                case -2:
                    __left.Dispose();
                    break;

                case 3:
                case -3:
                    __right.Dispose();
                    break;

                }
            }
            finally {
                __state = 4;
            }
        }

        void IEnumerator.Reset() {
            throw new NotSupportedException();
        }
    }
}
```

Созданный компилятором временных переменных, используемых в `foreach` инструкций будет снято в `__left` и `__right` поля объекта перечислителя. `__state` Объекта-перечислителя тщательно обновляется таким образом, правильный `Dispose()` метод будет вызываться правильно, если возникает исключение. Обратите внимание на то, что он не поддерживается для записи преобразованного кода с простыми `foreach` инструкций.

## <a name="async-functions"></a>Асинхронные функции

Метод ([методы](classes.md#methods)) или анонимная функция ([выражения анонимных функций](expressions.md#anonymous-function-expressions)) с `async` модификатор называется ***асинхронной функции***. Как правило термин ***async*** используется для описания любого вида функции, которая имеет `async` модификатор.

Произошла ошибка во время компиляции, список формальных параметров асинхронной функции задающих `ref` или `out` параметров.

*Return_type* асинхронный метод должен быть либо `void` или ***задачи типа***. Типы задач, `System.Threading.Tasks.Task` и конструировать типы из `System.Threading.Tasks.Task<T>`. Для краткости в этой главе эти ссылки на типы как `Task` и `Task<T>`, соответственно. Асинхронный метод возвращает тип задачи считается возвращения задачи.

Точное определение типов задач. Это определяется реализацией, но с точки зрения языка типом задачи в одном из состояний неполные данные, успешно или произошел сбой. Задача, завершившаяся сбоем записывает соответствующие исключения. Успешно `Task<T>` записывает результат типа `T`. Типы задач awaitable и поэтому может быть операндов выражения await ([выражениях Await](expressions.md#await-expressions)).

Вызов функции async имеет возможность приостанавливать оценки с помощью параметра выражениях await ([выражениях Await](expressions.md#await-expressions)) в его тексте. Оценки позже может быть возобновить в точке приостановки выражение с помощью параметра await ***делегат возобновления***. Возобновление делегат имеет тип `System.Action`, и при его вызове, вычисление функции асинхронного вызова будет возобновлена с выражение await, в котором она остановилась. ***Текущего вызывающего пользователя*** значения асинхронной функции вызова не данные первоначального вызывающего объекта, если вызов функции никогда не было приостановлено или самой последней вызывающий объект делегата возобновления.

### <a name="evaluation-of-a-task-returning-async-function"></a>Вычисления функции async возвращающий задачу

Вызов функции возвращающий задачу асинхронный вызывает экземпляр типа Возвращенная задача будет создан. Это называется ***задача возврата*** функции async. Задача изначально находится в незавершенном состоянии.

Тело функции async затем вычисляется до (по достижении выражения await) либо приостанавливается или завершается, по которому точки управления возвращается вызывающему объекту, а также задача возврата.

При завершении тело функции async задача возврата перемещается за пределы неполный:

*  Если в результате достижения оператор return или конец тела завершает тело функции, любой результат записывается в возвращаемое задачу, которая помещается в состоянии успешного выполнения.
*  Если тело функции завершается в результате неперехваченное исключение ([инструкция throw](statements.md#the-throw-statement)) записано исключение в возвращаемое задачу, которая переходит в состояние faulted.

### <a name="evaluation-of-a-void-returning-async-function"></a>Вычисления функции async возвращающие void

Если тип возвращаемого значения асинхронной функции `void`, оценки отличается от приведенного выше следующим образом: так как возвращается ни одна задача, функция вместо этого взаимодействует завершения и исключения из текущего потока ***синхронизации контекст***. Точное определение контекст синхронизации, зависит от реализации, но является представлением элемента «where» выполняется текущий поток. Контекст синхронизации уведомляется при вычисления функции async возвращающую начинается, завершается успешно или вызывает исключение исключение.

Это обеспечивает контекст для отслеживания количества асинхронные функции, возвращающие void запускается под его управлением и принятия решения о том, как распространить исключения, поступающие из них.
