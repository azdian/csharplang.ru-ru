# <a name="types"></a><span data-ttu-id="b19c0-101">Типы</span><span class="sxs-lookup"><span data-stu-id="b19c0-101">Types</span></span>

<span data-ttu-id="b19c0-102">Типы языка C# можно разделить на две основные категории: ***типы значений*** и ***ссылочные типы***.</span><span class="sxs-lookup"><span data-stu-id="b19c0-102">The types of the C# language are divided into two main categories: ***value types*** and ***reference types***.</span></span> <span data-ttu-id="b19c0-103">Типы значений и ссылочные типы могут быть ***универсальных типов***, который сделать один или несколько ***параметры типа***.</span><span class="sxs-lookup"><span data-stu-id="b19c0-103">Both value types and reference types may be ***generic types***, which take one or more ***type parameters***.</span></span> <span data-ttu-id="b19c0-104">Параметры типа можно назначить обоих типов значений и ссылочные типы.</span><span class="sxs-lookup"><span data-stu-id="b19c0-104">Type parameters can designate both value types and reference types.</span></span>

```antlr
type
    : value_type
    | reference_type
    | type_parameter
    | type_unsafe
    ;
```

<span data-ttu-id="b19c0-105">Окончательный категории типов указателей, доступна только в небезопасном коде.</span><span class="sxs-lookup"><span data-stu-id="b19c0-105">The final category of types, pointers, is available only in unsafe code.</span></span> <span data-ttu-id="b19c0-106">Это описано далее в [типы указателей](unsafe-code.md#pointer-types).</span><span class="sxs-lookup"><span data-stu-id="b19c0-106">This is discussed further in [Pointer types](unsafe-code.md#pointer-types).</span></span>

<span data-ttu-id="b19c0-107">Типы значений отличаются от ссылочных типов, переменные типа значений содержат непосредственно данные, тогда как переменные, ссылки на типы хранилища ***ссылки*** обращаются к данным, которые именуются ***объекты***.</span><span class="sxs-lookup"><span data-stu-id="b19c0-107">Value types differ from reference types in that variables of the value types directly contain their data, whereas variables of the reference types store ***references*** to their data, the latter being known as ***objects***.</span></span> <span data-ttu-id="b19c0-108">Со ссылочными типами это две переменные могут ссылаться на тот же объект и поэтому может случиться операции над одной переменной затронут объект, который ссылается другая переменная.</span><span class="sxs-lookup"><span data-stu-id="b19c0-108">With reference types, it is possible for two variables to reference the same object, and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="b19c0-109">С типами значений каждая переменная имеет свою собственную копию данных и операции над одной могут затрагивать другую невозможно.</span><span class="sxs-lookup"><span data-stu-id="b19c0-109">With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other.</span></span>

<span data-ttu-id="b19c0-110">Система типов C# унифицирована таким образом, что значение любого типа можно рассматривать как объект.</span><span class="sxs-lookup"><span data-stu-id="b19c0-110">C#'s type system is unified such that a value of any type can be treated as an object.</span></span> <span data-ttu-id="b19c0-111">Каждый тип в C# является прямо или косвенно производным от типа класса `object`, и этот тип `object` является исходным базовым классом для всех типов.</span><span class="sxs-lookup"><span data-stu-id="b19c0-111">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="b19c0-112">Чтобы значения ссылочного типа обрабатывались как объекты, им просто присваивается тип `object`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-112">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="b19c0-113">Значения типов значений, рассматриваются как объекты, выполняя операции упаковки и распаковки ([упаковка-преобразование и распаковка-преобразование](types.md#boxing-and-unboxing)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-113">Values of value types are treated as objects by performing boxing and unboxing operations ([Boxing and unboxing](types.md#boxing-and-unboxing)).</span></span>

## <a name="value-types"></a><span data-ttu-id="b19c0-114">Типы значений</span><span class="sxs-lookup"><span data-stu-id="b19c0-114">Value types</span></span>

<span data-ttu-id="b19c0-115">Тип значения является типом структуры или тип перечисления.</span><span class="sxs-lookup"><span data-stu-id="b19c0-115">A value type is either a struct type or an enumeration type.</span></span> <span data-ttu-id="b19c0-116">C# предоставляет набор предопределенных типов структуры вызывается ***простых типов***.</span><span class="sxs-lookup"><span data-stu-id="b19c0-116">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="b19c0-117">Простые типы определяются с помощью зарезервированных слов.</span><span class="sxs-lookup"><span data-stu-id="b19c0-117">The simple types are identified through reserved words.</span></span>

```antlr
value_type
    : struct_type
    | enum_type
    ;

struct_type
    : type_name
    | simple_type
    | nullable_type
    ;

simple_type
    : numeric_type
    | 'bool'
    ;

numeric_type
    : integral_type
    | floating_point_type
    | 'decimal'
    ;

integral_type
    : 'sbyte'
    | 'byte'
    | 'short'
    | 'ushort'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    ;

floating_point_type
    : 'float'
    | 'double'
    ;

nullable_type
    : non_nullable_value_type '?'
    ;

non_nullable_value_type
    : type
    ;

enum_type
    : type_name
    ;
```

<span data-ttu-id="b19c0-118">В отличие от переменной ссылочного типа, переменная типа значения может содержать значение `null` только в том случае, если тип значения — обнуляемый тип.</span><span class="sxs-lookup"><span data-stu-id="b19c0-118">Unlike a variable of a reference type, a variable of a value type can contain the value `null` only if the value type is a nullable type.</span></span>  <span data-ttu-id="b19c0-119">Для каждого типа значения, не допускающим значения есть соответствующий обнуляемый тип, включающий те же значения, а также значение `null`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-119">For every non-nullable value type there is a corresponding nullable value type denoting the same set of values plus the value `null`.</span></span>

<span data-ttu-id="b19c0-120">Присвоение переменной значения типа создает копию значения, присваиваемого.</span><span class="sxs-lookup"><span data-stu-id="b19c0-120">Assignment to a variable of a value type creates a copy of the value being assigned.</span></span> <span data-ttu-id="b19c0-121">В отличие от назначения переменной ссылочного типа, который копирует ссылка, но не объект, указанный ссылкой.</span><span class="sxs-lookup"><span data-stu-id="b19c0-121">This differs from assignment to a variable of a reference type, which copies the reference but not the object identified by the reference.</span></span>

### <a name="the-systemvaluetype-type"></a><span data-ttu-id="b19c0-122">Тип System.ValueType</span><span class="sxs-lookup"><span data-stu-id="b19c0-122">The System.ValueType type</span></span>

<span data-ttu-id="b19c0-123">Все типы значений неявно наследуются от класса `System.ValueType`, который, в свою очередь, наследует от класса `object`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-123">All value types implicitly inherit from the class `System.ValueType`, which, in turn, inherits from class `object`.</span></span> <span data-ttu-id="b19c0-124">Он не поддерживается для любого типа на основании типа значения и типы значений являются запечатанными таким образом неявно ([запечатанных классов](classes.md#sealed-classes)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-124">It is not possible for any type to derive from a value type, and value types are thus implicitly sealed ([Sealed classes](classes.md#sealed-classes)).</span></span>

<span data-ttu-id="b19c0-125">Обратите внимание, что `System.ValueType` сам не *value_type*.</span><span class="sxs-lookup"><span data-stu-id="b19c0-125">Note that `System.ValueType` is not itself a *value_type*.</span></span> <span data-ttu-id="b19c0-126">Кроме того, это *class_type* из которой все *value_type*s автоматически являются производными.</span><span class="sxs-lookup"><span data-stu-id="b19c0-126">Rather, it is a *class_type* from which all *value_type*s are automatically derived.</span></span>

### <a name="default-constructors"></a><span data-ttu-id="b19c0-127">Конструкторы по умолчанию</span><span class="sxs-lookup"><span data-stu-id="b19c0-127">Default constructors</span></span>

<span data-ttu-id="b19c0-128">Все типы значений неявно объявляет конструктор открытого экземпляра без параметров вызывается ***конструктор по умолчанию***.</span><span class="sxs-lookup"><span data-stu-id="b19c0-128">All value types implicitly declare a public parameterless instance constructor called the ***default constructor***.</span></span> <span data-ttu-id="b19c0-129">Конструктор по умолчанию возвращает экземпляр инициализируемого нулевым значением, называемый ***значение по умолчанию*** для типа значения:</span><span class="sxs-lookup"><span data-stu-id="b19c0-129">The default constructor returns a zero-initialized instance known as the ***default value*** for the value type:</span></span>

*  <span data-ttu-id="b19c0-130">Для всех *simple_type*, значение по умолчанию имеет значение, произведенное битового шаблона изо всех нулей:</span><span class="sxs-lookup"><span data-stu-id="b19c0-130">For all *simple_type*s, the default value is the value produced by a bit pattern of all zeros:</span></span>
    * <span data-ttu-id="b19c0-131">Для `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, и `ulong`, значение по умолчанию — `0`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-131">For `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, and `ulong`, the default value is `0`.</span></span>
    * <span data-ttu-id="b19c0-132">Для `char`, значение по умолчанию — `'\x0000'`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-132">For `char`, the default value is `'\x0000'`.</span></span>
    * <span data-ttu-id="b19c0-133">Для `float`, значение по умолчанию — `0.0f`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-133">For `float`, the default value is `0.0f`.</span></span>
    * <span data-ttu-id="b19c0-134">Для `double`, значение по умолчанию — `0.0d`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-134">For `double`, the default value is `0.0d`.</span></span>
    * <span data-ttu-id="b19c0-135">Для `decimal`, значение по умолчанию — `0.0m`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-135">For `decimal`, the default value is `0.0m`.</span></span>
    * <span data-ttu-id="b19c0-136">Для `bool`, значение по умолчанию — `false`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-136">For `bool`, the default value is `false`.</span></span>
*  <span data-ttu-id="b19c0-137">Для *enum_type* `E`, значение по умолчанию — `0`, преобразованным в тип `E`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-137">For an *enum_type* `E`, the default value is `0`, converted to the type `E`.</span></span>
*  <span data-ttu-id="b19c0-138">Для *struct_type*, значение по умолчанию является значение, создаваемое путем установки все поля типа значения полей с типом значения по умолчанию и справочник по всем `null`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-138">For a *struct_type*, the default value is the value produced by setting all value type fields to their default value and all reference type fields to `null`.</span></span>
*  <span data-ttu-id="b19c0-139">Для *nullable_type* значение по умолчанию — это экземпляр, для которого `HasValue` свойство имеет значение false и `Value` свойство не определено.</span><span class="sxs-lookup"><span data-stu-id="b19c0-139">For a *nullable_type* the default value is an instance for which the `HasValue` property is false and the `Value` property is undefined.</span></span> <span data-ttu-id="b19c0-140">Значение по умолчанию также называется ***значение null*** типа, допускающего значение NULL.</span><span class="sxs-lookup"><span data-stu-id="b19c0-140">The default value is also known as the ***null value*** of the nullable type.</span></span>

<span data-ttu-id="b19c0-141">Как и любой другой конструктор экземпляров, конструктор по умолчанию для типа значения, вызываемая при помощи `new` оператор.</span><span class="sxs-lookup"><span data-stu-id="b19c0-141">Like any other instance constructor, the default constructor of a value type is invoked using the `new` operator.</span></span> <span data-ttu-id="b19c0-142">В целях повышения эффективности это требование не является фактически реализацией создается вызов конструктора.</span><span class="sxs-lookup"><span data-stu-id="b19c0-142">For efficiency reasons, this requirement is not intended to actually have the implementation generate a constructor call.</span></span> <span data-ttu-id="b19c0-143">В примере ниже, переменные `i` и `j` инициализируются до нуля.</span><span class="sxs-lookup"><span data-stu-id="b19c0-143">In the example below, variables `i` and `j` are both initialized to zero.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        int j = new int();
    }
}
```

<span data-ttu-id="b19c0-144">Так как каждый тип значения неявно имеет открытый конструктор экземпляра, он не поддерживается для типа структуры к явное объявление конструктора без параметров.</span><span class="sxs-lookup"><span data-stu-id="b19c0-144">Because every value type implicitly has a public parameterless instance constructor, it is not possible for a struct type to contain an explicit declaration of a parameterless constructor.</span></span> <span data-ttu-id="b19c0-145">Тип структуры тем не менее может объявлять параметризованные конструкторы экземпляров ([конструкторы](structs.md#constructors)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-145">A struct type is however permitted to declare parameterized instance constructors ([Constructors](structs.md#constructors)).</span></span>

### <a name="struct-types"></a><span data-ttu-id="b19c0-146">Типы структур</span><span class="sxs-lookup"><span data-stu-id="b19c0-146">Struct types</span></span>

<span data-ttu-id="b19c0-147">Тип структуры является типом значения, которые могут объявлять константы, поля, методы, свойства, индексаторы, операторы, конструкторы экземпляров, статические конструкторы и вложенные типы.</span><span class="sxs-lookup"><span data-stu-id="b19c0-147">A struct type is a value type that can declare constants, fields, methods, properties, indexers, operators, instance constructors, static constructors, and nested types.</span></span> <span data-ttu-id="b19c0-148">Объявление типов структуры описан в [объявления структур](structs.md#struct-declarations).</span><span class="sxs-lookup"><span data-stu-id="b19c0-148">The declaration of struct types is described in [Struct declarations](structs.md#struct-declarations).</span></span>

### <a name="simple-types"></a><span data-ttu-id="b19c0-149">Простые типы</span><span class="sxs-lookup"><span data-stu-id="b19c0-149">Simple types</span></span>

<span data-ttu-id="b19c0-150">C# предоставляет набор предопределенных типов структуры вызывается ***простых типов***.</span><span class="sxs-lookup"><span data-stu-id="b19c0-150">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="b19c0-151">Простые типы определяются с помощью зарезервированных слов, но эти зарезервированные слова — это просто псевдонимы предопределенных типов структуры в `System` пространства имен, как описано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="b19c0-151">The simple types are identified through reserved words, but these reserved words are simply aliases for predefined struct types in the `System` namespace, as described in the table below.</span></span>


| <span data-ttu-id="b19c0-152">__Зарезервированное слово__</span><span class="sxs-lookup"><span data-stu-id="b19c0-152">__Reserved word__</span></span> | <span data-ttu-id="b19c0-153">__Тип с псевдонимом__</span><span class="sxs-lookup"><span data-stu-id="b19c0-153">__Aliased type__</span></span> |
|-------------------|------------------|
| `sbyte`           | `System.SByte`   | 
| `byte`            | `System.Byte`    | 
| `short`           | `System.Int16`   | 
| `ushort`          | `System.UInt16`  | 
| `int`             | `System.Int32`   | 
| `uint`            | `System.UInt32`  | 
| `long`            | `System.Int64`   | 
| `ulong`           | `System.UInt64`  | 
| `char`            | `System.Char`    | 
| `float`           | `System.Single`  | 
| `double`          | `System.Double`  | 
| `bool`            | `System.Boolean` | 
| `decimal`         | `System.Decimal` | 

<span data-ttu-id="b19c0-154">Так как простой тип псевдонимы типа структуры, каждый простой тип содержит члены.</span><span class="sxs-lookup"><span data-stu-id="b19c0-154">Because a simple type aliases a struct type, every simple type has members.</span></span> <span data-ttu-id="b19c0-155">Например `int` имеет члены, объявленные в `System.Int32` и члены, унаследованные от `System.Object`, и разрешены следующие инструкции:</span><span class="sxs-lookup"><span data-stu-id="b19c0-155">For example, `int` has the members declared in `System.Int32` and the members inherited from `System.Object`, and the following statements are permitted:</span></span>

```csharp
int i = int.MaxValue;           // System.Int32.MaxValue constant
string s = i.ToString();        // System.Int32.ToString() instance method
string t = 123.ToString();      // System.Int32.ToString() instance method
```

<span data-ttu-id="b19c0-156">Простые типы отличаются от других типов структуры, в том, что они разрешены некоторые дополнительные операции.</span><span class="sxs-lookup"><span data-stu-id="b19c0-156">The simple types differ from other struct types in that they permit certain additional operations:</span></span>

*  <span data-ttu-id="b19c0-157">Большинство простые типы разрешают значения, которые создаются путем записи *литералы* ([литералы](lexical-structure.md#literals)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-157">Most simple types permit values to be created by writing *literals* ([Literals](lexical-structure.md#literals)).</span></span> <span data-ttu-id="b19c0-158">Например `123` — это литерал типа `int` и `'a'` — это литерал типа `char`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-158">For example, `123` is a literal of type `int` and `'a'` is a literal of type `char`.</span></span> <span data-ttu-id="b19c0-159">C# делает не поддерживает литералы типов структуры в целом, а значения по умолчанию других типов структуры в конечном счете всегда создаются с помощью конструкторов экземпляров типов структуры.</span><span class="sxs-lookup"><span data-stu-id="b19c0-159">C# makes no provision for literals of struct types in general, and non-default values of other struct types are ultimately always created through instance constructors of those struct types.</span></span>
*  <span data-ttu-id="b19c0-160">Когда операнда выражения являются константами простого типа, компилятор может вычислить выражение во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="b19c0-160">When the operands of an expression are all simple type constants, it is possible for the compiler to evaluate the expression at compile-time.</span></span> <span data-ttu-id="b19c0-161">Такое выражение называется *constant_expression* ([константные выражения](expressions.md#constant-expressions)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-161">Such an expression is known as a *constant_expression* ([Constant expressions](expressions.md#constant-expressions)).</span></span> <span data-ttu-id="b19c0-162">Выражения, включающие операторы, определенные другими типами структуры, не считаются быть константными выражениями.</span><span class="sxs-lookup"><span data-stu-id="b19c0-162">Expressions involving operators defined by other struct types are not considered to be constant expressions.</span></span>
*  <span data-ttu-id="b19c0-163">Через `const` объявления можно объявлять константы простых типов ([константы](classes.md#constants)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-163">Through `const` declarations it is possible to declare constants of the simple types ([Constants](classes.md#constants)).</span></span> <span data-ttu-id="b19c0-164">Это не может быть константы других типов структуры, но обеспечивается похожий эффект `static readonly` поля.</span><span class="sxs-lookup"><span data-stu-id="b19c0-164">It is not possible to have constants of other struct types, but a similar effect is provided by `static readonly` fields.</span></span>
*  <span data-ttu-id="b19c0-165">Преобразования, включающие простые типы могут участвовать в вычислении операторов преобразования, определенные другими типами структуры, но оператор пользовательского преобразования никогда не может участвовать в вычисление другой определенный пользователем оператор ([оценки заданные пользователем преобразования](conversions.md#evaluation-of-user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-165">Conversions involving simple types can participate in evaluation of conversion operators defined by other struct types, but a user-defined conversion operator can never participate in evaluation of another user-defined operator ([Evaluation of user-defined conversions](conversions.md#evaluation-of-user-defined-conversions)).</span></span>

### <a name="integral-types"></a><span data-ttu-id="b19c0-166">Целочисленные типы</span><span class="sxs-lookup"><span data-stu-id="b19c0-166">Integral types</span></span>

<span data-ttu-id="b19c0-167">C# поддерживает девять целочисленных типов: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, и `char`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-167">C# supports nine integral types: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, and `char`.</span></span> <span data-ttu-id="b19c0-168">Целочисленные типы имеют следующие размеры и диапазоны значений:</span><span class="sxs-lookup"><span data-stu-id="b19c0-168">The integral types have the following sizes and ranges of values:</span></span>

*  <span data-ttu-id="b19c0-169">`sbyte` Представляет тип автоматический 8-битовых целых чисел со знаком в диапазоне от -128 до 127.</span><span class="sxs-lookup"><span data-stu-id="b19c0-169">The `sbyte` type represents signed 8-bit integers with values between -128 and 127.</span></span>
*  <span data-ttu-id="b19c0-170">`byte` Тип представляет 8-разрядных целых чисел со значениями от 0 до 255.</span><span class="sxs-lookup"><span data-stu-id="b19c0-170">The `byte` type represents unsigned 8-bit integers with values between 0 and 255.</span></span>
*  <span data-ttu-id="b19c0-171">`short` Представляет тип автоматический 16-разрядных целых чисел со знаком в диапазоне от -32768 до 32767.</span><span class="sxs-lookup"><span data-stu-id="b19c0-171">The `short` type represents signed 16-bit integers with values between -32768 and 32767.</span></span>
*  <span data-ttu-id="b19c0-172">`ushort` Тип представляет 16-разрядных целых чисел со значениями от 0 до 65535.</span><span class="sxs-lookup"><span data-stu-id="b19c0-172">The `ushort` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span>
*  <span data-ttu-id="b19c0-173">`int` Представляет тип подписи, 32-разрядных целых чисел со значениями от -2147483648 до 2147483647.</span><span class="sxs-lookup"><span data-stu-id="b19c0-173">The `int` type represents signed 32-bit integers with values between -2147483648 and 2147483647.</span></span>
*  <span data-ttu-id="b19c0-174">`uint` Тип представляет 32-разрядных целых чисел со значениями от 0 до 4294967295.</span><span class="sxs-lookup"><span data-stu-id="b19c0-174">The `uint` type represents unsigned 32-bit integers with values between 0 and 4294967295.</span></span>
*  <span data-ttu-id="b19c0-175">`long` Представляет тип подписью, 64-разрядных целых чисел со значениями от -9223372036854775808 до 9223372036854775807.</span><span class="sxs-lookup"><span data-stu-id="b19c0-175">The `long` type represents signed 64-bit integers with values between -9223372036854775808 and 9223372036854775807.</span></span>
*  <span data-ttu-id="b19c0-176">`ulong` Тип представляет 64-разрядных целых чисел со значениями от 0 до 18446744073709551615.</span><span class="sxs-lookup"><span data-stu-id="b19c0-176">The `ulong` type represents unsigned 64-bit integers with values between 0 and 18446744073709551615.</span></span>
*  <span data-ttu-id="b19c0-177">`char` Тип представляет 16-разрядных целых чисел со значениями от 0 до 65535.</span><span class="sxs-lookup"><span data-stu-id="b19c0-177">The `char` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span> <span data-ttu-id="b19c0-178">Набор возможных значений для `char` тип соответствует набору знаков Юникода.</span><span class="sxs-lookup"><span data-stu-id="b19c0-178">The set of possible values for the `char` type corresponds to the Unicode character set.</span></span> <span data-ttu-id="b19c0-179">Несмотря на то что `char` имеет то же представление, как `ushort`, не все операции, для каждого типа разрешены на другой.</span><span class="sxs-lookup"><span data-stu-id="b19c0-179">Although `char` has the same representation as `ushort`, not all operations permitted on one type are permitted on the other.</span></span>

<span data-ttu-id="b19c0-180">Целочисленного типа унарные и бинарные операторы всегда работают в режиме со знаком 32-битной точности, неподписанные 32-битной точности, 64-битной точности, со знаком или без знака 64-битной точности:</span><span class="sxs-lookup"><span data-stu-id="b19c0-180">The integral-type unary and binary operators always operate with signed 32-bit precision, unsigned 32-bit precision, signed 64-bit precision, or unsigned 64-bit precision:</span></span>

*  <span data-ttu-id="b19c0-181">Для унарных `+` и `~` операторов операнд преобразуется в тип `T`, где `T` — первый из `int`, `uint`, `long`, и `ulong` , могут быть полностью представлены все Возможные значения операнда.</span><span class="sxs-lookup"><span data-stu-id="b19c0-181">For the unary `+` and `~` operators, the operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="b19c0-182">Операция выполняется с использованием точность типа `T`, а тип результата — `T`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-182">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>
*  <span data-ttu-id="b19c0-183">Для унарных `-` оператор, операнд преобразуется в тип `T`, где `T` — первый из `int` и `long` , могут быть полностью представлены все возможные значения операнда.</span><span class="sxs-lookup"><span data-stu-id="b19c0-183">For the unary `-` operator, the operand is converted to type `T`, where `T` is the first of `int` and `long` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="b19c0-184">Операция выполняется с использованием точность типа `T`, а тип результата — `T`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-184">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span> <span data-ttu-id="b19c0-185">Унарный `-` оператор не может применяться к операндам типа `ulong`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-185">The unary `-` operator cannot be applied to operands of type `ulong`.</span></span>
*  <span data-ttu-id="b19c0-186">Для двоичного файла `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`, и `<=` операторы, операнды преобразуются в тип `T`, где `T` — первый из `int`, `uint`, `long`, и `ulong` , могут быть полностью представлены все возможные значения обоих операндов.</span><span class="sxs-lookup"><span data-stu-id="b19c0-186">For the binary `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`, and `<=` operators, the operands are converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of both operands.</span></span> <span data-ttu-id="b19c0-187">Операция выполняется с использованием точность типа `T`, а тип результата — `T` (или `bool` для операторов отношения).</span><span class="sxs-lookup"><span data-stu-id="b19c0-187">The operation is then performed using the precision of type `T`, and the type of the result is `T` (or `bool` for the relational operators).</span></span> <span data-ttu-id="b19c0-188">Она недопустима для один операнд типа `long` , а другой тип `ulong` с бинарными операторами.</span><span class="sxs-lookup"><span data-stu-id="b19c0-188">It is not permitted for one operand to be of type `long` and the other to be of type `ulong` with the binary operators.</span></span>
*  <span data-ttu-id="b19c0-189">Для двоичного файла `<<` и `>>` операторы, левый операнд преобразуется в тип `T`, где `T` — первый из `int`, `uint`, `long`, и `ulong` , могут быть полностью представлены все Возможные значения операнда.</span><span class="sxs-lookup"><span data-stu-id="b19c0-189">For the binary `<<` and `>>` operators, the left operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="b19c0-190">Операция выполняется с использованием точность типа `T`, а тип результата — `T`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-190">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>

<span data-ttu-id="b19c0-191">`char` Тип классифицируется как целочисленный тип, но он отличается от других целочисленных типов двумя способами:</span><span class="sxs-lookup"><span data-stu-id="b19c0-191">The `char` type is classified as an integral type, but it differs from the other integral types in two ways:</span></span>

*  <span data-ttu-id="b19c0-192">Отсутствуют неявные преобразования из других типов в `char` типа.</span><span class="sxs-lookup"><span data-stu-id="b19c0-192">There are no implicit conversions from other types to the `char` type.</span></span> <span data-ttu-id="b19c0-193">В частности несмотря на то что `sbyte`, `byte`, и `ushort` типы имеют диапазоны значений, которые являются полностью можно представить с помощью `char` неявные преобразования из типов `sbyte`, `byte`, или `ushort` для `char` не существуют.</span><span class="sxs-lookup"><span data-stu-id="b19c0-193">In particular, even though the `sbyte`, `byte`, and `ushort` types have ranges of values that are fully representable using the `char` type, implicit conversions from `sbyte`, `byte`, or `ushort` to `char` do not exist.</span></span>
*  <span data-ttu-id="b19c0-194">Константы типа `char` типа должно быть записано как *character_literal*s или как *integer_literal*s в сочетании с помощью приведения к типу `char`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-194">Constants of the `char` type must be written as *character_literal*s or as *integer_literal*s in combination with a cast to type `char`.</span></span> <span data-ttu-id="b19c0-195">Например, `(char)10` равносильно `'\x000A'`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-195">For example, `(char)10` is the same as `'\x000A'`.</span></span>

<span data-ttu-id="b19c0-196">`checked` И `unchecked` операторы и операторы используются для управления проверкой переполнения при выполнении целочисленных арифметических операций и преобразований ([операторы checked и unchecked](expressions.md#the-checked-and-unchecked-operators)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-196">The `checked` and `unchecked` operators and statements are used to control overflow checking for integral-type arithmetic operations and conversions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)).</span></span> <span data-ttu-id="b19c0-197">В `checked` контекста, переполнение вызывает ошибку времени компиляции или вызывает `System.OverflowException` исключение.</span><span class="sxs-lookup"><span data-stu-id="b19c0-197">In a `checked` context, an overflow produces a compile-time error or causes a `System.OverflowException` to be thrown.</span></span> <span data-ttu-id="b19c0-198">В `unchecked` контекста, переполнение игнорируется, а также удаляются любые старшие разряды, которые не помещаются в целевой тип.</span><span class="sxs-lookup"><span data-stu-id="b19c0-198">In an `unchecked` context, overflows are ignored and any high-order bits that do not fit in the destination type are discarded.</span></span>

### <a name="floating-point-types"></a><span data-ttu-id="b19c0-199">Типы с плавающей запятой</span><span class="sxs-lookup"><span data-stu-id="b19c0-199">Floating point types</span></span>

<span data-ttu-id="b19c0-200">C# поддерживает два типы с плавающей запятой: `float` и `double`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-200">C# supports two floating point types: `float` and `double`.</span></span> <span data-ttu-id="b19c0-201">`float` И `double` типы представлены с помощью 32-разрядный одиночной точности и 64-разрядных двойной точности IEEE 754 форматов, которые предоставляют следующие наборы значений:</span><span class="sxs-lookup"><span data-stu-id="b19c0-201">The `float` and `double` types are represented using the 32-bit single-precision and 64-bit double-precision IEEE 754 formats, which provide the following sets of values:</span></span>

*  <span data-ttu-id="b19c0-202">Положительный и отрицательный нуль.</span><span class="sxs-lookup"><span data-stu-id="b19c0-202">Positive zero and negative zero.</span></span> <span data-ttu-id="b19c0-203">В большинстве ситуаций, положительного и отрицательного нуля ведут себя одинаково как значений, но некоторые операции различие между ними ([оператор деления](expressions.md#division-operator)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-203">In most situations, positive zero and negative zero behave identically as the simple value zero, but certain operations distinguish between the two ([Division operator](expressions.md#division-operator)).</span></span>
*  <span data-ttu-id="b19c0-204">Положительная и отрицательная бесконечность.</span><span class="sxs-lookup"><span data-stu-id="b19c0-204">Positive infinity and negative infinity.</span></span> <span data-ttu-id="b19c0-205">Бесконечности действительных созданные с помощью таких операций, как ненулевое число деления на ноль.</span><span class="sxs-lookup"><span data-stu-id="b19c0-205">Infinities are produced by such operations as dividing a non-zero number by zero.</span></span> <span data-ttu-id="b19c0-206">Например `1.0 / 0.0` дает положительной бесконечности и `-1.0 / 0.0` дает отрицательная бесконечность.</span><span class="sxs-lookup"><span data-stu-id="b19c0-206">For example, `1.0 / 0.0` yields positive infinity, and `-1.0 / 0.0` yields negative infinity.</span></span>
*  <span data-ttu-id="b19c0-207">***Не является числовым*** значение часто сокращенное значение NaN.</span><span class="sxs-lookup"><span data-stu-id="b19c0-207">The ***Not-a-Number*** value, often abbreviated NaN.</span></span> <span data-ttu-id="b19c0-208">Значения NaN создает недопустимый операций с плавающей запятой, например деления нуля на нуль.</span><span class="sxs-lookup"><span data-stu-id="b19c0-208">NaNs are produced by invalid floating-point operations, such as dividing zero by zero.</span></span>
*  <span data-ttu-id="b19c0-209">Конечный набор ненулевые значения формы `s * m * 2^e`, где `s` равно 1 или -1, и `m` и `e` определяются определенного типа с плавающей запятой: для `float`, `0 < m < 2^24` и `-149 <= e <= 104`и для `double`, `0 < m < 2^53` и `1075 <= e <= 970`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-209">The finite set of non-zero values of the form `s * m * 2^e`, where `s` is 1 or -1, and `m` and `e` are determined by the particular floating-point type: For `float`, `0 < m < 2^24` and `-149 <= e <= 104`, and for `double`, `0 < m < 2^53` and `1075 <= e <= 970`.</span></span> <span data-ttu-id="b19c0-210">Денормализованные числа с плавающей запятой, считаются допустимыми значениями ненулевое значение.</span><span class="sxs-lookup"><span data-stu-id="b19c0-210">Denormalized floating-point numbers are considered valid non-zero values.</span></span>

<span data-ttu-id="b19c0-211">`float` Тип может представлять значения в диапазоне примерно от `1.5 * 10^-45` для `3.4 * 10^38` с точностью до 7 цифр.</span><span class="sxs-lookup"><span data-stu-id="b19c0-211">The `float` type can represent values ranging from approximately `1.5 * 10^-45` to `3.4 * 10^38` with a precision of 7 digits.</span></span>

<span data-ttu-id="b19c0-212">`double` Тип может представлять значения в диапазоне примерно от `5.0 * 10^-324` для `1.7 × 10^308` с точностью до 15-16 знаков.</span><span class="sxs-lookup"><span data-stu-id="b19c0-212">The `double` type can represent values ranging from approximately `5.0 * 10^-324` to `1.7 × 10^308` with a precision of 15-16 digits.</span></span>

<span data-ttu-id="b19c0-213">Если один из операндов бинарного оператора типом с плавающей запятой, затем второй операнд должен иметь целочисленный тип или типом с плавающей запятой, и операция вычисляется следующим образом:</span><span class="sxs-lookup"><span data-stu-id="b19c0-213">If one of the operands of a binary operator is of a floating-point type, then the other operand must be of an integral type or a floating-point type, and the operation is evaluated as follows:</span></span>

*  <span data-ttu-id="b19c0-214">Если один из операндов имеет целочисленный тип, что операнд преобразуется в тип с плавающей запятой имеет другой операнд.</span><span class="sxs-lookup"><span data-stu-id="b19c0-214">If one of the operands is of an integral type, then that operand is converted to the floating-point type of the other operand.</span></span>
*  <span data-ttu-id="b19c0-215">Затем, если любой из операндов имеет тип `double`, то другой операнд преобразуется в `double`, операция выполняется с помощью по крайней мере `double` диапазон и точность, а тип результата — `double` (или `bool` для реляционные операторы).</span><span class="sxs-lookup"><span data-stu-id="b19c0-215">Then, if either of the operands is of type `double`, the other operand is converted to `double`, the operation is performed using at least `double` range and precision, and the type of the result is `double` (or `bool` for the relational operators).</span></span>
*  <span data-ttu-id="b19c0-216">В противном случае операция выполняется с помощью по крайней мере `float` диапазон и точность, а тип результата — `float` (или `bool` для операторов отношения).</span><span class="sxs-lookup"><span data-stu-id="b19c0-216">Otherwise, the operation is performed using at least `float` range and precision, and the type of the result is `float` (or `bool` for the relational operators).</span></span>

<span data-ttu-id="b19c0-217">С плавающей запятой операторов, включая операторы присваивания, никогда не создают исключений.</span><span class="sxs-lookup"><span data-stu-id="b19c0-217">The floating-point operators, including the assignment operators, never produce exceptions.</span></span> <span data-ttu-id="b19c0-218">Вместо этого в исключительных ситуациях операций с плавающей запятой сформировать ноль, бесконечность или NaN, как описано ниже:</span><span class="sxs-lookup"><span data-stu-id="b19c0-218">Instead, in exceptional situations, floating-point operations produce zero, infinity, or NaN, as described below:</span></span>

*  <span data-ttu-id="b19c0-219">Если результат операции с плавающей запятой слишком мал для конечного формата, результат операции становится положительный ноль или отрицательный нуль.</span><span class="sxs-lookup"><span data-stu-id="b19c0-219">If the result of a floating-point operation is too small for the destination format, the result of the operation becomes positive zero or negative zero.</span></span>
*  <span data-ttu-id="b19c0-220">Если результат операции с плавающей запятой слишком велико для конечного формата, результат операции становится положительной бесконечности или минус бесконечности.</span><span class="sxs-lookup"><span data-stu-id="b19c0-220">If the result of a floating-point operation is too large for the destination format, the result of the operation becomes positive infinity or negative infinity.</span></span>
*  <span data-ttu-id="b19c0-221">Если операция с плавающей запятой недопустимо, результат операции NaN.</span><span class="sxs-lookup"><span data-stu-id="b19c0-221">If a floating-point operation is invalid, the result of the operation becomes NaN.</span></span>
*  <span data-ttu-id="b19c0-222">Если один или оба операнда операции с плавающей запятой является NaN, результат операции NaN.</span><span class="sxs-lookup"><span data-stu-id="b19c0-222">If one or both operands of a floating-point operation is NaN, the result of the operation becomes NaN.</span></span>

<span data-ttu-id="b19c0-223">Операции с плавающей запятой может выполняться с более высокой точностью, чем тип результата операции.</span><span class="sxs-lookup"><span data-stu-id="b19c0-223">Floating-point operations may be performed with higher precision than the result type of the operation.</span></span> <span data-ttu-id="b19c0-224">Например, некоторые архитектуры оборудования поддерживает использование типа с плавающей запятой «расширенный» или «long double» с более широкий диапазон и точность, чем `double` введите, а также неявно выполнять все операции с плавающей запятой, с помощью этого выше точность типа.</span><span class="sxs-lookup"><span data-stu-id="b19c0-224">For example, some hardware architectures support an "extended" or "long double" floating-point type with greater range and precision than the `double` type, and implicitly perform all floating-point operations using this higher precision type.</span></span> <span data-ttu-id="b19c0-225">Только за счет понижения производительности можно такой аппаратной архитектуры для выполнения операций с плавающей запятой с меньшей точностью, и во избежание понижения производительности и точности, C# разрешает тип с точностью выше быть используется для всех операций с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="b19c0-225">Only at excessive cost in performance can such hardware architectures be made to perform floating-point operations with less precision, and rather than require an implementation to forfeit both performance and precision, C# allows a higher precision type to be used for all floating-point operations.</span></span> <span data-ttu-id="b19c0-226">Кроме предоставления более точные результаты, не дает никаких измеримое эффектов.</span><span class="sxs-lookup"><span data-stu-id="b19c0-226">Other than delivering more precise results, this rarely has any measurable effects.</span></span> <span data-ttu-id="b19c0-227">Тем не менее, в выражениях формы `x * y / z`, где результат умножения, находится за пределами `double` диапазон, но последующие деления возвращает промежуточный результат обратно в `double` в диапазон, тот факт, что выражение является вычисляется в верхним диапазоном формата может привести к конечный результат вместо бесконечности.</span><span class="sxs-lookup"><span data-stu-id="b19c0-227">However, in expressions of the form `x * y / z`, where the multiplication produces a result that is outside the `double` range, but the subsequent division brings the temporary result back into the `double` range, the fact that the expression is evaluated in a higher range format may cause a finite result to be produced instead of an infinity.</span></span>

### <a name="the-decimal-type"></a><span data-ttu-id="b19c0-228">Тип decimal</span><span class="sxs-lookup"><span data-stu-id="b19c0-228">The decimal type</span></span>

<span data-ttu-id="b19c0-229">Тип `decimal` — это 128-разрядный тип данных для финансовых и денежных расчетов.</span><span class="sxs-lookup"><span data-stu-id="b19c0-229">The `decimal` type is a 128-bit data type suitable for financial and monetary calculations.</span></span> <span data-ttu-id="b19c0-230">`decimal` Тип может представлять значения в диапазоне от `1.0 * 10^-28` для приблизительно `7.9 * 10^28` с 28-29 значимыми цифрами.</span><span class="sxs-lookup"><span data-stu-id="b19c0-230">The `decimal` type can represent values ranging from `1.0 * 10^-28` to approximately `7.9 * 10^28` with 28-29 significant digits.</span></span>

<span data-ttu-id="b19c0-231">Конечный набор значений типа `decimal` представлены в формате `(-1)^s * c * 10^-e`, где знак `s` равен 0 или 1, коэффициент `c` определяется `0 <= *c* < 2^96`и масштаб `e` — таким образом, чтобы `0 <= e <= 28`. `decimal` Со знаком нули, бесконечность или NaN не поддерживает тип.</span><span class="sxs-lookup"><span data-stu-id="b19c0-231">The finite set of values of type `decimal` are of the form `(-1)^s * c * 10^-e`, where the sign `s` is 0 or 1, the coefficient `c` is given by `0 <= *c* < 2^96`, and the scale `e` is such that `0 <= e <= 28`.The `decimal` type does not support signed zeros, infinities, or NaN's.</span></span> <span data-ttu-id="b19c0-232">Объект `decimal` представляется в виде 96-разрядного целого числа, масштабируется по степени числа 10.</span><span class="sxs-lookup"><span data-stu-id="b19c0-232">A `decimal` is represented as a 96-bit integer scaled by a power of ten.</span></span> <span data-ttu-id="b19c0-233">Для `decimal`s с абсолютным значением меньше, чем `1.0m`, значение точного до 28-го десятичного разряда, но нет ничего.</span><span class="sxs-lookup"><span data-stu-id="b19c0-233">For `decimal`s with an absolute value less than `1.0m`, the value is exact to the 28th decimal place, but no further.</span></span> <span data-ttu-id="b19c0-234">Для `decimal`s с абсолютным значением больше или равно `1.0m`, имеют точность до 28 или 29 цифр.</span><span class="sxs-lookup"><span data-stu-id="b19c0-234">For `decimal`s with an absolute value greater than or equal to `1.0m`, the value is exact to 28 or 29 digits.</span></span> <span data-ttu-id="b19c0-235">Отличие `float` и `double` типы данных могут представляться десятичных дробей, например 0,1 точно в `decimal` представление.</span><span class="sxs-lookup"><span data-stu-id="b19c0-235">Contrary to the `float` and `double` data types, decimal fractional numbers such as 0.1 can be represented exactly in the `decimal` representation.</span></span> <span data-ttu-id="b19c0-236">В `float` и `double` представления таких чисел, являются часто бесконечные дроби, что делает эти представления, более подвержены округления ошибки.</span><span class="sxs-lookup"><span data-stu-id="b19c0-236">In the `float` and `double` representations, such numbers are often infinite fractions, making those representations more prone to round-off errors.</span></span>

<span data-ttu-id="b19c0-237">Если один из операндов бинарного оператора имеет тип `decimal`, то второй операнд должен иметь целочисленный тип или тип `decimal`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-237">If one of the operands of a binary operator is of type `decimal`, then the other operand must be of an integral type or of type `decimal`.</span></span> <span data-ttu-id="b19c0-238">Если присутствует операнд целочисленного типа, он преобразуется в `decimal` перед выполнением операции.</span><span class="sxs-lookup"><span data-stu-id="b19c0-238">If an integral type operand is present, it is converted to `decimal` before the operation is performed.</span></span>

<span data-ttu-id="b19c0-239">Результат операции над значениями типа `decimal` является, который получится после вычисления результату (сохраняя масштаб, как это определено для каждого оператора) и затем округления в соответствии с представлением.</span><span class="sxs-lookup"><span data-stu-id="b19c0-239">The result of an operation on values of type `decimal` is that which would result from calculating an exact result (preserving scale, as defined for each operator) and then rounding to fit the representation.</span></span> <span data-ttu-id="b19c0-240">Результаты округляются до ближайшего значения, которое может быть представлено и, если результат находится точно посередине между двумя представимых значений, значение, которое имеет четное число в позиции младшего разряда (это называется «банковское округление»).</span><span class="sxs-lookup"><span data-stu-id="b19c0-240">Results are rounded to the nearest representable value, and, when a result is equally close to two representable values, to the value that has an even number in the least significant digit position (this is known as "banker's rounding").</span></span> <span data-ttu-id="b19c0-241">Нулевой результат всегда имеет знак числа 0 и масштабом 0.</span><span class="sxs-lookup"><span data-stu-id="b19c0-241">A zero result always has a sign of 0 and a scale of 0.</span></span>

<span data-ttu-id="b19c0-242">Если десятичное арифметическая операция дает значение меньше или равно `5 * 10^-29` в абсолютном значении, результат операции становится равным нулю.</span><span class="sxs-lookup"><span data-stu-id="b19c0-242">If a decimal arithmetic operation produces a value less than or equal to `5 * 10^-29` in absolute value, the result of the operation becomes zero.</span></span> <span data-ttu-id="b19c0-243">Если `decimal` результат арифметической операции слишком велик для `decimal` формат, `System.OverflowException` возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="b19c0-243">If a `decimal` arithmetic operation produces a result that is too large for the `decimal` format, a `System.OverflowException` is thrown.</span></span>

<span data-ttu-id="b19c0-244">`decimal` Тип имеет большую точность более мелких диапазон, чем типы с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="b19c0-244">The `decimal` type has greater precision but smaller range than the floating-point types.</span></span> <span data-ttu-id="b19c0-245">Таким образом, преобразования из типов с плавающей запятой для `decimal` может выдавать исключения переполнения и преобразования из `decimal` для типов с плавающей запятой может привести к потере точности.</span><span class="sxs-lookup"><span data-stu-id="b19c0-245">Thus, conversions from the floating-point types to `decimal` might produce overflow exceptions, and conversions from `decimal` to the floating-point types might cause loss of precision.</span></span> <span data-ttu-id="b19c0-246">По этим причинам существует неявного преобразования между типами с плавающей запятой и `decimal`, и без явного приведения не нельзя сочетать с плавающей запятой и `decimal` операндов в одном выражении.</span><span class="sxs-lookup"><span data-stu-id="b19c0-246">For these reasons, no implicit conversions exist between the floating-point types and `decimal`, and without explicit casts, it is not possible to mix floating-point and `decimal` operands in the same expression.</span></span>

### <a name="the-bool-type"></a><span data-ttu-id="b19c0-247">Тип bool</span><span class="sxs-lookup"><span data-stu-id="b19c0-247">The bool type</span></span>

<span data-ttu-id="b19c0-248">`bool` Тип представляет логические величины.</span><span class="sxs-lookup"><span data-stu-id="b19c0-248">The `bool` type represents boolean logical quantities.</span></span> <span data-ttu-id="b19c0-249">Возможные значения типа `bool` являются `true` и `false`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-249">The possible values of type `bool` are `true` and `false`.</span></span>

<span data-ttu-id="b19c0-250">Нет стандартных преобразований между `bool` и других типов.</span><span class="sxs-lookup"><span data-stu-id="b19c0-250">No standard conversions exist between `bool` and other types.</span></span> <span data-ttu-id="b19c0-251">В частности `bool` тип отделен от целочисленного типа и `bool` значение не может использоваться вместо целого значения и наоборот.</span><span class="sxs-lookup"><span data-stu-id="b19c0-251">In particular, the `bool` type is distinct and separate from the integral types, and a `bool` value cannot be used in place of an integral value, and vice versa.</span></span>

<span data-ttu-id="b19c0-252">В языках C и C++, нулевое значение целочисленного типа или с плавающей запятой или указатель null можно преобразовать в логическое значение `false`, и ненулевое значение целочисленного типа или с плавающей запятой или указатель отличное от null может быть преобразована в логическое значение `true`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-252">In the C and C++ languages, a zero integral or floating-point value, or a null pointer can be converted to the boolean value `false`, and a non-zero integral or floating-point value, or a non-null pointer can be converted to the boolean value `true`.</span></span> <span data-ttu-id="b19c0-253">В C# такие преобразования выполняются, явное сравнение целого или с плавающей запятой числа до нуля, или явное сравнение ссылку на объект `null`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-253">In C#, such conversions are accomplished by explicitly comparing an integral or floating-point value to zero, or by explicitly comparing an object reference to `null`.</span></span>

### <a name="enumeration-types"></a><span data-ttu-id="b19c0-254">Типы перечисления.</span><span class="sxs-lookup"><span data-stu-id="b19c0-254">Enumeration types</span></span>

<span data-ttu-id="b19c0-255">Тип перечисления является отдельным типом со списком именованных констант.</span><span class="sxs-lookup"><span data-stu-id="b19c0-255">An enumeration type is a distinct type with named constants.</span></span> <span data-ttu-id="b19c0-256">Каждый тип перечисления имеет базовый тип, который должен быть `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` или `ulong`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-256">Every enumeration type has an underlying type, which must be `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` or `ulong`.</span></span> <span data-ttu-id="b19c0-257">Набор значений типа перечисления является таким же, как набор значений базового типа.</span><span class="sxs-lookup"><span data-stu-id="b19c0-257">The set of values of the enumeration type is the same as the set of values of the underlying type.</span></span> <span data-ttu-id="b19c0-258">Значения этого типа перечисления не ограничиваются значениями именованных констант.</span><span class="sxs-lookup"><span data-stu-id="b19c0-258">Values of the enumeration type are not restricted to the values of the named constants.</span></span> <span data-ttu-id="b19c0-259">Типы перечисления определяются посредством объявления перечислений ([объявления перечислений](enums.md#enum-declarations)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-259">Enumeration types are defined through enumeration declarations ([Enum declarations](enums.md#enum-declarations)).</span></span>

### <a name="nullable-types"></a><span data-ttu-id="b19c0-260">Типы, допускающие значения NULL</span><span class="sxs-lookup"><span data-stu-id="b19c0-260">Nullable types</span></span>

<span data-ttu-id="b19c0-261">Обнуляемый тип может представлять все значения его ***базовый тип*** плюс дополнительное значение null.</span><span class="sxs-lookup"><span data-stu-id="b19c0-261">A nullable type can represent all values of its ***underlying type*** plus an additional null value.</span></span> <span data-ttu-id="b19c0-262">Обнуляемый записывается `T?`, где `T` является базовым типом.</span><span class="sxs-lookup"><span data-stu-id="b19c0-262">A nullable type is written `T?`, where `T` is the underlying type.</span></span> <span data-ttu-id="b19c0-263">Этот синтаксис является сокращением для `System.Nullable<T>`, и две формы могут быть взаимозаменяемыми.</span><span class="sxs-lookup"><span data-stu-id="b19c0-263">This syntax is shorthand for `System.Nullable<T>`, and the two forms can be used interchangeably.</span></span>

<span data-ttu-id="b19c0-264">Объект ***не поддерживающий значение NULL тип*** и наоборот является любой тип значения, отличные от `System.Nullable<T>` и его сокращенной формы `T?` (для любого `T`), плюс любой параметр типа, который должен быть тип значения, не допускающие значения NULL (то есть любые параметр типа с `struct` ограничение).</span><span class="sxs-lookup"><span data-stu-id="b19c0-264">A ***non-nullable value type*** conversely is any value type other than `System.Nullable<T>` and its shorthand `T?` (for any `T`), plus any type parameter that is constrained to be a non-nullable value type (that is, any type parameter with a `struct` constraint).</span></span> <span data-ttu-id="b19c0-265">`System.Nullable<T>` Тип определяет ограничение типа значения для `T` ([ограничения параметров типа](classes.md#type-parameter-constraints)), что означает, что базовый тип типа nullable может быть любого типа не поддерживающий значение NULL.</span><span class="sxs-lookup"><span data-stu-id="b19c0-265">The `System.Nullable<T>` type specifies the value type constraint for `T` ([Type parameter constraints](classes.md#type-parameter-constraints)), which means that the underlying type of a nullable type can be any non-nullable value type.</span></span> <span data-ttu-id="b19c0-266">Базовый тип типа nullable не может быть ссылочным типом или типом ссылки.</span><span class="sxs-lookup"><span data-stu-id="b19c0-266">The underlying type of a nullable type cannot be a nullable type or a reference type.</span></span> <span data-ttu-id="b19c0-267">Например `int??` и `string?` являются недопустимыми типами.</span><span class="sxs-lookup"><span data-stu-id="b19c0-267">For example, `int??` and `string?` are invalid types.</span></span>

<span data-ttu-id="b19c0-268">Экземпляр типа nullable `T?` имеет два открытых свойства только для чтения:</span><span class="sxs-lookup"><span data-stu-id="b19c0-268">An instance of a nullable type `T?` has two public read-only properties:</span></span>

*  <span data-ttu-id="b19c0-269">Объект `HasValue` свойство типа `bool`</span><span class="sxs-lookup"><span data-stu-id="b19c0-269">A `HasValue` property of type `bool`</span></span>
*  <span data-ttu-id="b19c0-270">Объект `Value` свойство типа `T`</span><span class="sxs-lookup"><span data-stu-id="b19c0-270">A `Value` property of type `T`</span></span>

<span data-ttu-id="b19c0-271">Экземпляр, для которого `HasValue` имеет значение true, говорят отличное от null.</span><span class="sxs-lookup"><span data-stu-id="b19c0-271">An instance for which `HasValue` is true is said to be non-null.</span></span> <span data-ttu-id="b19c0-272">Содержит экземпляр отличное от null и `Value` возвращает это значение.</span><span class="sxs-lookup"><span data-stu-id="b19c0-272">A non-null instance contains a known value and `Value` returns that value.</span></span>

<span data-ttu-id="b19c0-273">Экземпляр, для которого `HasValue` является false говорят, что иметь значение null.</span><span class="sxs-lookup"><span data-stu-id="b19c0-273">An instance for which `HasValue` is false is said to be null.</span></span> <span data-ttu-id="b19c0-274">Пустой экземпляр имеет неопределенное значение.</span><span class="sxs-lookup"><span data-stu-id="b19c0-274">A null instance has an undefined value.</span></span> <span data-ttu-id="b19c0-275">При чтении `Value` null экземпляра приводит к `System.InvalidOperationException` исключение.</span><span class="sxs-lookup"><span data-stu-id="b19c0-275">Attempting to read the `Value` of a null instance causes a `System.InvalidOperationException` to be thrown.</span></span> <span data-ttu-id="b19c0-276">Процесс доступа к `Value` свойства экземпляра допускает значения NULL, считается ***распаковки***.</span><span class="sxs-lookup"><span data-stu-id="b19c0-276">The process of accessing the `Value` property of a nullable instance is referred to as ***unwrapping***.</span></span>

<span data-ttu-id="b19c0-277">Помимо конструктора по умолчанию, каждый тип, допускающий значение NULL `T?` имеет открытый конструктор, принимающий один аргумент типа `T`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-277">In addition to the default constructor, every nullable type `T?` has a public constructor that takes a single argument of type `T`.</span></span> <span data-ttu-id="b19c0-278">Для заданного значения `x` типа `T`, вызов конструктора формы</span><span class="sxs-lookup"><span data-stu-id="b19c0-278">Given a value `x` of type `T`, a constructor invocation of the form</span></span>

```csharp
new T?(x)
```
<span data-ttu-id="b19c0-279">Создает экземпляр ненулевые `T?` для которого `Value` свойство `x`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-279">creates a non-null instance of `T?` for which the `Value` property is `x`.</span></span> <span data-ttu-id="b19c0-280">Процесс создания непустого экземпляра обнуляемого типа, для заданного значения называется ***упаковки***.</span><span class="sxs-lookup"><span data-stu-id="b19c0-280">The process of creating a non-null instance of a nullable type for a given value is referred to as ***wrapping***.</span></span>

<span data-ttu-id="b19c0-281">Неявные преобразования доступны из `null` литерал `T?` ([преобразования литерала Null](conversions.md#null-literal-conversions)) и из `T` для `T?` ([неявные преобразования обнуляемых типов](conversions.md#implicit-nullable-conversions)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-281">Implicit conversions are available from the `null` literal to `T?` ([Null literal conversions](conversions.md#null-literal-conversions)) and from `T` to `T?` ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions)).</span></span>

## <a name="reference-types"></a><span data-ttu-id="b19c0-282">Ссылочные типы</span><span class="sxs-lookup"><span data-stu-id="b19c0-282">Reference types</span></span>

<span data-ttu-id="b19c0-283">Ссылочный тип является типом класса, тип интерфейса, типом массива или типом делегата.</span><span class="sxs-lookup"><span data-stu-id="b19c0-283">A reference type is a class type, an interface type, an array type, or a delegate type.</span></span>

```antlr
reference_type
    : class_type
    | interface_type
    | array_type
    | delegate_type
    ;

class_type
    : type_name
    | 'object'
    | 'dynamic'
    | 'string'
    ;

interface_type
    : type_name
    ;

array_type
    : non_array_type rank_specifier+
    ;

non_array_type
    : type
    ;

rank_specifier
    : '[' dim_separator* ']'
    ;

dim_separator
    : ','
    ;

delegate_type
    : type_name
    ;
```

<span data-ttu-id="b19c0-284">Значение ссылочного типа — это ссылка на ***экземпляр*** типа, ранее известные как ***объект***.</span><span class="sxs-lookup"><span data-stu-id="b19c0-284">A reference type value is a reference to an ***instance*** of the type, the latter known as an ***object***.</span></span> <span data-ttu-id="b19c0-285">Специальное значение `null` совместима с все ссылочные типы и указывает на отсутствие экземпляра.</span><span class="sxs-lookup"><span data-stu-id="b19c0-285">The special value `null` is compatible with all reference types and indicates the absence of an instance.</span></span>

### <a name="class-types"></a><span data-ttu-id="b19c0-286">Типы классов</span><span class="sxs-lookup"><span data-stu-id="b19c0-286">Class types</span></span>

<span data-ttu-id="b19c0-287">Тип класса определяет структуру данных, содержащий данные членов (константы и поля), функции-члены (методы, свойства, события, индексаторы, операторы, конструкторы экземпляров, деструкторы и статические конструкторы) и вложенные типы.</span><span class="sxs-lookup"><span data-stu-id="b19c0-287">A class type defines a data structure that contains data members (constants and fields), function members (methods, properties, events, indexers, operators, instance constructors, destructors and static constructors), and nested types.</span></span> <span data-ttu-id="b19c0-288">Типы классов поддерживают наследование — механизм, при котором производные классы, расширяющие и уточняющие определения базовых классов.</span><span class="sxs-lookup"><span data-stu-id="b19c0-288">Class types support inheritance, a mechanism whereby derived classes can extend and specialize base classes.</span></span> <span data-ttu-id="b19c0-289">Экземпляры типов классов создаются с помощью *object_creation_expression*s ([выражения создания объектов](expressions.md#object-creation-expressions)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-289">Instances of class types are created using *object_creation_expression*s ([Object creation expressions](expressions.md#object-creation-expressions)).</span></span>

<span data-ttu-id="b19c0-290">Типы классов, описаны в [классы](classes.md).</span><span class="sxs-lookup"><span data-stu-id="b19c0-290">Class types are described in [Classes](classes.md).</span></span>

<span data-ttu-id="b19c0-291">Некоторые предопределенные типы классов имеют особое значение в языке C#, как описано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="b19c0-291">Certain predefined class types have special meaning in the C# language, as described in the table below.</span></span>


| <span data-ttu-id="b19c0-292">__Тип класса__</span><span class="sxs-lookup"><span data-stu-id="b19c0-292">__Class type__</span></span>     | <span data-ttu-id="b19c0-293">__Описание__</span><span class="sxs-lookup"><span data-stu-id="b19c0-293">__Description__</span></span>                                         |
|--------------------|---------------------------------------------------------|
| `System.Object`    | <span data-ttu-id="b19c0-294">Исходным базовым классом для всех других типов.</span><span class="sxs-lookup"><span data-stu-id="b19c0-294">The ultimate base class of all other types.</span></span> <span data-ttu-id="b19c0-295">См. в разделе [тип объекта](types.md#the-object-type).</span><span class="sxs-lookup"><span data-stu-id="b19c0-295">See [The object type](types.md#the-object-type).</span></span> | 
| `System.String`    | <span data-ttu-id="b19c0-296">Строковый тип в языке C#.</span><span class="sxs-lookup"><span data-stu-id="b19c0-296">The string type of the C# language.</span></span> <span data-ttu-id="b19c0-297">См. в разделе [строкового типа](types.md#the-string-type).</span><span class="sxs-lookup"><span data-stu-id="b19c0-297">See [The string type](types.md#the-string-type).</span></span>         |
| `System.ValueType` | <span data-ttu-id="b19c0-298">Базовый класс для всех типов значений.</span><span class="sxs-lookup"><span data-stu-id="b19c0-298">The base class of all value types.</span></span> <span data-ttu-id="b19c0-299">См. в разделе [типа System.ValueType](types.md#the-systemvaluetype-type).</span><span class="sxs-lookup"><span data-stu-id="b19c0-299">See [The System.ValueType type](types.md#the-systemvaluetype-type).</span></span>          |
| `System.Enum`      | <span data-ttu-id="b19c0-300">Базовый класс для всех типов перечислений.</span><span class="sxs-lookup"><span data-stu-id="b19c0-300">The base class of all enum types.</span></span> <span data-ttu-id="b19c0-301">См. в разделе [перечисления](enums.md).</span><span class="sxs-lookup"><span data-stu-id="b19c0-301">See [Enums](enums.md).</span></span>              |
| `System.Array`     | <span data-ttu-id="b19c0-302">Базовый класс для всех этих типов.</span><span class="sxs-lookup"><span data-stu-id="b19c0-302">The base class of all array types.</span></span> <span data-ttu-id="b19c0-303">См. раздел [Массивы](arrays.md).</span><span class="sxs-lookup"><span data-stu-id="b19c0-303">See [Arrays](arrays.md).</span></span>             |
| `System.Delegate`  | <span data-ttu-id="b19c0-304">Базовый класс для всех типов делегатов.</span><span class="sxs-lookup"><span data-stu-id="b19c0-304">The base class of all delegate types.</span></span> <span data-ttu-id="b19c0-305">См. в разделе [делегаты](delegates.md).</span><span class="sxs-lookup"><span data-stu-id="b19c0-305">See [Delegates](delegates.md).</span></span>          |
| `System.Exception` | <span data-ttu-id="b19c0-306">Базовый класс для всех типов исключений.</span><span class="sxs-lookup"><span data-stu-id="b19c0-306">The base class of all exception types.</span></span> <span data-ttu-id="b19c0-307">См. в разделе [исключения](exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="b19c0-307">See [Exceptions](exceptions.md).</span></span>         |

### <a name="the-object-type"></a><span data-ttu-id="b19c0-308">Тип объекта</span><span class="sxs-lookup"><span data-stu-id="b19c0-308">The object type</span></span>

<span data-ttu-id="b19c0-309">`object` Тип класса является исходным базовым классом для всех других типов.</span><span class="sxs-lookup"><span data-stu-id="b19c0-309">The `object` class type is the ultimate base class of all other types.</span></span> <span data-ttu-id="b19c0-310">Каждый тип в C# прямо или косвенно является производным от `object` типа класса.</span><span class="sxs-lookup"><span data-stu-id="b19c0-310">Every type in C# directly or indirectly derives from the `object` class type.</span></span>

<span data-ttu-id="b19c0-311">Ключевое слово `object` является всего лишь псевдоним для стандартных классов `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-311">The keyword `object` is simply an alias for the predefined class `System.Object`.</span></span>

### <a name="the-dynamic-type"></a><span data-ttu-id="b19c0-312">Динамический тип</span><span class="sxs-lookup"><span data-stu-id="b19c0-312">The dynamic type</span></span>

<span data-ttu-id="b19c0-313">`dynamic` Введите, например `object`, могут ссылаться на любой объект.</span><span class="sxs-lookup"><span data-stu-id="b19c0-313">The `dynamic` type, like `object`, can reference any object.</span></span> <span data-ttu-id="b19c0-314">Когда операторы применяются к выражениям типа `dynamic`, способы их устранения, откладывается до запуска программы.</span><span class="sxs-lookup"><span data-stu-id="b19c0-314">When operators are applied to expressions of type `dynamic`, their resolution is deferred until the program is run.</span></span> <span data-ttu-id="b19c0-315">Таким образом Если оператор не может использоваться по закону для объекта ссылки, ошибка не выдается во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="b19c0-315">Thus, if the operator cannot legally be applied to the referenced object, no error is given during compilation.</span></span> <span data-ttu-id="b19c0-316">Вместо этого будет создано исключение при сбое разрешения оператора во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="b19c0-316">Instead an exception will be thrown when resolution of the operator fails at run-time.</span></span>

<span data-ttu-id="b19c0-317">Его назначение — дать динамической привязки, которая подробно описана [динамической привязки](expressions.md#dynamic-binding).</span><span class="sxs-lookup"><span data-stu-id="b19c0-317">Its purpose is to allow dynamic binding, which is described in detail in [Dynamic binding](expressions.md#dynamic-binding).</span></span>

<span data-ttu-id="b19c0-318">`dynamic` считается идентичным `object` только в следующих аспектах:</span><span class="sxs-lookup"><span data-stu-id="b19c0-318">`dynamic` is considered identical to `object` except in the following respects:</span></span>

*  <span data-ttu-id="b19c0-319">Операции над выражениями типа `dynamic` можно динамически привязать ([динамической привязки](expressions.md#dynamic-binding)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-319">Operations on expressions of type `dynamic` can be dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)).</span></span>
*  <span data-ttu-id="b19c0-320">Определение типа ([вывод типа](expressions.md#type-inference)), он предпочтет `dynamic` через `object` Если оба значения являются кандидатами.</span><span class="sxs-lookup"><span data-stu-id="b19c0-320">Type inference ([Type inference](expressions.md#type-inference)) will prefer `dynamic` over `object` if both are candidates.</span></span>

<span data-ttu-id="b19c0-321">Из-за этого эквивалентности ниже содержит:</span><span class="sxs-lookup"><span data-stu-id="b19c0-321">Because of this equivalence, the following holds:</span></span>

*  <span data-ttu-id="b19c0-322">Отсутствует неявное преобразование идентификации между `object` и `dynamic`, а также между сконструированных типов, которые повторяются при замене `dynamic` с `object`</span><span class="sxs-lookup"><span data-stu-id="b19c0-322">There is an implicit identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing `dynamic` with `object`</span></span>
*  <span data-ttu-id="b19c0-323">Явные и неявные преобразования в и из `object` также применяются к и из `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-323">Implicit and explicit conversions to and from `object` also apply to and from `dynamic`.</span></span>
*  <span data-ttu-id="b19c0-324">Сигнатуры методов, которые повторяются при замене `dynamic` с `object` считаются такой же сигнатурой</span><span class="sxs-lookup"><span data-stu-id="b19c0-324">Method signatures that are the same when replacing `dynamic` with `object` are considered the same signature</span></span>
*  <span data-ttu-id="b19c0-325">Тип `dynamic` неотличим от `object` во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="b19c0-325">The type `dynamic` is indistinguishable from `object` at run-time.</span></span>
*  <span data-ttu-id="b19c0-326">Выражение типа `dynamic` называется ***динамического выражения***.</span><span class="sxs-lookup"><span data-stu-id="b19c0-326">An expression of the type `dynamic` is referred to as a ***dynamic expression***.</span></span>

### <a name="the-string-type"></a><span data-ttu-id="b19c0-327">Тип string</span><span class="sxs-lookup"><span data-stu-id="b19c0-327">The string type</span></span>

<span data-ttu-id="b19c0-328">`string` Тип является типом запечатанный класс, который напрямую наследует от `object`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-328">The `string` type is a sealed class type that inherits directly from `object`.</span></span> <span data-ttu-id="b19c0-329">Экземпляры `string` класс представляет символьные строки в Юникоде.</span><span class="sxs-lookup"><span data-stu-id="b19c0-329">Instances of the `string` class represent Unicode character strings.</span></span>

<span data-ttu-id="b19c0-330">Значения типа `string` могут быть записаны в виде строковых литералов ([строковые литералы](lexical-structure.md#string-literals)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-330">Values of the `string` type can be written as string literals ([String literals](lexical-structure.md#string-literals)).</span></span>

<span data-ttu-id="b19c0-331">Ключевое слово `string` является всего лишь псевдоним для стандартных классов `System.String`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-331">The keyword `string` is simply an alias for the predefined class `System.String`.</span></span>

### <a name="interface-types"></a><span data-ttu-id="b19c0-332">Типы интерфейса</span><span class="sxs-lookup"><span data-stu-id="b19c0-332">Interface types</span></span>

<span data-ttu-id="b19c0-333">Интерфейс определяет контракт.</span><span class="sxs-lookup"><span data-stu-id="b19c0-333">An interface defines a contract.</span></span> <span data-ttu-id="b19c0-334">Класс или структура, реализующие интерфейс необходимо придерживаться этого контракта.</span><span class="sxs-lookup"><span data-stu-id="b19c0-334">A class or struct that implements an interface must adhere to its contract.</span></span> <span data-ttu-id="b19c0-335">Интерфейс может наследовать от нескольких базовых интерфейсах и класс или структура может реализовывать несколько интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="b19c0-335">An interface may inherit from multiple base interfaces, and a class or struct may implement multiple interfaces.</span></span>

<span data-ttu-id="b19c0-336">Типы интерфейса описаны в [интерфейсы](interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="b19c0-336">Interface types are described in [Interfaces](interfaces.md).</span></span>

### <a name="array-types"></a><span data-ttu-id="b19c0-337">Типы массивов</span><span class="sxs-lookup"><span data-stu-id="b19c0-337">Array types</span></span>

<span data-ttu-id="b19c0-338">Массив — это структура данных, который содержит ноль или более переменных, которым осуществляется по вычисляемым индексам.</span><span class="sxs-lookup"><span data-stu-id="b19c0-338">An array is a data structure that contains zero or more variables which are accessed through computed indices.</span></span> <span data-ttu-id="b19c0-339">Этот тип называется типом элемента массива и переменными, содержащимися в массиве, также называются элементами массива, имеют тот же тип.</span><span class="sxs-lookup"><span data-stu-id="b19c0-339">The variables contained in an array, also called the elements of the array, are all of the same type, and this type is called the element type of the array.</span></span>

<span data-ttu-id="b19c0-340">Массив типов, описаны в [массивы](arrays.md).</span><span class="sxs-lookup"><span data-stu-id="b19c0-340">Array types are described in [Arrays](arrays.md).</span></span>

### <a name="delegate-types"></a><span data-ttu-id="b19c0-341">Тип делегатов</span><span class="sxs-lookup"><span data-stu-id="b19c0-341">Delegate types</span></span>

<span data-ttu-id="b19c0-342">Делегат — структуру данных, который ссылается на один или несколько методов.</span><span class="sxs-lookup"><span data-stu-id="b19c0-342">A delegate is a data structure that refers to one or more methods.</span></span> <span data-ttu-id="b19c0-343">Для экземпляра метода, он также ссылается на соответствующие экземпляры объектов.</span><span class="sxs-lookup"><span data-stu-id="b19c0-343">For instance methods, it also refers to their corresponding object instances.</span></span>

<span data-ttu-id="b19c0-344">Ближайшим эквивалентом делегата в C или C++ является указатель на функцию, но в то время как указатель на функцию может ссылаться только на статические функции, делегат может ссылаться и на статические и методы экземпляра.</span><span class="sxs-lookup"><span data-stu-id="b19c0-344">The closest equivalent of a delegate in C or C++ is a function pointer, but whereas a function pointer can only reference static functions, a delegate can reference both static and instance methods.</span></span> <span data-ttu-id="b19c0-345">В последнем случае делегат сохраняет не только ссылку на точку входа метода, но ссылка на экземпляр объекта, для которого следует вызвать метод.</span><span class="sxs-lookup"><span data-stu-id="b19c0-345">In the latter case, the delegate stores not only a reference to the method's entry point, but also a reference to the object instance on which to invoke the method.</span></span>

<span data-ttu-id="b19c0-346">Типы делегатов, описаны в [делегаты](delegates.md).</span><span class="sxs-lookup"><span data-stu-id="b19c0-346">Delegate types are described in [Delegates](delegates.md).</span></span>

## <a name="boxing-and-unboxing"></a><span data-ttu-id="b19c0-347">Упаковка-преобразование и распаковка-преобразование</span><span class="sxs-lookup"><span data-stu-id="b19c0-347">Boxing and unboxing</span></span>

<span data-ttu-id="b19c0-348">Концепция упаковка-преобразование и распаковка-преобразование является центральной в системе типов C#.</span><span class="sxs-lookup"><span data-stu-id="b19c0-348">The concept of boxing and unboxing is central to C#'s type system.</span></span> <span data-ttu-id="b19c0-349">Он обеспечивает связь между *value_type*s и *reference_type*s, позволяя любое значение *value_type* для преобразования из типа и `object`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-349">It provides a bridge between *value_type*s and *reference_type*s by permitting any value of a *value_type* to be converted to and from type `object`.</span></span> <span data-ttu-id="b19c0-350">Упаковка-преобразование и распаковка-преобразование обеспечивает единое представление системы типов, при котором значение любого типа в конечном счете воспринимаются как объект.</span><span class="sxs-lookup"><span data-stu-id="b19c0-350">Boxing and unboxing enables a unified view of the type system wherein a value of any type can ultimately be treated as an object.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="b19c0-351">Упаковки-преобразования</span><span class="sxs-lookup"><span data-stu-id="b19c0-351">Boxing conversions</span></span>

<span data-ttu-id="b19c0-352">Упаковка-преобразование позволяет *value_type* должен неявно преобразовываться к *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="b19c0-352">A boxing conversion permits a *value_type* to be implicitly converted to a *reference_type*.</span></span> <span data-ttu-id="b19c0-353">Существуют следующие преобразования упаковки-преобразования:</span><span class="sxs-lookup"><span data-stu-id="b19c0-353">The following boxing conversions exist:</span></span>

*  <span data-ttu-id="b19c0-354">Из любого *value_type* к типу `object`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-354">From any *value_type* to the type `object`.</span></span>
*  <span data-ttu-id="b19c0-355">Из любого *value_type* к типу `System.ValueType`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-355">From any *value_type* to the type `System.ValueType`.</span></span>
*  <span data-ttu-id="b19c0-356">Из любого *non_nullable_value_type* к любому *interface_type* реализуется *value_type*.</span><span class="sxs-lookup"><span data-stu-id="b19c0-356">From any *non_nullable_value_type* to any *interface_type* implemented by the *value_type*.</span></span>
*  <span data-ttu-id="b19c0-357">Из любого *nullable_type* к любому *interface_type* реализуется базовый тип *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="b19c0-357">From any *nullable_type* to any *interface_type* implemented by the underlying type of the *nullable_type*.</span></span>
*  <span data-ttu-id="b19c0-358">Из любого *enum_type* к типу `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-358">From any *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="b19c0-359">Из любого *nullable_type* с базовой *enum_type* к типу `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-359">From any *nullable_type* with an underlying *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="b19c0-360">Обратите внимание, что неявное преобразование из параметра типа выполняется как упаковка-преобразование во время выполнения концов преобразование из типа значения к ссылочному типу ([неявные преобразования, включающие параметры типа](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-360">Note that an implicit conversion from a type parameter will be executed as a boxing conversion if at run-time it ends up converting from a value type to a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span>

<span data-ttu-id="b19c0-361">Упаковка значения *non_nullable_value_type* состоит выделение экземпляра объекта и копирование *non_nullable_value_type* значение в этом экземпляре.</span><span class="sxs-lookup"><span data-stu-id="b19c0-361">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *non_nullable_value_type* value into that instance.</span></span>

<span data-ttu-id="b19c0-362">Упаковка значения *nullable_type* создает ссылку на null, если это `null` значение (`HasValue` — `false`), или результат развертывания и упаковки базового значения, в противном случае.</span><span class="sxs-lookup"><span data-stu-id="b19c0-362">Boxing a value of a *nullable_type* produces a null reference if it is the `null` value (`HasValue` is `false`), or the result of unwrapping and boxing the underlying value otherwise.</span></span>

<span data-ttu-id="b19c0-363">Фактический процесс Упаковка значения *non_nullable_value_type* проще всего определить представляете существование универсальный ***класс упаковки***, который ведет себя так, как если бы он был объявлен следующим образом:</span><span class="sxs-lookup"><span data-stu-id="b19c0-363">The actual process of boxing a value of a *non_nullable_value_type* is best explained by imagining the existence of a generic ***boxing class***, which behaves as if it were declared as follows:</span></span>

```csharp
sealed class Box<T>: System.ValueType
{
    T value;

    public Box(T t) {
        value = t;
    }
}
```

<span data-ttu-id="b19c0-364">Упаковка-преобразование значения `v` типа `T` теперь состоит из выполнения выражения `new Box<T>(v)`и возвратом результата в виде значения типа `object`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-364">Boxing of a value `v` of type `T` now consists of executing the expression `new Box<T>(v)`, and returning the resulting instance as a value of type `object`.</span></span> <span data-ttu-id="b19c0-365">Таким образом операторы</span><span class="sxs-lookup"><span data-stu-id="b19c0-365">Thus, the statements</span></span>
```csharp
int i = 123;
object box = i;
```
<span data-ttu-id="b19c0-366">по существу соответствуют</span><span class="sxs-lookup"><span data-stu-id="b19c0-366">conceptually correspond to</span></span>
```csharp
int i = 123;
object box = new Box<int>(i);
```

<span data-ttu-id="b19c0-367">Класс упаковки `Box<T>` выше не существует фактически и динамический тип упакованного значения не является типом класса.</span><span class="sxs-lookup"><span data-stu-id="b19c0-367">A boxing class like `Box<T>` above doesn't actually exist and the dynamic type of a boxed value isn't actually a class type.</span></span> <span data-ttu-id="b19c0-368">Вместо этого упакованное значение типа `T` имеет динамический тип `T`и проверочного динамического типа с помощью `is` оператор можете просто сослаться на тип `T`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-368">Instead, a boxed value of type `T` has the dynamic type `T`, and a dynamic type check using the `is` operator can simply reference type `T`.</span></span> <span data-ttu-id="b19c0-369">Например, примененная к объекту директива</span><span class="sxs-lookup"><span data-stu-id="b19c0-369">For example,</span></span>
```csharp
int i = 123;
object box = i;
if (box is int) {
    Console.Write("Box contains an int");
}
```
<span data-ttu-id="b19c0-370">Выводит строку "`Box contains an int`" на консоли.</span><span class="sxs-lookup"><span data-stu-id="b19c0-370">will output the string "`Box contains an int`" on the console.</span></span>

<span data-ttu-id="b19c0-371">Упаковка-преобразование подразумевает создать копию упаковываемого значения.</span><span class="sxs-lookup"><span data-stu-id="b19c0-371">A boxing conversion implies making a copy of the value being boxed.</span></span> <span data-ttu-id="b19c0-372">Это отличается от преобразования *reference_type* ввода `object`, в котором значение продолжает ссылаться на тот же экземпляр и считается менее производный тип `object`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-372">This is different from a conversion of a *reference_type* to type `object`, in which the value continues to reference the same instance and simply is regarded as the less derived type `object`.</span></span> <span data-ttu-id="b19c0-373">Например при объявлении</span><span class="sxs-lookup"><span data-stu-id="b19c0-373">For example, given the declaration</span></span>
```csharp
struct Point
{
    public int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```
<span data-ttu-id="b19c0-374">следующие инструкции</span><span class="sxs-lookup"><span data-stu-id="b19c0-374">the following statements</span></span>
```csharp
Point p = new Point(10, 10);
object box = p;
p.x = 20;
Console.Write(((Point)box).x);
```
<span data-ttu-id="b19c0-375">будет выведено значение 10 в консоли, так как операция неявной упаковки-преобразования, которая выполняется в назначение `p` для `box` заставляет значение `p` для копирования.</span><span class="sxs-lookup"><span data-stu-id="b19c0-375">will output the value 10 on the console because the implicit boxing operation that occurs in the assignment of `p` to `box` causes the value of `p` to be copied.</span></span> <span data-ttu-id="b19c0-376">Было `Point` были объявлены `class` вместо этого значение 20 будут выведены, так как `p` и `box` будет ссылаться на тот же экземпляр.</span><span class="sxs-lookup"><span data-stu-id="b19c0-376">Had `Point` been declared a `class` instead, the value 20 would be output because `p` and `box` would reference the same instance.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="b19c0-377">Распаковки-преобразования</span><span class="sxs-lookup"><span data-stu-id="b19c0-377">Unboxing conversions</span></span>

<span data-ttu-id="b19c0-378">Разрешает распаковки-преобразования *reference_type* явным образом преобразовать *value_type*.</span><span class="sxs-lookup"><span data-stu-id="b19c0-378">An unboxing conversion permits a *reference_type* to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="b19c0-379">Существуют следующие распаковки-преобразования:</span><span class="sxs-lookup"><span data-stu-id="b19c0-379">The following unboxing conversions exist:</span></span>

*  <span data-ttu-id="b19c0-380">От типа `object` к любому *value_type*.</span><span class="sxs-lookup"><span data-stu-id="b19c0-380">From the type `object` to any *value_type*.</span></span>
*  <span data-ttu-id="b19c0-381">От типа `System.ValueType` к любому *value_type*.</span><span class="sxs-lookup"><span data-stu-id="b19c0-381">From the type `System.ValueType` to any *value_type*.</span></span>
*  <span data-ttu-id="b19c0-382">Из любого *interface_type* к любому *non_nullable_value_type* , реализующий *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="b19c0-382">From any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span>
*  <span data-ttu-id="b19c0-383">Из любого *interface_type* к любому *nullable_type* базовый тип которого реализует *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="b19c0-383">From any *interface_type* to any *nullable_type* whose underlying type implements the *interface_type*.</span></span>
*  <span data-ttu-id="b19c0-384">От типа `System.Enum` к любому *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="b19c0-384">From the type `System.Enum` to any *enum_type*.</span></span>
*  <span data-ttu-id="b19c0-385">От типа `System.Enum` к любому *nullable_type* с базовой *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="b19c0-385">From the type `System.Enum` to any *nullable_type* with an underlying *enum_type*.</span></span>
*  <span data-ttu-id="b19c0-386">Обратите внимание, что явное преобразование к параметру типа выполняется как распаковки-преобразования во время выполнения концов преобразование из ссылочного типа в тип значения ([явные преобразования динамических](conversions.md#explicit-dynamic-conversions)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-386">Note that an explicit conversion to a type parameter will be executed as an unboxing conversion if at run-time it ends up converting from a reference type to a value type ([Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)).</span></span>

<span data-ttu-id="b19c0-387">Операция распаковки для *non_nullable_value_type* состоит из, что экземпляр объекта является упакованным значением заданного *non_nullable_value_type*, а затем скопировав значение из экземпляр.</span><span class="sxs-lookup"><span data-stu-id="b19c0-387">An unboxing operation to a *non_nullable_value_type* consists of first checking that the object instance is a boxed value of the given *non_nullable_value_type*, and then copying the value out of the instance.</span></span>

<span data-ttu-id="b19c0-388">Для распаковки *nullable_type* дает значение null *nullable_type* Если операнд источника `null`, или результатом распаковки-преобразования экземпляр объекта для базового типа *nullable_type* в противном случае.</span><span class="sxs-lookup"><span data-stu-id="b19c0-388">Unboxing to a *nullable_type* produces the null value of the *nullable_type* if the source operand is `null`, or the wrapped result of unboxing the object instance to the underlying type of the *nullable_type* otherwise.</span></span>

<span data-ttu-id="b19c0-389">Ссылка на класс упаковки, описанный в предыдущем разделе, распаковки-преобразования объекта `box` для *value_type* `T` состоит из выполнения выражения `((Box<T>)box).value`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-389">Referring to the imaginary boxing class described in the previous section, an unboxing conversion of an object `box` to a *value_type* `T` consists of executing the expression `((Box<T>)box).value`.</span></span> <span data-ttu-id="b19c0-390">Таким образом операторы</span><span class="sxs-lookup"><span data-stu-id="b19c0-390">Thus, the statements</span></span>
```csharp
object box = 123;
int i = (int)box;
```
<span data-ttu-id="b19c0-391">по существу соответствуют</span><span class="sxs-lookup"><span data-stu-id="b19c0-391">conceptually correspond to</span></span>
```csharp
object box = new Box<int>(123);
int i = ((Box<int>)box).value;
```

<span data-ttu-id="b19c0-392">Для распаковки-преобразования для заданного *non_nullable_value_type* для успешного выполнения во время выполнения, значение исходного операнда должен быть ссылкой на упакованное значение этого *non_nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="b19c0-392">For an unboxing conversion to a given *non_nullable_value_type* to succeed at run-time, the value of the source operand must be a reference to a boxed value of that *non_nullable_value_type*.</span></span> <span data-ttu-id="b19c0-393">Если операнд источника `null`, `System.NullReferenceException` возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="b19c0-393">If the source operand is `null`, a `System.NullReferenceException` is thrown.</span></span> <span data-ttu-id="b19c0-394">Если исходного операнда является ссылкой на объект несовместимые `System.InvalidCastException` возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="b19c0-394">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="b19c0-395">Для распаковки-преобразования для заданного *nullable_type* для успешного выполнения во время выполнения, значение исходного операнда должно быть либо `null` или ссылка на упакованное значение базового *non_nullable_value_type* из *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="b19c0-395">For an unboxing conversion to a given *nullable_type* to succeed at run-time, the value of the source operand must be either `null` or a reference to a boxed value of the underlying *non_nullable_value_type* of the *nullable_type*.</span></span> <span data-ttu-id="b19c0-396">Если исходного операнда является ссылкой на объект несовместимые `System.InvalidCastException` возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="b19c0-396">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

## <a name="constructed-types"></a><span data-ttu-id="b19c0-397">Сконструированные типы</span><span class="sxs-lookup"><span data-stu-id="b19c0-397">Constructed types</span></span>

<span data-ttu-id="b19c0-398">Объявление универсального типа сам по себе обозначает ***несвязанных универсального типа*** , используемый в качестве «проект» для формирования различных типов посредством применения ***аргументы типа***.</span><span class="sxs-lookup"><span data-stu-id="b19c0-398">A generic type declaration, by itself, denotes an ***unbound generic type*** that is used as a "blueprint" to form many different types, by way of applying ***type arguments***.</span></span> <span data-ttu-id="b19c0-399">Записывается аргументы типа в угловых скобках (`<` и `>`) сразу после имени универсального типа.</span><span class="sxs-lookup"><span data-stu-id="b19c0-399">The type arguments are written within angle brackets (`<` and `>`) immediately following the name of the generic type.</span></span> <span data-ttu-id="b19c0-400">Тип, который включает по крайней мере один тип аргумента называется ***сконструированный тип***.</span><span class="sxs-lookup"><span data-stu-id="b19c0-400">A type that includes at least one type argument is called a ***constructed type***.</span></span> <span data-ttu-id="b19c0-401">Сконструированный тип может использоваться в большинстве мест на языке, в которой отображаются имя типа.</span><span class="sxs-lookup"><span data-stu-id="b19c0-401">A constructed type can be used in most places in the language in which a type name can appear.</span></span> <span data-ttu-id="b19c0-402">Несвязанный универсальный тип может использоваться только в пределах *typeof_expression* ([оператор typeof](expressions.md#the-typeof-operator)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-402">An unbound generic type can only be used within a *typeof_expression* ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

<span data-ttu-id="b19c0-403">Сконструированные типы также могут быть использованы в выражениях как простые имена ([простые имена](expressions.md#simple-names)) или когда доступ к члену ([доступ к членам](expressions.md#member-access)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-403">Constructed types can also be used in expressions as simple names ([Simple names](expressions.md#simple-names)) or when accessing a member ([Member access](expressions.md#member-access)).</span></span>

<span data-ttu-id="b19c0-404">Когда *namespace_or_type_name* вычисляется, только универсальных типов с правильным количеством считаются параметров типа.</span><span class="sxs-lookup"><span data-stu-id="b19c0-404">When a *namespace_or_type_name* is evaluated, only generic types with the correct number of type parameters are considered.</span></span> <span data-ttu-id="b19c0-405">Таким образом можно использовать тот же идентификатор для выявления различных типов, поскольку типы имеют различное число параметров типа.</span><span class="sxs-lookup"><span data-stu-id="b19c0-405">Thus, it is possible to use the same identifier to identify different types, as long as the types have different numbers of type parameters.</span></span> <span data-ttu-id="b19c0-406">Это полезно в том случае, если требуется смешать универсальных и неуниверсальных классах в одной программе:</span><span class="sxs-lookup"><span data-stu-id="b19c0-406">This is useful when mixing generic and non-generic classes in the same program:</span></span>

```csharp
namespace Widgets
{
    class Queue {...}
    class Queue<TElement> {...}
}

namespace MyApplication
{
    using Widgets;

    class X
    {
        Queue q1;            // Non-generic Widgets.Queue
        Queue<int> q2;       // Generic Widgets.Queue
    }
}
```

<span data-ttu-id="b19c0-407">Объект *type_name* может идентифицировать сконструированный тип, несмотря на то, что непосредственно не заданы параметры типа.</span><span class="sxs-lookup"><span data-stu-id="b19c0-407">A *type_name* might identify a constructed type even though it doesn't specify type parameters directly.</span></span> <span data-ttu-id="b19c0-408">Это может произойти, где тип является вложенным в объявлении универсального класса, а тип экземпляра, содержащего объявления неявно используется для поиска имени ([вложенные типы в универсальных классах](classes.md#nested-types-in-generic-classes)):</span><span class="sxs-lookup"><span data-stu-id="b19c0-408">This can occur where a type is nested within a generic class declaration, and the instance type of the containing declaration is implicitly used for name lookup ([Nested types in generic classes](classes.md#nested-types-in-generic-classes)):</span></span>

```csharp
class Outer<T>
{
    public class Inner {...}

    public Inner i;                // Type of i is Outer<T>.Inner
}
```

<span data-ttu-id="b19c0-409">В небезопасном коде сконструированный тип не может использоваться как *unmanaged_type* ([типы указателей](unsafe-code.md#pointer-types)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-409">In unsafe code, a constructed type cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

### <a name="type-arguments"></a><span data-ttu-id="b19c0-410">Аргументы типа</span><span class="sxs-lookup"><span data-stu-id="b19c0-410">Type arguments</span></span>

<span data-ttu-id="b19c0-411">Каждый аргумент из списка аргументов типов — это просто *тип*.</span><span class="sxs-lookup"><span data-stu-id="b19c0-411">Each argument in a type argument list is simply a *type*.</span></span>

```antlr
type_argument_list
    : '<' type_arguments '>'
    ;

type_arguments
    : type_argument (',' type_argument)*
    ;

type_argument
    : type
    ;
```

<span data-ttu-id="b19c0-412">В небезопасном коде ([небезопасный код](unsafe-code.md)), *type_argument* не может иметь тип указателя.</span><span class="sxs-lookup"><span data-stu-id="b19c0-412">In unsafe code ([Unsafe code](unsafe-code.md)), a *type_argument* may not be a pointer type.</span></span> <span data-ttu-id="b19c0-413">Каждый аргумент типа должен соответствовать любые ограничения для соответствующего параметра типа ([ограничения параметров типа](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-413">Each type argument must satisfy any constraints on the corresponding type parameter ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>

### <a name="open-and-closed-types"></a><span data-ttu-id="b19c0-414">Открытые и закрытые типы</span><span class="sxs-lookup"><span data-stu-id="b19c0-414">Open and closed types</span></span>

<span data-ttu-id="b19c0-415">Все типы можно классифицировать как ***открытые типы*** или ***закрытые типы***.</span><span class="sxs-lookup"><span data-stu-id="b19c0-415">All types can be classified as either ***open types*** or ***closed types***.</span></span> <span data-ttu-id="b19c0-416">Открытый тип является типом, который включает в себя параметры типа.</span><span class="sxs-lookup"><span data-stu-id="b19c0-416">An open type is a type that involves type parameters.</span></span> <span data-ttu-id="b19c0-417">В частности:</span><span class="sxs-lookup"><span data-stu-id="b19c0-417">More specifically:</span></span>

*  <span data-ttu-id="b19c0-418">Параметр типа определяет открытый тип.</span><span class="sxs-lookup"><span data-stu-id="b19c0-418">A type parameter defines an open type.</span></span>
*  <span data-ttu-id="b19c0-419">Только в том случае, если его тип элемента является открытым типом, типом массива является открытым типом.</span><span class="sxs-lookup"><span data-stu-id="b19c0-419">An array type is an open type if and only if its element type is an open type.</span></span>
*  <span data-ttu-id="b19c0-420">Сконструированный тип является открытым типом только в том случае, если один или несколько из его аргументов типа является открытым типом.</span><span class="sxs-lookup"><span data-stu-id="b19c0-420">A constructed type is an open type if and only if one or more of its type arguments is an open type.</span></span> <span data-ttu-id="b19c0-421">Вложенный сформированный тип является открытым типом только в том случае, если один или несколько аргументов типа или аргументы типа для содержащих его типов является открытым типом.</span><span class="sxs-lookup"><span data-stu-id="b19c0-421">A constructed nested type is an open type if and only if one or more of its type arguments or the type arguments of its containing type(s) is an open type.</span></span>

<span data-ttu-id="b19c0-422">Закрытый тип является типом, который не является открытым типом.</span><span class="sxs-lookup"><span data-stu-id="b19c0-422">A closed type is a type that is not an open type.</span></span>

<span data-ttu-id="b19c0-423">Во время выполнения весь код в объявлении универсального типа выполняется в контексте закрытого сконструированного типа, который был создан путем применения аргументов типа в универсальном объявлении.</span><span class="sxs-lookup"><span data-stu-id="b19c0-423">At run-time, all of the code within a generic type declaration is executed in the context of a closed constructed type that was created by applying type arguments to the generic declaration.</span></span> <span data-ttu-id="b19c0-424">Каждый параметр типа в универсальный тип привязан к определенному типу во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="b19c0-424">Each type parameter within the generic type is bound to a particular run-time type.</span></span> <span data-ttu-id="b19c0-425">Обработка времени выполнения всех инструкций и выражений всегда осуществляется с закрытые типы и открытые типы происходить только во время компиляции обработки.</span><span class="sxs-lookup"><span data-stu-id="b19c0-425">The run-time processing of all statements and expressions always occurs with closed types, and open types occur only during compile-time processing.</span></span>

<span data-ttu-id="b19c0-426">Каждый закрытым сконструированным типом имеет свой собственный набор статических переменных, которые не являются общими с любой другой закрытые сконструированные типы.</span><span class="sxs-lookup"><span data-stu-id="b19c0-426">Each closed constructed type has its own set of static variables, which are not shared with any other closed constructed types.</span></span> <span data-ttu-id="b19c0-427">Поскольку открытый тип не существует во время выполнения, существует статические переменные, связанные с открытым типом.</span><span class="sxs-lookup"><span data-stu-id="b19c0-427">Since an open type does not exist at run-time, there are no static variables associated with an open type.</span></span> <span data-ttu-id="b19c0-428">Два закрытых сконструированных типов относятся к одному типу, если они созданы на базе одного несвязанного универсального типа, а их соответствующие аргументы типа относятся к одному типу.</span><span class="sxs-lookup"><span data-stu-id="b19c0-428">Two closed constructed types are the same type if they are constructed from the same unbound generic type, and their corresponding type arguments are the same type.</span></span>

### <a name="bound-and-unbound-types"></a><span data-ttu-id="b19c0-429">Присоединенные и свободные типы</span><span class="sxs-lookup"><span data-stu-id="b19c0-429">Bound and unbound types</span></span>

<span data-ttu-id="b19c0-430">Термин ***несвязанных тип*** относится к неуниверсального типа или несвязанного универсального типа.</span><span class="sxs-lookup"><span data-stu-id="b19c0-430">The term ***unbound type*** refers to a non-generic type or an unbound generic type.</span></span> <span data-ttu-id="b19c0-431">Термин ***связанный тип*** ссылается на неуниверсального типа или сконструированным типом.</span><span class="sxs-lookup"><span data-stu-id="b19c0-431">The term ***bound type*** refers to a non-generic type or a constructed type.</span></span>

<span data-ttu-id="b19c0-432">Несвязанный тип ссылается на сущность, объявленных в объявлении типа.</span><span class="sxs-lookup"><span data-stu-id="b19c0-432">An unbound type refers to the entity declared by a type declaration.</span></span> <span data-ttu-id="b19c0-433">Несвязанный универсальный тип не является типом и не может использоваться как тип переменной, аргумента или возвращаемого значения или как базовый тип.</span><span class="sxs-lookup"><span data-stu-id="b19c0-433">An unbound generic type is not itself a type, and cannot be used as the type of a variable, argument or return value, or as a base type.</span></span> <span data-ttu-id="b19c0-434">Только конструкция, в котором можно ссылаться несвязанного универсального типа — `typeof` выражение ([оператор typeof](expressions.md#the-typeof-operator)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-434">The only construct in which an unbound generic type can be referenced is the `typeof` expression ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

### <a name="satisfying-constraints"></a><span data-ttu-id="b19c0-435">Соблюдение ограничений</span><span class="sxs-lookup"><span data-stu-id="b19c0-435">Satisfying constraints</span></span>

<span data-ttu-id="b19c0-436">Каждый раз, когда упоминаемый сконструированного типа или универсального метода, проверяются на соответствие ограничения параметра типа, объявленные в универсальном типе или методе аргументов типа ([ограничения параметров типа](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-436">Whenever a constructed type or generic method is referenced, the supplied type arguments are checked against the type parameter constraints declared on the generic type or method ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="b19c0-437">Для каждого `where` предложение, аргумент типа `A` , соответствующий именованный параметр типа проверяется каждое ограничение, следующим образом:</span><span class="sxs-lookup"><span data-stu-id="b19c0-437">For each `where` clause, the type argument `A` that corresponds to the named type parameter is checked against each constraint as follows:</span></span>

*  <span data-ttu-id="b19c0-438">Если ограничение типа класса, тип интерфейса или параметр типа, пусть `C` представляют ограничения для аргументов типа заменителями любые параметры типа, которые отображаются в ограничении.</span><span class="sxs-lookup"><span data-stu-id="b19c0-438">If the constraint is a class type, an interface type, or a type parameter, let `C` represent that constraint with the supplied type arguments substituted for any type parameters that appear in the constraint.</span></span> <span data-ttu-id="b19c0-439">В соответствии с ограничением, должен быть в случае, если тип `A` преобразуется в тип `C` одним из следующих:</span><span class="sxs-lookup"><span data-stu-id="b19c0-439">To satisfy the constraint, it must be the case that type `A` is convertible to type `C` by one of the following:</span></span>
    * <span data-ttu-id="b19c0-440">Преобразование удостоверения ([преобразование идентификации](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="b19c0-440">An identity conversion ([Identity conversion](conversions.md#identity-conversion))</span></span>
    * <span data-ttu-id="b19c0-441">И неявное ссылочное преобразование ([неявные преобразования ссылочных типов](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="b19c0-441">An implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
    * <span data-ttu-id="b19c0-442">Упаковка-преобразование ([осуществлять преобразования-упаковки](conversions.md#boxing-conversions)) при условии, что тип A является типом значения, не допускающие значения NULL.</span><span class="sxs-lookup"><span data-stu-id="b19c0-442">A boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)), provided that type A is a non-nullable value type.</span></span>
    * <span data-ttu-id="b19c0-443">Неявное преобразование ссылок, упаковки-преобразования или тип параметра из параметра типа `A` для `C`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-443">An implicit reference, boxing or type parameter conversion from a type parameter `A` to `C`.</span></span>
*  <span data-ttu-id="b19c0-444">Если ограничение является ограничение ссылочного типа (`class`), тип `A` должен соответствовать одному из следующих:</span><span class="sxs-lookup"><span data-stu-id="b19c0-444">If the constraint is the reference type constraint (`class`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="b19c0-445">`A` — Это тип интерфейса, тип класса, тип делегата или тип массива.</span><span class="sxs-lookup"><span data-stu-id="b19c0-445">`A` is an interface type, class type, delegate type or array type.</span></span> <span data-ttu-id="b19c0-446">Обратите внимание, что `System.ValueType` и `System.Enum` являются ссылочными типами, которые удовлетворяют этому ограничению.</span><span class="sxs-lookup"><span data-stu-id="b19c0-446">Note that `System.ValueType` and `System.Enum` are reference types that satisfy this constraint.</span></span>
    * <span data-ttu-id="b19c0-447">`A` является параметром типа, который известен быть ссылочным типом ([ограничения параметров типа](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-447">`A` is a type parameter that is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="b19c0-448">Если ограничение является ограничение типа значения (`struct`), тип `A` должен соответствовать одному из следующих:</span><span class="sxs-lookup"><span data-stu-id="b19c0-448">If the constraint is the value type constraint (`struct`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="b19c0-449">`A` является типом структуры или тип перечисления, но не является обнуляемым типом.</span><span class="sxs-lookup"><span data-stu-id="b19c0-449">`A` is a struct type or enum type, but not a nullable type.</span></span> <span data-ttu-id="b19c0-450">Обратите внимание, что `System.ValueType` и `System.Enum` являются ссылочными типами, которые не удовлетворяют этому ограничению.</span><span class="sxs-lookup"><span data-stu-id="b19c0-450">Note that `System.ValueType` and `System.Enum` are reference types that do not satisfy this constraint.</span></span>
    * <span data-ttu-id="b19c0-451">`A` является параметром типа с ограничением типа значения ([ограничения параметров типа](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-451">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="b19c0-452">Если ограничение является ограничение конструктора `new()`, тип `A` не должно быть `abstract` и должен иметь открытый конструктор без параметров.</span><span class="sxs-lookup"><span data-stu-id="b19c0-452">If the constraint is the constructor constraint `new()`, the type `A` must not be `abstract` and must have a public parameterless constructor.</span></span> <span data-ttu-id="b19c0-453">Это выполняется, если выполняется одно из следующих:</span><span class="sxs-lookup"><span data-stu-id="b19c0-453">This is satisfied if one of the following is true:</span></span>
    * <span data-ttu-id="b19c0-454">`A` является типом значения, так как все типы значений иметь открытый конструктор по умолчанию ([конструкторы по умолчанию](types.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-454">`A` is a value type, since all value types have a public default constructor ([Default constructors](types.md#default-constructors)).</span></span>
    * <span data-ttu-id="b19c0-455">`A` Представляет параметр типа ограничение конструктора ([ограничения параметров типа](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-455">`A` is a type parameter having the constructor constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="b19c0-456">`A` является параметром типа с ограничением типа значения ([ограничения параметров типа](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-456">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="b19c0-457">`A` — Это класс, который не `abstract` и содержит явно объявленный `public` конструктор без параметров.</span><span class="sxs-lookup"><span data-stu-id="b19c0-457">`A` is a class that is not `abstract` and contains an explicitly declared `public` constructor with no parameters.</span></span>
    * <span data-ttu-id="b19c0-458">`A` не `abstract` и имеет конструктор по умолчанию ([конструкторы по умолчанию](classes.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-458">`A` is not `abstract` and has a default constructor ([Default constructors](classes.md#default-constructors)).</span></span>

<span data-ttu-id="b19c0-459">Ошибка времени компиляции возникает, если один или несколько ограничений параметров типа не совместимы с заданными аргументами типа.</span><span class="sxs-lookup"><span data-stu-id="b19c0-459">A compile-time error occurs if one or more of a type parameter's constraints are not satisfied by the given type arguments.</span></span>

<span data-ttu-id="b19c0-460">Так как параметры типа не наследуются, установленных ограничений либо наследуется.</span><span class="sxs-lookup"><span data-stu-id="b19c0-460">Since type parameters are not inherited, constraints are never inherited either.</span></span> <span data-ttu-id="b19c0-461">В следующем примере `D` должен указать ограничения для параметра типа `T` таким образом, чтобы `T` удовлетворяет ограничение, наложенное базовый класс `B<T>`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-461">In the example below, `D` needs to specify the constraint on its type parameter `T` so that `T` satisfies the constraint imposed by the base class `B<T>`.</span></span> <span data-ttu-id="b19c0-462">Напротив, класс `E` не требуется указывать ограничения, так как `List<T>` реализует `IEnumerable` для любого `T`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-462">In contrast, class `E` need not specify a constraint, because `List<T>` implements `IEnumerable` for any `T`.</span></span>

```csharp
class B<T> where T: IEnumerable {...}

class D<T>: B<T> where T: IEnumerable {...}

class E<T>: B<List<T>> {...}
```

## <a name="type-parameters"></a><span data-ttu-id="b19c0-463">Параметры типа</span><span class="sxs-lookup"><span data-stu-id="b19c0-463">Type parameters</span></span>

<span data-ttu-id="b19c0-464">Параметр типа — это идентификатор, обозначающий тип значения или ссылочный тип, который привязывается данный параметр во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="b19c0-464">A type parameter is an identifier designating a value type or reference type that the parameter is bound to at run-time.</span></span>

```antlr
type_parameter
    : identifier
    ;
```

<span data-ttu-id="b19c0-465">Так как параметр типа может быть создан с множеством различных фактических типов аргументов, параметры типа имеют несколько различных операций и ограничений, чем другие типы.</span><span class="sxs-lookup"><span data-stu-id="b19c0-465">Since a type parameter can be instantiated with many different actual type arguments, type parameters have slightly different operations and restrictions than other types.</span></span> <span data-ttu-id="b19c0-466">Сюда входит следующее.</span><span class="sxs-lookup"><span data-stu-id="b19c0-466">These include:</span></span>

*  <span data-ttu-id="b19c0-467">Параметр типа не может использоваться непосредственно для объявления базового класса ([базового класса](classes.md#base-class)) или интерфейс ([списков параметров типа Variant](interfaces.md#variant-type-parameter-lists)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-467">A type parameter cannot be used directly to declare a base class ([Base class](classes.md#base-class)) or interface ([Variant type parameter lists](interfaces.md#variant-type-parameter-lists)).</span></span>
*  <span data-ttu-id="b19c0-468">Правила для поиска членов в типе, параметры зависят от ограничений, если таковые имеются, примененных к параметру типа.</span><span class="sxs-lookup"><span data-stu-id="b19c0-468">The rules for member lookup on type parameters depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="b19c0-469">Они подробно описаны в [поиск члена](expressions.md#member-lookup).</span><span class="sxs-lookup"><span data-stu-id="b19c0-469">They are detailed in [Member lookup](expressions.md#member-lookup).</span></span>
*  <span data-ttu-id="b19c0-470">Доступные преобразования для параметра типа зависят от ограничений, если таковое имеется, применяется к параметру типа.</span><span class="sxs-lookup"><span data-stu-id="b19c0-470">The available conversions for a type parameter depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="b19c0-471">Они подробно описаны в [неявные преобразования, включающие параметры типа](conversions.md#implicit-conversions-involving-type-parameters) и [явные преобразования динамических](conversions.md#explicit-dynamic-conversions).</span><span class="sxs-lookup"><span data-stu-id="b19c0-471">They are detailed in [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions).</span></span>
*  <span data-ttu-id="b19c0-472">Литерал `null` невозможно преобразовать к типу, заданному параметром типа, за исключением случаев, если параметр типа является ссылочным типом ([неявные преобразования, включающие параметры типа](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-472">The literal `null` cannot be converted to a type given by a type parameter, except if the type parameter is known to be a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span> <span data-ttu-id="b19c0-473">Тем не менее `default` выражение ([выражения значения по умолчанию](expressions.md#default-value-expressions)) можно использовать.</span><span class="sxs-lookup"><span data-stu-id="b19c0-473">However, a `default` expression ([Default value expressions](expressions.md#default-value-expressions)) can be used instead.</span></span> <span data-ttu-id="b19c0-474">Кроме того, можно сравнить значение с типом, заданное в параметре типа с `null` с помощью `==` и `!=` ([операторы равенства ссылочного типа](expressions.md#reference-type-equality-operators)) Если параметр типа имеет ограничение типа значения.</span><span class="sxs-lookup"><span data-stu-id="b19c0-474">In addition, a value with a type given by a type parameter can be compared with `null` using `==` and `!=` ([Reference type equality operators](expressions.md#reference-type-equality-operators)) unless the type parameter has the value type constraint.</span></span>
*  <span data-ttu-id="b19c0-475">Объект `new` выражение ([выражения создания объектов](expressions.md#object-creation-expressions)) может использоваться только с параметром типа, если параметр типа ограничивается *constructor_constraint* или тип ограничения (значения[ Ограничения параметров типа](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-475">A `new` expression ([Object creation expressions](expressions.md#object-creation-expressions)) can only be used with a type parameter if the type parameter is constrained by a *constructor_constraint* or the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="b19c0-476">Параметр типа не может использоваться в любом месте внутри атрибута.</span><span class="sxs-lookup"><span data-stu-id="b19c0-476">A type parameter cannot be used anywhere within an attribute.</span></span>
*  <span data-ttu-id="b19c0-477">Параметр типа не может использоваться в доступ к членам ([доступ к членам](expressions.md#member-access)) или имя типа ([пространства имен и тип](basic-concepts.md#namespace-and-type-names)) для определения статического члена или вложенного типа.</span><span class="sxs-lookup"><span data-stu-id="b19c0-477">A type parameter cannot be used in a member access ([Member access](expressions.md#member-access)) or type name ([Namespace and type names](basic-concepts.md#namespace-and-type-names)) to identify a static member or a nested type.</span></span>
*  <span data-ttu-id="b19c0-478">В небезопасном коде параметр типа не может использоваться как *unmanaged_type* ([типы указателей](unsafe-code.md#pointer-types)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-478">In unsafe code, a type parameter cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

<span data-ttu-id="b19c0-479">Как тип параметры типа являются исключительно конструкцию времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="b19c0-479">As a type, type parameters are purely a compile-time construct.</span></span> <span data-ttu-id="b19c0-480">Во время выполнения каждого параметра типа связан с типом времени выполнения, который был указан, указав аргумент типа для универсального типа.</span><span class="sxs-lookup"><span data-stu-id="b19c0-480">At run-time, each type parameter is bound to a run-time type that was specified by supplying a type argument to the generic type declaration.</span></span> <span data-ttu-id="b19c0-481">Таким образом, тип переменной, объявленный с помощью параметра типа во время выполнения будет быть закрытым сконструированным типом ([открытые и закрытые типы](types.md#open-and-closed-types)).</span><span class="sxs-lookup"><span data-stu-id="b19c0-481">Thus, the type of a variable declared with a type parameter will, at run-time, be a closed constructed type ([Open and closed types](types.md#open-and-closed-types)).</span></span> <span data-ttu-id="b19c0-482">Во время выполнения всех инструкций и выражений, содержащих параметры типа используются фактические типы, предоставленные как аргумент типа для этого параметра.</span><span class="sxs-lookup"><span data-stu-id="b19c0-482">The run-time execution of all statements and expressions involving type parameters uses the actual type that was supplied as the type argument for that parameter.</span></span>

## <a name="expression-tree-types"></a><span data-ttu-id="b19c0-483">Типы дерева выражений</span><span class="sxs-lookup"><span data-stu-id="b19c0-483">Expression tree types</span></span>

<span data-ttu-id="b19c0-484">***Деревья выражений*** разрешить лямбда-выражения в виде структур данных, а не исполняемый код.</span><span class="sxs-lookup"><span data-stu-id="b19c0-484">***Expression trees*** permit lambda expressions to be represented as data structures instead of executable code.</span></span> <span data-ttu-id="b19c0-485">Деревья выражений являются значения ***типы дерева выражений*** формы `System.Linq.Expressions.Expression<D>`, где `D` — это любой тип делегата.</span><span class="sxs-lookup"><span data-stu-id="b19c0-485">Expression trees are values of ***expression tree types*** of the form `System.Linq.Expressions.Expression<D>`, where `D` is any delegate type.</span></span> <span data-ttu-id="b19c0-486">Далее в этой спецификации, мы будем называть эти типы, с помощью сокращенного `Expression<D>`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-486">For the remainder of this specification we will refer to these types using the shorthand `Expression<D>`.</span></span>

<span data-ttu-id="b19c0-487">Если существует преобразование из лямбда-выражение с типом делегата `D`, также существует преобразование в тип дерева выражения `Expression<D>`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-487">If a conversion exists from a lambda expression to a delegate type `D`, a conversion also exists to the expression tree type `Expression<D>`.</span></span> <span data-ttu-id="b19c0-488">В то время как преобразование лямбда-выражения к типу делегата создает делегат, который ссылается на исполняемый код для лямбда-выражения, преобразование в тип дерева выражения создает представление дерева выражения лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="b19c0-488">Whereas the conversion of a lambda expression to a delegate type generates a delegate that references executable code for the lambda expression, conversion to an expression tree type creates an expression tree representation of the lambda expression.</span></span>

<span data-ttu-id="b19c0-489">Деревья выражений очень эффективный данных в памяти представления лямбда-выражений и структуре лямбда-выражения прозрачной и явной.</span><span class="sxs-lookup"><span data-stu-id="b19c0-489">Expression trees are efficient in-memory data representations of lambda expressions and make the structure of the lambda expression transparent and explicit.</span></span>

<span data-ttu-id="b19c0-490">Так же, как тип делегата `D`, `Expression<D>` считается имеет параметров и возвращаемых типов, которые являются те же `D`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-490">Just like a delegate type `D`, `Expression<D>` is said to have parameter and return types, which are the same as those of `D`.</span></span>

<span data-ttu-id="b19c0-491">В следующем примере представлен лямбда-выражения и как исполняемый код и как дерево выражения.</span><span class="sxs-lookup"><span data-stu-id="b19c0-491">The following example represents a lambda expression both as executable code and as an expression tree.</span></span> <span data-ttu-id="b19c0-492">Так как существует преобразование в `Func<int,int>`, также существует преобразование в `Expression<Func<int,int>>`:</span><span class="sxs-lookup"><span data-stu-id="b19c0-492">Because a conversion exists to `Func<int,int>`, a conversion also exists to `Expression<Func<int,int>>`:</span></span>

```csharp
Func<int,int> del = x => x + 1;                    // Code

Expression<Func<int,int>> exp = x => x + 1;        // Data
```

<span data-ttu-id="b19c0-493">Выполнив эти назначения делегата `del` ссылается на метод, возвращающий `x + 1`и дерево выражения `exp` ссылается на структуру данных, описывающую выражение `x => x + 1`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-493">Following these assignments, the delegate `del` references a method that returns `x + 1`, and the expression tree `exp` references a data structure that describes the expression `x => x + 1`.</span></span>

<span data-ttu-id="b19c0-494">Точное определение универсального типа `Expression<D>` а также точные правила построения дерева выражений, когда лямбда-выражение преобразуется в тип дерева выражения, оба находятся вне области данной спецификации.</span><span class="sxs-lookup"><span data-stu-id="b19c0-494">The exact definition of the generic type `Expression<D>` as well as the precise rules for constructing an expression tree when a lambda expression is converted to an expression tree type, are both outside the scope of this specification.</span></span>

<span data-ttu-id="b19c0-495">Чтобы сделать явное важны две вещи:</span><span class="sxs-lookup"><span data-stu-id="b19c0-495">Two things are important to make explicit:</span></span>

*  <span data-ttu-id="b19c0-496">Не все лямбда-выражения можно преобразовать в деревья выражений.</span><span class="sxs-lookup"><span data-stu-id="b19c0-496">Not all lambda expressions can be converted to expression trees.</span></span> <span data-ttu-id="b19c0-497">Например лямбда-выражения тела оператора и лямбда-выражения, содержащего выражения присваивания не удается представить.</span><span class="sxs-lookup"><span data-stu-id="b19c0-497">For instance, lambda expressions with statement bodies, and lambda expressions containing assignment expressions cannot be represented.</span></span> <span data-ttu-id="b19c0-498">В этом случае преобразование по-прежнему существует, но приведет к сбою во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="b19c0-498">In these cases, a conversion still exists, but will fail at compile-time.</span></span> <span data-ttu-id="b19c0-499">Эти исключения, подробно изложены в [преобразования анонимных функций](conversions.md#anonymous-function-conversions).</span><span class="sxs-lookup"><span data-stu-id="b19c0-499">These exceptions are detailed in [Anonymous function conversions](conversions.md#anonymous-function-conversions).</span></span>
*   <span data-ttu-id="b19c0-500">`Expression<D>` предоставляет метод экземпляра `Compile` которого создает делегат типа `D`:</span><span class="sxs-lookup"><span data-stu-id="b19c0-500">`Expression<D>` offers an instance method `Compile` which produces a delegate of type `D`:</span></span>

    ```csharp
    Func<int,int> del2 = exp.Compile();
    ```

    <span data-ttu-id="b19c0-501">Вызов данного делегата вызывает код, представленный деревом выражения, который будет выполнен.</span><span class="sxs-lookup"><span data-stu-id="b19c0-501">Invoking this delegate causes the code represented by the expression tree to be executed.</span></span> <span data-ttu-id="b19c0-502">Таким образом учитывая приведенные выше определения, del и del2 эквивалентны и двух следующих операторов будет иметь тот же эффект:</span><span class="sxs-lookup"><span data-stu-id="b19c0-502">Thus, given the definitions above, del and del2 are equivalent, and the following two statements will have the same effect:</span></span>

    ```csharp
    int i1 = del(1);
    
    int i2 = del2(1);
    ```

    <span data-ttu-id="b19c0-503">После выполнения этого кода `i1` и `i2` будет иметь значение `2`.</span><span class="sxs-lookup"><span data-stu-id="b19c0-503">After executing this code,  `i1` and `i2` will both have the value `2`.</span></span>

