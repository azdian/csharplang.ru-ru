# <a name="types"></a>Типы

Типы языка C# можно разделить на две основные категории: ***типы значений*** и ***ссылочные типы***. Типы значений и ссылочные типы могут быть ***универсальных типов***, который сделать один или несколько ***параметры типа***. Параметры типа можно назначить обоих типов значений и ссылочные типы.

```antlr
type
    : value_type
    | reference_type
    | type_parameter
    | type_unsafe
    ;
```

Окончательный категории типов указателей, доступна только в небезопасном коде. Это описано далее в [типы указателей](unsafe-code.md#pointer-types).

Типы значений отличаются от ссылочных типов, переменные типа значений содержат непосредственно данные, тогда как переменные, ссылки на типы хранилища ***ссылки*** обращаются к данным, которые именуются ***объекты***. Со ссылочными типами это две переменные могут ссылаться на тот же объект и поэтому может случиться операции над одной переменной затронут объект, который ссылается другая переменная. С типами значений каждая переменная имеет свою собственную копию данных и операции над одной могут затрагивать другую невозможно.

Система типов C# унифицирована таким образом, что значение любого типа можно рассматривать как объект. Каждый тип в C# является прямо или косвенно производным от типа класса `object`, и этот тип `object` является исходным базовым классом для всех типов. Чтобы значения ссылочного типа обрабатывались как объекты, им просто присваивается тип `object`. Значения типов значений, рассматриваются как объекты, выполняя операции упаковки и распаковки ([упаковка-преобразование и распаковка-преобразование](types.md#boxing-and-unboxing)).

## <a name="value-types"></a>Типы значений

Тип значения является типом структуры или тип перечисления. C# предоставляет набор предопределенных типов структуры вызывается ***простых типов***. Простые типы определяются с помощью зарезервированных слов.

```antlr
value_type
    : struct_type
    | enum_type
    ;

struct_type
    : type_name
    | simple_type
    | nullable_type
    ;

simple_type
    : numeric_type
    | 'bool'
    ;

numeric_type
    : integral_type
    | floating_point_type
    | 'decimal'
    ;

integral_type
    : 'sbyte'
    | 'byte'
    | 'short'
    | 'ushort'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    ;

floating_point_type
    : 'float'
    | 'double'
    ;

nullable_type
    : non_nullable_value_type '?'
    ;

non_nullable_value_type
    : type
    ;

enum_type
    : type_name
    ;
```

В отличие от переменной ссылочного типа, переменная типа значения может содержать значение `null` только в том случае, если тип значения — обнуляемый тип.  Для каждого типа значения, не допускающим значения есть соответствующий обнуляемый тип, включающий те же значения, а также значение `null`.

Присвоение переменной значения типа создает копию значения, присваиваемого. В отличие от назначения переменной ссылочного типа, который копирует ссылка, но не объект, указанный ссылкой.

### <a name="the-systemvaluetype-type"></a>Тип System.ValueType

Все типы значений неявно наследуются от класса `System.ValueType`, который, в свою очередь, наследует от класса `object`. Он не поддерживается для любого типа на основании типа значения и типы значений являются запечатанными таким образом неявно ([запечатанных классов](classes.md#sealed-classes)).

Обратите внимание, что `System.ValueType` сам не *value_type*. Кроме того, это *class_type* из которой все *value_type*s автоматически являются производными.

### <a name="default-constructors"></a>Конструкторы по умолчанию

Все типы значений неявно объявляет конструктор открытого экземпляра без параметров вызывается ***конструктор по умолчанию***. Конструктор по умолчанию возвращает экземпляр инициализируемого нулевым значением, называемый ***значение по умолчанию*** для типа значения:

*  Для всех *simple_type*, значение по умолчанию имеет значение, произведенное битового шаблона изо всех нулей:
    * Для `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, и `ulong`, значение по умолчанию — `0`.
    * Для `char`, значение по умолчанию — `'\x0000'`.
    * Для `float`, значение по умолчанию — `0.0f`.
    * Для `double`, значение по умолчанию — `0.0d`.
    * Для `decimal`, значение по умолчанию — `0.0m`.
    * Для `bool`, значение по умолчанию — `false`.
*  Для *enum_type* `E`, значение по умолчанию — `0`, преобразованным в тип `E`.
*  Для *struct_type*, значение по умолчанию является значение, создаваемое путем установки все поля типа значения полей с типом значения по умолчанию и справочник по всем `null`.
*  Для *nullable_type* значение по умолчанию — это экземпляр, для которого `HasValue` свойство имеет значение false и `Value` свойство не определено. Значение по умолчанию также называется ***значение null*** типа, допускающего значение NULL.

Как и любой другой конструктор экземпляров, конструктор по умолчанию для типа значения, вызываемая при помощи `new` оператор. В целях повышения эффективности это требование не является фактически реализацией создается вызов конструктора. В примере ниже, переменные `i` и `j` инициализируются до нуля.

```csharp
class A
{
    void F() {
        int i = 0;
        int j = new int();
    }
}
```

Так как каждый тип значения неявно имеет открытый конструктор экземпляра, он не поддерживается для типа структуры к явное объявление конструктора без параметров. Тип структуры тем не менее может объявлять параметризованные конструкторы экземпляров ([конструкторы](structs.md#constructors)).

### <a name="struct-types"></a>Типы структур

Тип структуры является типом значения, которые могут объявлять константы, поля, методы, свойства, индексаторы, операторы, конструкторы экземпляров, статические конструкторы и вложенные типы. Объявление типов структуры описан в [объявления структур](structs.md#struct-declarations).

### <a name="simple-types"></a>Простые типы

C# предоставляет набор предопределенных типов структуры вызывается ***простых типов***. Простые типы определяются с помощью зарезервированных слов, но эти зарезервированные слова — это просто псевдонимы предопределенных типов структуры в `System` пространства имен, как описано в следующей таблице.


| __Зарезервированное слово__ | __Тип с псевдонимом__ |
|-------------------|------------------|
| `sbyte`           | `System.SByte`   | 
| `byte`            | `System.Byte`    | 
| `short`           | `System.Int16`   | 
| `ushort`          | `System.UInt16`  | 
| `int`             | `System.Int32`   | 
| `uint`            | `System.UInt32`  | 
| `long`            | `System.Int64`   | 
| `ulong`           | `System.UInt64`  | 
| `char`            | `System.Char`    | 
| `float`           | `System.Single`  | 
| `double`          | `System.Double`  | 
| `bool`            | `System.Boolean` | 
| `decimal`         | `System.Decimal` | 

Так как простой тип псевдонимы типа структуры, каждый простой тип содержит члены. Например `int` имеет члены, объявленные в `System.Int32` и члены, унаследованные от `System.Object`, и разрешены следующие инструкции:

```csharp
int i = int.MaxValue;           // System.Int32.MaxValue constant
string s = i.ToString();        // System.Int32.ToString() instance method
string t = 123.ToString();      // System.Int32.ToString() instance method
```

Простые типы отличаются от других типов структур тем, что они разрешают некоторые дополнительные операции:

*  Большинство простые типы разрешают значения, которые создаются путем записи *литералы* ([литералы](lexical-structure.md#literals)). Например `123` — это литерал типа `int` и `'a'` — это литерал типа `char`. C# делает не поддерживает литералы типов структуры в целом, а значения по умолчанию других типов структуры в конечном счете всегда создаются с помощью конструкторов экземпляров типов структуры.
*  Когда операнда выражения являются константами простого типа, компилятор может вычислить выражение во время компиляции. Такое выражение называется *constant_expression* ([константные выражения](expressions.md#constant-expressions)). Выражения, включающие операторы, определенные другими типами структуры, не считаются быть константными выражениями.
*  Через `const` объявления можно объявлять константы простых типов ([константы](classes.md#constants)). Это не может быть константы других типов структуры, но обеспечивается похожий эффект `static readonly` поля.
*  Преобразования, включающие простые типы могут участвовать в вычислении операторов преобразования, определенные другими типами структуры, но оператор пользовательского преобразования никогда не может участвовать в вычисление другой определенный пользователем оператор ([оценки заданные пользователем преобразования](conversions.md#evaluation-of-user-defined-conversions)).

### <a name="integral-types"></a>Целочисленные типы

C# поддерживает девять целочисленных типов: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, и `char`. Целочисленные типы имеют следующие размеры и диапазоны значений:

*  `sbyte` Представляет тип автоматический 8-битовых целых чисел со знаком в диапазоне от -128 до 127.
*  `byte` Тип представляет 8-разрядных целых чисел со значениями от 0 до 255.
*  `short` Представляет тип автоматический 16-разрядных целых чисел со знаком в диапазоне от -32768 до 32767.
*  `ushort` Тип представляет 16-разрядных целых чисел со значениями от 0 до 65535.
*  `int` Представляет тип подписи, 32-разрядных целых чисел со значениями от -2147483648 до 2147483647.
*  `uint` Тип представляет 32-разрядных целых чисел со значениями от 0 до 4294967295.
*  `long` Представляет тип подписью, 64-разрядных целых чисел со значениями от -9223372036854775808 до 9223372036854775807.
*  `ulong` Тип представляет 64-разрядных целых чисел со значениями от 0 до 18446744073709551615.
*  `char` Тип представляет 16-разрядных целых чисел со значениями от 0 до 65535. Набор возможных значений для `char` тип соответствует набору знаков Юникода. Несмотря на то что `char` имеет то же представление, как `ushort`, не все операции, для каждого типа разрешены на другой.

Целочисленного типа унарные и бинарные операторы всегда работают в режиме со знаком 32-битной точности, неподписанные 32-битной точности, 64-битной точности, со знаком или без знака 64-битной точности:

*  Для унарных `+` и `~` операторов операнд преобразуется в тип `T`, где `T` — первый из `int`, `uint`, `long`, и `ulong` , могут быть полностью представлены все Возможные значения операнда. Операция выполняется с использованием точность типа `T`, а тип результата — `T`.
*  Для унарных `-` оператор, операнд преобразуется в тип `T`, где `T` — первый из `int` и `long` , могут быть полностью представлены все возможные значения операнда. Операция выполняется с использованием точность типа `T`, а тип результата — `T`. Унарный `-` оператор не может применяться к операндам типа `ulong`.
*  Для двоичного файла `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`, и `<=` операторы, операнды преобразуются в тип `T`, где `T` — первый из `int`, `uint`, `long`, и `ulong` , могут быть полностью представлены все возможные значения обоих операндов. Операция выполняется с использованием точность типа `T`, а тип результата — `T` (или `bool` для операторов отношения). Она недопустима для один операнд типа `long` , а другой тип `ulong` с бинарными операторами.
*  Для двоичного файла `<<` и `>>` операторы, левый операнд преобразуется в тип `T`, где `T` — первый из `int`, `uint`, `long`, и `ulong` , могут быть полностью представлены все Возможные значения операнда. Операция выполняется с использованием точность типа `T`, а тип результата — `T`.

`char` Тип классифицируется как целочисленный тип, но он отличается от других целочисленных типов двумя способами:

*  Отсутствуют неявные преобразования из других типов в `char` типа. В частности несмотря на то что `sbyte`, `byte`, и `ushort` типы имеют диапазоны значений, которые являются полностью можно представить с помощью `char` неявные преобразования из типов `sbyte`, `byte`, или `ushort` для `char` не существуют.
*  Константы типа `char` типа должно быть записано как *character_literal*s или как *integer_literal*s в сочетании с помощью приведения к типу `char`. Например, `(char)10` равносильно `'\x000A'`.

`checked` И `unchecked` операторы и операторы используются для управления проверкой переполнения при выполнении целочисленных арифметических операций и преобразований ([операторы checked и unchecked](expressions.md#the-checked-and-unchecked-operators)). В `checked` контекста, переполнение вызывает ошибку времени компиляции или вызывает `System.OverflowException` исключение. В `unchecked` контекста, переполнение игнорируется, а также удаляются любые старшие разряды, которые не помещаются в целевой тип.

### <a name="floating-point-types"></a>Типы с плавающей запятой

C# поддерживает два типы с плавающей запятой: `float` и `double`. `float` И `double` типы представлены с помощью 32-разрядный одиночной точности и 64-разрядных двойной точности IEEE 754 форматов, которые предоставляют следующие наборы значений:

*  Положительный и отрицательный нуль. В большинстве ситуаций, положительного и отрицательного нуля ведут себя одинаково как значений, но некоторые операции различие между ними ([оператор деления](expressions.md#division-operator)).
*  Положительная и отрицательная бесконечность. Бесконечности действительных созданные с помощью таких операций, как ненулевое число деления на ноль. Например `1.0 / 0.0` дает положительной бесконечности и `-1.0 / 0.0` дает отрицательная бесконечность.
*  ***Не является числовым*** значение часто сокращенное значение NaN. Значения NaN создает недопустимый операций с плавающей запятой, например деления нуля на нуль.
*  Конечный набор ненулевые значения формы `s * m * 2^e`, где `s` равно 1 или -1, и `m` и `e` определяются определенного типа с плавающей запятой: Для `float`, `0 < m < 2^24` и `-149 <= e <= 104`, а также для `double`, `0 < m < 2^53` и `1075 <= e <= 970`. Денормализованные числа с плавающей запятой, считаются допустимыми значениями ненулевое значение.

`float` Тип может представлять значения в диапазоне примерно от `1.5 * 10^-45` для `3.4 * 10^38` с точностью до 7 цифр.

`double` Тип может представлять значения в диапазоне примерно от `5.0 * 10^-324` для `1.7 × 10^308` с точностью до 15-16 знаков.

Если один из операндов бинарного оператора типом с плавающей запятой, затем второй операнд должен иметь целочисленный тип или типом с плавающей запятой, и операция вычисляется следующим образом:

*  Если один из операндов имеет целочисленный тип, что операнд преобразуется в тип с плавающей запятой имеет другой операнд.
*  Затем, если любой из операндов имеет тип `double`, то другой операнд преобразуется в `double`, операция выполняется с помощью по крайней мере `double` диапазон и точность, а тип результата — `double` (или `bool` для реляционные операторы).
*  В противном случае операция выполняется с помощью по крайней мере `float` диапазон и точность, а тип результата — `float` (или `bool` для операторов отношения).

С плавающей запятой операторов, включая операторы присваивания, никогда не создают исключений. Вместо этого в исключительных ситуациях операций с плавающей запятой сформировать ноль, бесконечность или NaN, как описано ниже:

*  Если результат операции с плавающей запятой слишком мал для конечного формата, результат операции становится положительный ноль или отрицательный нуль.
*  Если результат операции с плавающей запятой слишком велико для конечного формата, результат операции становится положительной бесконечности или минус бесконечности.
*  Если операция с плавающей запятой недопустимо, результат операции NaN.
*  Если один или оба операнда операции с плавающей запятой является NaN, результат операции NaN.

Операции с плавающей запятой может выполняться с более высокой точностью, чем тип результата операции. Например, некоторые архитектуры оборудования поддерживает использование типа с плавающей запятой «расширенный» или «long double» с более широкий диапазон и точность, чем `double` введите, а также неявно выполнять все операции с плавающей запятой, с помощью этого выше точность типа. Только за счет понижения производительности можно такой аппаратной архитектуры для выполнения операций с плавающей запятой с меньшей точностью, и во избежание понижения производительности и точности, C# разрешает тип с точностью выше быть используется для всех операций с плавающей запятой. Кроме предоставления более точные результаты, не дает никаких измеримое эффектов. Тем не менее, в выражениях формы `x * y / z`, где результат умножения, находится за пределами `double` диапазон, но последующие деления возвращает промежуточный результат обратно в `double` в диапазон, тот факт, что выражение является вычисляется в верхним диапазоном формата может привести к конечный результат вместо бесконечности.

### <a name="the-decimal-type"></a>Тип decimal

Тип `decimal` — это 128-разрядный тип данных для финансовых и денежных расчетов. `decimal` Тип может представлять значения в диапазоне от `1.0 * 10^-28` для приблизительно `7.9 * 10^28` с 28-29 значимыми цифрами.

Конечный набор значений типа `decimal` представлены в формате `(-1)^s * c * 10^-e`, где знак `s` равен 0 или 1, коэффициент `c` определяется `0 <= *c* < 2^96`и масштаб `e` — таким образом, чтобы `0 <= e <= 28`. `decimal` Со знаком нули, бесконечность или NaN не поддерживает тип. Объект `decimal` представляется в виде 96-разрядного целого числа, масштабируется по степени числа 10. Для `decimal`s с абсолютным значением меньше, чем `1.0m`, значение точного до 28-го десятичного разряда, но нет ничего. Для `decimal`s с абсолютным значением больше или равно `1.0m`, имеют точность до 28 или 29 цифр. Отличие `float` и `double` типы данных могут представляться десятичных дробей, например 0,1 точно в `decimal` представление. В `float` и `double` представления таких чисел, являются часто бесконечные дроби, что делает эти представления, более подвержены округления ошибки.

Если один из операндов бинарного оператора имеет тип `decimal`, то второй операнд должен иметь целочисленный тип или тип `decimal`. Если присутствует операнд целочисленного типа, он преобразуется в `decimal` перед выполнением операции.

Результат операции над значениями типа `decimal` является, который получится после вычисления результату (сохраняя масштаб, как это определено для каждого оператора) и затем округления в соответствии с представлением. Результаты округляются до ближайшего значения, которое может быть представлено и, если результат находится точно посередине между двумя представимых значений, значение, которое имеет четное число в позиции младшего разряда (это называется «банковское округление»). Нулевой результат всегда имеет знак числа 0 и масштабом 0.

Если десятичное арифметическая операция дает значение меньше или равно `5 * 10^-29` в абсолютном значении, результат операции становится равным нулю. Если `decimal` результат арифметической операции слишком велик для `decimal` формат, `System.OverflowException` возникает исключение.

`decimal` Тип имеет большую точность более мелких диапазон, чем типы с плавающей запятой. Таким образом, преобразования из типов с плавающей запятой для `decimal` может выдавать исключения переполнения и преобразования из `decimal` для типов с плавающей запятой может привести к потере точности. По этим причинам существует неявного преобразования между типами с плавающей запятой и `decimal`, и без явного приведения не нельзя сочетать с плавающей запятой и `decimal` операндов в одном выражении.

### <a name="the-bool-type"></a>Тип bool

`bool` Тип представляет логические величины. Возможные значения типа `bool` являются `true` и `false`.

Нет стандартных преобразований между `bool` и других типов. В частности `bool` тип отделен от целочисленного типа и `bool` значение не может использоваться вместо целого значения и наоборот.

В языках C и C++, нулевое значение целочисленного типа или с плавающей запятой или указатель null можно преобразовать в логическое значение `false`, и ненулевое значение целочисленного типа или с плавающей запятой или указатель отличное от null может быть преобразована в логическое значение `true`. В C# такие преобразования выполняются, явное сравнение целого или с плавающей запятой числа до нуля, или явное сравнение ссылку на объект `null`.

### <a name="enumeration-types"></a>Типы перечисления.

Тип перечисления является отдельным типом со списком именованных констант. Каждый тип перечисления имеет базовый тип, который должен быть `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` или `ulong`. Набор значений типа перечисления является таким же, как набор значений базового типа. Значения этого типа перечисления не ограничиваются значениями именованных констант. Типы перечисления определяются посредством объявления перечислений ([объявления перечислений](enums.md#enum-declarations)).

### <a name="nullable-types"></a>Типы, допускающие значения NULL

Обнуляемый тип может представлять все значения его ***базовый тип*** плюс дополнительное значение null. Обнуляемый записывается `T?`, где `T` является базовым типом. Этот синтаксис является сокращением для `System.Nullable<T>`, и две формы могут быть взаимозаменяемыми.

Объект ***не поддерживающий значение NULL тип*** и наоборот является любой тип значения, отличные от `System.Nullable<T>` и его сокращенной формы `T?` (для любого `T`), плюс любой параметр типа, который должен быть тип значения, не допускающие значения NULL (то есть любые параметр типа с `struct` ограничение). `System.Nullable<T>` Тип определяет ограничение типа значения для `T` ([ограничения параметров типа](classes.md#type-parameter-constraints)), что означает, что базовый тип типа nullable может быть любого типа не поддерживающий значение NULL. Базовый тип типа nullable не может быть ссылочным типом или типом ссылки. Например `int??` и `string?` являются недопустимыми типами.

Экземпляр типа nullable `T?` имеет два открытых свойства только для чтения:

*  Объект `HasValue` свойство типа `bool`
*  Объект `Value` свойство типа `T`

Экземпляр, для которого `HasValue` имеет значение true, говорят отличное от null. Содержит экземпляр отличное от null и `Value` возвращает это значение.

Экземпляр, для которого `HasValue` является false говорят, что иметь значение null. Пустой экземпляр имеет неопределенное значение. При чтении `Value` null экземпляра приводит к `System.InvalidOperationException` исключение. Процесс доступа к `Value` свойства экземпляра допускает значения NULL, считается ***распаковки***.

Помимо конструктора по умолчанию, каждый тип, допускающий значение NULL `T?` имеет открытый конструктор, принимающий один аргумент типа `T`. Для заданного значения `x` типа `T`, вызов конструктора формы

```csharp
new T?(x)
```
Создает экземпляр ненулевые `T?` для которого `Value` свойство `x`. Процесс создания непустого экземпляра обнуляемого типа, для заданного значения называется ***упаковки***.

Неявные преобразования доступны из `null` литерал `T?` ([преобразования литерала Null](conversions.md#null-literal-conversions)) и из `T` для `T?` ([неявные преобразования обнуляемых типов](conversions.md#implicit-nullable-conversions)).

## <a name="reference-types"></a>Ссылочные типы

Ссылочный тип является типом класса, тип интерфейса, типом массива или типом делегата.

```antlr
reference_type
    : class_type
    | interface_type
    | array_type
    | delegate_type
    ;

class_type
    : type_name
    | 'object'
    | 'dynamic'
    | 'string'
    ;

interface_type
    : type_name
    ;

array_type
    : non_array_type rank_specifier+
    ;

non_array_type
    : type
    ;

rank_specifier
    : '[' dim_separator* ']'
    ;

dim_separator
    : ','
    ;

delegate_type
    : type_name
    ;
```

Значение ссылочного типа — это ссылка на ***экземпляр*** типа, ранее известные как ***объект***. Специальное значение `null` совместима с все ссылочные типы и указывает на отсутствие экземпляра.

### <a name="class-types"></a>Типы классов

Тип класса определяет структуру данных, содержащий данные членов (константы и поля), функции-члены (методы, свойства, события, индексаторы, операторы, конструкторы экземпляров, деструкторы и статические конструкторы) и вложенные типы. Типы классов поддерживают наследование — механизм, при котором производные классы, расширяющие и уточняющие определения базовых классов. Экземпляры типов классов создаются с помощью *object_creation_expression*s ([выражения создания объектов](expressions.md#object-creation-expressions)).

Типы классов, описаны в [классы](classes.md).

Некоторые предопределенные типы классов имеют особое значение в языке C#, как описано в следующей таблице.


| __Тип класса__     | __Описание__                                         |
|--------------------|---------------------------------------------------------|
| `System.Object`    | Исходным базовым классом для всех других типов. См. в разделе [тип объекта](types.md#the-object-type). | 
| `System.String`    | Строковый тип в языке C#. См. в разделе [строкового типа](types.md#the-string-type).         |
| `System.ValueType` | Базовый класс для всех типов значений. См. в разделе [типа System.ValueType](types.md#the-systemvaluetype-type).          |
| `System.Enum`      | Базовый класс для всех типов перечислений. См. в разделе [перечисления](enums.md).              |
| `System.Array`     | Базовый класс для всех этих типов. См. раздел [Массивы](arrays.md).             |
| `System.Delegate`  | Базовый класс для всех типов делегатов. См. в разделе [делегаты](delegates.md).          |
| `System.Exception` | Базовый класс для всех типов исключений. См. в разделе [исключения](exceptions.md).         |

### <a name="the-object-type"></a>Тип объекта

`object` Тип класса является исходным базовым классом для всех других типов. Каждый тип в C# прямо или косвенно является производным от `object` типа класса.

Ключевое слово `object` является всего лишь псевдоним для стандартных классов `System.Object`.

### <a name="the-dynamic-type"></a>Динамический тип

`dynamic` Введите, например `object`, могут ссылаться на любой объект. Когда операторы применяются к выражениям типа `dynamic`, способы их устранения, откладывается до запуска программы. Таким образом Если оператор не может использоваться по закону для объекта ссылки, ошибка не выдается во время компиляции. Вместо этого будет создано исключение при сбое разрешения оператора во время выполнения.

Его назначение — дать динамической привязки, которая подробно описана [динамической привязки](expressions.md#dynamic-binding).

`dynamic` считается идентичным `object` только в следующих аспектах:

*  Операции над выражениями типа `dynamic` можно динамически привязать ([динамической привязки](expressions.md#dynamic-binding)).
*  Определение типа ([вывод типа](expressions.md#type-inference)), он предпочтет `dynamic` через `object` Если оба значения являются кандидатами.

Из-за этого эквивалентности ниже содержит:

*  Отсутствует неявное преобразование идентификации между `object` и `dynamic`, а также между сконструированных типов, которые повторяются при замене `dynamic` с `object`
*  Явные и неявные преобразования в и из `object` также применяются к и из `dynamic`.
*  Сигнатуры методов, которые повторяются при замене `dynamic` с `object` считаются такой же сигнатурой
*  Тип `dynamic` неотличим от `object` во время выполнения.
*  Выражение типа `dynamic` называется ***динамического выражения***.

### <a name="the-string-type"></a>Тип string

`string` Тип является типом запечатанный класс, который напрямую наследует от `object`. Экземпляры `string` класс представляет символьные строки в Юникоде.

Значения типа `string` могут быть записаны в виде строковых литералов ([строковые литералы](lexical-structure.md#string-literals)).

Ключевое слово `string` является всего лишь псевдоним для стандартных классов `System.String`.

### <a name="interface-types"></a>Типы интерфейса

Интерфейс определяет контракт. Класс или структура, реализующие интерфейс необходимо придерживаться этого контракта. Интерфейс может наследовать от нескольких базовых интерфейсах и класс или структура может реализовывать несколько интерфейсов.

Типы интерфейса описаны в [интерфейсы](interfaces.md).

### <a name="array-types"></a>Типы массивов

Массив — это структура данных, который содержит ноль или более переменных, которым осуществляется по вычисляемым индексам. Этот тип называется типом элемента массива и переменными, содержащимися в массиве, также называются элементами массива, имеют тот же тип.

Массив типов, описаны в [массивы](arrays.md).

### <a name="delegate-types"></a>Тип делегатов

Делегат — структуру данных, который ссылается на один или несколько методов. Для экземпляра метода, он также ссылается на соответствующие экземпляры объектов.

Ближайшим эквивалентом делегата в C или C++ является указатель на функцию, но в то время как указатель на функцию может ссылаться только на статические функции, делегат может ссылаться и на статические и методы экземпляра. В последнем случае делегат сохраняет не только ссылку на точку входа метода, но ссылка на экземпляр объекта, для которого следует вызвать метод.

Типы делегатов, описаны в [делегаты](delegates.md).

## <a name="boxing-and-unboxing"></a>Упаковка-преобразование и распаковка-преобразование

Концепция упаковка-преобразование и распаковка-преобразование является центральной в системе типов C#. Он обеспечивает связь между *value_type*s и *reference_type*s, позволяя любое значение *value_type* для преобразования из типа и `object`. Упаковка-преобразование и распаковка-преобразование обеспечивает единое представление системы типов, при котором значение любого типа в конечном счете воспринимаются как объект.

### <a name="boxing-conversions"></a>Упаковки-преобразования

Упаковка-преобразование позволяет *value_type* должен неявно преобразовываться к *reference_type*. Существуют следующие преобразования упаковки-преобразования:

*  Из любого *value_type* к типу `object`.
*  Из любого *value_type* к типу `System.ValueType`.
*  Из любого *non_nullable_value_type* к любому *interface_type* реализуется *value_type*.
*  Из любого *nullable_type* к любому *interface_type* реализуется базовый тип *nullable_type*.
*  Из любого *enum_type* к типу `System.Enum`.
*  Из любого *nullable_type* с базовой *enum_type* к типу `System.Enum`.
*  Обратите внимание, что неявное преобразование из параметра типа выполняется как упаковка-преобразование во время выполнения концов преобразование из типа значения к ссылочному типу ([неявные преобразования, включающие параметры типа](conversions.md#implicit-conversions-involving-type-parameters)).

Упаковка значения *non_nullable_value_type* состоит выделение экземпляра объекта и копирование *non_nullable_value_type* значение в этом экземпляре.

Упаковка значения *nullable_type* создает ссылку на null, если это `null` значение (`HasValue` — `false`), или результат развертывания и упаковки базового значения, в противном случае.

Фактический процесс Упаковка значения *non_nullable_value_type* проще всего определить представляете существование универсальный ***класс упаковки***, который ведет себя так, как если бы он был объявлен следующим образом:

```csharp
sealed class Box<T>: System.ValueType
{
    T value;

    public Box(T t) {
        value = t;
    }
}
```

Упаковка-преобразование значения `v` типа `T` теперь состоит из выполнения выражения `new Box<T>(v)`и возвратом результата в виде значения типа `object`. Таким образом операторы
```csharp
int i = 123;
object box = i;
```
по существу соответствуют
```csharp
int i = 123;
object box = new Box<int>(i);
```

Класс упаковки `Box<T>` выше не существует фактически и динамический тип упакованного значения не является типом класса. Вместо этого упакованное значение типа `T` имеет динамический тип `T`и проверочного динамического типа с помощью `is` оператор можете просто сослаться на тип `T`. Например, примененная к объекту директива
```csharp
int i = 123;
object box = i;
if (box is int) {
    Console.Write("Box contains an int");
}
```
Выводит строку "`Box contains an int`" на консоли.

Упаковка-преобразование подразумевает создать копию упаковываемого значения. Это отличается от преобразования *reference_type* ввода `object`, в котором значение продолжает ссылаться на тот же экземпляр и считается менее производный тип `object`. Например при объявлении
```csharp
struct Point
{
    public int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```
следующие инструкции
```csharp
Point p = new Point(10, 10);
object box = p;
p.x = 20;
Console.Write(((Point)box).x);
```
будет выведено значение 10 в консоли, так как операция неявной упаковки-преобразования, которая выполняется в назначение `p` для `box` заставляет значение `p` для копирования. Было `Point` были объявлены `class` вместо этого значение 20 будут выведены, так как `p` и `box` будет ссылаться на тот же экземпляр.

### <a name="unboxing-conversions"></a>Распаковки-преобразования

Разрешает распаковки-преобразования *reference_type* явным образом преобразовать *value_type*. Существуют следующие распаковки-преобразования:

*  От типа `object` к любому *value_type*.
*  От типа `System.ValueType` к любому *value_type*.
*  Из любого *interface_type* к любому *non_nullable_value_type* , реализующий *interface_type*.
*  Из любого *interface_type* к любому *nullable_type* базовый тип которого реализует *interface_type*.
*  От типа `System.Enum` к любому *enum_type*.
*  От типа `System.Enum` к любому *nullable_type* с базовой *enum_type*.
*  Обратите внимание, что явное преобразование к параметру типа выполняется как распаковки-преобразования во время выполнения концов преобразование из ссылочного типа в тип значения ([явные преобразования динамических](conversions.md#explicit-dynamic-conversions)).

Операция распаковки для *non_nullable_value_type* состоит из, что экземпляр объекта является упакованным значением заданного *non_nullable_value_type*, а затем скопировав значение из экземпляр.

Для распаковки *nullable_type* дает значение null *nullable_type* Если операнд источника `null`, или результатом распаковки-преобразования экземпляр объекта для базового типа *nullable_type* в противном случае.

Ссылка на класс упаковки, описанный в предыдущем разделе, распаковки-преобразования объекта `box` для *value_type* `T` состоит из выполнения выражения `((Box<T>)box).value`. Таким образом операторы
```csharp
object box = 123;
int i = (int)box;
```
по существу соответствуют
```csharp
object box = new Box<int>(123);
int i = ((Box<int>)box).value;
```

Для распаковки-преобразования для заданного *non_nullable_value_type* для успешного выполнения во время выполнения, значение исходного операнда должен быть ссылкой на упакованное значение этого *non_nullable_value_type*. Если операнд источника `null`, `System.NullReferenceException` возникает исключение. Если исходного операнда является ссылкой на объект несовместимые `System.InvalidCastException` возникает исключение.

Для распаковки-преобразования для заданного *nullable_type* для успешного выполнения во время выполнения, значение исходного операнда должно быть либо `null` или ссылка на упакованное значение базового *non_nullable_value_type* из *nullable_type*. Если исходного операнда является ссылкой на объект несовместимые `System.InvalidCastException` возникает исключение.

## <a name="constructed-types"></a>Сконструированные типы

Объявление универсального типа сам по себе обозначает ***несвязанных универсального типа*** , используемый в качестве «проект» для формирования различных типов посредством применения ***аргументы типа***. Записывается аргументы типа в угловых скобках (`<` и `>`) сразу после имени универсального типа. Тип, который включает по крайней мере один тип аргумента называется ***сконструированный тип***. Сконструированный тип может использоваться в большинстве мест на языке, в которой отображаются имя типа. Несвязанный универсальный тип может использоваться только в пределах *typeof_expression* ([оператор typeof](expressions.md#the-typeof-operator)).

Сконструированные типы также могут быть использованы в выражениях как простые имена ([простые имена](expressions.md#simple-names)) или когда доступ к члену ([доступ к членам](expressions.md#member-access)).

Когда *namespace_or_type_name* вычисляется, только универсальных типов с правильным количеством считаются параметров типа. Таким образом можно использовать тот же идентификатор для выявления различных типов, поскольку типы имеют различное число параметров типа. Это полезно в том случае, если требуется смешать универсальных и неуниверсальных классах в одной программе:

```csharp
namespace Widgets
{
    class Queue {...}
    class Queue<TElement> {...}
}

namespace MyApplication
{
    using Widgets;

    class X
    {
        Queue q1;            // Non-generic Widgets.Queue
        Queue<int> q2;       // Generic Widgets.Queue
    }
}
```

Объект *type_name* может идентифицировать сконструированный тип, несмотря на то, что непосредственно не заданы параметры типа. Это может произойти, где тип является вложенным в объявлении универсального класса, а тип экземпляра, содержащего объявления неявно используется для поиска имени ([вложенные типы в универсальных классах](classes.md#nested-types-in-generic-classes)):

```csharp
class Outer<T>
{
    public class Inner {...}

    public Inner i;                // Type of i is Outer<T>.Inner
}
```

В небезопасном коде сконструированный тип не может использоваться как *unmanaged_type* ([типы указателей](unsafe-code.md#pointer-types)).

### <a name="type-arguments"></a>Аргументы типа

Каждый аргумент из списка аргументов типов — это просто *тип*.

```antlr
type_argument_list
    : '<' type_arguments '>'
    ;

type_arguments
    : type_argument (',' type_argument)*
    ;

type_argument
    : type
    ;
```

В небезопасном коде ([небезопасный код](unsafe-code.md)), *type_argument* не может иметь тип указателя. Каждый аргумент типа должен соответствовать любые ограничения для соответствующего параметра типа ([ограничения параметров типа](classes.md#type-parameter-constraints)).

### <a name="open-and-closed-types"></a>Открытые и закрытые типы

Все типы можно классифицировать как ***открытые типы*** или ***закрытые типы***. Открытый тип является типом, который включает в себя параметры типа. В частности:

*  Параметр типа определяет открытый тип.
*  Только в том случае, если его тип элемента является открытым типом, типом массива является открытым типом.
*  Сконструированный тип является открытым типом только в том случае, если один или несколько из его аргументов типа является открытым типом. Вложенный сформированный тип является открытым типом только в том случае, если один или несколько аргументов типа или аргументы типа для содержащих его типов является открытым типом.

Закрытый тип является типом, который не является открытым типом.

Во время выполнения весь код в объявлении универсального типа выполняется в контексте закрытого сконструированного типа, который был создан путем применения аргументов типа в универсальном объявлении. Каждый параметр типа в универсальный тип привязан к определенному типу во время выполнения. Обработка времени выполнения всех инструкций и выражений всегда осуществляется с закрытые типы и открытые типы происходить только во время компиляции обработки.

Каждый закрытым сконструированным типом имеет свой собственный набор статических переменных, которые не являются общими с любой другой закрытые сконструированные типы. Поскольку открытый тип не существует во время выполнения, существует статические переменные, связанные с открытым типом. Два закрытых сконструированных типов относятся к одному типу, если они созданы на базе одного несвязанного универсального типа, а их соответствующие аргументы типа относятся к одному типу.

### <a name="bound-and-unbound-types"></a>Присоединенные и свободные типы

Термин ***несвязанных тип*** относится к неуниверсального типа или несвязанного универсального типа. Термин ***связанный тип*** ссылается на неуниверсального типа или сконструированным типом.

Несвязанный тип ссылается на сущность, объявленных в объявлении типа. Несвязанный универсальный тип не является типом и не может использоваться как тип переменной, аргумента или возвращаемого значения или как базовый тип. Только конструкция, в котором можно ссылаться несвязанного универсального типа — `typeof` выражение ([оператор typeof](expressions.md#the-typeof-operator)).

### <a name="satisfying-constraints"></a>Соблюдение ограничений

Каждый раз, когда упоминаемый сконструированного типа или универсального метода, проверяются на соответствие ограничения параметра типа, объявленные в универсальном типе или методе аргументов типа ([ограничения параметров типа](classes.md#type-parameter-constraints)). Для каждого `where` предложение, аргумент типа `A` , соответствующий именованный параметр типа проверяется каждое ограничение, следующим образом:

*  Если ограничение типа класса, тип интерфейса или параметр типа, пусть `C` представляют ограничения для аргументов типа заменителями любые параметры типа, которые отображаются в ограничении. В соответствии с ограничением, должен быть в случае, если тип `A` преобразуется в тип `C` одним из следующих:
    * Преобразование удостоверения ([преобразование идентификации](conversions.md#identity-conversion))
    * И неявное ссылочное преобразование ([неявные преобразования ссылочных типов](conversions.md#implicit-reference-conversions))
    * Упаковка-преобразование ([осуществлять преобразования-упаковки](conversions.md#boxing-conversions)) при условии, что тип A является типом значения, не допускающие значения NULL.
    * Неявное преобразование ссылок, упаковки-преобразования или тип параметра из параметра типа `A` для `C`.
*  Если ограничение является ограничение ссылочного типа (`class`), тип `A` должен соответствовать одному из следующих:
    * `A` — Это тип интерфейса, тип класса, тип делегата или тип массива. Обратите внимание, что `System.ValueType` и `System.Enum` являются ссылочными типами, которые удовлетворяют этому ограничению.
    * `A` является параметром типа, который известен быть ссылочным типом ([ограничения параметров типа](classes.md#type-parameter-constraints)).
*  Если ограничение является ограничение типа значения (`struct`), тип `A` должен соответствовать одному из следующих:
    * `A` является типом структуры или тип перечисления, но не является обнуляемым типом. Обратите внимание, что `System.ValueType` и `System.Enum` являются ссылочными типами, которые не удовлетворяют этому ограничению.
    * `A` является параметром типа с ограничением типа значения ([ограничения параметров типа](classes.md#type-parameter-constraints)).
*  Если ограничение является ограничение конструктора `new()`, тип `A` не должно быть `abstract` и должен иметь открытый конструктор без параметров. Это выполняется, если выполняется одно из следующих:
    * `A` является типом значения, так как все типы значений иметь открытый конструктор по умолчанию ([конструкторы по умолчанию](types.md#default-constructors)).
    * `A` Представляет параметр типа ограничение конструктора ([ограничения параметров типа](classes.md#type-parameter-constraints)).
    * `A` является параметром типа с ограничением типа значения ([ограничения параметров типа](classes.md#type-parameter-constraints)).
    * `A` — Это класс, который не `abstract` и содержит явно объявленный `public` конструктор без параметров.
    * `A` не `abstract` и имеет конструктор по умолчанию ([конструкторы по умолчанию](classes.md#default-constructors)).

Ошибка времени компиляции возникает, если один или несколько ограничений параметров типа не совместимы с заданными аргументами типа.

Так как параметры типа не наследуются, установленных ограничений либо наследуется. В следующем примере `D` должен указать ограничения для параметра типа `T` таким образом, чтобы `T` удовлетворяет ограничение, наложенное базовый класс `B<T>`. Напротив, класс `E` не требуется указывать ограничения, так как `List<T>` реализует `IEnumerable` для любого `T`.

```csharp
class B<T> where T: IEnumerable {...}

class D<T>: B<T> where T: IEnumerable {...}

class E<T>: B<List<T>> {...}
```

## <a name="type-parameters"></a>Параметры типа

Параметр типа — это идентификатор, обозначающий тип значения или ссылочный тип, который привязывается данный параметр во время выполнения.

```antlr
type_parameter
    : identifier
    ;
```

Так как параметр типа может быть создан с множеством различных фактических типов аргументов, параметры типа имеют несколько различных операций и ограничений, чем другие типы. Сюда входит следующее.

*  Параметр типа не может использоваться непосредственно для объявления базового класса ([базового класса](classes.md#base-class)) или интерфейс ([списков параметров типа Variant](interfaces.md#variant-type-parameter-lists)).
*  Правила для поиска членов в типе, параметры зависят от ограничений, если таковые имеются, примененных к параметру типа. Они подробно описаны в [поиск члена](expressions.md#member-lookup).
*  Доступные преобразования для параметра типа зависят от ограничений, если таковое имеется, применяется к параметру типа. Они подробно описаны в [неявные преобразования, включающие параметры типа](conversions.md#implicit-conversions-involving-type-parameters) и [явные преобразования динамических](conversions.md#explicit-dynamic-conversions).
*  Литерал `null` невозможно преобразовать к типу, заданному параметром типа, за исключением случаев, если параметр типа является ссылочным типом ([неявные преобразования, включающие параметры типа](conversions.md#implicit-conversions-involving-type-parameters)). Тем не менее `default` выражение ([выражения значения по умолчанию](expressions.md#default-value-expressions)) можно использовать. Кроме того, можно сравнить значение с типом, заданное в параметре типа с `null` с помощью `==` и `!=` ([операторы равенства ссылочного типа](expressions.md#reference-type-equality-operators)) Если параметр типа имеет ограничение типа значения.
*  Объект `new` выражение ([выражения создания объектов](expressions.md#object-creation-expressions)) может использоваться только с параметром типа, если параметр типа ограничивается *constructor_constraint* или тип ограничения (значения[ Ограничения параметров типа](classes.md#type-parameter-constraints)).
*  Параметр типа не может использоваться в любом месте внутри атрибута.
*  Параметр типа не может использоваться в доступ к членам ([доступ к членам](expressions.md#member-access)) или имя типа ([пространства имен и тип](basic-concepts.md#namespace-and-type-names)) для определения статического члена или вложенного типа.
*  В небезопасном коде параметр типа не может использоваться как *unmanaged_type* ([типы указателей](unsafe-code.md#pointer-types)).

Как тип параметры типа являются исключительно конструкцию времени компиляции. Во время выполнения каждого параметра типа связан с типом времени выполнения, который был указан, указав аргумент типа для универсального типа. Таким образом, тип переменной, объявленный с помощью параметра типа во время выполнения будет быть закрытым сконструированным типом ([открытые и закрытые типы](types.md#open-and-closed-types)). Во время выполнения всех инструкций и выражений, содержащих параметры типа используются фактические типы, предоставленные как аргумент типа для этого параметра.

## <a name="expression-tree-types"></a>Типы дерева выражений

***Деревья выражений*** разрешить лямбда-выражения в виде структур данных, а не исполняемый код. Деревья выражений являются значения ***типы дерева выражений*** формы `System.Linq.Expressions.Expression<D>`, где `D` — это любой тип делегата. Далее в этой спецификации, мы будем называть эти типы, с помощью сокращенного `Expression<D>`.

Если существует преобразование из лямбда-выражение с типом делегата `D`, также существует преобразование в тип дерева выражения `Expression<D>`. В то время как преобразование лямбда-выражения к типу делегата создает делегат, который ссылается на исполняемый код для лямбда-выражения, преобразование в тип дерева выражения создает представление дерева выражения лямбда-выражения.

Деревья выражений очень эффективный данных в памяти представления лямбда-выражений и структуре лямбда-выражения прозрачной и явной.

Так же, как тип делегата `D`, `Expression<D>` считается имеет параметров и возвращаемых типов, которые являются те же `D`.

В следующем примере представлен лямбда-выражения и как исполняемый код и как дерево выражения. Так как существует преобразование в `Func<int,int>`, также существует преобразование в `Expression<Func<int,int>>`:

```csharp
Func<int,int> del = x => x + 1;                    // Code

Expression<Func<int,int>> exp = x => x + 1;        // Data
```

Выполнив эти назначения делегата `del` ссылается на метод, возвращающий `x + 1`и дерево выражения `exp` ссылается на структуру данных, описывающую выражение `x => x + 1`.

Точное определение универсального типа `Expression<D>` а также точные правила построения дерева выражений, когда лямбда-выражение преобразуется в тип дерева выражения, оба находятся вне области данной спецификации.

Чтобы сделать явное важны две вещи:

*  Не все лямбда-выражения можно преобразовать в деревья выражений. Например лямбда-выражения тела оператора и лямбда-выражения, содержащего выражения присваивания не удается представить. В этом случае преобразование по-прежнему существует, но приведет к сбою во время компиляции. Эти исключения, подробно изложены в [преобразования анонимных функций](conversions.md#anonymous-function-conversions).
*   `Expression<D>` предоставляет метод экземпляра `Compile` которого создает делегат типа `D`:

    ```csharp
    Func<int,int> del2 = exp.Compile();
    ```

    Вызов данного делегата вызывает код, представленный деревом выражения, который будет выполнен. Таким образом учитывая приведенные выше определения, del и del2 эквивалентны и двух следующих операторов будет иметь тот же эффект:

    ```csharp
    int i1 = del(1);
    
    int i2 = del2(1);
    ```

    После выполнения этого кода `i1` и `i2` будет иметь значение `2`.

