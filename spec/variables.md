# <a name="variables"></a>Переменные

Переменные представляют места хранения. Каждая переменная имеет тип, который определяет значения, которые могут быть сохранены в переменной. C# — это строго типизированный язык и компилятор C# гарантирует, что значения, хранящиеся в переменных, всегда будут соответствующего типа. Значение переменной можно изменить путем назначения или с помощью `++` и `--` операторы.

Переменная должна быть ***определенно присвоенной*** ([определенного присваивания](variables.md#definite-assignment)) перед его значение можно получить.

Как описано в следующих разделах, переменные, либо ***начальным значением*** или ***изначально не присвоены значения***. Переменная с начальным значением имеет четко определенные начальное значение и всегда считается определенно присвоенной. У переменной без начального значения. Для переменной считается определенно присвоенной в конкретном месте присвоения значения переменной должно находиться в каждом возможном пути исполнения приведет к этому расположению.

## <a name="variable-categories"></a>Категории переменных

C# определяет семь категорий переменных: статические переменные, переменные экземпляра, элементы массива, параметры значений, ссылочные параметры, выходные параметры и локальные переменные. В последующих разделах описан каждый из этих категорий.

В примере
```csharp
class A
{
public static int x;
int y;

void F(int[] v, int a, ref int b, out int c) {
int i = 1;
c = a + b++;
}
}
```
`x` Статическая переменная, `y` является переменной экземпляра `v[0]` является элементом массива `a` является значение параметра, `b` — это ссылочный параметр, `c` является параметром output и `i` является локальной переменной.

### <a name="static-variables"></a>Статические переменные

Поле объявлено с `static` модификатор называется ***статической переменной***. Статическая переменная появляется перед выполнением статического конструктора ([статические конструкторы](classes.md#static-constructors)) для его содержащего типа и создается в соответствующем домене приложения перестает существовать.

Начальное значение статической переменной является значением по умолчанию ([значения по умолчанию](variables.md#default-values)) типа переменной.

В целях проверки определенного присваивания статическая переменная считается начальным значением.

### <a name="instance-variables"></a>Переменные экземпляра

Поле объявлено без `static` модификатор называется ***переменная экземпляра***.

#### <a name="instance-variables-in-classes"></a>Переменные экземпляра в классах

Переменная экземпляра класса появляется, когда создается новый экземпляр этого класса и перестает существовать при отсутствии ссылок на этот экземпляр и выполнен деструктор экземпляра (если таковые имеются).

Начальное значение переменной экземпляра класса является значением по умолчанию ([значения по умолчанию](variables.md#default-values)) типа переменной.

Для целей проверки определенного присваивания переменной экземпляра класса считается начальным значением.

#### <a name="instance-variables-in-structs"></a>Переменные экземпляра в структурах

Переменная экземпляра структуры имеет такое же время жизни, как переменную структуры, к которой он принадлежит. Другими словами, когда переменную с типом структуры создается или прекращает свое существование, поэтому слишком у переменных экземпляра структуры.

Состояние первоначального назначения переменной экземпляра структуры совпадает, содержащего переменной структуры. Другими словами, когда переменная структуры имеющей, поэтому слишком переменные экземпляров, а когда переменная структуры, считается изначально не присвоены значения, переменные экземпляров — аналогично неназначенные.

### <a name="array-elements"></a>Элементы массива

Элементы массива появляются при создании экземпляра массива и исчезают при отсутствии ссылок на этот экземпляр массива.

Начальное значение каждого из элементов массива является значением по умолчанию ([значения по умолчанию](variables.md#default-values)) типа элементов массива.

Для целей проверки определенного присваивания элемент массива считается начальным значением.

### <a name="value-parameters"></a>Параметры значения

Параметр, объявленный без `ref` или `out` модификатор ***значение параметра***.

Значение параметра поступает при вызове функции-члена (метод, конструктор экземпляра, метод доступа или оператора) или анонимной функции которой параметр принадлежит и инициализируется со значением аргумента, указанного в вызове. Значение параметра обычно перестает существовать при возврате из функции-члена или анонимной функции. Тем не менее если значение параметра записанным анонимная функция ([выражения анонимных функций](expressions.md#anonymous-function-expressions)), его время жизни увеличивается по крайней мере до делегат или дерево выражения, созданного из этого анонимная функция подходит для сборка мусора.

Для целей проверки определенного присваивания параметр значение считается начальным значением.

### <a name="reference-parameters"></a>Параметры ссылок

Параметр, объявленный с `ref` модификатор ***ссылочный параметр***.

Ссылочный параметр не создает новое место хранения. Вместо этого параметр ссылки представляет место хранения переменной, заданной в качестве аргумента в функцию-член или анонимной функции вызова. Таким образом значение параметра ссылки — это всегда совпадает с базовой переменной.

Справочник по параметрам применяются следующие правила определенного назначения. Обратите внимание на разные правила для выходных параметров, описанных в [выходных параметров](variables.md#output-parameters).

*  Переменной должен быть явно присвоен ([определенного присваивания](variables.md#definite-assignment)), прежде чем их можно было передать в качестве ссылочного параметра при вызове функции члена или делегата.
*  Внутри функции-члена или анонимной функции считается начальным значением ссылочного параметра.

Внутри метода экземпляра или методе доступа экземпляра типа структуры `this` ключевое слово ведет себя точно так, как ссылочный параметр типа структуры ([такой доступ](expressions.md#this-access)).

### <a name="output-parameters"></a>Выходные параметры

Параметр, объявленный с `out` модификатор ***выходной параметр***.

Выходной параметр не создает новое место хранения. Вместо этого выходного параметра представляет то же место хранения переменной, заданной в качестве аргумента при вызове функции-члена или делегата. Таким образом значение выходного параметра является всегда совпадает с базовой переменной.

Применяются следующие правила определенного назначения для выходных параметров. Обратите внимание на разные правила для выходных параметров, описанные в [ссылочные параметры](variables.md#reference-parameters).

*  Переменная не нужно назначать определенно могут передаваться в качестве выходного параметра в функции-члене или вызов делегата.
*  После нормального завершения вызова функции-члена или делегата каждой переменной, который был передан как выходной параметр считается назначить в этом пути выполнения.
*  Внутри функции-члена или анонимной функции считается изначально не присвоены значения выходного параметра.
*  Каждый выходной параметр функции-члена или анонимной функции должен быть явно присвоен ([определенного присваивания](variables.md#definite-assignment)) перед функцией члена или анонимной функции завершается нормально.

Внутри конструктора экземпляра типа структуры `this` ключевое слово ведет себя точно так, как выходной параметр типа структуры ([такой доступ](expressions.md#this-access)).

### <a name="local-variables"></a>Локальные переменные

Объект ***локальной переменной*** объявляется с *local_variable_declaration*, который могут возникать в *блок*, *for_statement*, *switch_statement* или *using_statement*; или *foreach_statement* или *specific_catch_clause* для *try_statement*.

Время существования локальной переменной — это часть во время которого хранилища гарантированно будет зарезервирован для его выполнения программы. Это время существования расширяет по крайней мере из записи в *блок*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, или *specific_catch_clause* с которым он связан, откладывается до времени выполнения, *блок*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, или *specific_catch_clause* окончания никак. (Ввод закрытой *блок* или вызов метода приостанавливается, но не завершает выполнение текущего *блок*, *for_statement*, *switch_statement* , *using_statement*, *foreach_statement*, или *specific_catch_clause*.) Если локальная переменная перехватывается анонимная функция ([захваченные внешние переменные](expressions.md#captured-outer-variables)), его времени существования расширяет по крайней мере до дерева, делегата или выражения, создаваемую из анонимной функции, а также другие объекты, ссылаться на захваченной переменной, подходящие для сборки мусора.

Если родительский *блок*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, или *specific_catch_clause* вводится рекурсивно, новый экземпляр локальной переменной создается каждый раз и его *local_variable_initializer*, если имеется, вычисляется Каждый раз.

Локальная переменная, созданная по *local_variable_declaration* автоматически не инициализирован, и поэтому имеет значение по умолчанию отсутствует. Для целей проверки определенного присваивания локальной переменной представленные *local_variable_declaration* считается изначально не присвоены значения. Объект *local_variable_declaration* может включать *local_variable_initializer*, в этом случае переменная считается определенно присвоенной только после инициализирующего выражения ([ Операторы объявления](variables.md#declaration-statements)).

В области действия локальной переменной, вызванные *local_variable_declaration*, произошла ошибка во время компиляции, для ссылки на эту локальную переменную в позиции текста, который предшествует его *local_variable_declarator*. Если объявление локальной переменной является неявным ([объявления локальных переменных](statements.md#local-variable-declarations)), это также ошибка при ссылке на эту переменную в его *local_variable_declarator*.

Локальная переменная, созданная по *foreach_statement* или *specific_catch_clause* считается определенно присвоенной в пределах всей области видимости.

Фактическое время жизни локальной переменной зависит от реализации. К примеру, компилятор может статически определить, что локальной переменной в блоке используется только для небольших часть этого блока. С помощью этого анализа, компилятор может создать код, получаемый в места хранения переменной короче, чем время жизни содержащего его блока.

Хранилище, на который ссылается локальная ссылочная переменная освобождается независимо от времени существования этого локальную ссылочную переменную ([автоматическое управление памятью](basic-concepts.md#automatic-memory-management)).

## <a name="default-values"></a>Значения по умолчанию

Следующие категории переменных автоматически инициализируются значениями по умолчанию:

*  Статические переменные.
*  Переменные экземпляров класса экземпляра.
*  Элементы массива.

Значение по умолчанию переменной зависит от типа переменной и определяется следующим образом:

*  Для переменной *value_type*, значение по умолчанию является таким же, как значение, вычисленное *value_type*в конструктор по умолчанию ([конструкторы по умолчанию](types.md#default-constructors)).
*  Для переменной *reference_type*, значение по умолчанию — `null`.

Инициализация значения по умолчанию обычно выполняется, если диспетчер памяти или сборщик мусора инициализации памяти, все биты нулями, прежде чем он выделяется для использования. По этой причине удобно использовать все биты нулями для представления пустая ссылка.

## <a name="definite-assignment"></a>Определенного присваивания

В заданном расположении в исполняемый код функции-члена, переменная считается ***определенно присвоенной*** Если компилятор может подтвердить, с отдельного статического анализа потока ([точные правила определения определенного Назначение](variables.md#precise-rules-for-determining-definite-assignment)), переменная автоматически инициализируется или по крайней мере один назначения. Другими словами, ниже приведены правила определенного присваивания.

*  Переменная с начальным значением ([изначально назначается переменные](variables.md#initially-assigned-variables)) всегда считается определенно присвоенной.
*  Переменной ([без начального значения переменных](variables.md#initially-unassigned-variables)) считается определенно присвоенной в заданную позицию, если все возможные пути выполнения приводит к этому расположению содержать по крайней мере одно из следующих:
    * Простое назначение ([простое присваивание](expressions.md#simple-assignment)), в котором переменная является левым операндом.
    * Выражения вызова ([выражения вызова](expressions.md#invocation-expressions)) или выражение создания объекта ([выражения создания объектов](expressions.md#object-creation-expressions)), передает переменную в качестве выходного параметра.
    * Для локальной переменной, в объявлении локальной переменной ([объявления локальных переменных](statements.md#local-variable-declarations)), включающий инициализаторе переменных.

Формальная спецификация, определяющая изложенные выше правила описан в [изначально назначается переменные](variables.md#initially-assigned-variables), [без начального значения переменных](variables.md#initially-unassigned-variables), и [точные правила определения определенного присваивания](variables.md#precise-rules-for-determining-definite-assignment).

Состояния определенного присваивания переменных экземпляра *struct_type* переменной отслеживаются как по отдельности, так и в совокупности. В дополнительных выше правилам применяются следующие правила для *struct_type* переменные и их переменные экземпляра:

*  Переменная экземпляра считается определенно присвоенной, если содержащий его *struct_type* переменная считается определенно присвоенной.
*  Объект *struct_type* переменная считается определенно присвоенной, если каждая из его переменных экземпляра считается определенно присвоенной.

Определенного присваивания является обязательным в следующих контекстах:

*  Переменной должен быть явно присвоен во всех расположениях, где извлекается ее значение. Это гарантирует, что неопределенные значения никогда не возникают. Чтобы получить значение переменной, за исключением случаев считается вхождения переменной в выражении
    * переменная является левый операнд простого присваивания,
    * переменная передается в качестве выходного параметра, или
    * переменная является *struct_type* переменной и указана как левый операнд доступ к члену.
*  Переменной должен быть явно присвоен во всех расположениях, где он передается в качестве ссылочного параметра. Это гарантирует, что функцию-член вызван метод, можно изначально назначается ссылочный параметр.
*  Все выходные параметры функции-члена должен быть явно присвоен во всех расположениях, где функцию-член возвращает (через `return` инструкции или с помощью выполнения достигнут конец тела функции-члена). Это гарантирует, что функции-члены не возвращают неопределенные значения в выходных параметров, позволяя таким образом компилятор рассматривал вызова функции-члена, принимающий эквивалентно присвоения значения переменной переменную в качестве выходного параметра.
*  `this` Переменной *struct_type* конструктор экземпляра должен быть явно присвоен во всех расположениях, где возвращает этот конструктор экземпляра.

### <a name="initially-assigned-variables"></a>Переменные с начальным значением

Следующие категории переменных классифицируются с начальным значением:

*  Статические переменные.
*  Переменные экземпляров класса экземпляра.
*  Переменные экземпляра переменных начальным значением структуры.
*  Элементы массива.
*  Параметры по значению.
*  Ссылочные параметры.
*  Переменные, объявленные в `catch` предложение или `foreach` инструкции.

### <a name="initially-unassigned-variables"></a>Изначально не присвоены значения переменных

Без начального значения, относятся следующие категории переменных:

*  Переменные экземпляра структуры изначально не присвоены значения переменных.
*  Выходные параметры, включая `this` переменной конструкторов экземпляров структуры.
*  За исключением локальных переменных, объявленных в `catch` предложение или `foreach` инструкции.

### <a name="precise-rules-for-determining-definite-assignment"></a>Точные правила для выявления определенного присваивания

Чтобы определить, что каждая из используемых переменных определенно присвоенной, компилятор должен использовать процесс, который эквивалентен, описанный в этом разделе.

Компилятор обрабатывает тело каждого функция-член, имеющий один или несколько переменных без начального значения. Для каждой переменной *v*, компилятор определяет ***состояние определенного присваивания*** для *v* в каждой из следующих точек в функцию-член:

*  В начале каждой инструкции
*  В конечной точке ([конечные точки и доступность](statements.md#end-points-and-reachability)) каждой инструкции
*  В каждой ветке, где управление передается в другой оператор или в конечную точку, инструкции
*  В начале каждого выражения
*  В конце каждого выражения

Состояние определенного присваивания *v* может быть либо:

*  Определенно присвоенной. Это означает, что на всех возможных потоках управления к этому моменту *v* было назначено значение.
*  Определенно присвоенной. Для состояния переменной в конце выражения типа `bool`, состояние переменной, которая не определенно присвоенной мая (но не обязательно), относятся к одной из следующих вложенных состояний:
    * Определенно присвоенной после выражения значение true. Это состояние указывает, что *v* присваивается определенным образом в том случае, если логическое выражение возвращает значение true, но не назначен обязательно, если логическое выражение вычислено как false.
    * Определенно присвоенной после выражения false. Это состояние указывает, что *v* присваивается определенным образом в том случае, если логическое выражение вычислено как false, но присваивается не обязательно, если логическое выражение вычисляется как true.

Следующие правила определяют как состояние переменной *v* определяется в каждом расположении.

#### <a name="general-rules-for-statements"></a>Общие правила для операторов

*  *v* не является определенно присвоенной в начале тела функции-члена.
*  *v* определенно присвоенной в начале каждой недостижимого оператора.
*  Состояние определенного присваивания *v* в начале любой другой инструкции, определяется путем проверки состояния определенного присваивания *v* на все передачи потока управления, предназначенных для начала, инструкция. Если (и только в том случае, если) *v* определенно назначается на все ветвях потоков управления, затем *v* определенно присвоенной в начале инструкции. Набор возможных ветвлений потоков управления определяется так же как и для проверки достижимости операторов ([конечные точки и доступность](statements.md#end-points-and-reachability)).
*  Состояние определенного присваивания *v* в конечной точке блока, `checked`, `unchecked`, `if`, `while`, `do`, `for`, `foreach`, `lock`, `using`, или `switch` определяется путем проверки состояния определенного присваивания *v* на все передачи потока управления, предназначенных для конечной точки этой инструкции. Если *v* определенно назначается на все ветвях потоков управления, затем *v* определенно присвоенной в конечной точке инструкции. В противном случае; *v* не является определенно присвоенной в конечной точке инструкции. Набор возможных ветвлений потоков управления определяется так же как и для проверки достижимости операторов ([конечные точки и доступность](statements.md#end-points-and-reachability)).

#### <a name="block-statements-checked-and-unchecked-statements"></a>Блок операторов, этот флажок установлен и снят флажок операторов

Состояние определенного присваивания *v* на элементе управления передачи для первой инструкции списка операторов в блоке (или в конечную точку блока, если список операторов пуст) совпадает со значением определенного присваивания переменной *v* перед блоком, `checked`, или `unchecked` инструкции.

#### <a name="expression-statements"></a>Операторы выражений

Для инструкции выражение *stmt* , состоящий из выражения *expr*:

*  *v* имеющий то же состояние определенного присваивания в начале *expr* как в начале *stmt*.
*  Если *v* Если определенно присвоенной в конце *expr*, он считается определенно присвоенной в конечную точку *stmt*; в противном случае; определенно не назначен в конечную точку *stmt*.

#### <a name="declaration-statements"></a>Операторы объявления

*  Если *stmt* является оператором объявления без инициализаторов, затем *v* имеет такое же состояние определенного присваивания в конечную точку *stmt* как в начале *stmt*.
*  Если *stmt* является оператором объявления с инициализаторами, затем состояние определенного присваивания для *v* определяется так, как если *stmt* списка операторов, с помощью одно назначение инструкции для каждого объявления с инициализатором (в порядке объявления).

#### <a name="if-statements"></a>Если инструкции

Для `if` инструкции *stmt* формы:
```csharp
if ( expr ) then_stmt else else_stmt
```

*  *v* имеющий то же состояние определенного присваивания в начале *expr* как в начале *stmt*.
*  Если *v* определенно присвоенной в конце *expr*, а затем она определенно присвоенной передачу потока управления в *then_stmt* и либо *else_stmt*  или в конечной точке *stmt* Если отсутствует предложение else.
*  Если *v* имеет состояние «определенно назначены после выражения true» в конце *expr*, а затем она определенно присвоенной передачу потока управления в *then_stmt*и не определенно присвоенной ветви потока управления, либо *else_stmt* или в конечной точке *stmt* Если отсутствует предложение else.
*  Если *v* имеет состояние «определенно назначены после выражения false» в конце *expr*, а затем она определенно присвоенной передачу потока управления в *else_stmt*и не определенно присвоенной передачу потока управления в *then_stmt*. Она является определенно присвоенной в конечной точке *stmt* только в том случае, если она является определенно присвоенной в конечной точке *then_stmt*.
*  В противном случае *v* считается определенно присвоенной ветви потока управления, либо *then_stmt* или *else_stmt*, или в конечной точке  *stmt* Если отсутствует предложение else.

#### <a name="switch-statements"></a>Операторы switch

В `switch` инструкции *stmt* с управляющее выражение *expr*:

*  Состояние определенного присваивания *v* в начале *expr* совпадает со значением состояния *v* в начале *stmt*.
*  Состояние определенного присваивания *v* в потоке управления передача в список доступен коммутатор блок инструкций является таким же, как состояние определенного присваивания *v* в конце *expr*.

#### <a name="while-statements"></a>While-операторы

Для `while` инструкции *stmt* формы:
```csharp
while ( expr ) while_body
```

*  *v* имеющий то же состояние определенного присваивания в начале *expr* как в начале *stmt*.
*  Если *v* определенно присвоенной в конце *expr*, а затем она определенно присвоенной передачу потока управления в *while_body* и конечную точку  *stmt*.
*  Если *v* имеет состояние «определенно назначены после выражения true» в конце *expr*, то определенно присвоенной передачу потока управления в *while_body*, но не определенно присвоенной в конечной точке *stmt*.
*  Если *v* имеет состояние «определенно назначены после выражения false» в конце *expr*, а затем она определенно присвоенной передачу потока управления в конечную точку *stmt* , но определенно присвоенной ветви потока управления для *while_body*.

#### <a name="do-statements"></a>Инструкции

Для `do` инструкции *stmt* формы:
```csharp
do do_body while ( expr ) ;
```

*  *v* имеющий то же состояние определенного присваивания ветви потока управления в начале *stmt* для *do_body* как в начале *stmt*.
*  *v* имеющий то же состояние определенного присваивания в начале *expr* на конечную точку *do_body*.
*  Если *v* определенно присвоенной в конце *expr*, а затем она определенно присвоенной передачу потока управления в конечную точку *stmt*.
*  Если *v* имеет состояние «определенно назначены после выражения false» в конце *expr*, а затем она определенно присвоенной передачу потока управления в конечную точку *stmt* .

#### <a name="for-statements"></a>Для инструкций

Проверка наличия определенного присваивания `for` инструкцию для формы:
```csharp
for ( for_initializer ; for_condition ; for_iterator ) embedded_statement
```
выполняется для оператора:
```csharp
{
for_initializer ;
while ( for_condition ) {
embedded_statement ;
for_iterator ;
}
}
```

Если *for_condition* исключается из `for` инструкции, а затем вычисление определенного присваивания продолжается так, как если *for_condition* были заменены `true` в выше расширения .

#### <a name="break-continue-and-goto-statements"></a>Прервать, продолжить работу и операторы "goto"

Состояние определенного присваивания *v* ветви потока управления, из-за `break`, `continue`, или `goto` инструкция является таким же, как состояние определенного присваивания *v* в начало оператора.

#### <a name="throw-statements"></a>Операторы throw

Для инструкции *stmt* формы
```csharp
throw expr ;
```

Состояние определенного присваивания *v* в начале *expr* совпадает со значением состояния определенного присваивания *v* в начале *stmt*.

#### <a name="return-statements"></a>Операторы "Return"

Для инструкции *stmt* формы
```csharp
return expr ;
```

*  Состояние определенного присваивания *v* в начале *expr* совпадает со значением состояния определенного присваивания *v* в начале *stmt*.
*  Если *v* является выходным параметром, то он должен быть явно присвоен либо:
    * После *expr*
    * или в конце `finally` блока `try` - `finally` или `try` - `catch` - `finally` , ограничивающий `return` инструкции.

Для оператора stmt формы:
```csharp
return ;
```

*  Если *v* является выходным параметром, то он должен быть явно присвоен либо:
    * Прежде чем *stmt*
    * или в конце `finally` блока `try` - `finally` или `try` - `catch` - `finally` , ограничивающий `return` инструкции.

#### <a name="try-catch-statements"></a>Операторы try-catch

Для инструкции *stmt* формы:
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
```

*  Состояние определенного присваивания *v* в начале *try_block* совпадает со значением состояния определенного присваивания *v* в начале *stmt*.
*  Состояние определенного присваивания *v* в начале *catch_block_i* (для любого *я*) совпадает со значением состояния определенного присваивания *v*в начале *stmt*.
*  Состояние определенного присваивания *v* в конечной точке *stmt* определенно присвоенной (и только если) *v* определенно присвоенной в конечной точке  *try_block* и каждый *catch_block_i* (для каждого *я* от 1 до *n*).

#### <a name="try-finally-statements"></a>Операторы try-finally

Для `try` инструкции *stmt* формы:
```csharp
try try_block finally finally_block
```

*  Состояние определенного присваивания *v* в начале *try_block* совпадает со значением состояния определенного присваивания *v* в начале *stmt*.
*  Состояние определенного присваивания *v* в начале *finally_block* совпадает со значением состояния определенного присваивания *v* в начале *stmt* .
*  Состояние определенного присваивания *v* в конечной точке *stmt* определенно присвоенной (и только если) по крайней мере одно из следующих имеет значение true:
    * *v* определенно присвоенной в конечной точке *try_block*
    * *v* определенно присвоенной в конечной точке *finally_block*

При переключении потока управления (например, `goto` инструкции), которое начинается в *try_block*и заканчивается за пределами *try_block*, затем *v* также считается определенно присвоенной в ветви потока управления, если *v* определенно присвоенной в конечной точке *finally_block*. (Это не единственная — Если *v* определенно присвоенной по другой причине этой ветви потока управления, то он по-прежнему считается определенно присвоенной.)

#### <a name="try-catch-finally-statements"></a>Операторы try-catch-finally

Анализ определенного присваивания для `try` - `catch` - `finally` инструкцию для формы:
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
finally *finally_block*
```
выполняется, как если бы были инструкция `try` - `finally` заключения инструкции `try` - `catch` инструкции:
```csharp
try {
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
}
finally finally_block
```

В следующем примере показано, как разные блоки `try` инструкции ([оператора try](statements.md#the-try-statement)) влияют на определенного присваивания.
```csharp
class A
{
static void F() {
int i, j;
try {
goto LABEL;
// neither i nor j definitely assigned
i = 1;
// i definitely assigned
}

catch {
// neither i nor j definitely assigned
i = 3;
// i definitely assigned
}

finally {
// neither i nor j definitely assigned
j = 5;
// j definitely assigned
}
// i and j definitely assigned
LABEL:;
// j definitely assigned

}
}
```

#### <a name="foreach-statements"></a>Инструкции по каждому элементу

Для `foreach` инструкции *stmt* формы:
```csharp
foreach ( type identifier in expr ) embedded_statement
```

*  Состояние определенного присваивания *v* в начале *expr* совпадает со значением состояния *v* в начале *stmt*.
*  Состояние определенного присваивания *v* ветви потока управления для *embedded_statement* или конечную точку *stmt* совпадает со значением состояния *v* в конце *expr*.

#### <a name="using-statements"></a>С помощью инструкций

Для `using` инструкции *stmt* формы:
```csharp
using ( resource_acquisition ) embedded_statement
```

*  Состояние определенного присваивания *v* в начале *resource_acquisition* совпадает со значением состояния *v* в начале *stmt*.
*  Состояние определенного присваивания *v* ветви потока управления для *embedded_statement* совпадает со значением состояния *v* в конце *resource_ Приобретение*.

#### <a name="lock-statements"></a>Инструкции блокировки

Для `lock` инструкции *stmt* формы:
```csharp
lock ( expr ) embedded_statement
```

*  Состояние определенного присваивания *v* в начале *expr* совпадает со значением состояния *v* в начале *stmt*.
*  Состояние определенного присваивания *v* ветви потока управления для *embedded_statement* совпадает со значением состояния *v* в конце *expr*.

#### <a name="yield-statements"></a>Операторы yield

Для `yield return` инструкции *stmt* формы:
```csharp
yield return expr ;
```

*  Состояние определенного присваивания *v* в начале *expr* совпадает со значением состояния *v* в начале *stmt*.
*  Состояние определенного присваивания *v* в конце *stmt* совпадает со значением состояния *v* в конце *expr*.
*  Объект `yield break` инструкции не влияет на состояние определенного присваивания.

#### <a name="general-rules-for-simple-expressions"></a>Общие правила для простых выражений

Следующее правило применяется для этих видов выражений: литералы ([литералы](expressions.md#literals)), простые имена ([простые имена](expressions.md#simple-names)), выражения доступа к членам ([доступ к членам](expressions.md#member-access)), выражения неиндексированных доступ к базовым членам ([базового доступа](expressions.md#base-access)), `typeof` выражения ([оператор typeof](expressions.md#the-typeof-operator)), выражения значения по умолчанию ([выражения значения по умолчанию ](expressions.md#default-value-expressions)) и `nameof` выражения ([выражения Nameof](expressions.md#nameof-expressions)).

*  Состояние определенного присваивания *v* в конце такого выражения совпадает со значением состояния определенного присваивания *v* в начале выражения.

#### <a name="general-rules-for-expressions-with-embedded-expressions"></a>Общие правила для выражений с внедренными выражениями

Применяются следующие правила для этих видов выражений: выражения в скобках ([выражения в скобках](expressions.md#parenthesized-expressions)), выражения доступа к элементу ([доступ к элементам](expressions.md#element-access)), базовый доступ к выражения с Индексирование ([базового доступа](expressions.md#base-access)), увеличения и уменьшения выражения ([постфиксных инкремента и декремента](expressions.md#postfix-increment-and-decrement-operators), [префиксный инкремент и декремент операторы](expressions.md#prefix-increment-and-decrement-operators)), выражения приведения ([выражения приведения](expressions.md#cast-expressions)), унарный `+`, `-`, `~`, `*` выражения, двоичный `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, `^` выражения ([арифметические операторы](expressions.md#arithmetic-operators), [операторы сдвига](expressions.md#shift-operators), [отношения и операторы тестирования типа](expressions.md#relational-and-type-testing-operators) [Логические операторы](expressions.md#logical-operators)), составные выражения присваивания ([Составное присваивание](expressions.md#compound-assignment)), `checked` и `unchecked` выражения ([checked и unchecked операторы](expressions.md#the-checked-and-unchecked-operators)), а также массив и делегат выражения для создания ([оператор new](expressions.md#the-new-operator)).

Каждый из этих выражений имеет один или несколько вложенных выражений, которые оцениваются, безусловно, в определенном порядке. Например, двоичный файл `%` оператор вычисляет левой части оператора, а затем правой части. Операция индексирования вычисляет индексированным выражением, а затем каждое из выражений индекса, в порядке слева направо. Для выражения *expr*, который имеет вложенных выражений *e1, e2,..., eN*, вычисленное в указанном порядке:

*  Состояние определенного присваивания *v* в начале *e1* совпадает со значением состояние определенного присваивания в начале *expr*.
*  Состояние определенного присваивания *v* в начале *ei* (*я* больше единицы) совпадает со значением состояние определенного присваивания в конце предыдущего подвыражения.
*  Состояние определенного присваивания *v* в конце *expr* совпадает со значением состояние определенного присваивания в конце *eN*

#### <a name="invocation-expressions-and-object-creation-expressions"></a>Выражения вызова и выражения создания объекта

Для выражения вызова *expr* формы:
```csharp
primary_expression ( arg1 , arg2 , ... , argN )
```
или выражение создания объекта в форме:
```csharp
new type ( arg1 , arg2 , ... , argN )
```

*  Для выражения вызова состояние определенного присваивания *v* перед *primary_expression* совпадает со значением состояния *v* перед *expr*.
*  Для выражения вызова состояние определенного присваивания *v* перед *arg1* совпадает со значением состояния *v* после *primary_expression*.
*  Для выражения создания объекта, состояние определенного присваивания *v* перед *arg1* совпадает со значением состояния *v* перед *expr*.
*  Для каждого аргумента *argi*, состояние определенного присваивания *v* после *argi* определяется правилами обычным выражением, пропуская любой `ref` или `out`модификаторы.
*  Для каждого аргумента *argi* для любого *я* больше единицы, состояние определенного присваивания *v* перед *argi* совпадает со значением состояния *v* после предыдущего *arg*.
*  Если переменная *v* передается в качестве `out` аргумента (т. е. аргумент формы `out v`) в любом из аргументов, а затем состояние *v* после *expr* присваивается определенным образом. В противном случае; состояние *v* после *expr* совпадает со значением состояния *v* после *argN*.
*  Для инициализаторов массива ([выражениях создания массива](expressions.md#array-creation-expressions)), инициализаторы объектов ([инициализаторы объектов](expressions.md#object-initializers)), инициализаторы коллекций ([инициализаторы](expressions.md#collection-initializers)) и Инициализаторы анонимных объектов ([выражения создания анонимных объектов](expressions.md#anonymous-object-creation-expressions)), состояние определенного присваивания определяется расширения, определенные на основе этих конструкций.

#### <a name="simple-assignment-expressions"></a>Простые выражения присваивания

Для выражения *expr* формы `w = expr_rhs`:

*  Состояние определенного присваивания *v* перед *expr_rhs* совпадает со значением состояния определенного присваивания *v* перед *expr*.
*  Состояние определенного присваивания *v* после *expr* определяется:
   * Если *w* — это та же переменная, как *v*, состояние определенного присваивания переменной *v* после *expr* присваивается определенным образом.
   * В противном случае, если назначение происходит в конструкторе экземпляра типа структуры, если *w* имеет доступ к свойству, обозначающий автоматически реализуемого свойства *P* конструируемого экземпляра и *v* является скрытым резервное поле *P*, состояние определенного присваивания переменной *v* после *expr* определенно назначить.
   * В противном случае состояние определенного присваивания *v* после *expr* совпадает со значением состояния определенного присваивания *v* после *expr_rhs*.

#### <a name="-conditional-and-expressions"></a>& & (условный оператор AND) выражения

Для выражения *expr* формы `expr_first && expr_second`:

*  Состояние определенного присваивания *v* перед *expr_first* совпадает со значением состояния определенного присваивания *v* перед *expr*.
*  Состояние определенного присваивания *v* перед *expr_second* определенно присвоенной, если состояние *v* после *expr_first* либо определенно присвоенной или «определенно присвоенной после выражения true». В противном случае он не назначается явно.
*  Состояние определенного присваивания *v* после *expr* определяется:
    * Если *expr_first* является константным выражением со значением `false`, состояние определенного присваивания переменной *v* после *expr* совпадает со значением определенного присваивания состояние *v* после *expr_first*.
    * В противном случае, если состояние *v* после *expr_first* является определенно присвоенной, то состояние *v* после *expr* присваивается определенным образом.
    * В противном случае, если состояние *v* после *expr_second* определенно присвоенной и состояние *v* после *expr_first* определенно « назначенные после выражения false», а затем состояние *v* после *expr* присваивается определенным образом.
    * В противном случае, если состояние *v* после *expr_second* определенно присвоенной или «определенно присвоенной после значение true, выражение», а затем состояние *v* после  *expr* «присваивается определенным образом после выражения true».
    * В противном случае, если состояние *v* после *expr_first* «определенно присвоенной после выражения false», а состояние *v* после *expr_second* «определенно присвоенной после выражения false», то состояние *v* после *expr* «присваивается определенным образом после выражения false».
    * В противном случае состояние *v* после *expr* определенно не назначается.

В примере
```csharp
class A
{
    static void F(int x, int y) {
        int i;
        if (x >= 0 && (i = y) >= 0) {
            // i definitely assigned
        }
        else {
            // i not definitely assigned
        }
        // i not definitely assigned
    }
}
```
переменная `i` считается определенно присвоенной в одном из внедренных операторов `if` инструкции, но не в другой. В `if` инструкция в методе `F`, переменная `i` определенно присвоенной первый внедренный оператор, поскольку выполнение выражения `(i = y)` всегда предшествует выполнению этого внедренного оператора. Напротив, переменная `i` не является определенно присвоенной во втором операторе внедренных, так как `x >= 0` может завершиться с итогом false, приводит к переменной `i` не назначены.

#### <a name="-conditional-or-expressions"></a>|| (условный оператор OR) выражения

Для выражения *expr* формы `expr_first || expr_second`:

*  Состояние определенного присваивания *v* перед *expr_first* совпадает со значением состояния определенного присваивания *v* перед *expr*.
*  Состояние определенного присваивания *v* перед *expr_second* определенно присвоенной, если состояние *v* после *expr_first* либо определенно присвоенной или «определенно присвоенной после выражения false». В противном случае он не назначается явно.
*  Определенного присваивания переменной *v* после *expr* определяется:
    * Если *expr_first* является константным выражением со значением `true`, состояние определенного присваивания переменной *v* после *expr* совпадает со значением определенного присваивания состояние *v* после *expr_first*.
    * В противном случае, если состояние *v* после *expr_first* является определенно присвоенной, то состояние *v* после *expr* присваивается определенным образом.
    * В противном случае, если состояние *v* после *expr_second* определенно присвоенной и состояние *v* после *expr_first* определенно « назначенные после выражения true», а затем состояние *v* после *expr* присваивается определенным образом.
    * В противном случае, если состояние *v* после *expr_second* определенно присвоенной или «определенно присвоенной после выражения false», а затем состояние *v* после *expr* «присваивается определенным образом после выражения false».
    * В противном случае, если состояние *v* после *expr_first* «определенно присвоенной после выражения true», а состояние *v* после *expr_second*«определенно присвоенной после выражения true», то состояние *v* после *expr* «присваивается определенным образом после выражения true».
    * В противном случае состояние *v* после *expr* определенно не назначается.

В примере
```csharp
class A
{
    static void G(int x, int y) {
        int i;
        if (x >= 0 || (i = y) >= 0) {
            // i not definitely assigned
        }
        else {
            // i definitely assigned
        }
        // i not definitely assigned
    }
}
```
переменная `i` считается определенно присвоенной в одном из внедренных операторов `if` инструкции, но не в другой. В `if` инструкция в методе `G`, переменная `i` определенно присвоенной второй внедренный оператор, поскольку выполнение выражения `(i = y)` всегда предшествует выполнению этого внедренного оператора. Напротив, переменная `i` не является определенно присвоенной в первом внедренный оператор, поскольку `x >= 0` может завершиться с итогом значение true, приводит к переменной `i` не назначены.

#### <a name="-logical-negation-expressions"></a>! выражения (логическое отрицание)

Для выражения *expr* формы `! expr_operand`:

*  Состояние определенного присваивания *v* перед *expr_operand* совпадает со значением состояния определенного присваивания *v* перед *expr*.
*  Состояние определенного присваивания *v* после *expr* определяется:
    * Если состояние *v* после * expr_operand * является определенно присвоенной, то состояние *v* после *expr* присваивается определенным образом.
    * Если состояние *v* после * expr_operand * не является определенно присвоенной, то состояние *v* после *expr* определенно не назначается.
    * Если состояние *v* после * expr_operand * «определенно присвоенной после выражения false», то состояние *v* после *expr* «присваивается определенным образом после true выражение».
    * Если состояние *v* после * expr_operand * «определенно присвоенной после выражения true», то состояние *v* после *expr* «присваивается определенным образом после false выражение».

#### <a name="-null-coalescing-expressions"></a>?? выражения (нулем)

Для выражения *expr* формы `expr_first ?? expr_second`:

*  Состояние определенного присваивания *v* перед *expr_first* совпадает со значением состояния определенного присваивания *v* перед *expr*.
*  Состояние определенного присваивания *v* перед *expr_second* совпадает со значением состояния определенного присваивания *v* после *expr_first*.
*  Определенного присваивания переменной *v* после *expr* определяется:
    * Если *expr_first* является константным выражением ([константные выражения](expressions.md#constant-expressions)) со значением null, то состояние *v* после *expr* совпадает состоянию *v* после *expr_second*.
*  В противном случае состояние *v* после *expr* совпадает со значением состояния определенного присваивания *v* после *expr_first*.

#### <a name="-conditional-expressions"></a>?: (условный) выражения

Для выражения *expr* формы `expr_cond ? expr_true : expr_false`:

*  Состояние определенного присваивания *v* перед *expr_cond* совпадает со значением состояния *v* перед *expr*.
*  Состояние определенного присваивания *v* перед *expr_true* является определенно присвоенной только в том случае, если содержит одно из следующих:
    * *expr_cond* является константным выражением со значением `false`
    * состояние *v* после *expr_cond* имеет определенно присвоенной или «определенно назначены после выражения true».
*  Состояние определенного присваивания *v* перед *expr_false* является определенно присвоенной только в том случае, если содержит одно из следующих:
    * *expr_cond* является константным выражением со значением `true`
*  состояние *v* после *expr_cond* имеет определенно присвоенной или «определенно присвоенной после выражения false».
*  Состояние определенного присваивания *v* после *expr* определяется:
    * Если *expr_cond* является константным выражением ([константные выражения](expressions.md#constant-expressions)) со значением `true` состояние переменной *v* после *expr* совпадает со значением состояния *v* после *expr_true*.
    * В противном случае, если *expr_cond* является константным выражением ([константные выражения](expressions.md#constant-expressions)) со значением `false` состояние переменной *v* после *expr* совпадает со значением состояния *v* после *expr_false*.
    * В противном случае, если состояние *v* после *expr_true* присваивается определенным образом и состояние *v* после *expr_false* определенно назначена, состояние *v* после *expr* присваивается определенным образом.
    * В противном случае состояние *v* после *expr* определенно не назначается.

#### <a name="anonymous-functions"></a>Анонимные функции

Для *lambda_expression* или *anonymous_method_expression* *expr* с текстом (либо *блок* или *выражение* ) *текст*:

*  Состояние определенного присваивания внешней переменной *v* перед *текст* совпадает со значением состояния *v* перед *expr*. То есть состояние определенного присваивания внешних переменных наследуется из контекста анонимной функции.
*  Состояние определенного присваивания внешней переменной *v* после *expr* совпадает со значением состояния *v* перед *expr*.

Пример
```csharp
delegate bool Filter(int i);

void F() {
    int max;

    // Error, max is not definitely assigned
    Filter f = (int n) => n < max;

    max = 5;
    DoWork(f);
}
```
вызывает ошибку времени компиляции с момента `max` не является определенно присвоенной где объявлен анонимной функции. Пример
```csharp
delegate void D();

void F() {
    int n;
    D d = () => { n = 1; };

    d();

    // Error, n is not definitely assigned
    Console.WriteLine(n);
}
```
также вызывает ошибку времени компиляции с момента назначения `n` в анонимной функции не влияет на состояние определенного присваивания `n` вне анонимной функции.

## <a name="variable-references"></a>Ссылки на переменные

Объект *variable_reference* — *выражение* , классифицируется как переменная. Объект *variable_reference* обозначает место хранения, может осуществляться как получить текущее значение и сохранить новое значение.

```antlr
variable_reference
    : expression
    ;
```

В C и C++ *variable_reference* называется *lvalue*.

## <a name="atomicity-of-variable-references"></a>Атомарность ссылок на переменные

Операции чтения и записи из следующих типов данных являются атомарными: `bool`, `char`, `byte`, `sbyte`, `short`, `ushort`, `uint`, `int`, `float`и ссылочные типы. Кроме того чтение и запись типов перечисления с базовым типом, в списке выше также являются атомарными. Выполняет чтение и запись других типов, включая `long`, `ulong`, `double`, и `decimal`, а также определяемые пользователем типы, не гарантируется атомарным. Помимо функций библиотеки, предназначенных для этой цели нет никакой гарантии из атомарных чтения, изменения и записи, такие как в случае инкремента или декремента.

