# <a name="statements"></a>Операторы

C# предоставляет широкий набор инструкций. Большинство из них будут знакомы разработчикам, кто имеет опыт программирования на C и C++.

```antlr
statement
    : labeled_statement
    | declaration_statement
    | embedded_statement
    ;

embedded_statement
    : block
    | empty_statement
    | expression_statement
    | selection_statement
    | iteration_statement
    | jump_statement
    | try_statement
    | checked_statement
    | unchecked_statement
    | lock_statement
    | using_statement
    | yield_statement
    | embedded_statement_unsafe
    ;
```

*Embedded_statement* нетерминального символа используется для инструкций, которые отображаются в других инструкциях. Использование *embedded_statement* вместо *инструкции* исключает использование операторы объявления и операторы с метками в следующих контекстах. Пример
```csharp
void F(bool b) {
    if (b)
        int i = 44;
}
```
приводит к ошибке времени компиляции, так как `if` инструкция требует *embedded_statement* вместо *инструкции* для его Если ветвь. Если этот код был разрешен, то переменная `i` должна быть объявлена, но никогда не может быть использована. Тем не менее, поместив `i`объявления в блоке, пример является допустимым.

## <a name="end-points-and-reachability"></a>Конечные точки и доступность

Каждая инструкция имеет ***конечная точка***. Интуитивно понятно конечную точку инструкции — это расположение, в который следует сразу за инструкцию. Правила выполнения составных операторов (инструкции, содержащие внедренные операторы) укажите действие, выполняемое, когда управление достигает конечной точки внедренного оператора. Например когда управление достигает конечной точки оператор в блоке, управление передается следующему оператору в блоке.

Если возможно, оператор может получить доступ в процессе выполнения, инструкция считается ***доступен***. И наоборот, если есть вероятность того, что инструкция будет выполняться, инструкция считается ***недоступен***.

В примере
```csharp
void F() {
    Console.WriteLine("reachable");
    goto Label;
    Console.WriteLine("unreachable");
    Label:
    Console.WriteLine("reachable");
}
```
Второй вызов `Console.WriteLine` недоступен, так как вероятность того, что инструкция будет выполняться.

Выводится предупреждение, если компилятор определяет, что оператор является недоступным. Это не рассматривается как ошибка для инструкции будет воспринята как недоступная.

Чтобы определить, доступен ли определенной инструкции или конечной точки, компилятор выполняет анализ потока в соответствии с правилами достижимости, определенные для каждой инструкции. Анализ потока учитывает значения константных выражений ([константные выражения](expressions.md#constant-expressions)), управления поведением операторов, но возможные значения Неконстантные выражения не учитываются. Другими словами для целей анализа потока управления, неконстантное выражение данного типа считается принимать любое значение этого типа.

В примере
```csharp
void F() {
    const int i = 1;
    if (i == 2) Console.WriteLine("unreachable");
}
```
Логическое выражение `if` инструкция — это константное выражение, так как оба операнда `==` оператор являются константами. Как константное выражение вычисляется во время компиляции, результатом которого является значение `false`, `Console.WriteLine` вызов считается недоступным. Тем не менее если `i` изменяется на быть локальной переменной
```csharp
void F() {
    int i = 1;
    if (i == 2) Console.WriteLine("reachable");
}
```
`Console.WriteLine` вызов считается доступным, несмотря на то что на самом деле он никогда не выполняется.

*Блок* функции члена всегда считается доступным. Последовательно применяя правила достижимости каждый оператор в блоке, можно определить достижимость любого конкретного оператора.

В примере
```csharp
void F(int x) {
    Console.WriteLine("start");
    if (x < 0) Console.WriteLine("negative");
}
```
Доступность второго `Console.WriteLine` определяется следующим образом:

*  Первый `Console.WriteLine` оператор выражения доступен поскольку блок `F` доступен метод.
*  Конечная точка первого `Console.WriteLine` оператор выражения доступен, поскольку сам оператор достижим.
*  `if` Оператор достижим из-за окончания первого `Console.WriteLine` оператор выражения доступен.
*  Второй `Console.WriteLine` оператор выражения доступен так как логическое выражение `if` оператор не имеет постоянное значение `false`.

Существуют две ситуации, в которых это ошибка времени компиляции для конечной точки инструкции быть доступен:

*  Так как `switch` инструкция не поддерживает раздел switch, который «проваливания» следующий раздел switch, произошла ошибка во время компиляции, для конечной точки списка операторов раздела switch достижимым. Если эта ошибка возникает, это обычно означает, что, `break` отсутствует инструкция.
*  Это ошибка времени компиляции для конечной точки блока функции-члена, которая вычисляет значение достижимым. Если эта ошибка возникает, это обычно означает, что, `return` отсутствует инструкция.

## <a name="blocks"></a>Blocks

С помощью *блоков* можно использовать несколько операторов в таких контекстах, где ожидается только один оператор.

```antlr
block
    : '{' statement_list? '}'
    ;
```

Объект *блок* состоит из необязательного *statement_list* ([инструкция выводит список](statements.md#statement-lists)), заключенный в фигурные скобки. Если указан список операторов, блок считается пустым.

Блок может содержать операторы объявления ([операторы объявления](statements.md#declaration-statements)). Областью видимости локальной переменной или константы, объявленных в блоке является блоком.

Блок выполняется следующим образом:

*  Если блок является пустой, управление передается в конечную точку блока.
*  Если блок не является пустой, управление передается списка операторов. Если управление достигает конца списка операторов, элемент управления передается в конечную точку блока.

Список операторов в блоке будет доступен в том случае, если доступен сам блок.

Конечная точка блок доступен, если блок является пустой, или если конечная точка списка операторов достижима.

Объект *блок* , содержит один или несколько `yield` инструкций ([оператор yield](statements.md#the-yield-statement)) называется блоком итератора. Блоки итераторов используются для реализации функции-члены как итераторы ([итераторы](classes.md#iterators)). Некоторые дополнительные ограничения применяются к блокам итератора.

*  Произошла ошибка во время компиляции для `return` инструкции в блоке итератора (но `yield return` инструкции, разрешены).
*  Произошла ошибка во время компиляции для блока итератора должен содержать небезопасный контекст ([небезопасных контекстах](unsafe-code.md#unsafe-contexts)). Блока итератора всегда определяет безопасный контекст, даже в том случае, если объявление является вложенным в небезопасном контексте.

### <a name="statement-lists"></a>Список операторов

Объект ***списка операторов*** состоит из одного или нескольких инструкций, созданных в последовательности. Списки инструкций происходят в *блок*s ([блоки](statements.md#blocks)) и в *switch_block*s ([оператора switch](statements.md#the-switch-statement)).

```antlr
statement_list
    : statement+
    ;
```

Список инструкций выполняется путем передачи управления в первой инструкции. Если и элемента управления достигает конечной точки оператора, управление передается оператору, следующему. Если управление достигает конечной точки последнего выполнения инструкции, элемент управления передается в конечную точку списка операторов.

Инструкции в списке инструкции доступен в том случае, если верно хотя бы одно из следующих:

*  Инструкция является первой инструкцией, а сам список операторов доступна.
*  Конечная точка предыдущего оператора достижима.
*  Оператор является оператором с меткой и метка имеет ссылку на доступную `goto` инструкции.

Конечная точка списка операторов доступен в том случае, если конечная точка последней инструкции в списке доступен.

## <a name="the-empty-statement"></a>Пустая инструкция

*Empty_statement* не выполняет никаких действий.

```antlr
empty_statement
    : ';'
    ;
```

Пустой оператор используется в том случае, когда нет операций для выполнения в контексте, где требуется оператор.

Выполнение пустого оператора просто передает управление конечной точки инструкции. Таким образом конечная точка пустого оператора достижима, если доступен пустой оператор.

Пустой оператор можно использовать при написании `while` инструкции с пустым текстом:
```csharp
bool ProcessMessage() {...}

void ProcessMessages() {
    while (ProcessMessage())
        ;
}
```

Кроме того, пустого оператора можно объявить метку непосредственно перед закрывающим "`}`" блока:
```csharp
void F() {
    ...
    if (done) goto exit;
    ...
    exit: ;
}
```

## <a name="labeled-statements"></a>Инструкции с метками

Объект *labeled_statement* позволяет инструкцию, чтобы иметь префикс в метку. Операторы с метками, разрешены в блоках, но не допускаются как внедренные операторы.

```antlr
labeled_statement
    : identifier ':' statement
    ;
```

Оператор с меткой объявляет метку, имя, заданное в *идентификатор*. Областью метки является весь блок, в котором она объявлена, включая вложенные блоки. Это ошибка времени компиляции для двух меток с тем же именем, чтобы перекрывающиеся области.

Метку можно ссылаться из `goto` инструкций ([инструкцию goto](statements.md#the-goto-statement)) в пределах метки. Это означает, что `goto` инструкций может передать контроль в блоках и из блоков, но не внутрь блока.

Метки имеют собственную область объявления и не конфликтуют с другими идентификаторами. Пример
```csharp
int F(int x) {
    if (x >= 0) goto x;
    x = -x;
    x: return x;
}
```
является допустимым именем, `x` как параметр и метку.

Выполнение инструкции с метками в точности соответствует выполнение оператору после метки.

Помимо достижимости в рамках обычного потока управления, оператор с меткой доступен, если метка имеет ссылку на доступную `goto` инструкции. (Исключение: Если `goto` оператор находится внутри `try` , включающий `finally` блока и оператор с меткой за пределами `try`и конечная точка `finally` блок недоступен, то оператор с меткой недостижим из `goto` инструкции.)

## <a name="declaration-statements"></a>Инструкции объявления

Объект *declaration_statement* объявляет локальную переменную или константу. Операторы объявления разрешены в блоках, но не допускаются как внедренные операторы.

```antlr
declaration_statement
    : local_variable_declaration ';'
    | local_constant_declaration ';'
    ;
```

### <a name="local-variable-declarations"></a>Объявления локальных переменных

Объект *local_variable_declaration* объявляет один или несколько локальных переменных.

```antlr
local_variable_declaration
    : local_variable_type local_variable_declarators
    ;

local_variable_type
    : type
    | 'var'
    ;

local_variable_declarators
    : local_variable_declarator
    | local_variable_declarators ',' local_variable_declarator
    ;

local_variable_declarator
    : identifier
    | identifier '=' local_variable_initializer
    ;

local_variable_initializer
    : expression
    | array_initializer
    | local_variable_initializer_unsafe
    ;
```

*Local_variable_type* из *local_variable_declaration* напрямую указывает тип переменных, представленных в объявлении, либо указывает с идентификатором `var` , Тип неявно определяется инициализатором. Тип сопровождается список *local_variable_declarator*s, каждый из которых представляет новую переменную. Объект *local_variable_declarator* состоит из *идентификатор* , которая содержит название переменной, при желании указав через "`=`" токена и *local_variable_initializer* , задающее начальное значение переменной.

В контексте объявления локальной переменной, идентификатор var выступает в качестве контекстно-зависимое ключевое слово ([ключевые слова](lexical-structure.md#keywords)). При *local_variable_type* указывается как `var` и тип с именем `var` — в области, объявление является ***неявно типизированные в объявлении локальной переменной***, тип которого является выводится из типа из соответствующего выражения инициализатора. Неявно типизированные локальные объявления переменных распространяются следующие ограничения:

*  *Local_variable_declaration* не может включать несколько *local_variable_declarator*s.
*  *Local_variable_declarator* должен включать *local_variable_initializer*.
*  *Local_variable_initializer* должно быть *выражение*.
*  Инициализатор *выражение* должно иметь тип времени компиляции.
*  Инициализатор *выражение* не может ссылаться на сам объявленной переменной

Ниже приведены примеры неправильные объявления неявно типизированных локальных переменных.

```csharp
var x;               // Error, no initializer to infer type from
var y = {1, 2, 3};   // Error, array initializer not permitted
var z = null;        // Error, null does not have a type
var u = x => x + 1;  // Error, anonymous functions do not have a type
var v = v++;         // Error, initializer cannot refer to variable itself
```

Получено значение локальной переменной в выражение, использующее *simple_name* ([простые имена](expressions.md#simple-names)), и изменения значения локальной переменной с помощью *назначения* () [Операторы присваивания](expressions.md#assignment-operators)). Локальной переменной должен быть явно присвоен ([определенного присваивания](variables.md#definite-assignment)) во всех расположениях, где извлекается ее значение.

Локальная переменная, объявленная в области *local_variable_declaration* представляет собой блок, в котором содержится объявление. Это ошибка для ссылки на локальную переменную в позиции текста, который предшествует *local_variable_declarator* локальной переменной. В области локальной переменной это ошибка времени компиляции, чтобы объявить другой локальной переменной или константы с тем же именем.

Объявление локальной переменной, объявляется несколько переменных соответствует несколько объявлений одного переменных с одним типом. Кроме того использование инициализатора в объявлении локальной переменной в точности соответствует оператора присваивания, который вставляется непосредственно после объявления.

Пример
```csharp
void F() {
    int x = 1, y, z = x * 2;
}
```
в точности соответствует
```csharp
void F() {
    int x; x = 1;
    int y;
    int z; z = x * 2;
}
```

В неявно типизированной локальной объявление переменной тип объявляемой переменной принимается совпадал с типом выражения, используемого для инициализации переменной. Пример:
```csharp
var i = 5;
var s = "Hello";
var d = 1.0;
var numbers = new int[] {1, 2, 3};
var orders = new Dictionary<int,Order>();
```

Неявно типизированные локальные объявления переменных выше будут точными эквивалентами следующих явно типизированных объявлений:
```csharp
int i = 5;
string s = "Hello";
double d = 1.0;
int[] numbers = new int[] {1, 2, 3};
Dictionary<int,Order> orders = new Dictionary<int,Order>();
```

### <a name="local-constant-declarations"></a>Локальные объявления констант

Объект *local_constant_declaration* объявляет один или несколько локальных констант.

```antlr
local_constant_declaration
    : 'const' type constant_declarators
    ;

constant_declarators
    : constant_declarator (',' constant_declarator)*
    ;

constant_declarator
    : identifier '=' constant_expression
    ;
```

*Тип* из *local_constant_declaration* указывает тип констант, представленных в объявлении. Тип сопровождается список *constant_declarator*s, каждый из которых представляет новую константу. Объект *constant_declarator* состоит из *идентификатор* которых имена следуют константа "`=`" токена, за которым следует *constant_expression* ([ Константные выражения](expressions.md#constant-expressions)), задающее значение константы.

*Тип* и *constant_expression* объявлении локальной константы должны следовать тем же правилам, что и объявление член константы ([константы](classes.md#constants)).

Значение локальной константы получается в выражение, использующее *simple_name* ([простые имена](expressions.md#simple-names)).

Областью локальной константы является блок, в котором содержится объявление. Это ошибка для ссылки на локальную константу в позиции текста, который предшествует его *constant_declarator*. В области локальной константы это ошибка времени компиляции, чтобы объявить другой локальной переменной или константы с тем же именем.

Объявление локальной константы, объявляющее несколько констант соответствует несколько объявлений из одной константы с тем же типом.

## <a name="expression-statements"></a>Инструкции выражений

*Expression_statement* вычисления данного выражения. Значение, вычисленное с помощью выражения, если таковые имеются, удаляются.

```antlr
expression_statement
    : statement_expression ';'
    ;

statement_expression
    : invocation_expression
    | null_conditional_invocation_expression
    | object_creation_expression
    | assignment
    | post_increment_expression
    | post_decrement_expression
    | pre_increment_expression
    | pre_decrement_expression
    | await_expression
    ;
```

Не все выражения разрешены как инструкции. В частности, выражения, такие как `x + y` и `x == 1` , просто вычислить значение (в который будут отменены), как операторы не разрешены.

Выполнение *expression_statement* вычисляет автономной и затем передает управление конечной точки *expression_statement*. Конечная точка *expression_statement* доступен, если это *expression_statement* доступен.

## <a name="selection-statements"></a>Операторы выбора

Операторы выбора выберите один из нескольких возможных вариантов для выполнения на основе значения из выражения.

```antlr
selection_statement
    : if_statement
    | switch_statement
    ;
```

### <a name="the-if-statement"></a>Если инструкция

`if` Инструкция выбирает оператор для выполнения на основе значения логического выражения.

```antlr
if_statement
    : 'if' '(' boolean_expression ')' embedded_statement
    | 'if' '(' boolean_expression ')' embedded_statement 'else' embedded_statement
    ;
```

`else` Часть связана с лексически ближайшего предшествующего `if` это разрешается с помощью синтаксиса. Таким образом `if` инструкцию для формы
```csharp
if (x) if (y) F(); else G();
```
эквивалентно
```csharp
if (x) {
    if (y) {
        F();
    }
    else {
        G();
    }
}
```

`if` Инструкция выполняется следующим образом:

*  *Boolean_expression* ([логических выражений](expressions.md#boolean-expressions)) вычисляется.
*  Если логическое выражение дает `true`, управление передается первой инструкции embedded. Если и элемента управления достигает конечной точки этого оператора, управление передается конечную точку `if` инструкции.
*  Если логическое выражение дает `false` и если `else` часть присутствует, управление передается второй внедренный оператор. Если и элемента управления достигает конечной точки этого оператора, управление передается конечную точку `if` инструкции.
*  Если логическое выражение дает `false` и если `else` часть отсутствует, управление передается в конечную точку `if` инструкции.

Первый внедренный оператор `if` оператор достижим Если `if` оператор достижим и логическое выражение имеет значение константы `false`.

Второй внедренный оператор `if` инструкции, если он имеется, доступен при `if` оператор достижим и логическое выражение имеет значение константы `true`.

Конечная точка `if` инструкции доступен, если конечная точка по крайней мере одного из его встроенных операторов достижима. Кроме того, точка конца `if` инструкции, не имеющий `else` часть доступен Если `if` оператор достижим и логическое выражение имеет значение константы `true`.

### <a name="the-switch-statement"></a>Оператор switch

Оператор switch выбирает для выполнения список операторов, метка которого соответствует значению выражения switch.

```antlr
switch_statement
    : 'switch' '(' expression ')' switch_block
    ;

switch_block
    : '{' switch_section* '}'
    ;

switch_section
    : switch_label+ statement_list
    ;

switch_label
    : 'case' constant_expression ':'
    | 'default' ':'
    ;
```

Объект *switch_statement* состоит из ключевого слова `switch`следуют выражение в скобках (называемых в выражении выбора вариантов), за которыми следует *switch_block*. *Switch_block* состоит из нуля или более *switch_section*s, заключенный в фигурные скобки. Каждый *switch_section* состоит из одного или нескольких *switch_label*s, за которым следует *statement_list* ([инструкция выводит список](statements.md#statement-lists)).

***, Управляющие типом*** из `switch` инструкции устанавливается в выражении выбора вариантов.

*  Если тип выражения выбора вариантов `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `bool`, `char`, `string`, или *enum_type*, или если он допускает значения NULL тип, соответствующий одному из этих типов, то это управление тип `switch` инструкции.
*  В противном случае ровно один пользовательские неявное преобразование ([заданные пользователем преобразования](conversions.md#user-defined-conversions)) должен существовать из типа в выражении выбора вариантов к одному из следующих возможные типы, управляющие: `sbyte`, `byte`, `short` , `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `string`, или, допускающий значение NULL тип, соответствующий одному из этих типов.
*  В противном случае если такого неявного преобразования не существует или если несколько таких неявных преобразований, возникает ошибка времени компиляции.

Константное выражение каждого `case` метки должно представлять значение, которое может быть неявно преобразован ([неявные преобразования](conversions.md#implicit-conversions)) в тип `switch` инструкции. Ошибка времени компиляции возникает, если два или более `case` метки в том же `switch` инструкции укажите то же постоянное значение.

Допускается не более одного `default` метки в операторе switch.

Объект `switch` инструкция выполняется следующим образом:

*  В выражении выбора вариантов вычисляется и преобразуется в тип.
*  Если одна из констант в `case` метки в том же `switch` инструкции равно значению выражения switch, управление передается инструкции списке, приведенном в сопоставленной `case` метки.
*  Если ни одна из констант, указанных в `case` метки в том же `switch` оператор равен значению выражения switch и если `default` метка присутствует, управление передается оператору, следующему списку `default` Метка.
*  Если ни одна из констант, указанных в `case` метки в том же `switch` оператор равен значению выражения switch, а если `default` метка присутствует, управление передается в конечную точку `switch` инструкции.

Если доступен конечную точку списка операторов раздела switch, возникает ошибка времени компиляции. Это называется «без передачи управления дальше» правило. Пример
```csharp
switch (i) {
case 0:
    CaseZero();
    break;
case 1:
    CaseOne();
    break;
default:
    CaseOthers();
    break;
}
```
является допустимым, поскольку нет раздел switch содержит доступную конечную точку. В отличие от C и C++ выполнение раздела switch не допускается для «проваливания» в следующий раздел switch и в примере
```csharp
switch (i) {
case 0:
    CaseZero();
case 1:
    CaseZeroOrOne();
default:
    CaseAny();
}
```
приводит к ошибке времени компиляции. При выполнении раздела switch должны предшествовать выполнения другого раздела switch, явно `goto case` или `goto default` необходимо использовать оператор:
```csharp
switch (i) {
case 0:
    CaseZero();
    goto case 1;
case 1:
    CaseZeroOrOne();
    goto default;
default:
    CaseAny();
    break;
}
```

Несколько меток разрешены в *switch_section*. Пример
```csharp
switch (i) {
case 0:
    CaseZero();
    break;
case 1:
    CaseOne();
    break;
case 2:
default:
    CaseTwo();
    break;
}
```
является допустимым. Пример не нарушает правило «не пройти через», так как метки `case 2:` и `default:` входят в одной и той же *switch_section*.

Правило «не пройти через» запрещает распространенных ошибок, возникающих в C и C++ при `break` случайно опускаются операторы. Кроме того, из-за этого правила из разделов switch `switch` инструкции можно произвольно переупорядочить без влияния на поведение оператора. Например, разделы `switch` приведенной выше инструкции, которые могли быть отменены без влияния на поведение оператора:
```csharp
switch (i) {
default:
    CaseAny();
    break;
case 1:
    CaseZeroOrOne();
    goto default;
case 0:
    CaseZero();
    goto case 1;
}
```

Список операторов в разделе switch, как правило, заканчивается в `break`, `goto case`, или `goto default` разрешено оператора, но любой конструкции отображает конечную точку списка операторов недоступен. Например `while` инструкции, которые управляются логическое выражение `true` известно, что никогда не reach конечной точке. Аналогичным образом `throw` или `return` инструкции всегда передает управление в другом месте и не достигает конечной точке. Таким образом следующий пример является допустимым:
```csharp
switch (i) {
case 0:
    while (true) F();
case 1:
    throw new ArgumentException();
case 2:
    return;
}
```

Тип `switch` оператор может быть тип `string`. Пример:
```csharp
void DoCommand(string command) {
    switch (command.ToLower()) {
    case "run":
        DoRun();
        break;
    case "save":
        DoSave();
        break;
    case "quit":
        DoQuit();
        break;
    default:
        InvalidCommand(command);
        break;
    }
}
```

Операторы равенства строк, такие как ([строковые операторы равенства](expressions.md#string-equality-operators)), `switch` инструкции чувствительно к регистру и будет выполняться данный раздел switch, только в том случае, если строка выражения switch точно соответствует `case` метки Константа.

Когда управление тип `switch` инструкция является `string`, значение `null` разрешается как константа метка case.

*Statement_list*s из *switch_block* может содержать операторы объявления ([операторы объявления](statements.md#declaration-statements)). Область локальной переменной или константы, объявленные в блоке коммутатора является блоком коммутатора.

Список операторов в разделе switch доступен Если `switch` оператор достижим и по крайней мере одно из следующих имеет значение true:

*  В выражении выбора вариантов представляет собой Непостоянное значение.
*  Выражение switch является постоянное значение, которое соответствует `case` метки в разделе switch.
*  Выражение switch является постоянное значение, которое не соответствует ни одному `case` метки, а раздел switch содержит `default` метки.
*  Метка switch раздел switch ссылается доступную `goto case` или `goto default` инструкции.

Конечная точка `switch` инструкции доступен, если верно хотя бы одно из следующих:

*  `switch` Инструкция содержит доступную `break` инструкцию, которая завершает работу `switch` инструкции.
*  `switch` Доступен инструкции, выражения switch неконстантное значение и нет `default` имеется метка.
*  `switch` Доступен инструкции, выражения switch является постоянное значение, которое не соответствует ни одному `case` метку и нет `default` имеется метка.

## <a name="iteration-statements"></a>Операторы итерации

Оператор итераций повторно выполняет внедренную инструкцию.

```antlr
iteration_statement
    : while_statement
    | do_statement
    | for_statement
    | foreach_statement
    ;
```

### <a name="the-while-statement"></a>Оператор while

`while` Инструкции условно выполняет внедренную инструкцию ноль или более раз.

```antlr
while_statement
    : 'while' '(' boolean_expression ')' embedded_statement
    ;
```

Объект `while` инструкция выполняется следующим образом:

*  *Boolean_expression* ([логических выражений](expressions.md#boolean-expressions)) вычисляется.
*  Если логическое выражение дает `true`, управление передается внедренный оператор. Если элемент управления достигает конечной точки внедренного оператора (возможно, в результате выполнения `continue` инструкции), управление передается в начале `while` инструкции.
*  Если логическое выражение дает `false`, управление передается в конечную точку `while` инструкции.

В рамках внедренный оператор в `while` инструкции, `break` инструкции ([оператор break](statements.md#the-break-statement)) может использоваться для передачи управления конечную точку `while` (что приводит к завершению итерации внедренный оператор оператор) и `continue` инструкции ([оператор continue](statements.md#the-continue-statement)) может использоваться для передачи управления в конечную точку внедренного оператора (выполняя другой итерации `while` инструкции).

Внедренный оператор в `while` оператор достижим Если `while` оператор достижим и логическое выражение имеет значение константы `false`.

Конечная точка `while` инструкции доступен, если верно хотя бы одно из следующих:

*  `while` Инструкция содержит доступную `break` инструкцию, которая завершает работу `while` инструкции.
*  `while` Оператор достижим и логическое выражение имеет значение константы `true`.

### <a name="the-do-statement"></a>Оператор do

`do` Инструкция выполняет ту или иную внедренный оператор один или несколько раз.

```antlr
do_statement
    : 'do' embedded_statement 'while' '(' boolean_expression ')' ';'
    ;
```

Объект `do` инструкция выполняется следующим образом:

*  Управление передается внедренный оператор.
*  Если элемент управления достигает конечной точки внедренного оператора (возможно, в результате выполнения `continue` инструкции), *boolean_expression* ([логических выражений](expressions.md#boolean-expressions)) вычисляется. Если логическое выражение дает `true`, управление передается в начале `do` инструкции. В противном случае управление передается в конечную точку `do` инструкции.

В рамках внедренный оператор в `do` инструкции, `break` инструкции ([оператор break](statements.md#the-break-statement)) может использоваться для передачи управления конечную точку `do` (что приводит к завершению итерации внедренный оператор оператор) и `continue` инструкции ([оператор continue](statements.md#the-continue-statement)) может использоваться для передачи управления в конечную точку внедренного оператора.

Внедренный оператор в `do` оператор достижим Если `do` оператор достижим.

Конечная точка `do` инструкции доступен, если верно хотя бы одно из следующих:

*  `do` Инструкция содержит доступную `break` инструкцию, которая завершает работу `do` инструкции.
*  Конечная точка внедренного оператора достижима и логическое выражение имеет значение константы `true`.

### <a name="the-for-statement"></a>Оператор for

`for` Инструкция вычисляет последовательность выражений инициализации, а затем, пока условие имеет значение true, многократно выполняет внедренную инструкцию и вычисляет последовательность выражений итерации.

```antlr
for_statement
    : 'for' '(' for_initializer? ';' for_condition? ';' for_iterator? ')' embedded_statement
    ;

for_initializer
    : local_variable_declaration
    | statement_expression_list
    ;

for_condition
    : boolean_expression
    ;

for_iterator
    : statement_expression_list
    ;

statement_expression_list
    : statement_expression (',' statement_expression)*
    ;
```

*For_initializer*, если он присутствует, состоит из *local_variable_declaration* ([объявления локальных переменных](statements.md#local-variable-declarations)) или список *statement_ выражение*s ([операторы выражений](statements.md#expression-statements)) через запятую. Область локальная переменная, объявленная с *for_initializer* начинается с *local_variable_declarator* для переменной и расширяет в конец внедренного оператора. Область включает *for_condition* и *for_iterator*.

*For_condition*, если он указан, должно быть *boolean_expression* ([логических выражений](expressions.md#boolean-expressions)).

*For_iterator*, если он присутствует, состоит из списка *statement_expression*s ([операторы выражений](statements.md#expression-statements)) через запятую.

Оператор For выполняется следующим образом:

*  Если *for_initializer* отсутствует, инициализаторы переменных или выражения инструкции выполняются в порядке, они записываются. Этот шаг выполняется только один раз.
*  Если *for_condition* присутствует, оно вычисляется.
*  Если *for_condition* отсутствует или если результатом вычисления является `true`, управление передается внедренный оператор. Если элемент управления достигает конечной точки внедренного оператора (возможно, в результате выполнения `continue` инструкции), выражения *for_iterator*, если имеется, вычисляются в последовательности, а затем другую итерацию выполняется, начиная с ознакомительной версией *for_condition* на предыдущем шаге.
*  Если *for_condition* существует и вычисление дает `false`, управление передается в конечную точку `for` инструкции.

В рамках внедренный оператор в `for` инструкции, `break` инструкции ([оператор break](statements.md#the-break-statement)) может использоваться для передачи управления конечную точку `for` (что приводит к завершению итерации внедренный оператор оператор) и `continue` инструкции ([оператор continue](statements.md#the-continue-statement)) может использоваться для передачи управления в конечную точку внедренного оператора (выполняя *for_iterator* и выполнение другой итерации `for` инструкции, начиная с *for_condition*).

Внедренный оператор в `for` инструкции доступен, если выполняется одно из следующих:

*  `for` Оператор достижим и не *for_condition* присутствует.
*  `for` Оператор достижим и *for_condition* присутствует и имеет постоянное значение `false`.

Конечная точка `for` инструкции доступен, если верно хотя бы одно из следующих:

*  `for` Инструкция содержит доступную `break` инструкцию, которая завершает работу `for` инструкции.
*  `for` Оператор достижим и *for_condition* присутствует и имеет постоянное значение `true`.

### <a name="the-foreach-statement"></a>Оператор foreach

`foreach` Инструкция перебирает элементы коллекции, выполняя внедренный оператор для каждого элемента коллекции.

```antlr
foreach_statement
    : 'foreach' '(' local_variable_type identifier 'in' expression ')' embedded_statement
    ;
```

*Тип* и *идентификатор* из `foreach` оператор объявления ***переменной итерации*** инструкции. Если `var` передан идентификатор *local_variable_type*и тип с именем `var` находится в области видимости, считается переменной итерации ***переменной неявно типизированных итерации***, и его тип воспринимается как тип элемента `foreach` инструкции, как указано ниже. Переменная итерации соответствует только для чтения локальную переменную с областью, охватывающей внедренный оператор. Во время выполнения `foreach` инструкции, переменная итерации представляет элемент коллекции, для которого итерации в настоящее время выполняется. Ошибка времени компиляции возникает, если внедренный оператор пытается изменить переменную итерации (с помощью присваивания или `++` и `--` операторы) или передать ее как `ref` или `out` параметра.

Далее для краткости `IEnumerable`, `IEnumerator`, `IEnumerable<T>` и `IEnumerator<T>` см. соответствующие типы в пространствах имен `System.Collections` и `System.Collections.Generic`.

Сначала определяет обработку во время компиляции оператора foreach ***тип коллекции***, ***тип перечислителя*** и ***тип элемента*** выражения. Это происходит следующим образом:

*  Если тип `X` из *выражение* является типом массива, то существует и неявное ссылочное преобразование из `X` для `IEnumerable` интерфейса (так как `System.Array` реализует этот интерфейс). ***Тип коллекции*** — `IEnumerable` интерфейс, ***тип перечислителя*** — `IEnumerator` интерфейс и ***тип элемента*** является тип элемента тип массива `X`.
*  Если тип `X` из *выражение* — `dynamic` то существует неявное преобразование из *выражение* для `IEnumerable` интерфейс ([неявное dynamic преобразования](conversions.md#implicit-dynamic-conversions)). ***Тип коллекции*** — `IEnumerable` интерфейс и ***тип перечислителя*** является `IEnumerator` интерфейс. Если `var` передан идентификатор *local_variable_type* то ***тип элемента*** — `dynamic`, в противном случае это `object`.
*  В противном случае определить ли тип `X` имеет соответствующий `GetEnumerator` метод:
   * Выполните поиск члена типа `X` с идентификатором `GetEnumerator` и аргументы типа. Если поиск члена не создает совпадение, или он приводит к неоднозначности, или обнаружено соответствие, который не является группой методов, проверьте наличие перечислимого интерфейса, как описано ниже. Выдано предупреждение, если поиск члена дает любой результат, за исключением группу методов или соответствие не рекомендуется.
   * Выполнения разрешения перегрузки, с помощью результирующей группы методов и пустым списком аргументов. Если разрешение перегрузки в методы не применимо, приводит к неоднозначности, или результатов в подходящий метод, но, что метод является либо статическими, либо не открытый, наличие перечислимого интерфейса, как описано ниже. Выдано предупреждение, если разрешение перегрузки дает любой результат, за исключением метода однозначный открытого экземпляра или применимые методы не рекомендуется.
   * Если тип возвращаемого значения, `E` из `GetEnumerator` метод не является классом, тип структуры или интерфейса, ошибка и никакие дополнительные действия не выполняются.
   * Поиск члена выполняется на `E` с идентификатором `Current` и аргументы типа. Если поиск члена не дает результата, происходит ошибка или результат-либо, кроме открытого свойства экземпляра, разрешающего чтение, ошибка, и никакие дальнейшие действия не предпринимаются.
   * Поиск члена выполняется на `E` с идентификатором `MoveNext` и аргументы типа. Если поиск члена не дает результата, происходит ошибка или результатом является какой-либо кроме группу методов, выдается ошибка и никакие дальнейшие действия не предпринимаются.
   * Разрешение перегрузки выполняется на группу методов с пустым списком аргументов. Если результаты разрешение перегрузки не применимые методы, приводит к неоднозначности или результаты в подходящий метод, но этот метод является либо статический, либо не открытый или его возвращаемый тип не является `bool`, выдается ошибка и никакие дальнейшие действия не предпринимаются.
   * ***Тип коллекции*** — `X`, ***тип перечислителя*** — `E`и ***тип элемента*** — это тип `Current` свойства.

*  В противном случае проверьте перечислимого интерфейса:
   * Если для всех типов `Ti` для которого существует неявное преобразование из `X` для `IEnumerable<Ti>`, есть уникальный тип `T` таким образом, чтобы `T` не `dynamic` и для всех остальных `Ti` существует неявное преобразование из `IEnumerable<T>` для `IEnumerable<Ti>`, а затем ***тип коллекции*** — это интерфейс `IEnumerable<T>`, ***тип перечислителя*** — это интерфейс `IEnumerator<T>`и ***тип элемента*** является `T`.
   * В противном случае, если имеется более одного типа `T`, выдается ошибка и никакие дальнейшие действия не предпринимаются.
   * В противном случае, если отсутствует неявное преобразование из `X` для `System.Collections.IEnumerable` интерфейс, а затем ***тип коллекции*** — это интерфейс ***тип перечислителя*** — это интерфейс `System.Collections.IEnumerator`и ***тип элемента*** является `object`.
   * В противном случае выдается ошибка и никакие дальнейшие действия не предпринимаются.

Указанные выше шаги и в случае успешного выполнения однозначно привести к типу коллекции `C`, тип перечислителя `E` и тип элемента `T`. Оператор foreach в форме
```csharp
foreach (V v in x) embedded_statement
```
затем распространяется на:
```csharp
{
    E e = ((C)(x)).GetEnumerator();
    try {
        while (e.MoveNext()) {
            V v = (V)(T)e.Current;
            embedded_statement
        }
    }
    finally {
        ... // Dispose e
    }
}
```

Переменная `e` не видно, но доступ к выражению `x` или внедренный оператор, или любой другой исходный код программы. Переменная `v` только для чтения в внедренный оператор. Если не существует явное преобразование ([явные преобразования](conversions.md#explicit-conversions)) из `T` (тип элемента) для `V` ( *local_variable_type* в операторе foreach), выдается ошибка и никакие дополнительные действия не предпринимаются. Если `x` имеет значение `null`, `System.NullReferenceException` возникает исключение во время выполнения.

Реализация может реализовать данный оператор foreach по-разному, например, для повышения производительности, до тех пор, пока поведение согласуется с выше расширения.

Размещение `v` внутри while цикл важно как записывается по любой анонимной функции в *embedded_statement*.

Пример:
```csharp
int[] values = { 7, 9, 13 };
Action f = null;

foreach (var value in values)
{
    if (f == null) f = () => Console.WriteLine("First value: " + value);
}

f();
```
Если `v` была объявлена вне while цикла, оно будет совместно использоваться всех итераций, а его значение после для цикла будет окончательное значение, а `13`, который относится к какой вызов `f` распечатает. Вместо этого, так как для каждой итерации задается собственный переменной `v`, одной записанной по `f` в первой итерации будут по-прежнему для хранения значения `7`, который является то, что будут печататься. (Примечание: объявлен в более ранних версиях C# `v` цикл while снаружи.)

Тело блока finally строится с помощью следующих действий:

*  Если неявное преобразование из `E` для `System.IDisposable` интерфейс, затем
   *  Если `E` является типом значения, не допускающим то предложение finally развертывается в семантический эквивалент следующего:

      ```csharp
      finally {
          ((System.IDisposable)e).Dispose();
      }
      ```

   *  В противном случае предложение finally развертывается в семантический эквивалент следующего:

      ```csharp
      finally {
          if (e != null) ((System.IDisposable)e).Dispose();
      }
      ```

   Кроме случаев, когда `E` является типом значения или параметра типа, создать экземпляр типа значения, а затем приведение из `e` для `System.IDisposable` не приведет к выполнению упаковки.

*  В противном случае, если `E` является запечатанным типом, предложение finally развертывается в пустой блок:

   ```csharp
   finally {
   }
   ```

*  В противном случае предложение finally развертывается для:

   ```csharp
   finally {
       System.IDisposable d = e as System.IDisposable;
       if (d != null) d.Dispose();
   }
   ```    

   Локальная переменная `d` не видно, но доступны для любого пользовательского кода. В частности, он не конфликтует с любой другой переменной, область которого входят блок finally.

Порядок, в котором `foreach` обходит элементы массива, выглядит следующим образом: Для одномерных массивов элементы распространяются по возрастанию индекс, начиная с индекса `0` и заканчивая индексом `Length - 1`. Для многомерных массивов элементы распространяются, индексы самого правого измерения являются сначала, а затем Далее левой измерения, и т. д слева.

В следующем примере выводится из каждого значения в двумерном массиве, по порядку:
```csharp
using System;

class Test
{
    static void Main() {
        double[,] values = {
            {1.2, 2.3, 3.4, 4.5},
            {5.6, 6.7, 7.8, 8.9}
        };

        foreach (double elementValue in values)
            Console.Write("{0} ", elementValue);

        Console.WriteLine();
    }
}
```
Вывод выглядит следующим образом:
```csharp
1.2 2.3 3.4 4.5 5.6 6.7 7.8 8.9
```

В примере
```csharp
int[] numbers = { 1, 3, 5, 7, 9 };
foreach (var n in numbers) Console.WriteLine(n);
```
Тип `n` выводится как `int`, тип элемента `numbers`.

## <a name="jump-statements"></a>Операторы перехода

Операторы перехода осуществляют безусловную передачу управления.

```antlr
jump_statement
    : break_statement
    | continue_statement
    | goto_statement
    | return_statement
    | throw_statement
    ;
```

Расположение, к которому оператор перехода передает управление называется ***целевой*** оператора перехода.

Если оператор перехода находится в пределах блока, а целевой объект, что оператор перехода находится вне этого блока, оператор jump называется ***выйти из*** блока. Хотя оператор перехода может передать управление из блока, он никогда не передает управление в блок.

Выполнение оператора перехода усложняется наличием промежуточные `try` инструкций. При отсутствии таких `try` операторы, оператор перехода обеспечивает безусловную передачу управления из оператора перехода своей цели. При наличии таких промежуточных `try` инструкции, выполнение более сложен. Выход из оператора перехода, один или несколько `try` связанных блоков с `finally` блоки, элемент управления изначально передается `finally` блок самого внутреннего `try` инструкции. Если элемент управления достигает конечной точки `finally` блок, элемент управления передается `finally` блок Далее включающего `try` инструкции. Этот процесс повторяется, пока `finally` блоки всех промежуточных `try` инструкций.

В примере
```csharp
using System;

class Test
{
    static void Main() {
        while (true) {
            try {
                try {
                    Console.WriteLine("Before break");
                    break;
                }
                finally {
                    Console.WriteLine("Innermost finally block");
                }
            }
            finally {
                Console.WriteLine("Outermost finally block");
            }
        }
        Console.WriteLine("After break");
    }
}
```
`finally` блокировок, сопоставленных с двумя `try` инструкции перед передачей управления в целевой объект оператора перехода.

Вывод выглядит следующим образом:
```
Before break
Innermost finally block
Outermost finally block
After break
```

### <a name="the-break-statement"></a>Оператор break

`break` Инструкция завершает работу ближайшего внешнего оператора `switch`, `while`, `do`, `for`, или `foreach` инструкции.

```antlr
break_statement
    : 'break' ';'
    ;
```

Цель `break` инструкция является конечной точкой ближайшего внешнего оператора `switch`, `while`, `do`, `for`, или `foreach` инструкции. Если `break` оператор не входит в `switch`, `while`, `do`, `for`, или `foreach` инструкции, возникает ошибка времени компиляции.

Когда несколько `switch`, `while`, `do`, `for`, или `foreach` инструкций вложены друг в друга, `break` заявление применяется только к самой внутренней инструкции. Для передачи управления на нескольких уровнях вложенности, `goto` инструкции ([инструкцию goto](statements.md#the-goto-statement)) необходимо использовать.

Объект `break` инструкция не может быть закрыто `finally` блока ([оператора try](statements.md#the-try-statement)). При `break` оператор находится внутри `finally` block, цель `break` инструкция должна быть в пределах одного `finally` block; в противном случае возникает ошибка времени компиляции.

Объект `break` инструкция выполняется следующим образом:

*  Если `break` инструкция завершает работу, один или несколько `try` связанных блоков с `finally` блоки, элемент управления изначально передается `finally` блок самого внутреннего `try` инструкции. Если элемент управления достигает конечной точки `finally` блок, элемент управления передается `finally` блок Далее включающего `try` инструкции. Этот процесс повторяется, пока `finally` блоки всех промежуточных `try` инструкций.
*  Управление передается от целевого объекта `break` инструкции.

Так как `break` инструкции Безусловно передает управление в другом месте, конечная точка `break` инструкции никогда не доступен.

### <a name="the-continue-statement"></a>Оператор continue

`continue` Инструкция запускает новую итерацию ближайшего внешнего оператора `while`, `do`, `for`, или `foreach` инструкции.

```antlr
continue_statement
    : 'continue' ';'
    ;
```

Цель `continue` инструкция является конечной точкой внедренного оператора ближайшего внешнего оператора `while`, `do`, `for`, или `foreach` инструкции. Если `continue` оператор не входит в `while`, `do`, `for`, или `foreach` инструкции, возникает ошибка времени компиляции.

Когда несколько `while`, `do`, `for`, или `foreach` инструкций вложены друг в друга, `continue` заявление применяется только к самой внутренней инструкции. Для передачи управления на нескольких уровнях вложенности, `goto` инструкции ([инструкцию goto](statements.md#the-goto-statement)) необходимо использовать.

Объект `continue` инструкция не может быть закрыто `finally` блока ([оператора try](statements.md#the-try-statement)). При `continue` оператор находится внутри `finally` block, цель `continue` инструкция должна быть в пределах одного `finally` block; в противном случае возникает ошибка времени компиляции.

Объект `continue` инструкция выполняется следующим образом:

*  Если `continue` инструкция завершает работу, один или несколько `try` связанных блоков с `finally` блоки, элемент управления изначально передается `finally` блок самого внутреннего `try` инструкции. Если элемент управления достигает конечной точки `finally` блок, элемент управления передается `finally` блок Далее включающего `try` инструкции. Этот процесс повторяется, пока `finally` блоки всех промежуточных `try` инструкций.
*  Управление передается от целевого объекта `continue` инструкции.

Так как `continue` инструкции Безусловно передает управление в другом месте, конечная точка `continue` инструкции никогда не доступен.

### <a name="the-goto-statement"></a>Оператор goto

`goto` Оператор передает управление в инструкцию, помеченный атрибутом метку.

```antlr
goto_statement
    : 'goto' identifier ';'
    | 'goto' 'case' constant_expression ';'
    | 'goto' 'default' ';'
    ;
```

Цель `goto` *идентификатор* инструкция является оператор с меткой с указанной меткой. Если метку с заданным именем не существует в текущей функции-члене или `goto` инструкции не входит в область метки, возникает ошибка времени компиляции. Это правило позволяет использовать `goto` инструкцию, чтобы передать управление за пределы вложенной области, но не в вложенной области. В примере
```csharp
using System;

class Test
{
    static void Main(string[] args) {
        string[,] table = {
            {"Red", "Blue", "Green"},
            {"Monday", "Wednesday", "Friday"}
        };

        foreach (string str in args) {
            int row, colm;
            for (row = 0; row <= 1; ++row)
                for (colm = 0; colm <= 2; ++colm)
                    if (str == table[row,colm])
                         goto done;

            Console.WriteLine("{0} not found", str);
            continue;
    done:
            Console.WriteLine("Found {0} at [{1}][{2}]", str, row, colm);
        }
    }
}
```
`goto` оператор используется для передачи управления из вложенной области.

Цель `goto case` инструкция является списка операторов в немедленно включающего `switch` инструкции ([оператора switch](statements.md#the-switch-statement)), который содержит `case` метку с заданным значением константы. Если `goto case` оператор не входит в `switch` инструкции, если *constant_expression* не может быть неявно преобразован ([неявные преобразования](conversions.md#implicit-conversions)) на тип ближайшее заключения `switch` инструкции, или если ближайшего внешнего оператора `switch` инструкция не содержит `case` метку с заданным значением константы, возникает ошибка времени компиляции.

Цель `goto default` инструкция является списка операторов в немедленно включающего `switch` инструкции ([оператора switch](statements.md#the-switch-statement)), который содержит `default` метки. Если `goto default` оператор не входит в `switch` инструкции, или если ближайшего внешнего оператора `switch` инструкция не содержит `default` метки, возникает ошибка времени компиляции.

Объект `goto` инструкция не может быть закрыто `finally` блока ([оператора try](statements.md#the-try-statement)). При `goto` оператор находится внутри `finally` block, цель `goto` инструкция должна быть в пределах одного `finally` блок, или в противном случае возникает ошибка времени компиляции.

Объект `goto` инструкция выполняется следующим образом:

*  Если `goto` инструкция завершает работу, один или несколько `try` связанных блоков с `finally` блоки, элемент управления изначально передается `finally` блок самого внутреннего `try` инструкции. Если элемент управления достигает конечной точки `finally` блок, элемент управления передается `finally` блок Далее включающего `try` инструкции. Этот процесс повторяется, пока `finally` блоки всех промежуточных `try` инструкций.
*  Управление передается от целевого объекта `goto` инструкции.

Так как `goto` инструкции Безусловно передает управление в другом месте, конечная точка `goto` инструкции никогда не доступен.

### <a name="the-return-statement"></a>Оператор return

`return` Оператор возвращает управление вызывающему объекту текущей функции, в котором `return` содержится инструкция.

```antlr
return_statement
    : 'return' expression? ';'
    ;
```

Объект `return` оператор выражение не может использоваться только в функции-члена, не вычисляет значение, то есть метод с типом результата ([тело метода](classes.md#method-body)) `void`, `set` метод доступа свойства или индексатор, `add` и `remove` методы доступа события, конструкторе экземпляра, статический конструктор или деструктор.

Объект `return` инструкции с выражением может использоваться только в функции-члена, которая вычисляет значение, то есть метод с типом результата, отличный от void, `get` метод доступа свойства или индексатора или определяемого пользователем оператора. Неявное преобразование ([неявные преобразования](conversions.md#implicit-conversions)) должен существовать в возвращаемый тип, содержащий функции-члена из типа выражения.

Возвращает операторы также могут использоваться в тексте выражения анонимных функций ([выражения анонимных функций](expressions.md#anonymous-function-expressions)) и участвовать в определении того, какие преобразования существует для этих функций.

Произошла ошибка во время компиляции для `return` инструкции в `finally` блока ([оператора try](statements.md#the-try-statement)).

Объект `return` инструкция выполняется следующим образом:

*  Если `return` инструкция указывает выражение, выражение вычисляется, и полученное значение преобразуется в возвращаемый тип, содержащий функции с помощью неявного преобразования. Результат преобразования становится значением результата, созданного функцией.
*  Если `return` оператор входит в один или несколько `try` или `catch` связанных блоков с `finally` блоки, элемент управления изначально передается `finally` блок самого внутреннего `try` инструкции. Если элемент управления достигает конечной точки `finally` блок, элемент управления передается `finally` блок Далее включающего `try` инструкции. Этот процесс повторяется, пока `finally` блоки, включающего все `try` инструкций.
*  Если содержащего функция не является асинхронной функции, управление возвращается вызывающему вместе с их результата, содержащего функции, если таковые имеются.
*  Если содержащий функция является асинхронной функции, управление возвращается вызывающему объекту текущего и результирующее значение, если таковые имеются, записывается в задача возврата как описано в разделе ([интерфейсы перечислителя](classes.md#enumerator-interfaces)).

Так как `return` инструкции Безусловно передает управление в другом месте, конечная точка `return` инструкции никогда не доступен.

### <a name="the-throw-statement"></a>Оператор throw

`throw` Оператор создает исключение.

```antlr
throw_statement
    : 'throw' expression? ';'
    ;
```

Объект `throw` оператор с выражение создает значение, полученное путем вычисления выражения. Выражение должно представлять значение с типом класса `System.Exception`, типа класса, производного от `System.Exception` или типа параметра типа, имеющий `System.Exception` (или его подкласс) как его эффективным базовым классом. Если при вычислении выражения создаются `null`, `System.NullReferenceException` вместо этого создается исключение.

Объект `throw` оператор выражения не может использоваться только в `catch` заблокировать, в этом случае этот оператор повторно создает исключение, которое в настоящее время обрабатывается, `catch` блок.

Так как `throw` инструкции Безусловно передает управление в другом месте, конечная точка `throw` инструкции никогда не доступен.

При возникновении исключения управление передается первому `catch` предложение в вложенным `try` инструкцию, которая может обработать исключение. Процесс, который имеет место, начиная с момента этого исключения в точку передачи управления в подходящий обработчик исключений называется ***распространение исключений***. Распространение исключения сводится к повторению следующее до `catch` найти предложение, которое совпадает с исключением. В этом описании ***точкой генерации*** изначально — расположение, по которому возникает исключение.

*  В текущей функции-члена каждой `try` инструкцию, которая содержит точку генерации проверяется. Для каждой инструкции `S`, начиная с самого внутреннего `try` инструкции и заканчивая самым внешним `try` инструкции, следующие шаги:

   * Если `try` блока `S` содержит точку генерации и если S имеет один или несколько `catch` предложений, `catch` предложения проверяются в порядке их следования в поисках подходящего обработчика для исключения, в соответствии с правилами, заданными в Раздел [оператора try](statements.md#the-try-statement). Если соответствующий `catch` находится предложение, распространение исключения завершается передачей управления в блок, `catch` предложение.

   * В противном случае, если `try` блока или `catch` блока `S` содержит точку генерации и если `S` имеет `finally` блок, элемент управления передается `finally` блока. Если `finally` блок создает другое исключение, завершается обработка текущего исключения. В противном случае, когда управление достигает конечной точки `finally` блока, продолжение обработки текущего исключения.

*  Если обработчик исключений не находится в текущем вызове функции, вызов функции прекращается и происходит одно из следующих:

   * Если синхронные текущей функции, описанные выше действия повторяются для вызывающего функции с точкой throw, соответствующий инструкции, из которого была вызвана функция-член.

   * Если текущая функция ключевых слов async и возвращающий задачу, исключение записывается в возвращаемое задачу, которая помещается в состояние faulted или отменено, как описано в разделе [интерфейсы перечислителя](classes.md#enumerator-interfaces).

   * Если текущая функция ключевых слов async и возвращающие void, контекст синхронизации для текущего потока уведомляется, как описано в разделе [перечисляемые интерфейсы](classes.md#enumerable-interfaces).

*  При обработке исключения, прерывание всех вызовов функций-членов в текущем потоке, указывающее, что поток не имеет обработчика для исключения, затем поток может сам завершен. Влияние прекращение их действия определяется реализацией.

## <a name="the-try-statement"></a>Оператор try

`try` Инструкция предоставляет механизм для перехвата исключений, возникающих во время выполнения блока. Кроме того `try` инструкция предоставляет возможность указать блок кода, который выполняется всегда, когда элемент управления покидает `try` инструкции.

```antlr
try_statement
    : 'try' block catch_clause+
    | 'try' block finally_clause
    | 'try' block catch_clause+ finally_clause
    ;

catch_clause
    : 'catch' exception_specifier? exception_filter?  block
    ;

exception_specifier
    : '(' type identifier? ')'
    ;

exception_filter
    : 'when' '(' expression ')'
    ;

finally_clause
    : 'finally' block
    ;
```

Существует три возможных форм `try` инструкции:

*  Объект `try` блока, а затем по одному или нескольким `catch` блоков.
*  Объект `try` блока, за которым следует `finally` блока.
*  Объект `try` блока, а затем по одному или нескольким `catch` блоки, за которым следует `finally` блока.

При `catch` предложение указывает *exception_specifier*, тип должен быть `System.Exception`, тип, который является производным от `System.Exception` или параметра типа, имеющего `System.Exception` (или его подкласс) как его вступают в силу базовый класс.

Когда `catch` предложение указывает оба *exception_specifier* с *идентификатор*, ***переменной исключения*** заданное имя и тип объявлен. Переменная исключения соответствует локальной переменной с областью, охватывающей `catch` предложение. Во время выполнения *exception_filter* и *блок*, переменная исключения представляет исключение, обрабатываемое в данный момент. В целях проверки определенного присваивания переменной исключения считается определенно присвоенной во всей области действия.

Если не `catch` предложение включает в себя имя переменной исключения, вы не сможете получить доступ к объекту исключения в фильтре и `catch` блока.

Объект `catch` предложение, которое не соответствует *exception_specifier* вызывается общего `catch` предложение.

Некоторые языки программирования могут поддерживать исключения, которые не может быть представлен как объект, производный от `System.Exception`, несмотря на то, что такие исключения не генерируются кодом C#. Общая `catch` предложение может использоваться для перехвата таких исключений. Таким образом, общая `catch` предложение является семантически отличной от одного, которое указывает тип `System.Exception`, в том, что первое из них может также перехватывать исключения из других языков.

Чтобы обнаружить обработчик для исключения, `catch` предложения проверяются в лексическом порядке. Если `catch` предложение указывает тип, но не фильтр исключений, возникает ошибка времени компиляции для более поздней версии `catch` предложение в том же `try` инструкцию, чтобы указать тип, совпадает или является производным от, что тип. Если `catch` предложение указывает без типа и без фильтра, он должен находиться в конце `catch` предложение для этого `try` инструкции.

В рамках `catch` блока, `throw` инструкции ([инструкция throw](statements.md#the-throw-statement)) без выражения может использоваться для повторного вызова исключения, которое было перехвачено `catch` блок. Назначения переменной исключения не изменяют исключение выдается заново.

В примере
```csharp
using System;

class Test
{
    static void F() {
        try {
            G();
        }
        catch (Exception e) {
            Console.WriteLine("Exception in F: " + e.Message);
            e = new Exception("F");
            throw;                // re-throw
        }
    }

    static void G() {
        throw new Exception("G");
    }

    static void Main() {
        try {
            F();
        }
        catch (Exception e) {
            Console.WriteLine("Exception in Main: " + e.Message);
        }
    }
}
```
метод `F` перехватывает исключение, записывает диагностическую информацию в консоль, изменяет переменную исключения и повторно создает исключение. Исключение, которое выдается повторно является исходное исключение, поэтому выходные данные:
```
Exception in F: G
Exception in Main: G
```

Если исключение первого блока catch `e` вместо повторного создания текущего исключения, выходные данные будет выглядеть следующим образом:
```csharp
Exception in F: G
Exception in Main: F
```

Произошла ошибка во время компиляции для `break`, `continue`, или `goto` инструкции для передачи управления из `finally` блока. При `break`, `continue`, или `goto` инструкция `finally` блок целевого объекта инструкции должно быть в пределах одного `finally` блок, или в противном случае возникает ошибка времени компиляции.

Произошла ошибка во время компиляции для `return` инструкции в `finally` блока.

Объект `try` инструкция выполняется следующим образом:

*  Управление передается `try` блока.
*  Если элемент управления достигает конечной точки `try` блок:
   *  Если `try` инструкция имеет `finally` блока, `finally` выполняется блок.
   *  Управление передается в конечную точку `try` инструкции.

*  Если исключение распространяется на `try` инструкции во время выполнения `try` блок:
   *  `catch` Предложения, если таковые имеются, проверяются в порядке их следования в поисках подходящего обработчика для исключения. Если `catch` предложение не указывать тип или указывает тип исключения или базовый тип типа исключения:
      *  Если `catch` предложение объявляет переменную исключения, объект исключения присваивается переменной исключения.
      *  Если `catch` предложение объявляет фильтр исключений, оценка фильтра. Если результат вычисления равен `false`, предложение catch не является результатом того, поиск продолжается через все последующие `catch` предложений для подходящего обработчика.
      *  В противном случае `catch` предложение считается соответствующим, а управление передается соответствующий `catch` блока.
      *  Если элемент управления достигает конечной точки `catch` блок:
         * Если `try` инструкция имеет `finally` блока, `finally` выполняется блок.
         * Управление передается в конечную точку `try` инструкции.
      *  Если исключение распространяется на `try` инструкции во время выполнения `catch` блок:
         *  Если `try` инструкция имеет `finally` блока, `finally` выполняется блок.
         *  Исключение передается далее заключающему `try` инструкции.
   *  Если `try` инструкция не `catch` предложений или нет ни одной `catch` предложение совпадает с исключением:
      *  Если `try` инструкция имеет `finally` блока, `finally` выполняется блок.
      *  Исключение передается далее заключающему `try` инструкции.

Операторы `finally` блок всегда выполняются, когда элемент управления покидает `try` инструкции. Это верно, происходит ли передачу управления результате нормального выполнения, в результате выполнения `break`, `continue`, `goto`, или `return` инструкции, или в результате распространения исключения из `try` инструкция.

Если возникает исключение во время выполнения `finally` блокировать и не перехватывается внутри того же блока finally, исключение распространяется Далее заключающему `try` инструкции. Если в этот момент распространялось другое исключение, это исключение будет потеряно. Процесс распространения исключения рассматривается далее в описание `throw` инструкции ([оператор throw](statements.md#the-throw-statement)).

`try` Блока `try` оператор достижим Если `try` оператор достижим.

Объект `catch` блока `try` оператор достижим Если `try` оператор достижим.

`finally` Блока `try` оператор достижим Если `try` оператор достижим.

Конечная точка `try` инструкции доступен, если выполняются оба следующих условия:

*  Конечная точка `try` блок доступен, или точка конца по крайней мере один `catch` блок доступен.
*  Если `finally` имеется блок, конечная точка `finally` блок доступен.

## <a name="the-checked-and-unchecked-statements"></a>Операторы checked и unchecked

`checked` И `unchecked` инструкции используются для управления ***контекстом проверки переполнения*** для целочисленных арифметических операций и преобразований.

```antlr
checked_statement
    : 'checked' block
    ;

unchecked_statement
    : 'unchecked' block
    ;
```

`checked` Инструкция вызывает все выражения в *блок* в проверяемом контексте и `unchecked` инструкция вызывает все выражения в *блок* в непроверенный контекст.

`checked` И `unchecked` инструкций будут точными эквивалентами `checked` и `unchecked` операторы ([операторы checked и unchecked](expressions.md#the-checked-and-unchecked-operators)), за исключением того, что они работают на блоки вместо выражения .

## <a name="the-lock-statement"></a>В операторе lock

`lock` Инструкция получает взаимоисключающую блокировку для заданного объекта, выполняет инструкцию и затем снимает блокировку.

```antlr
lock_statement
    : 'lock' '(' expression ')' embedded_statement
    ;
```

Выражение `lock` инструкции должно представлять значение типа, известные как *reference_type*. Преобразование не неявная упаковка-преобразование ([осуществлять преобразования-упаковки](conversions.md#boxing-conversions)) никогда не выполняется для выражения `lock` инструкции и, таким образом является ошибкой во время компиляции, чтобы выражение обозначало значение *value_type*.

Объект `lock` инструкции формы
```csharp
lock (x) ...
```
где `x` выражение *reference_type*, является точным эквивалентом
```csharp
bool __lockWasTaken = false;
try {
    System.Threading.Monitor.Enter(x, ref __lockWasTaken);
    ...
}
finally {
    if (__lockWasTaken) System.Threading.Monitor.Exit(x);
}
```
за исключением того, что `x` вычисляется только один раз.

Во время блокировки взаимного исключения, код, выполняемый в одном потоке выполнения можно также получить и снятия блокировки. Тем не менее код, выполняемый в других потоках блокируется получение блокировки до снятия блокировки.

Блокировка `System.Type` объекты для синхронизации доступа к статическим данным не рекомендуется. Другой код может быть заблокирован тот же тип, что может привести к взаимоблокировке. Лучшим подходом является для синхронизации доступа к статическим данным, заблокировав закрытый статический объект. Пример:
```csharp
class Cache
{
    private static readonly object synchronizationObject = new object();

    public static void Add(object x) {
        lock (Cache.synchronizationObject) {
            ...
        }
    }

    public static void Remove(object x) {
        lock (Cache.synchronizationObject) {
            ...
        }
    }
}
```

## <a name="the-using-statement"></a>Оператор using

`using` Инструкция получает один или несколько ресурсов, выполняет инструкцию и затем удаляет ресурс.

```antlr
using_statement
    : 'using' '(' resource_acquisition ')' embedded_statement
    ;

resource_acquisition
    : local_variable_declaration
    | expression
    ;
```

Объект ***ресурсов*** — это класс или структура, реализующие `System.IDisposable`, который включает один метод без параметров, с именем `Dispose`. Код, использующий ресурс может вызвать `Dispose` для указания, что ресурс больше не нужен. Если `Dispose` не вызывается, то автоматически со временем возникает в результате сборки мусора.

Если виде *resource_acquisition* — *local_variable_declaration* то типом *local_variable_declaration* должен быть либо `dynamic` или тип который может быть неявно преобразован в `System.IDisposable`. Если виде *resource_acquisition* — *выражение* затем этого выражения должны неявно преобразовываться в `System.IDisposable`.

Локальные переменные, объявленные в *resource_acquisition* доступны только для чтения и должны включать инициализатор. Ошибка времени компиляции возникает, если внедренный оператор пытается изменить эти локальные переменные (с помощью присваивания или `++` и `--` операторы), получить адрес их или передавать их в виде `ref` или `out` параметров.

Объект `using` инструкция преобразуется в состоит из трех частей: приобретения, использование и удаление. Использование ресурса неявно включается в `try` инструкция, включающая `finally` предложение. Это `finally` предложение удаляет ресурс. Если `null` ресурс запрашивается, затем вызов `Dispose` производится, и исключение не создается. Если ресурс типа `dynamic` преобразуется динамически через неявное преобразование динамических ([неявные преобразования динамических](conversions.md#implicit-dynamic-conversions)) к `IDisposable` во время приобретения, чтобы обеспечить преобразование успешно выполнена до использования и реализации.

Объект `using` инструкции формы
```csharp
using (ResourceType resource = expression) statement
```
соответствует одному из тремя способами. Когда `ResourceType` является типом значения, не допускающие значения NULL, является развертывание
```csharp
{
    ResourceType resource = expression;
    try {
        statement;
    }
    finally {
        ((IDisposable)resource).Dispose();
    }
}
```

В противном случае, если `ResourceType` имеет значение NULL или ссылочным типом, кроме `dynamic`, расширение
```csharp
{
    ResourceType resource = expression;
    try {
        statement;
    }
    finally {
        if (resource != null) ((IDisposable)resource).Dispose();
    }
}
```

В противном случае, если `ResourceType` является `dynamic`, расширение
```csharp
{
    ResourceType resource = expression;
    IDisposable d = (IDisposable)resource;
    try {
        statement;
    }
    finally {
        if (d != null) d.Dispose();
    }
}
```

В обоих `resource` переменная доступна только для чтения в внедренный оператор и `d` переменная недоступна и невидимым для внедренного оператора.

Реализация может реализовать с помощью инструкциях по-разному, например, для повышения производительности, до тех пор, пока поведение согласуется с выше расширения.

Объект `using` инструкции формы
```csharp
using (expression) statement
```
имеет же тремя способами. В этом случае `ResourceType` неявно имеет тип времени компиляции `expression`, если он имеется. В противном случае интерфейс `IDisposable` сам используется в качестве `ResourceType`. `resource` Переменной недоступна и невидимым для внедренного оператора.

Когда *resource_acquisition* принимает форму *local_variable_declaration*, имеется возможность присоединять несколько ресурсов данного типа. Объект `using` инструкции формы
```csharp
using (ResourceType r1 = e1, r2 = e2, ..., rN = eN) statement
```
вложен точно эквивалентен последовательность `using` инструкции:
```csharp
using (ResourceType r1 = e1)
    using (ResourceType r2 = e2)
        ...
            using (ResourceType rN = eN)
                statement
```

В приведенном ниже примере создается файл с именем `log.txt` и записывает две строки текста в файл. В примере затем открывается один и тот же файл для чтения и копирует автономной строки текста в консоль.
```csharp
using System;
using System.IO;

class Test
{
    static void Main() {
        using (TextWriter w = File.CreateText("log.txt")) {
            w.WriteLine("This is line one");
            w.WriteLine("This is line two");
        }

        using (TextReader r = File.OpenText("log.txt")) {
            string s;
            while ((s = r.ReadLine()) != null) {
                Console.WriteLine(s);
            }

        }
    }
}
```

Так как `TextWriter` и `TextReader` классы реализуют `IDisposable` интерфейс, можно использовать пример `using` инструкции для операций чтения или убедитесь, что следующие записи в базовый файл правильно закрыты.

## <a name="the-yield-statement"></a>Оператор yield

`yield` Оператор используется в блоке итератора ([блоки](statements.md#blocks)) для объекта перечислителя оператор yield ([объекты перечислителя](classes.md#enumerator-objects)) или перечисляемый объект ([перечисляемых объектов](classes.md#enumerable-objects)) итератор или для обозначения конца итерации.

```antlr
yield_statement
    : 'yield' 'return' expression ';'
    | 'yield' 'break' ';'
    ;
```

`yield` не является зарезервированным словом. он имеет специальное значение только в том случае, когда стоит непосредственно перед `return` или `break` ключевое слово. В других контекстах `yield` можно использовать в качестве идентификатора.

Существует ряд ограничений, о том, где `yield` оператор может использоваться, как описано ниже.

*  Произошла ошибка во время компиляции для `yield` инструкции (из двух форм) вне *method_body*, *operator_body* или *accessor_body*
*  Произошла ошибка во время компиляции для `yield` инструкции (из двух форм) для отображения внутри анонимной функции.
*  Произошла ошибка во время компиляции для `yield` инструкции (из двух форм) в `finally` предложении `try` инструкции.
*  Произошла ошибка во время компиляции для `yield return` инструкцию, чтобы находиться в любом месте `try` инструкцию, которая содержит любые `catch` предложения.

В следующем примере показано несколько допустимых и недопустимых способов использования `yield` инструкций.

```csharp
delegate IEnumerable<int> D();

IEnumerator<int> GetEnumerator() {
    try {
        yield return 1;        // Ok
        yield break;           // Ok
    }
    finally {
        yield return 2;        // Error, yield in finally
        yield break;           // Error, yield in finally
    }

    try {
        yield return 3;        // Error, yield return in try...catch
        yield break;           // Ok
    }
    catch {
        yield return 4;        // Error, yield return in try...catch
        yield break;           // Ok
    }

    D d = delegate { 
        yield return 5;        // Error, yield in an anonymous function
    }; 
}

int MyMethod() {
    yield return 1;            // Error, wrong return type for an iterator block
}
```

Неявное преобразование ([неявные преобразования](conversions.md#implicit-conversions)) должен существовать из типа выражения в `yield return` инструкции в тип результата ([Yield типа](classes.md#yield-type)) итератора.

Объект `yield return` инструкция выполняется следующим образом:

*  Выражение, заданное в инструкции вычисляется, неявно преобразован в тип результата и назначенные `Current` свойство объекта перечислителя.
*  Выполнение блока итератора приостанавливается. Если `yield return` оператор находится внутри одного или нескольких `try` блокирует, сопоставленного `finally` блоки не выполняются в данный момент.
*  `MoveNext` Метод объекта перечислителя возвращает `true` вызвавшему объекту, указывающее, что он успешно перемещен к следующему элементу.

Следующий вызов объекта-перечислителя `MoveNext` метод возобновляет выполнение блока итератора, из которой оно было приостановлено.

Объект `yield break` инструкция выполняется следующим образом:

*  Если `yield break` оператор входит в один или несколько `try` связанных блоков с `finally` блоки, элемент управления изначально передается `finally` блок самого внутреннего `try` инструкции. Если элемент управления достигает конечной точки `finally` блок, элемент управления передается `finally` блок Далее включающего `try` инструкции. Этот процесс повторяется, пока `finally` блоки, включающего все `try` инструкций.
*  Управление возвращается вызывающему объекту блока итератора. Это может быть либо `MoveNext` метод или `Dispose` метод объекта перечислителя.

Так как `yield break` инструкции Безусловно передает управление в другом месте, конечная точка `yield break` инструкции никогда не доступен.
