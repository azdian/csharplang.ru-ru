# <a name="unsafe-code"></a>Небезопасный код

Core язык C#, как определено в предыдущих главах, заметно отличается от C и C++ в нем не используются указателей с типом данных. Вместо этого C# предоставляет ссылки и возможность создавать объекты, которые управляются сборщиком мусора. Эта разработка в сочетании с другими компонентами, делает C# гораздо безопаснее язык, чем C или C++. В базовом языке C# это просто не могут существовать неинициализированной переменной, «несвязанные» указатель или выражение, который индексирует массив за пределами границ элемента. Целые категории ошибок, регулярно подвержены C и C++ программы таким образом устраняются.

Хотя практически любого конструкции с типом указателя в C или C++ имеет аналог ссылочного типа в C#, тем не менее, существуют ситуации, где доступ к типам указатель становится необходимостью. Например взаимодействие с базовой операционной системы, доступ к устройству, размещенный в памяти или реализации критичных по времени алгоритм может оказаться возможно или целесообразно без доступа к указателям. Для решения этой задачи, C# предоставляет возможность записи ***небезопасный код***.

В небезопасном коде можно объявить и использовать для указателей, для выполнения преобразований между указателями и целочисленных типов, для получения адреса переменных и т. д. В некотором смысле написание небезопасного кода аналогично написание кода C помощью программы C#.

Небезопасный код на самом деле является компонентом «безопасных» с точки зрения разработчиков и пользователей. Небезопасный код должен быть явно помечен модификатором `unsafe`, поэтому разработчики не может использовать небезопасные возможности случайно и механизм выполнения убедитесь, что небезопасный код не может быть выполнена в ненадежной среде.

## <a name="unsafe-contexts"></a>Небезопасные контексты

Небезопасные возможности C# доступны только в небезопасных контекстах. Небезопасный контекст вводится путем включения `unsafe` модификатор в объявлении типа или члена, или создав *unsafe_statement*:

*  Объявление класса, структуры, интерфейса или делегата может включать `unsafe` модификатор, в этом случае все текстовое пространство этого объявления (включая тело класса, структуры или интерфейса) считается небезопасным контекстом.
*  Объявление поля, метода, свойства, события, индексатор, оператор, конструктор экземпляра, деструктор или статический конструктор может включать `unsafe` модификатор, в этом случае все текстовое пространство этого объявления члена считается небезопасный контекст.
*  *Unsafe_statement* позволяет использовать в небезопасном контексте *блок*. Все текстовое пространство связанного *блок* считается небезопасным контекстом.

Ниже приведены соответствующие грамматические производства.

```antlr
class_modifier_unsafe
    : 'unsafe'
    ;

struct_modifier_unsafe
    : 'unsafe'
    ;

interface_modifier_unsafe
    : 'unsafe'
    ;

delegate_modifier_unsafe
    : 'unsafe'
    ;

field_modifier_unsafe
    : 'unsafe'
    ;

method_modifier_unsafe
    : 'unsafe'
    ;

property_modifier_unsafe
    : 'unsafe'
    ;

event_modifier_unsafe
    : 'unsafe'
    ;

indexer_modifier_unsafe
    : 'unsafe'
    ;

operator_modifier_unsafe
    : 'unsafe'
    ;

constructor_modifier_unsafe
    : 'unsafe'
    ;

destructor_declaration_unsafe
    : attributes? 'extern'? 'unsafe'? '~' identifier '(' ')' destructor_body
    | attributes? 'unsafe'? 'extern'? '~' identifier '(' ')' destructor_body
    ;

static_constructor_modifiers_unsafe
    : 'extern'? 'unsafe'? 'static'
    | 'unsafe'? 'extern'? 'static'
    | 'extern'? 'static' 'unsafe'?
    | 'unsafe'? 'static' 'extern'?
    | 'static' 'extern'? 'unsafe'?
    | 'static' 'unsafe'? 'extern'?
    ;

embedded_statement_unsafe
    : unsafe_statement
    | fixed_statement
    ;

unsafe_statement
    : 'unsafe' block
    ;
```

В примере

```csharp
public unsafe struct Node
{
    public int Value;
    public Node* Left;
    public Node* Right;
}
```

`unsafe` модификатор, указанный в объявлении структуры вызывает все текстовое пространство объявления структуры небезопасным контекстом. Таким образом, можно объявить `Left` и `Right` поля с типом указателя. Приведенный выше пример можно переписать

```csharp
public struct Node
{
    public int Value;
    public unsafe Node* Left;
    public unsafe Node* Right;
}
```

Здесь `unsafe` модификаторы в объявлениях полей делают эти объявления небезопасными контекстами.

Кроме установки небезопасный контекст, дающего возможность использования типов указателей, `unsafe` модификатор не оказывает влияния на тип или член. В примере

```csharp
public class A
{
    public unsafe virtual void F() {
        char* p;
        ...
    }
}

public class B: A
{
    public override void F() {
        base.F();
        ...
    }
}
```

`unsafe` модификатор `F` метод в `A` просто вызывает текстовое пространство `F` к небезопасным контекстом, в котором можно использовать небезопасные возможности языка. В переопределении `F` в `B`, нет необходимости повторно определить `unsafe` модификатор--Если, конечно, `F` метод в `B` сам должен иметь доступ к небезопасных функций.

Ситуация немного отличается, если тип указателя является частью сигнатуры метода

```csharp
public unsafe class A
{
    public virtual void F(char* p) {...}
}

public class B: A
{
    public unsafe override void F(char* p) {...}
}
```

Здесь так как `F`его сигнатура включает тип указателя, он может быть записано только в небезопасном контексте. Тем не менее, могут быть введены небезопасного контекста либо сделав весь класс unsafe, как в случае `A`, или путем включения `unsafe` модификатор в объявлении метода, как в случае `B`.

## <a name="pointer-types"></a>типы указателей;

В небезопасном контексте *тип* ([типы](types.md)) может быть *"тип указателя"* , а также *value_type* или *reference_type* . Тем не менее *"тип указателя"* также может использоваться в `typeof` выражение ([выражения создания анонимных объектов](expressions.md#anonymous-object-creation-expressions)) за пределами небезопасного контекста таким образом использование не является небезопасным.

```antlr
type_unsafe
    : pointer_type
    ;
```

Объект *"тип указателя"* записывается как *unmanaged_type* или ключевое слово `void`, за которым следует `*` маркера:

```antlr
pointer_type
    : unmanaged_type '*'
    | 'void' '*'
    ;

unmanaged_type
    : type
    ;
```

Тип, указанный до `*` в указатель типа называется ***тип референта*** типа указателя. Он представляет тип переменной, на который указывает значение типа указателя.

В отличие от ссылок (значений ссылочных типов) указатели не отслеживаются сборщиком мусора — сборщик мусора не имеет сведений о указатели и данных, на которые они указывают. Для этой причине указателем не разрешается указывать на ссылку или на структуру, содержащую ссылки, а тип референта указателя должен быть *unmanaged_type*.

*Unmanaged_type* является любым типом, не *reference_type* сконструированный тип и не содержит *reference_type* или сконструированный тип поля на любом уровне вложение. Другими словами *unmanaged_type* является одним из следующих:

*  `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal`, или `bool`.
*  Любой *enum_type*.
*  Любой *"тип указателя"*.
*  Любые пользовательские *struct_type* , не являющийся сконструированный тип и содержит поля *unmanaged_type*только s.

Интуитивно понятный для сочетания указателей и ссылок на правила — что референты ссылок (объекты) могут содержать указатели, но референты указателей не могут содержать ссылки.

В следующей таблице приведены некоторые примеры типов указателей:

| __Пример__ | __Описание__                               |
|-------------|-----------------------------------------------|
| `byte*`     | указатель на `byte`                             |
| `char*`     | указатель на `char`                             |
| `int**`     | Указатель на указатель на `int`                   |
| `int*[]`    | Одномерный массив указателей на `int` |
| `void*`     | Указатель на неизвестный тип                       |

В данной реализации все типы указателя должны иметь одинаковый размер и представление.

В отличие от C и C++, при объявлении нескольких указателей в одном объявлении, в C# `*` записывается вместе с базовым типом, не как префиксный знак пунктуации с каждым именем указателя. Пример

```csharp
int* pi, pj;    // NOT as int *pi, *pj;
```

Значение указателя, тип которых `T*` представляет собой адрес переменной типа `T`. Оператор косвенного обращения указателя `*` ([косвенного обращения указателя](unsafe-code.md#pointer-indirection)) может использоваться для доступа к этой переменной. Например, если переменная `P` типа `int*`, выражение `*P` обозначает `int` переменная найдена по адресу, содержащемуся в `P`.

Как и ссылку на объект, указатель может быть `null`. Косвенное обращение к `null` указатель приводит к поведению, определяемого реализацией. Указатель со значением `null` представленного все биты нулями.

`void*` Тип представляет указатель на неизвестный тип. Поскольку тип референта неизвестен, оператор косвенного обращения не может использоваться для указателя типа `void*`, и не может быть выполнена никакие вычисления на такой указатель. Однако указатель типа `void*` может быть приведен к любому другому типу указателя (и наоборот).

Типы указателей являются отдельной категорией типов. В отличие от ссылочных типов и типов значений, типы указателей не наследуют от `object` , не существует преобразований между типами указателей и `object`. В частности, упаковка-преобразование и распаковка-преобразование ([упаковка-преобразование и распаковка-преобразование](types.md#boxing-and-unboxing)) не поддерживаются для указателей. Однако преобразования могут быть между различными типами указателей и типы указателей и целочисленными типами. Это описывается в [преобразования указателей](unsafe-code.md#pointer-conversions).

Объект *"тип указателя"* нельзя использовать в качестве аргумента типа ([создан типы](types.md#constructed-types)) и определения типов ([вывод типа](expressions.md#type-inference)) происходит сбой при вызове универсального метода, будет выведен Аргумент должен иметь тип указателя типа.

Объект *"тип указателя"* может использоваться в качестве типа поле с модификатором volatile ([изменяемые поля](classes.md#volatile-fields)).

Несмотря на то, что указатели могут передаваться как `ref` или `out` параметры, это может привести к неопределенному поведению, так как указатель может также устанавливаться на локальную переменную, которой больше не существует, при возврате вызываемый метод или основного объекта, на которое он Указывает, больше не является фиксированным. Пример:

```csharp
using System;

class Test
{
    static int value = 20;

    unsafe static void F(out int* pi1, ref int* pi2) {
        int i = 10;
        pi1 = &i;

        fixed (int* pj = &value) {
            // ...
            pi2 = pj;
        }
    }

    static void Main() {
        int i = 10;
        unsafe {
            int* px1;
            int* px2 = &i;

            F(out px1, ref px2);

            Console.WriteLine("*px1 = {0}, *px2 = {1}",
                *px1, *px2);    // undefined behavior
        }
    }
}
```

Метод может возвращать значение некоторого типа, и этот тип может быть указателем. Например, когда получает указатель на непрерывная последовательность из `int`s, количество элементов в этой последовательности и некоторые другие `int` значение, следующий метод возвращает адрес этого значения в этой последовательности, если они совпадают; в противном случае возвращается `null`:

```csharp
unsafe static int* Find(int* pi, int size, int value) {
    for (int i = 0; i < size; ++i) {
        if (*pi == value) 
            return pi;
        ++pi;
    }
    return null;
}
```

В небезопасном контексте для операций с указателями имеется несколько конструкций:

*  `*` Оператор можно использовать для выполнения косвенного обращения указателя ([косвенного обращения указателя](unsafe-code.md#pointer-indirection)).
*  `->` Оператор может использоваться для доступа к члену структуры через указатель ([доступа к членам указателей](unsafe-code.md#pointer-member-access)).
*  `[]` Оператор может использоваться для индексации указатель ([доступ к элементу указателя](unsafe-code.md#pointer-element-access)).
*  `&` Оператор может использоваться для получения адреса переменной ([оператор address-of](unsafe-code.md#the-address-of-operator)).
*  `++` И `--` операторы могут использоваться для увеличения и уменьшения указателей ([указатель инкремента и декремента](unsafe-code.md#pointer-increment-and-decrement)).
*  `+` И `-` операторы могут использоваться для выполнения арифметических операций над указателями ([указателями](unsafe-code.md#pointer-arithmetic)).
*  `==`, `!=`, `<`, `>`, `<=`, И `=>` операторы могут использоваться для сравнения указателей ([Сравнение указателей](unsafe-code.md#pointer-comparison)).
*  `stackalloc` Оператор можно использовать для выделения памяти из стека вызовов ([буферы фиксированного размера](unsafe-code.md#fixed-size-buffers)).
*  `fixed` Инструкция может использоваться, чтобы временно зафиксировать переменную, поэтому можно получить его адрес ([оператор fixed](unsafe-code.md#the-fixed-statement)).

## <a name="fixed-and-moveable-variables"></a>Фиксированные и перемещаемые переменные

Оператор address-of ([оператор address-of](unsafe-code.md#the-address-of-operator)) и `fixed` инструкции ([оператор fixed](unsafe-code.md#the-fixed-statement)) разделить переменные на две категории: ***Предопределенных переменных*** и ***перемещаемые переменные***.

Фиксированные переменные находятся в местах хранения, не влияет на операции сборщика мусора. (Фиксированные переменные примеры локальные переменные, значения параметров и переменных, созданных с разыменования указателей.) С другой стороны перемещаемые переменные находятся в местах хранения, которые могут быть перемещены или удалены сборщиком мусора. (Примерами перемещаемые переменные являются поля в объекты и элементы массивов).

`&` Оператор ([оператор address-of](unsafe-code.md#the-address-of-operator)) разрешает адрес фиксированная переменная может быть получена без ограничений. Тем не менее, поскольку перемещаемой переменной может быть перемещена или удалена сборщиком мусора, адрес перемещаемой переменной может быть получен только с помощью `fixed` инструкции ([оператор fixed](unsafe-code.md#the-fixed-statement)) и этот адрес действителен только в течение этого `fixed` инструкции.

Точнее говоря фиксированная переменная является одним из следующих:

*  Переменной полученный в результате *simple_name* ([простые имена](expressions.md#simple-names)), ссылающийся на локальную переменную или параметр по значению, если переменная перехватывается анонимной функции.
*  Переменной полученный в результате *member_access* ([доступ к членам](expressions.md#member-access)) формы `V.I`, где `V` предопределенной переменная *struct_type*.
*  Переменной полученный в результате *pointer_indirection_expression* ([косвенного обращения указателя](unsafe-code.md#pointer-indirection)) формы `*P`, *pointer_member_access* ([Доступа к членам указателей](unsafe-code.md#pointer-member-access)) формы `P->I`, или *pointer_element_access* ([доступ к элементу указателя](unsafe-code.md#pointer-element-access)) формы `P[E]`.

Все остальные переменные классифицируются как перемещаемые переменные.

Обратите внимание на то, что статическое поле классифицируется как перемещаемой переменной. Также Обратите внимание, что `ref` или `out` параметр классифицируется как перемещаемой переменной, даже если аргумент, заданный в параметре фиксированная переменная. Наконец Обратите внимание на то, что переменная, созданная с разыменования указателя всегда классифицируется как фиксированная переменная.

## <a name="pointer-conversions"></a>Преобразования указателей

В небезопасном контексте, набор доступных неявных преобразований ([неявные преобразования](conversions.md#implicit-conversions)) расширена для включения следующих неявные преобразования указателей:

*  Из любого *"тип указателя"* к типу `void*`.
*  Из `null` литерала к любому *"тип указателя"*.

Кроме того, в небезопасном контексте, набор доступных явные преобразования ([явные преобразования](conversions.md#explicit-conversions)) расширена для включения следующих явные преобразования указателей:

*  Из любого *"тип указателя"* любым другим *"тип указателя"*.
*  Из `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, или `ulong` к любому *"тип указателя"*.
*  Из любого *"тип указателя"* для `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, или `ulong`.

Наконец, в небезопасном контексте набор стандартных неявных преобразований ([стандартные неявные преобразования](conversions.md#standard-implicit-conversions)) включает в себя следующие преобразования указателей:

*  Из любого *"тип указателя"* к типу `void*`.

Преобразования между двумя типами указателей никогда не изменяют фактическое значение указателя. Другими словами это преобразование из типа одного указателя в другой не влияет на базовый адрес, выделенный указатель.

Если один тип указателя преобразуется в другой, если полученный в результате указатель не выровнено для типа, который указывает, поведение не определено, если результат при разыменовывании. Как правило, понятие «правильно» является транзитивным: если указатель на тип `A` выровнен для указателя на тип `B`, который, в свою очередь, выровнен для указателя на тип `C`, затем указатель на тип `A`выровнен для указателя на тип `C`.

Рассмотрим следующий случай, в котором переменная одного типа осуществляется через указатель на другой тип:

```csharp
char c = 'A';
char* pc = &c;
void* pv = pc;
int* pi = (int*)pv;
int i = *pi;         // undefined
*pi = 123456;        // undefined
```

Если тип указателя преобразуется указатель байт, результат указывает на наименьший адресуемый байт переменной. Последовательными приращениями этого результата до размера переменной, дают указатели оставшиеся байты переменной. Например следующий метод отображает каждый из восьми байтов в значение типа double как шестнадцатеричное значение:

```csharp
using System;

class Test
{
    unsafe static void Main() {
      double d = 123.456e23;
        unsafe {
           byte* pb = (byte*)&d;
            for (int i = 0; i < sizeof(double); ++i)
               Console.Write("{0:X2} ", *pb++);
            Console.WriteLine();
        }
    }
}
```

Само собой выходные данные зависит от порядка следования байтов.

Сопоставления между указателями и целых чисел, определяемого реализацией. Однако на 32 * и 64-разрядных архитектур ЦП с линейного адресного пространства, преобразование указателей или из целочисленных типов обычно ведут себя так же, как преобразования `uint` или `ulong` значения, соответственно, или из этих целочисленных типов.

### <a name="pointer-arrays"></a>Массивы указателей

В небезопасном контексте могут создаваться массивы указателей. Только некоторые преобразования, которые применяются к другим типам массива можно использовать в массивах указателей:

*  Неявное преобразование ссылок ([неявные преобразования ссылочных типов](conversions.md#implicit-reference-conversions)) из любого *array_type* для `System.Array` и интерфейсов, реализуемых им также относятся к массивам указатель. Тем не менее, любая попытка доступа к элементам массива через `System.Array` или он реализует интерфейсы приведет к возникновению исключения во время выполнения, как типы указателей не преобразовываются `object`.
*  Явное и неявное преобразование ссылочных типов ([неявные преобразования ссылочных типов](conversions.md#implicit-reference-conversions), [явные преобразования ссылочных типов](conversions.md#explicit-reference-conversions)) из типа одномерного массива `S[]` для `System.Collections.Generic.IList<T>` и его универсальных базовых интерфейсов никогда не применяются к массивам указателей, поскольку типы указателей не может использоваться в качестве аргументов типа, а не поддерживается преобразование из типов указателей в типы, не являющихся указателями.
*  Преобразование явной ссылки ([явные преобразования ссылочных типов](conversions.md#explicit-reference-conversions)) из `System.Array` и интерфейсы, который реализуется, чтобы любой *array_type* относятся к массивам указатель.
*  Явных преобразований ([явные преобразования ссылочных типов](conversions.md#explicit-reference-conversions)) из `System.Collections.Generic.IList<S>` и его базовых интерфейсов в тип одномерного массива `T[]` никогда не применяется к массивам указателей, поскольку типы указателей не может быть использовать как аргументы типа и не поддерживается преобразование из типов указателей в типы, не являющихся указателями.

Эти ограничения означают, что расширение для `foreach` описано в разделе инструкции, обрабатывающие массивы [оператор foreach](statements.md#the-foreach-statement) не может применяться к массивам указателей. Вместо этого оператор foreach в форме

```csharp
foreach (V v in x) embedded_statement
```

где тип `x` является типом массива формы `T[,,...,]`, `N` является размерность за вычетом 1 и `T` или `V` является типом указателя, развернут с помощью вложенных циклов for, следующим образом:

```csharp
{
    T[,,...,] a = x;
    for (int i0 = a.GetLowerBound(0); i0 <= a.GetUpperBound(0); i0++)
    for (int i1 = a.GetLowerBound(1); i1 <= a.GetUpperBound(1); i1++)
    ...
    for (int iN = a.GetLowerBound(N); iN <= a.GetUpperBound(N); iN++) {
        V v = (V)a.GetValue(i0,i1,...,iN);
        embedded_statement
    }
}
```

Переменные `a`, `i0`, `i1`,..., `iN` не видно, но доступной для `x` или *embedded_statement* или любой другой исходный код программы. Переменная `v` только для чтения в внедренный оператор. Если не существует явное преобразование ([преобразования указателей](unsafe-code.md#pointer-conversions)) из `T` (тип элемента) для `V`, выдается ошибка и никакие дальнейшие действия не предпринимаются. Если `x` имеет значение `null`, `System.NullReferenceException` возникает исключение во время выполнения.

## <a name="pointers-in-expressions"></a>Указатели в выражениях

В небезопасном контексте выражение может давать результат типа указателя, но за пределами небезопасного контекста является ошибкой во время компиляции, чтобы выражение имело тип указателя. Точнее говоря, за пределами небезопасного контекста ошибка времени компиляции возникает, если любой *simple_name* ([простые имена](expressions.md#simple-names)), *member_access* ([доступ к членам ](expressions.md#member-access)), *invocation_expression* ([выражения вызова](expressions.md#invocation-expressions)), или *element_access* ([доступ к элементам](expressions.md#element-access)) является типом указателя.

В небезопасном контексте *primary_no_array_creation_expression* ([основные выражения](expressions.md#primary-expressions)) и *unary_expression* ([унарные операторы](expressions.md#unary-operators)) производства разрешить следующие дополнительные конструкции.

```antlr
primary_no_array_creation_expression_unsafe
    : pointer_member_access
    | pointer_element_access
    | sizeof_expression
    ;

unary_expression_unsafe
    : pointer_indirection_expression
    | addressof_expression
    ;
```

В следующих разделах описываются эти конструкции. Приоритет и ассоциативность операторов небезопасный подразумевается грамматикой.

### <a name="pointer-indirection"></a>Косвенное обращение по указателю

Объект *pointer_indirection_expression* состоит в виде звездочки (`*`) следуют *unary_expression*.

```antlr
pointer_indirection_expression
    : '*' unary_expression
    ;
```

Унарный `*` оператор обозначает косвенного обращения указателя и используется для получения переменной, на который указывает указатель. Результат вычисления `*P`, где `P` — это выражение типа указателя `T*`, является переменной типа `T`. Произошла ошибка во время компиляции, чтобы применить унарный `*` оператор для выражения типа `void*` или выражение, не типа указателя.

В результате применения унарного `*` оператор `null` указатель определяется реализацией. В частности, нет никакой гарантии, что эта операция создает исключение `System.NullReferenceException`.

Если недопустимое значение был назначен указателем, поведение унарный `*` оператор не определен. Среди недопустимых значений для разыменования указателя, унарный `*` имеют выровненный адрес указываемого для типа (см. пример в [преобразования указателей](unsafe-code.md#pointer-conversions)) и адрес переменной после окончания срока действия.

В целях анализа определенного присваивания переменной, полученным путем вычисления выражения формы `*P` считается начальным значением ([изначально назначается переменные](variables.md#initially-assigned-variables)).

### <a name="pointer-member-access"></a>Доступа к членам указателей

Объект *pointer_member_access* состоит из *primary_expression*, за которым следует "`->`" токена, за которым следует *идентификатор* и необязательно *type_argument_list*.

```antlr
pointer_member_access
    : primary_expression '->' identifier
    ;
```

В доступа к членам указателей формы `P->I`, `P` должно быть выражением типа указателя, отличное от `void*`, и `I` необходимо обозначить доступного члена типа, к которому `P` точек.

Доступа к членам указателей формы `P->I` вычисляется точно так, как `(*P).I`. Описание оператора косвенного обращения указателя (`*`), см. в разделе [косвенного обращения указателя](unsafe-code.md#pointer-indirection). Описание оператора доступа члена (`.`), см. в разделе [доступ к членам](expressions.md#member-access).

В примере

```csharp
using System;

struct Point
{
    public int x;
    public int y;

    public override string ToString() {
        return "(" + x + "," + y + ")";
    }
}

class Test
{
    static void Main() {
        Point point;
        unsafe {
            Point* p = &point;
            p->x = 10;
            p->y = 20;
            Console.WriteLine(p->ToString());
        }
    }
}
```

`->` оператор используется для доступа к полям и вызвать метод структуры через указатель. Так как операция `P->I` является точным эквивалентом `(*P).I`, `Main` метод можно было записать так:

```csharp
class Test
{
    static void Main() {
        Point point;
        unsafe {
            Point* p = &point;
            (*p).x = 10;
            (*p).y = 20;
            Console.WriteLine((*p).ToString());
        }
    }
}
```

### <a name="pointer-element-access"></a>Доступ к элементу указателя

Объект *pointer_element_access* состоит из *primary_no_array_creation_expression* следуют выражение, заключенное в "`[`«и»`]`«.

```antlr
pointer_element_access
    : primary_no_array_creation_expression '[' expression ']'
    ;
```

В доступе к элементу указателя формы `P[E]`, `P` должно быть выражением типа указателя, отличное от `void*`, и `E` должно быть выражением, которое может быть неявно преобразован в `int`, `uint`, `long`, или `ulong`.

Доступ к элементу указателя формы `P[E]` вычисляется точно так, как `*(P + E)`. Описание оператора косвенного обращения указателя (`*`), см. в разделе [косвенного обращения указателя](unsafe-code.md#pointer-indirection). Описание оператора сложения указатель (`+`), см. в разделе [указателями](unsafe-code.md#pointer-arithmetic).

В примере

```csharp
class Test
{
    static void Main() {
        unsafe {
            char* p = stackalloc char[256];
            for (int i = 0; i < 256; i++) p[i] = (char)i;
        }
    }
}
```

доступ к элементу указателя используется для инициализации символьного буфера в `for` цикла. Так как операция `P[E]` является точным эквивалентом `*(P + E)`, пример можно было записать так:

```csharp
class Test
{
    static void Main() {
        unsafe {
            char* p = stackalloc char[256];
            for (int i = 0; i < 256; i++) *(p + i) = (char)i;
        }
    }
}
```

Оператор доступа к элементу указателя не проверяет, выходящие за пределы области ошибки и поведение при доступе к элементу вне границ является неопределенным. Это так же, как C и C++.

### <a name="the-address-of-operator"></a>Оператор address-of

*Addressof_expression* состоит из амперсанда (`&`) следуют *unary_expression*.

```antlr
addressof_expression
    : '&' unary_expression
    ;
```

Если выражение `E` которого имеет тип `T` и классифицируется как фиксированная переменная ([атрибутов неизменности и перемещаемые переменные](unsafe-code.md#fixed-and-moveable-variables)), конструкция `&E` вычисляет адрес переменной, заданной по `E`. Тип результата — `T*` и классифицируется как значение. Ошибка времени компиляции возникает, если `E` не классифицируется как переменная, если `E` классифицируется как только для чтения локальной переменной, или если `E` обозначает перемещаемую переменную. В последнем случае оператор fixed ([оператор fixed](unsafe-code.md#the-fixed-statement)) может использоваться для временно «зафиксировать» переменную перед получением ее адреса. Как уже говорилось в [доступ к членам](expressions.md#member-access), за пределами конструкторе экземпляра или статический конструктор для структуры или класса, определяющего `readonly` поле, это поле считается значение, а не переменной. Таким образом его адрес не может быть выполнено. Аналогичным образом нельзя получить адрес константы.

`&` Оператор не требует аргумента определенно присвоенной, но следующие `&` операции, переменной, к которому применяется оператор считается определенно присвоенной, в ходе выполнения, в которой выполняется операция. Это отвечает программист должен убедиться, чтобы правильная инициализация переменной выполняются на самом деле в этой ситуации.

В примере

```csharp
using System;

class Test
{
    static void Main() {
        int i;
        unsafe {
            int* p = &i;
            *p = 123;
        }
        Console.WriteLine(i);
    }
}
```

`i` считается определенно присвоенной следуя `&i` операции, используемой для инициализации `p`. Назначение `*p` фактически инициализирует `i`, включение этой инициализации является обязанностью программиста, но ошибка во время компиляции не произойдет в том случае, если назначением был удален.

Правила определенного присваивания для `&` существует оператор таким образом, что можно избежать избыточной инициализации локальных переменных. Например многие внешние API принимают указатель на структуру, в которой содержатся API-интерфейсом. Вызовы таких интерфейсов API обычно передается адрес структуры локальной переменной и без этого правила избыточная инициализация переменной структуры не требуются.

### <a name="pointer-increment-and-decrement"></a>Увеличение и уменьшение указателя

В небезопасном контексте `++` и `--` операторы ([постфиксных инкремента и декремента](expressions.md#postfix-increment-and-decrement-operators) и [префиксный инкремент и декремент операторы](expressions.md#prefix-increment-and-decrement-operators)) могут применяться к указателю переменные для всех типов, за исключением `void*`. Таким образом, для каждого типа указателя `T*`, неявно определены следующие операторы:

```csharp
T* operator ++(T* x);
T* operator --(T* x);
```

Эти операторы дают те же результаты, что `x + 1` и `x - 1`соответственно ([указателями](unsafe-code.md#pointer-arithmetic)). Другими словами, для переменной указателя типа `T*`, `++` добавляет оператор `sizeof(T)` к адресу, содержащемуся в переменной и `--` оператор вычитает `sizeof(T)` из адреса, содержащегося в переменной.

Если указатель инкремента или декремента операция переполняет домен типа указателя, результат определяется реализацией, но исключения не создаются.

### <a name="pointer-arithmetic"></a>Расчеты с указателями

В небезопасном контексте `+` и `-` операторы ([оператор сложения](expressions.md#addition-operator) и [оператор вычитания](expressions.md#subtraction-operator)) могут применяться к значениям всех типов указателей, за исключением `void*`. Таким образом, для каждого типа указателя `T*`, неявно определены следующие операторы:

```csharp
T* operator +(T* x, int y);
T* operator +(T* x, uint y);
T* operator +(T* x, long y);
T* operator +(T* x, ulong y);

T* operator +(int x, T* y);
T* operator +(uint x, T* y);
T* operator +(long x, T* y);
T* operator +(ulong x, T* y);

T* operator -(T* x, int y);
T* operator -(T* x, uint y);
T* operator -(T* x, long y);
T* operator -(T* x, ulong y);

long operator -(T* x, T* y);
```

Если выражение `P` типа указателя `T*` и выражение `N` типа `int`, `uint`, `long`, или `ulong`, выражения `P + N` и `N + P` вычислений значение указателя типа `T*` , полученный добавлением `N * sizeof(T)` по адресу `P`. Аналогичным образом, выражение `P - N` вычисляет значение указателя типа `T*` , полученный в результате вычитания `N * sizeof(T)` из адреса, заданного выражением `P`.

Если даны два выражения `P` и `Q`, типа указателя `T*`, выражение `P - Q` вычисляет разницу между адресами, заданными `P` и `Q` и затем делитэтойразницы`sizeof(T)`. Тип результата — всегда `long`. По сути `P - Q` вычисляется как `((long)(P) - (long)(Q)) / sizeof(T)`.

Пример:

```csharp
using System;

class Test
{
    static void Main() {
        unsafe {
            int* values = stackalloc int[20];
            int* p = &values[1];
            int* q = &values[15];
            Console.WriteLine("p - q = {0}", p - q);
            Console.WriteLine("q - p = {0}", q - p);
        }
    }
}
```

в результате получается:

```
p - q = -14
q - p = 14
```

Если указатель арифметическая операция переполняет домен типа указателя, результат усекается в виде реализации, но исключения не создаются.

### <a name="pointer-comparison"></a>Сравнение указателей

В небезопасном контексте `==`, `!=`, `<`, `>`, `<=`, и `=>` операторы ([отношения и операторы тестирования типа](expressions.md#relational-and-type-testing-operators)) могут применяться к значениям всех типы указателей. Ниже перечислены операторы сравнения указатель.

```csharp
bool operator ==(void* x, void* y);
bool operator !=(void* x, void* y);
bool operator <(void* x, void* y);
bool operator >(void* x, void* y);
bool operator <=(void* x, void* y);
bool operator >=(void* x, void* y);
```

Поскольку существует неявное преобразование из любой тип указателя на `void*` тип операнда любого типа указателя можно сравнивать с помощью этих операторов. Операторы сравнения сравнивают адреса, заданные двух операндов, как если бы они были целых чисел без знака.

### <a name="the-sizeof-operator"></a>Оператор sizeof

`sizeof` Оператор возвращает число байтов, занимаемых переменной заданного типа. Тип, указанный в качестве операнда для `sizeof` должно быть *unmanaged_type* ([типы указателей](unsafe-code.md#pointer-types)).

```antlr
sizeof_expression
    : 'sizeof' '(' unmanaged_type ')'
    ;
```

Результат `sizeof` оператор является значение типа `int`. Для некоторых предопределенных типов `sizeof` оператор возвращает значение константы, как показано в следующей таблице.


| __Выражение__   | __Результат__ |
|------------------|------------|
| `sizeof(sbyte)`  | `1`        |
| `sizeof(byte)`   | `1`        |
| `sizeof(short)`  | `2`        |
| `sizeof(ushort)` | `2`        |
| `sizeof(int)`    | `4`        |
| `sizeof(uint)`   | `4`        |
| `sizeof(long)`   | `8`        |
| `sizeof(ulong)`  | `8`        |
| `sizeof(char)`   | `2`        |
| `sizeof(float)`  | `4`        |
| `sizeof(double)` | `8`        |
| `sizeof(bool)`   | `1`        |

Для всех других типов, результат `sizeof` оператор определяется реализацией и классифицируется как значение, а не как константа.

Порядок, в котором членов в структуры не задан.

Для целей выравнивания могут существовать безымянные заполнения в начале структуры, в рамках структуры и в конце структуры. Значения битов, используемых в качестве заполнителя, не определено.

При применении к операнду, имеющему тип структуры, результат — общее количество байтов в переменной этого типа, включая заполнения.

## <a name="the-fixed-statement"></a>Оператор fixed

В небезопасном контексте *embedded_statement* ([инструкций](statements.md)) рабочей среде позволяет порождение `fixed` инструкцию, которая используется для «починки» перемещаемой таким образом, чтобы его адрес остается неизменным в течение инструкции.

```antlr
fixed_statement
    : 'fixed' '(' pointer_type fixed_pointer_declarators ')' embedded_statement
    ;

fixed_pointer_declarators
    : fixed_pointer_declarator (','  fixed_pointer_declarator)*
    ;

fixed_pointer_declarator
    : identifier '=' fixed_pointer_initializer
    ;

fixed_pointer_initializer
    : '&' variable_reference
    | expression
    ;
```

Каждый *fixed_pointer_declarator* объявляет локальную переменную с заданной *"тип указателя"* и инициализирует эту локальную переменную с адресом, вычисленные поиском решения для соответствующего *fixed_ pointer_initializer*. Локальная переменная, объявленная в `fixed` инструкция доступна в любом *fixed_pointer_initializer*s, находящемся справа объявления этой переменной, а в *embedded_statement* из `fixed` инструкции. Локальная переменная, объявленная с `fixed` оператор считается только для чтения. Ошибка времени компиляции возникает, если внедренный оператор пытается изменить эту локальную переменную (с помощью присваивания или `++` и `--` операторы) или передать в качестве `ref` или `out` параметра.

Объект *fixed_pointer_initializer* может принимать одно из следующих:

*  Токен "`&`" следуют *variable_reference* ([точные правила для выявления определенного присваивания](variables.md#precise-rules-for-determining-definite-assignment)) для перемещаемой переменной ([атрибутов неизменности и перемещаемые переменные](unsafe-code.md#fixed-and-moveable-variables)) неуправляемого типа `T`, предоставленный тип `T*` неявно преобразуется к типу указателя, заданному в `fixed` инструкции. В этом случае инициализатор вычисляет адрес заданной переменной и переменной гарантированно остается по фиксированному адресу в течение `fixed` инструкции.
*  Выражение *array_type* с элементами неуправляемого типа `T`, предоставленный тип `T*` неявно преобразуется к типу указателя, заданному в `fixed` инструкции. В этом случае инициализатор вычисляет адрес первого элемента в массиве, и весь массив гарантированно остается по фиксированному адресу в течение `fixed` инструкции. Если выражение массива имеет значение null или массив не содержит элементов, инициализатор вычисляет адрес, равным нулю.
*  Выражение типа `string`, предоставленный тип `char*` неявно преобразуется к типу указателя, заданному в `fixed` инструкции. В этом случае инициализатор вычисляет адрес первого символа в строке, и вся строка гарантированно остается по фиксированному адресу в течение `fixed` инструкции. Поведение `fixed` инструкции определяется реализацией, если строковое выражение имеет значение null.
*  Объект *simple_name* или *member_access* , ссылается на элемент буфера фиксированного размера, перемещаемой переменной, указанный тип элемента буфера фиксированного размера не может быть неявно преобразован к типу указателя, заданному в `fixed` инструкции. В этом случае инициализатор вычисляет указатель на первый элемент буфера фиксированного размера ([буферы фиксированного размера в выражениях](unsafe-code.md#fixed-size-buffers-in-expressions)), и буфер фиксированного размера гарантированно остается по фиксированному адресу в течение `fixed`инструкции.

Для каждого адреса, вычисленные поиском решения *fixed_pointer_initializer* `fixed` оператор гарантирует, что переменная ссылается на адрес не быть перемещены или удалены сборщиком мусора до конца `fixed` инструкции. Например, если адрес вычисляется по *fixed_pointer_initializer* ссылается на поле объекта или элемента экземпляра массива, `fixed` инструкции гарантирует, что содержащий экземпляр объекта не перемещаются или удален в течение времени существования инструкции.

Это программист должен убедиться, что указатели, созданных `fixed` инструкций не доживают Помимо выполнения этих операторов. Например, если указатели созданные `fixed` инструкции передаются внешних интерфейсов API, что программист должен убедиться, что API-интерфейсы сохранить недостаточно памяти эти указатели.

Объекты основного может привести к фрагментации кучи (так как их нельзя перемещать). По этой причине объекты должны быть исправлены только при необходимости и только после этого минимальный интервал времени.

Пример

```csharp
class Test
{
    static int x;
    int y;

    unsafe static void F(int* p) {
        *p = 1;
    }

    static void Main() {
        Test t = new Test();
        int[] a = new int[10];
        unsafe {
            fixed (int* p = &x) F(p);
            fixed (int* p = &t.y) F(p);
            fixed (int* p = &a[0]) F(p);
            fixed (int* p = a) F(p);
        }
    }
}
```

Демонстрирует несколько раз используется `fixed` инструкции. Первый оператор исправления и получает адрес статического поля, вторая инструкция исправления ошибок и получает адрес поля экземпляра и третья инструкция исправления и извлекает адрес элемента массива. В каждом случае было бы использовать обычные `&` оператор, так как переменные классифицируются как перемещаемые переменные.

Четвертый `fixed` инструкцию в приведенном выше примере дает тот же результат, третьей.

Этот пример `fixed` использует инструкцию `string`:

```csharp
class Test
{
    static string name = "xx";

    unsafe static void F(char* p) {
        for (int i = 0; p[i] != '\0'; ++i)
            Console.WriteLine(p[i]);
    }

    static void Main() {
        unsafe {
            fixed (char* p = name) F(p);
            fixed (char* p = "xx") F(p);
        }
    }
}
```

В небезопасном контексте элементов одномерные массивы хранятся в порядке возрастания индекса, начиная с индекса `0` и заканчивая индексом `Length - 1`. Для многомерных массивов, массив, элементы хранятся таким образом, во-первых, увеличиваются индексы самого правого измерения затем следующего слева измерения, и т. д слева. В рамках `fixed` инструкции, которая получает указатель `p` на экземпляр массива `a`, значения указателя в диапазоне от `p` для `p + a.Length - 1` представляют адреса элементов в массиве. Аналогично, переменные в диапазоне от `p[0]` для `p[a.Length - 1]` представляют фактические элементы массива. Учитывая способом, в которой хранятся массивы, мы можно обращаться с массивом любого измерения как если бы оно было линейной.

Пример:

```csharp
using System;

class Test
{
    static void Main() {
        int[,,] a = new int[2,3,4];
        unsafe {
            fixed (int* p = a) {
                for (int i = 0; i < a.Length; ++i)    // treat as linear
                    p[i] = i;
            }
        }

        for (int i = 0; i < 2; ++i)
            for (int j = 0; j < 3; ++j) {
                for (int k = 0; k < 4; ++k)
                    Console.Write("[{0},{1},{2}] = {3,2} ", i, j, k, a[i,j,k]);
                Console.WriteLine();
            }
    }
}
```

в результате получается:

```
[0,0,0] =  0 [0,0,1] =  1 [0,0,2] =  2 [0,0,3] =  3
[0,1,0] =  4 [0,1,1] =  5 [0,1,2] =  6 [0,1,3] =  7
[0,2,0] =  8 [0,2,1] =  9 [0,2,2] = 10 [0,2,3] = 11
[1,0,0] = 12 [1,0,1] = 13 [1,0,2] = 14 [1,0,3] = 15
[1,1,0] = 16 [1,1,1] = 17 [1,1,2] = 18 [1,1,3] = 19
[1,2,0] = 20 [1,2,1] = 21 [1,2,2] = 22 [1,2,3] = 23
```

В примере

```csharp
class Test
{
    unsafe static void Fill(int* p, int count, int value) {
        for (; count != 0; count--) *p++ = value;
    }

    static void Main() {
        int[] a = new int[100];
        unsafe {
            fixed (int* p = a) Fill(p, 100, -1);
        }
    }
}
```

`fixed` можно исправить массива, чтобы его адрес может передаваться методу, который принимает указатель инструкции.

В данном примере:

```csharp
unsafe struct Font
{
    public int size;
    public fixed char name[32];
}

class Test
{
    unsafe static void PutString(string s, char* buffer, int bufSize) {
        int len = s.Length;
        if (len > bufSize) len = bufSize;
        for (int i = 0; i < len; i++) buffer[i] = s[i];
        for (int i = len; i < bufSize; i++) buffer[i] = (char)0;
    }

    Font f;

    unsafe static void Main()
    {
        Test test = new Test();
        test.f.size = 10;
        fixed (char* p = test.f.name) {
            PutString("Times New Roman", p, 32);
        }
    }
}
```

оператор fixed позволяет исправить буфер фиксированного размера структуры, чтобы его адрес может использоваться как указатель.

Объект `char*` значение, созданное фиксацией экземпляра строки, всегда указывает на строку, завершающуюся символом null. В операторе fixed, которая получает указатель `p` экземпляр строки `s`, значения указателя в диапазоне от `p` для `p + s.Length - 1` представления адресов символов в строке, а значение указателя `p + s.Length` всегда указывает на символ null (символ со значением `'\0'`).

Изменение объектов управляемого типа посредством фиксированных указателей может привести к неопределенному поведению. Например поскольку строки являются неизменяемыми, это программист должен убедиться, что ссылается указатель в строку фиксированной символы не изменяются.

Автоматическое завершение null строк особенно удобно, если вызов внешних API, ожидающих строки «В стиле». Обратите внимание, что экземпляр string может содержать символы null. Если присутствуют символы null, строка будет выглядеть усеченный обрабатываются как заканчивающаяся нулевым символом `char*`.

## <a name="fixed-size-buffers"></a>Буферы фиксированного размера

Буферы фиксированного размера используются для объявления массивов в строке «C style» как члены структур и главным образом используются для связи с неуправляемыми API.

### <a name="fixed-size-buffer-declarations"></a>Объявления буферов фиксированного размера

Объект ***буфера фиксированного размера*** является членом, который представляет хранилище для буфера фиксированной длины переменных данного типа. Объявление буфера фиксированного размера включает один или несколько буферов фиксированного размера с заданным типом элементов. Буферы фиксированного размера допускаются только в объявлениях структур и могут возникать только в небезопасных контекстах ([небезопасных контекстах](unsafe-code.md#unsafe-contexts)).

```antlr
struct_member_declaration_unsafe
    : fixed_size_buffer_declaration
    ;

fixed_size_buffer_declaration
    : attributes? fixed_size_buffer_modifier* 'fixed' buffer_element_type fixed_size_buffer_declarator+ ';'
    ;

fixed_size_buffer_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'unsafe'
    ;

buffer_element_type
    : type
    ;

fixed_size_buffer_declarator
    : identifier '[' constant_expression ']'
    ;
```

Объявление буфера фиксированного размера может включать набор атрибутов ([атрибуты](attributes.md)), `new` модификатор ([модификаторы](classes.md#modifiers)), является допустимым сочетанием четырех модификаторов доступа ([типа параметров и ограничений](classes.md#type-parameters-and-constraints)) и `unsafe` модификатор ([небезопасных контекстах](unsafe-code.md#unsafe-contexts)). Атрибуты и модификаторы применяются ко всем членам, объявленным с помощью объявления буфера фиксированного размера. Является ошибкой один и тот же модификатор встречается несколько раз в объявлении буфера фиксированного размера.

Объявление буфера фиксированного размера не может содержать `static` модификатор.

Тип элемента буфера объявление буфера фиксированного размера указывает тип элемента буферов, представленные этим определением. Тип элемента буфера должен быть один из предопределенных типов `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, или `bool`.

Тип элемента буфера следует список деклараторов буфера фиксированного размера, каждый из которых вводит новый член. Декларатор буфера фиксированного размера состоит из идентификатора с именем члена, а затем константное выражение, заключенное в `[` и `]` маркеров. Константное выражение указывает число элементов в члена, представленного этой декларатор буфера фиксированного размера. Тип константного выражения должен быть неявно преобразовать в тип `int`, и значение должно быть положительным целым числом ненулевое значение.

Элементы буфера фиксированного размера гарантированно размещались последовательно в памяти.

Объявление буфера фиксированного размера, который объявляет несколько буферов фиксированного размера соответствует несколько объявлений, входящем в объявление один фиксированный размер буфера с те же атрибуты и типы элементов. Пример

```csharp
unsafe struct A
{
   public fixed int x[5], y[10], z[100];
}
```

эквивалентно

```csharp
unsafe struct A
{
   public fixed int x[5];
   public fixed int y[10];
   public fixed int z[100];
}
```

### <a name="fixed-size-buffers-in-expressions"></a>Буферы фиксированного размера в выражениях

Поиск члена ([операторы](expressions.md#operators)) фиксированного размера буфера члена выполняется так же, как поиск члена поля.

Буфер фиксированного размера можно ссылаться в выражение, использующее *simple_name* ([вывод типа](expressions.md#type-inference)) или *member_access* ([проверки во время компиляции динамического разрешения перегрузки](expressions.md#compile-time-checking-of-dynamic-overload-resolution)).

При ссылке на член буфера фиксированного размера по простому имени действует так же, как доступ к члену в форме `this.I`, где `I` входит буфера фиксированного размера.

В доступ к члену в форме `E.I`, если `E` является типом структуры и поиск члена `I` тем, что тип структуры определяет член фиксированного размера, затем `E.I` является вычисляется и классифицируется следующим образом:

*  Если выражение `E.I` не происходит в небезопасном контексте, то возникает ошибка времени компиляции.
*  Если `E` классифицируется как значение, то возникает ошибка времени компиляции.
*  В противном случае, если `E` является перемещаемой ([атрибутов неизменности и перемещаемые переменные](unsafe-code.md#fixed-and-moveable-variables)) и выражение `E.I` не *fixed_pointer_initializer* ([фиксированной Инструкция](unsafe-code.md#the-fixed-statement)), возникает ошибка времени компиляции.
*  В противном случае `E` ссылается на переменную, основных и результатом выражения является указатель на первый элемент члена буфера фиксированного размера `I` в `E`. Результат имеет тип `S*`, где `S` является тип элемента `I`и классифицируется как значение.

Последующие элементы буфера фиксированного размера может осуществляться с помощью операции с указателем с первого элемента. В отличие от доступа к массивам доступ к элементам буфера фиксированного размера является небезопасной операцией и не проверки диапазона.

В следующем примере объявляется и используется структура с членом буфера фиксированного размера.

```csharp
unsafe struct Font
{
    public int size;
    public fixed char name[32];
}

class Test
{
    unsafe static void PutString(string s, char* buffer, int bufSize) {
        int len = s.Length;
        if (len > bufSize) len = bufSize;
        for (int i = 0; i < len; i++) buffer[i] = s[i];
        for (int i = len; i < bufSize; i++) buffer[i] = (char)0;
    }

    unsafe static void Main()
    {
        Font f;
        f.size = 10;
        PutString("Times New Roman", f.name, 32);
    }
}
```

### <a name="definite-assignment-checking"></a>Проверка определенного присваивания

Буферы фиксированного размера, не подвергаются проверке определенного присваивания ([определенного присваивания](variables.md#definite-assignment)), а члены буфера фиксированного размера игнорируются для определенного присваивания, проверка переменным типа структуры.

Когда Дальняя переменная члена буфера фиксированного размера является статической переменной, экземпляр переменной экземпляра класса или элемента массива, элементы буфера фиксированного размера автоматически инициализируются значениями по умолчанию ([Значения по умолчанию](variables.md#default-values)). Во всех остальных случаях начальное содержимое буфера фиксированного размера не определено.

## <a name="stack-allocation"></a>Выделение памяти в стеке

В небезопасном контексте объявления локальной переменной ([объявления локальных переменных](statements.md#local-variable-declarations)) может включать инициализатор выделения стека, который выделяет память из стека вызовов.

```antlr
local_variable_initializer_unsafe
    : stackalloc_initializer
    ;

stackalloc_initializer
    : 'stackalloc' unmanaged_type '[' expression ']'
    ;
```

*Unmanaged_type* указывает тип элементов, которые будут храниться в каталоге во вновь выделенный и *выражение* показывает некоторые из этих элементов. Взятые вместе, они указывают необходимый размер выделения. Так как размер выделения стека не может быть отрицательным, это ошибка времени компиляции, чтобы указать число элементов в качестве *constant_expression* , результатом которого является отрицательное значение.

Инициализатора выделения стека формы `stackalloc T[E]` требует `T` неуправляемый тип ([типы указателей](unsafe-code.md#pointer-types)) и `E` является выражением типа `int`. Конструкция выделяет `E * sizeof(T)` байт из вызова стек и возвращает указатель типа `T*`, на вновь выделенный блок. Если `E` имеет отрицательное значение, то поведение не определено. Если `E` равно нулю, то выделение не производится, а также указатель, возвращенный определяется реализацией. Если не хватает памяти для выделения блока заданного размера, `System.StackOverflowException` возникает исключение.

Содержимое только что выделенную память не определено.

Инициализаторы выделения стека не разрешены в `catch` или `finally` блоки ([оператора try](statements.md#the-try-statement)).

Невозможно явно освобождать память, выделенную с помощью `stackalloc`. Все блоки памяти в стеке, созданному в ходе выполнения функции-члена, автоматически удаляются при возврате функции-члена. Это соответствует `alloca` функция, это расширение, часто встречаются в реализации C и C++.

В примере

```csharp
using System;

class Test
{
    static string IntToString(int value) {
        int n = value >= 0? value: -value;
        unsafe {
            char* buffer = stackalloc char[16];
            char* p = buffer + 16;
            do {
                *--p = (char)(n % 10 + '0');
                n /= 10;
            } while (n != 0);
            if (value < 0) *--p = '-';
            return new string(p, 0, (int)(buffer + 16 - p));
        }
    }

    static void Main() {
        Console.WriteLine(IntToString(12345));
        Console.WriteLine(IntToString(-999));
    }
}
```

`stackalloc` используется инициализатор в `IntToString` метод, чтобы выделить буфер 16 символов в стеке. Чего буфер очищается автоматически при возврате метода.

## <a name="dynamic-memory-allocation"></a>Динамическое выделение памяти

За исключением `stackalloc` оператор, C# не предоставляет предопределенные конструкции для управления собранных памяти не сборщиком мусора. Обычно такие службы, предоставляемые библиотек классов или импортировать непосредственно из операционной системы. Например `Memory` класс ниже показано, как функции кучи операционной системы может осуществляться с помощью C#:

```csharp
using System;
using System.Runtime.InteropServices;

public unsafe class Memory
{
    // Handle for the process heap. This handle is used in all calls to the
    // HeapXXX APIs in the methods below.
    static int ph = GetProcessHeap();

    // Private instance constructor to prevent instantiation.
    private Memory() {}

    // Allocates a memory block of the given size. The allocated memory is
    // automatically initialized to zero.
    public static void* Alloc(int size) {
        void* result = HeapAlloc(ph, HEAP_ZERO_MEMORY, size);
        if (result == null) throw new OutOfMemoryException();
        return result;
    }

    // Copies count bytes from src to dst. The source and destination
    // blocks are permitted to overlap.
    public static void Copy(void* src, void* dst, int count) {
        byte* ps = (byte*)src;
        byte* pd = (byte*)dst;
        if (ps > pd) {
            for (; count != 0; count--) *pd++ = *ps++;
        }
        else if (ps < pd) {
            for (ps += count, pd += count; count != 0; count--) *--pd = *--ps;
        }
    }

    // Frees a memory block.
    public static void Free(void* block) {
        if (!HeapFree(ph, 0, block)) throw new InvalidOperationException();
    }

    // Re-allocates a memory block. If the reallocation request is for a
    // larger size, the additional region of memory is automatically
    // initialized to zero.
    public static void* ReAlloc(void* block, int size) {
        void* result = HeapReAlloc(ph, HEAP_ZERO_MEMORY, block, size);
        if (result == null) throw new OutOfMemoryException();
        return result;
    }

    // Returns the size of a memory block.
    public static int SizeOf(void* block) {
        int result = HeapSize(ph, 0, block);
        if (result == -1) throw new InvalidOperationException();
        return result;
    }

    // Heap API flags
    const int HEAP_ZERO_MEMORY = 0x00000008;

    // Heap API functions
    [DllImport("kernel32")]
    static extern int GetProcessHeap();

    [DllImport("kernel32")]
    static extern void* HeapAlloc(int hHeap, int flags, int size);

    [DllImport("kernel32")]
    static extern bool HeapFree(int hHeap, int flags, void* block);

    [DllImport("kernel32")]
    static extern void* HeapReAlloc(int hHeap, int flags, void* block, int size);

    [DllImport("kernel32")]
    static extern int HeapSize(int hHeap, int flags, void* block);
}
```

Пример, использующий `Memory` классов приведены ниже:

```csharp
class Test
{
    static void Main() {
        unsafe {
            byte* buffer = (byte*)Memory.Alloc(256);
            try {
                for (int i = 0; i < 256; i++) buffer[i] = (byte)i;
                byte[] array = new byte[256];
                fixed (byte* p = array) Memory.Copy(buffer, p, 256); 
            }
            finally {
                Memory.Free(buffer);
            }
            for (int i = 0; i < 256; i++) Console.WriteLine(array[i]);
        }
    }
}
```

Пример кода поочередно 256 байт памяти `Memory.Alloc` и инициализирует блок памяти со значениями, увеличение от 0 до 255. Он выделяет массив байтов 256 элемент и использует `Memory.Copy` следует скопировать содержимое блока памяти в массив байтов. Наконец, блок памяти освобождается с помощью `Memory.Free` и содержимое байтового массива выводится на консоль.
