# <a name="arrays"></a>Массивы

Массив — это структура данных, который содержит ряд переменных, к которым осуществляется по вычисляемым индексам. Этот тип называется типом элемента массива и переменными, содержащимися в массиве, также называются элементами массива, имеют тот же тип.

Массив имеет ранг, определяющий количество индексов, связанных с каждым элементом массива. Ранг массива также называют измерений массива. Массив с рангом, называется ***одномерный массив***. Массив с рангом, превышающее один называется ***многомерного массива***. Определенного размера многомерных массивов, часто называются двумерные массивы, трехмерные массивы и т. д.

Каждое измерение массива имеет соответствующую длину которого является целое число больше или равно нулю. Длины по измерениям не являются частью типа массива, но устанавливаются при создании экземпляра типа массива во время выполнения. Длина измерения определяет допустимый диапазон индексов для этого измерения: для измерения длины `N`, индексы могут варьироваться от `0` для `N - 1` включительно. Общее число элементов в массиве — это совокупность длину каждого измерения в массиве. Если один или несколько измерений массива имеют нулевую длину, массив считается пустым.

Элементы массива могут иметь любой тип, в том числе тип массива.

## <a name="array-types"></a>Типы массивов

Тип массива записывается как *non_array_type* следуют одна или несколько *rank_specifier*s:

```antlr
array_type
    : non_array_type rank_specifier+
    ;

non_array_type
    : type
    ;

rank_specifier
    : '[' dim_separator* ']'
    ;

dim_separator
    : ','
    ;
```

Объект *non_array_type* любой *тип* это сам по себе не *array_type*.

Ранг типа массива задается крайнее левое *rank_specifier* в *array_type*: A *rank_specifier* указывает, что массив является массивом с рангом, а также число "`,`" токены *rank_specifier*.

Тип элемента типа массива является типом, полученный в результате удаления в крайней левой позиции *rank_specifier*:

*  Тип массива в форме `T[R]` является массивом с рангом `R` и является типом элемента, не являющимся массивом `T`.
*  Тип массива в форме `T[R][R1]...[Rn]` является массивом с рангом `R` и типа элемента `T[R1]...[Rn]`.

По сути *rank_specifier*s читаются слева направо, перед типом последним элементом вектора. Тип `int[][,,][,]` представляет собой одномерный массив трехмерные массивы двумерных массивов `int`.

Во время выполнения, может быть значение типа массива `null` или ссылка на экземпляр такого типа массива.

### <a name="the-systemarray-type"></a>Типа System.Array

Тип `System.Array` является абстрактным базовым типом для всех этих типов. И неявное ссылочное преобразование ([неявные преобразования ссылочных типов](conversions.md#implicit-reference-conversions)) из любого типа массива для `System.Array`и преобразования явной ссылки ([явные преобразования ссылочных типов](conversions.md#explicit-reference-conversions)) существует из `System.Array` для любого типа массива. Обратите внимание, что `System.Array` сам не *array_type*. Кроме того, это *class_type* из которой все *array_type*s являются производными.

Во время выполнения, значение типа `System.Array` может быть `null` или ссылка на экземпляр любого типа массива.

### <a name="arrays-and-the-generic-ilist-interface"></a>Массивы и универсальный интерфейс IList

Одномерный массив `T[]` реализует интерфейс `System.Collections.Generic.IList<T>` (`IList<T>` для краткости) и его базовых интерфейсов. Соответственно, отсутствует неявное преобразование из `T[]` для `IList<T>` и его базовых интерфейсов. Кроме того, если имеется и неявное ссылочное преобразование из `S` для `T` затем `S[]` реализует `IList<T>` и нет и неявное ссылочное преобразование из `S[]` для `IList<T>` и его базовых интерфейсов () [Неявные преобразования ссылочных типов](conversions.md#implicit-reference-conversions)). Если выполняется преобразование явной ссылки из `S` для `T` то существует неявное преобразование из `S[]` для `IList<T>` и его базовых интерфейсов ([преобразования явной ссылки](conversions.md#explicit-reference-conversions)). Пример:
```csharp
using System.Collections.Generic;

class Test
{
    static void Main() {
        string[] sa = new string[5];
        object[] oa1 = new object[5];
        object[] oa2 = sa;

        IList<string> lst1 = sa;                    // Ok
        IList<string> lst2 = oa1;                   // Error, cast needed
        IList<object> lst3 = sa;                    // Ok
        IList<object> lst4 = oa1;                   // Ok

        IList<string> lst5 = (IList<string>)oa1;    // Exception
        IList<string> lst6 = (IList<string>)oa2;    // Ok
    }
}
```

Назначение `lst2 = oa1` приводит к ошибке времени компиляции с момента преобразование из `object[]` для `IList<string>` является явным преобразованием, не неявное. Приведение `(IList<string>)oa1` вызовет исключение во время выполнения с момента `oa1` ссылки `object[]` и не `string[]`. Однако приведение `(IList<string>)oa2` не вызывает исключение, поскольку у `oa2` ссылки `string[]`.

Каждый раз, когда выполняется преобразование ссылку, явного или неявного из `S[]` для `IList<T>`, имеется также неявное преобразование из `IList<T>` и его базовых интерфейсов для `S[]` ([явной ссылки преобразования](conversions.md#explicit-reference-conversions)).

Если в типе массива `S[]` реализует `IList<T>`, некоторые из членов реализованного интерфейса могут вызывать исключения. Точное поведение реализации интерфейса выходит за рамки этой спецификации.

## <a name="array-creation"></a>Создание массива

Экземпляры массива создаются с *array_creation_expression*s ([выражениях создания массива](expressions.md#array-creation-expressions)), поле или объявления локальных переменных, которые включают *array_initializer*([Инициализаторы массивов](arrays.md#array-initializers)).

Когда создается экземпляр массива, ранг и длина каждого из измерений, устанавливаются и остаются неизменными в течение всего времени жизни экземпляра. Другими словами невозможно изменить ранг массива, а также можно ли изменить размер его измерений.

Экземпляр массива всегда имеет тип массива. `System.Array` Тип является абстрактным типом, не может быть создан.

Элементы массивов, созданных *array_creation_expression*s всегда инициализируются значениями по умолчанию ([значения по умолчанию](variables.md#default-values)).

## <a name="array-element-access"></a>Доступ к элементам массива

Элементы массива осуществляется с помощью *element_access* выражения ([массива доступа](expressions.md#array-access)) формы `A[I1, I2, ..., In]`, где `A` представляет собой выражение из типа массива и каждый `Ix` — Выражение типа `int`, `uint`, `long`, `ulong`, или может быть неявно преобразован в один или несколько из этих типов. Доступ к элементам массива образом переменной, а именно элемент массива, выбранный по индексу.

Элементы массива могут быть перечислены с помощью `foreach` инструкции ([оператор foreach](statements.md#the-foreach-statement)).

## <a name="array-members"></a>Члены массива

Каждый тип массива наследует члены, объявленные `System.Array` типа.

## <a name="array-covariance"></a>Ковариация массивов

Для любой двух *reference_type*s `A` и `B`, если и неявное ссылочное преобразование ([неявные преобразования ссылочных типов](conversions.md#implicit-reference-conversions)) или явное преобразование ссылок ([ Явные преобразования ссылочных типов](conversions.md#explicit-reference-conversions)) существует `A` для `B`, то же преобразование ссылок из типа массива также существует `A[R]` в тип массива `B[R]`, где `R` любой заданный *rank_specifier* (но одинаковым для обоих типы массивов). Эта связь называется ***ковариацией***. Ковариация массивов в частности означает, что значение типа массива `A[R]` фактически может представлять собой ссылку на экземпляр типа массива `B[R]`, если существует неявное преобразование ссылок из `B` для `A`.

Из-за ковариантность массивов, присваивание к элементам массива ссылочного типа включает проверку во время выполнения, что гарантирует, что значение, назначаемое элементу массива фактически разрешенный тип ([простое присваивание](expressions.md#simple-assignment)). Пример:
```csharp
class Test
{
    static void Fill(object[] array, int index, int count, object value) {
        for (int i = index; i < index + count; i++) array[i] = value;
    }

    static void Main() {
        string[] strings = new string[100];
        Fill(strings, 0, 100, "Undefined");
        Fill(strings, 0, 10, null);
        Fill(strings, 90, 10, 0);
    }
}
```

Назначение `array[i]` в `Fill` метод неявно включает в себя проверку во время выполнения, который гарантирует, что объект, упоминаемый в `value` либо `null` или экземпляр, который совместим с фактическим типом элемента `array`. В `Main`, первые два вызова `Fill` выполниться успешно, но третий причины вызова `System.ArrayTypeMismatchException` исключение при выполнении первое присваивание `array[i]`. Исключение возникает, так как упакованное `int` не могут храниться в `string` массива.

Ковариация массивов специально не распространяется на массивы *value_type*s. Например, не существует преобразования, подходящее `int[]` будет считаться `object[]`.

## <a name="array-initializers"></a>Инициализаторы массивов

Инициализаторы массивов могут быть указаны в объявления поля ([поля](classes.md#fields)), объявлений локальных переменных ([объявления локальных переменных](statements.md#local-variable-declarations)) и выражения создания массива ([создания массива выражения](expressions.md#array-creation-expressions)):

```antlr
array_initializer
    : '{' variable_initializer_list? '}'
    | '{' variable_initializer_list ',' '}'
    ;

variable_initializer_list
    : variable_initializer (',' variable_initializer)*
    ;

variable_initializer
    : expression
    | array_initializer
    ;
```

Инициализатор массива состоит из последовательности переменных инициализаторов, заключенных между "`{`«и»`}`«маркеров и разделенных»`,`" маркеров. Каждый инициализатор переменной представляет собой выражение или, в случае многомерного массива, инициализатор вложенного массива.

Контекст, в котором используется инициализатор массива определяет тип инициализируемого массива. В выражение создания массива тип массива непосредственно предшествует инициализатору или выводится из выражения в инициализаторе массива. В поле или объявление переменной тип массива — тип поля или объявляемой переменной. Когда инициализатор массива используется в поле или объявления переменной, такие как:
```csharp
int[] a = {0, 2, 4, 6, 8};
```
Это просто сокращением для соответствующего выражения создания массива:
```csharp
int[] a = new int[] {0, 2, 4, 6, 8};
```

Одномерный массив инициализатор массива должны состоять из последовательности выражений, совместимого с типом элемента массива назначения. Выражения инициализации элементов массива в порядке по возрастанию, начиная с элемента с нулевым индексом. Количество выражений в инициализаторе массива определяет длину массива экземпляра. Например, приведенный выше инициализатор массива создает `int[]` экземпляр длиной 5 и инициализирует экземпляр со следующими значениями:
```csharp
a[0] = 0; a[1] = 2; a[2] = 4; a[3] = 6; a[4] = 8;
```

Многомерный массив инициализатор массива должен иметь столько уровней вложенности, сколько измерений в массиве. Правой размерности верхнего уровня вложенности соответствует левой размерности а внутреннего уровня вложения. Длина каждого измерения массива определяется количество элементов на соответствующем уровне вложенности в инициализаторе массива. Каждый инициализатор вложенного массива номер элементов должен быть таким же, как другие Инициализаторы массивов того же уровня. Пример:
```csharp
int[,] b = {{0, 1}, {2, 3}, {4, 5}, {6, 7}, {8, 9}};
```
создает двумерный массив с длиной пять для левого измерения и длину, равную 2 для правого измерения:
```csharp
int[,] b = new int[5, 2];
```
и затем инициализирует экземпляр массива со следующими значениями:
```csharp
b[0, 0] = 0; b[0, 1] = 1;
b[1, 0] = 2; b[1, 1] = 3;
b[2, 0] = 4; b[2, 1] = 5;
b[3, 0] = 6; b[3, 1] = 7;
b[4, 0] = 8; b[4, 1] = 9;
```

Если измерения, отличного от самым правым имеет нулевую длину, последующие измерения предполагается, что также имеет нулевую длину. Пример:
```csharp
int[,] c = {};
```
создает двумерный массив с длиной ноль для левого и правого измерения:
```csharp
int[,] c = new int[0, 0];
```

Если выражение создания массива включает явное длины по измерениям и инициализатора массива, длины должны быть константными выражениями, и количество элементов на каждом уровне вложенности должно совпадать с длиной соответствующего измерения. Далее приводятся некоторые примеры.
```csharp
int i = 3;
int[] x = new int[3] {0, 1, 2};        // OK
int[] y = new int[i] {0, 1, 2};        // Error, i not a constant
int[] z = new int[3] {0, 1, 2, 3};     // Error, length/initializer mismatch
```

Здесь инициализатор для `y` приводит к ошибке времени компиляции, так как выражение длины массива не является константой и инициализатор `z` приводит к ошибке времени компиляции, так как длина и количество элементов в Инициализатор не согласны.
