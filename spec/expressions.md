# <a name="expressions"></a>Выражения

Выражение — это последовательность операторов и операндов. В этой главе описывается синтаксис, порядок вычисления операндов и операторов, а также смысл выражений.

## <a name="expression-classifications"></a>Классификации выражений

Выражение может иметь один из следующих типов.

*  Значение. У каждого значения есть связанный с ним тип.
*  Переменная. Каждая переменная имеет связанный тип, а именно объявленный тип переменной.
*  Пространство имен. Выражение с этой классификацией может появляться только в левой части *member_access* ([доступ к членам](expressions.md#member-access)). В любом другом контексте выражение классифицируется как пространство имен вызывает ошибку времени компиляции.
*  Тип. Выражение с этой классификацией может появляться только в левой части *member_access* ([доступ к членам](expressions.md#member-access)), или в качестве операнда для `as` оператор ([оператор As ](expressions.md#the-as-operator)), `is` оператор ([является оператором](expressions.md#the-is-operator)), или `typeof` оператор ([оператор typeof](expressions.md#the-typeof-operator)). В любом другом контексте выражение классифицируется как тип вызывает ошибку времени компиляции.
*  Метод группу, которая представляет собой набор перегруженных методов, полученный в результате поиска члена ([поиск члена](expressions.md#member-lookup)). Группа методов может иметь связанное выражение экземпляра и связанный список аргументов типа. При вызове метода экземпляра, результат вычисления выражения экземпляра становится экземпляра, представленного `this` ([такой доступ](expressions.md#this-access)). Группа метод *invocation_expression* ([выражения вызова](expressions.md#invocation-expressions)), *delegate_creation_expression* ([делегировать создание выражения](expressions.md#delegate-creation-expressions)) и в качестве левой части операций является оператором и может быть неявно преобразован в совместимого типа делегата ([преобразования групп методов](conversions.md#method-group-conversions)). В любом другом контексте выражение классифицировано как группа метод вызывает ошибку времени компиляции.
*  Литерал null. Выражение с этой классификацией может неявно преобразовываться в ссылочный тип или тип, допускающий значение NULL.
*  Анонимная функция. Выражение с этой классификацией может неявно преобразовываться в совместимый тип делегата или тип дерева выражения.
*  Доступ к свойству. Каждый доступ к свойству имеет связанный тип, а именно тип свойства. Кроме того доступ к свойству может быть связанным выражением экземпляра. Если метод доступа ( `get` или `set` блок) экземпляра вызывается доступ к свойству, результат вычисления выражения экземпляра становится экземпляра, представленного `this` ([такой доступ](expressions.md#this-access)).
*  Доступ к событию. Каждого доступа к событию имеет связанный тип, а именно тип события. Кроме того доступ к событию может быть связанным выражением экземпляра. Доступ к событию может выглядеть как левый операнд `+=` и `-=` операторы ([назначения события](expressions.md#event-assignment)). В любом другом контексте выражение доступа к событию вызывает ошибку времени компиляции.
*  Доступ к индексатору. Каждого доступа к индексатору имеет связанный тип, а именно тип элемента индексатора. Кроме того доступ к индексатору имеет связанное выражение экземпляра и связанный список аргументов. Если метод доступа ( `get` или `set` блок) индексатора вызывается доступ, результат вычисления выражения экземпляра становится экземпляра, представленного `this` ([такой доступ](expressions.md#this-access)) и результат вычисления списка аргументов становится списком параметров вызова.
*  никаких действий. Это происходит, если выражение является вызов метода с типом возвращаемого значения `void`. Выражение классифицируется как допустимо только в контексте *statement_expression* ([операторы выражений](statements.md#expression-statements)).

Результат выражения никогда не является пространство имен, тип, группу методов или доступа к событиям. Скорее как указано выше, эти категории выражений представляют собой промежуточные конструкции, которые допускаются только в определенных контекстах.

Доступ к свойству или индексатору всегда менять свой тип значение при вызове *метод доступа get* или *метода доступа set*. Определенный метод доступа определяется в контексте доступа свойства или индексатора: Если доступ является целевым объектом назначения, *метода доступа set* вызывается для присвоения нового значения ([простое присваивание](expressions.md#simple-assignment)). В противном случае *метод доступа get* вызывается для получения текущего значения ([значения выражений](expressions.md#values-of-expressions)).

### <a name="values-of-expressions"></a>Значения выражений

Большинство конструкций, в которых участвует выражение, это требует, чтобы выражение обозначало ***значение***. В таких случаях если фактическое выражение обозначает пространство имен, типом, группой методов или nothing, возникает ошибка времени компиляции. Тем не менее если выражение обозначает доступ к свойству, индексатору или переменной, значение свойства, индексатора или переменной неявно заменяется:

*  Значение переменной является просто значение, хранящихся в расположении, указанном переменной. Переменная должна быть считается определенно присвоенной ([определенного присваивания](variables.md#definite-assignment)) перед его значение можно получить, или в противном случае возникает ошибка времени компиляции.
*  Значение выражения доступа к свойству получается путем вызова *метод доступа get* свойства. Если свойство не имеет *метод доступа get*, возникает ошибка времени компиляции. В противном случае вызов функции-члена ([Проверка динамического разрешения перегрузки во время компиляции](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) выполняется, и результат вызова становится значением выражения доступа к свойству.
*  Значение выражения доступа индексатора получается путем вызова *метод доступа get* индексатора. Если не имеет индексатора *метод доступа get*, возникает ошибка времени компиляции. В противном случае вызов функции-члена ([Проверка динамического разрешения перегрузки во время компиляции](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) выполняется с аргументом списка, связанное с выражением доступа индексатора, а результат вызова становится значение выражения доступа индексатора.

## <a name="static-and-dynamic-binding"></a>Статическая и динамическая привязка

Процесс определения значения операцию на основании типа или значения составляющих выражений (аргументы, операнды, приемники) часто называется ***привязки***. Для экземпляра значение вызова метода определяется на основе приемника и аргументы типа. Значение оператора определяется исходя из своих операндов типа.

В C#, значение операции обычно определяется во время компиляции, исходя из его составляющих выражений типа во время компиляции. Аналогично Если выражение содержит ошибку, ошибка обнаружена и компилятор сообщает. Этот подход известен как ***статической привязки***.

Тем не менее если выражение является динамическим выражением (т. е. имеет тип `dynamic`) это означает, что любой привязки, который участвует в должны быть основаны на типе времени выполнения (т. е. фактический тип объекта, он обозначает во время выполнения) вместо того, чтобы на тип При компиляции. Таким образом привязку такая операция откладывается до времени, которого операция, выполняемая во время выполнения программы. Это называется ***динамической привязки***.

Если операция является динамическим, практически не проверка выполняется компилятором. Вместо этого при сбое привязки времени выполнения, ошибки выводятся как исключения во время выполнения.

Следующие операции в C# регулируются привязки:

*  Доступ к членам: `e.M`
*  Вызов метода: `e.M(e1, ..., eN)`
*  Вызов делегата:`e(e1, ..., eN)`
*  Доступ к элементам: `e[e1, ..., eN]`
*  Создание объекта: `new C(e1, ..., eN)`
*  Перегрузка унарных операторов: `+`, `-`, `!`, `~`, `++`, `--`, `true`, `false`
*  Перегруженные бинарные операторы: `+`, `-`, `*`, `/`, `%`, `&`, `&&`, `|`, `||`, `??`, `^`, `<<` , `>>`, `==`,`!=`, `>`, `<`, `>=`, `<=`
*  Операторы присваивания: `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`
*  Явные и неявные преобразования

При использовании динамические выражения, C# по умолчанию статической привязки, это означает, что в процесс выбора используются типы составных выражений во время компиляции. Тем не менее если одна из составляющих выражений в приведенных выше операций динамического выражения, операция привязывается динамически.

### <a name="binding-time"></a>Во время привязки

Статическая привязка выполняется во время компиляции, а динамическая привязка происходит во время выполнения. В следующих разделах термин ***времени привязки*** ссылается на время компиляции или выполнения, в зависимости от того, когда выполняется привязка.

Следующий пример иллюстрирует уведомления статическая и динамическая привязка и во время привязки:
```csharp
object  o = 5;
dynamic d = 5;

Console.WriteLine(5);  // static  binding to Console.WriteLine(int)
Console.WriteLine(o);  // static  binding to Console.WriteLine(object)
Console.WriteLine(d);  // dynamic binding to Console.WriteLine(int)
```

Первые два вызова являются статическими: перегрузка `Console.WriteLine` выбирается на основе типа времени компиляции аргумента. Таким образом время привязки во время компиляции.

Третий вызов является динамическим: перегрузка `Console.WriteLine` выбирается на основе типа среды выполнения своего аргумента. Это происходит потому, что аргумент является динамическим выражением--его тип времени компиляции — `dynamic`. Таким образом время привязки третьего вызова во время выполнения.

### <a name="dynamic-binding"></a>Динамическая привязка

Динамическая привязка предназначена для разрешить программы на C# для взаимодействия с ***динамические объекты***, т. е. система типов объектов, которые не следовать нормальным правилам C#. Динамические объекты могут быть объекты из других языков программирования с системами различных типов, или они могут быть объекты, которые запрограммированы для реализации собственной семантики привязки для различных операций.

Механизм, по которому динамический объект реализует собственную семантику это определяется реализацией. --Снова определяется реализацией--данный интерфейс реализуется динамическими объектами для указания для C# времени выполнения, что они имеют особой семантики. Таким образом каждый раз, когда операции на динамический объект динамически связываются, собственную семантику привязки, а не те, C#, как указано в этом документе, перехватить.

Хотя динамической привязки предназначена для того, чтобы разрешить взаимодействие с динамическими объектами, C# позволяет динамической привязки для всех объектов ли они являются динамическими, или нет. Это обеспечивает более тесную интеграцию динамические объекты, как результаты выполнения операций над их сами по себе не может быть динамических объектов, но по-прежнему имеют тип неизвестного программисту во время компиляции. Также динамической привязки может помочь устранить подверженного ошибкам кода на основе отражения, даже в том случае, если не участвующие объекты динамических объектов.

В следующих разделах для каждой конструкции в языке точно при динамической привязки применяется, что компиляция проверки во время--если любой--применяется, и какие компиляции результат и выражение классификацией.

### <a name="types-of-constituent-expressions"></a>Типы составных выражений

Если операция статически привязку, тип составного выражения (например, получатель и аргумент, индекса или операнд) всегда считается типов во время компиляции этого выражения.

Если операция является динамическим, тип составного выражения определяется по-разному в зависимости от типа во время компиляции составного выражения:

*  Составное выражение типов во время компиляции `dynamic` должно иметь тип фактического значения, выражение принимает значение во время выполнения
*  Считается, что составное выражение, тип которого во время компиляции является параметром типа является тип, который параметр типа привязан к во время выполнения
*  В противном случае составное выражение считается тип времени компиляции.

## <a name="operators"></a>Операторы

Выражения, построенные на основе ***операндов*** и ***операторы***. Операторы в выражении указывают, какие действия нужно применить к операндам. Примеры операторов: `+`, `-`, `*`, `/` и `new`. Операндами могут являться литералы, поля, локальные переменные, выражения и т. п.

Существует три типа операторов.

*  Унарные операторы. Унарные операторы принимают один операнд и используют префиксной (такие как `--x`) или почтовый индекс (такие как `x++`).
*  Бинарные операторы. Бинарные операторы используются два операнда, и в виде инфикса (такие как `x + y`).
*  троичный оператор. Только один Тернарный оператор `?:`, существует; он принимает три операнда и используется инфиксная запись (`c ? x : y`).

Порядок вычисления операторов в выражении определяется ***приоритет*** и ***ассоциативность*** операторов ([приоритет и ассоциативность операторов](expressions.md#operator-precedence-and-associativity)) .

Операнды в выражении вычисляются слева направо. Например, в `F(i) + G(i++) * H(i)`, метод `F` вызывается с помощью старое значение `i`, затем метод `G` вызывается с старое значение `i`и, наконец, метод `H` вызывается с новым значением `i`. Это отдельно от и не связана с приоритетом операторов.

Некоторые операторы могут быть ***перегружены***. Перегрузка операторов позволяет создать определяемый пользователем оператор реализацию для операций там, где один или оба операнда имеют определяемый пользователем тип класса или структуры ([перегрузка операторов](expressions.md#operator-overloading)).

### <a name="operator-precedence-and-associativity"></a>Приоритет и ассоциативность операторов

Если выражение содержит несколько операторов, порядок вычисления этих операторов определяется их ***приоритетом***. Например, выражение `x + y * z` вычисляется как `x + (y * z)` поскольку `*` оператор имеет более высокий приоритет, чем двоичные `+` оператор. Приоритет оператора устанавливается для определения его связанные грамматики производства. Например *additive_expression* состоит из последовательности *multiplicative_expression*s, разделенных точкой `+` или `-` операторы, тем самым предоставляя `+` и `-` операторы имеют более низкий приоритет, чем `*`, `/`, и `%` операторы.

В следующей таблице перечислены все операторы в порядке от самого высокого до самого низкого:

| __Раздел__                                                                                   | __Категория__                | __Инструкции__ | 
|-----------------------------------------------------------------------------------------------|-----------------------------|---------------|
| [Первичные выражения](expressions.md#primary-expressions)                                     | Первичный                     | `x.y`  `f(x)`  `a[x]`  `x++`  `x--`  `new`  `typeof`  `default`  `checked`  `unchecked`  `delegate` | 
| [Унарные операторы](expressions.md#unary-operators)                                             | Унарный                       | `+`  `-`  `!`  `~`  `++x`  `--x`  `(T)x` | 
| [Арифметические операторы](expressions.md#arithmetic-operators)                                   | Мультипликативный              | `*`  `/`  `%` | 
| [Арифметические операторы](expressions.md#arithmetic-operators)                                   | Аддитивный                    | `+`  `-`      | 
| [Операторы сдвига](expressions.md#shift-operators)                                             | Сдвиг                       | `<<`  `>>`    | 
| [Реляционные операторы и операторы тестирования типа](expressions.md#relational-and-type-testing-operators) | Тестирования типа и относительные | `<`  `>`  `<=`  `>=`  `is`  `as` | 
| [Реляционные операторы и операторы тестирования типа](expressions.md#relational-and-type-testing-operators) | Равенство                    | `==`  `!=`    | 
| [Логические операторы](expressions.md#logical-operators)                                         | Логическое И                 | `&`           | 
| [Логические операторы](expressions.md#logical-operators)                                         | Логическое исключающее ИЛИ                 | `^`           | 
| [Логические операторы](expressions.md#logical-operators)                                         | Логическое ИЛИ                  | <code>&#124;</code>           |
| [Условные логические операторы](expressions.md#conditional-logical-operators)                 | Условное И             | `&&`          | 
| [Условные логические операторы](expressions.md#conditional-logical-operators)                 | Условное ИЛИ              | <code>&#124;&#124;</code>          | 
| [Оператор объединения со значением NULL](expressions.md#the-null-coalescing-operator)                   | Объединение со значением NULL             | `??`          | 
| [Условный оператор](expressions.md#conditional-operator)                                   | Условие                 | `?:`          | 
| [Операторы присваивания](expressions.md#assignment-operators), [выражения анонимных функций](expressions.md#anonymous-function-expressions)  | Присвоение и лямбда-выражения | `=`  `*=`  `/=`  `%=`  `+=`  `-=`  `<<=`  `>>=`  `&=`  `^=`  <code>&#124;=</code>  `=>` | 

Если операнд располагается между двумя операторами с одинаковым приоритетом, ассоциативностью операторов управляет порядком, в котором выполняются операции:

*  Кроме операторы присваивания и оператор объединения со значением null, все бинарные операторы имеют ***левую ассоциативность***, это означает, что операции выполняются слева направо. Например, выражение `x + y + z` вычисляется как `(x + y) + z`.
*  Операторы присваивания, оператор объединения со значением null и условный оператор (`?:`) являются ***правоассоциативным***, это означает, что операции выполняются слева направо. Например, выражение `x = y = z` вычисляется как `x = (y = z)`.

Приоритет и ассоциативность операторов можно изменять, используя скобки. Например, в выражении `x + y * z` сначала `y` умножается на `z`, а результат прибавляется к `x`, а в выражении `(x + y) * z` сначала суммируются `x` и `y`, а результат умножается на `z`.

### <a name="operator-overloading"></a>Перегрузка операторов

Все унарные и бинарные операторы имеют предварительно определенные реализации, которые автоматически становятся доступными в любом выражении. В дополнение к стандартным реализациям определенные пользователем реализации могут быть введены, включив `operator` объявления в классы и структуры ([операторы](classes.md#operators)). Реализации определяемых пользователем операторов всегда имеют приоритет над реализации стандартных операторов: Только если не применимо определяемого пользователем оператора существует считаться реализации стандартных операторов, как описано в разделе [разрешение перегрузки унарного оператора](expressions.md#unary-operator-overload-resolution) и [перегрузку бинарного оператора разрешение](expressions.md#binary-operator-overload-resolution).

***Перегружаемые унарные операторы*** являются:
```csharp
+   -   !   ~   ++   --   true   false
```

Несмотря на то что `true` и `false` явным образом не используются в выражениях (и поэтому не включены в таблице приоритетов в [приоритет и ассоциативность операторов](expressions.md#operator-precedence-and-associativity)), они считаются операторами, поскольку они являются вызывается в нескольких контекстах выражения: логические выражения ([логических выражений](expressions.md#boolean-expressions)) и выражения, включающие условия ([условный оператор](expressions.md#conditional-operator)) и логического условия операторы ([условные логические операторы](expressions.md#conditional-logical-operators)).

***Перегружаемые бинарные операторы*** являются:
```csharp
+   -   *   /   %   &   |   ^   <<   >>   ==   !=   >   <   >=   <=
```

Только перечисленные выше операторы могут быть перегружены. В частности, это невозможно перегрузить доступ к членам, вызов метода или `=`, `&&`, `||`, `??`, `?:`, `=>`, `checked`, `unchecked`, `new`, `typeof`, `default`, `as`, и `is` операторы.

При перегрузке бинарного оператора соответствующий оператор присвоения (если таковой имеется) также неявно перегружается. Например, при перегрузке оператора `*` также является перегрузкой оператора `*=`. Это описано далее в [Составное присваивание](expressions.md#compound-assignment). Обратите внимание, что сам оператор присваивания (`=`) не могут быть перегружены. Назначения всегда выполняет простое побитовое копирование значения в переменную.

Операций приведения типов, таких как `(T)x`, являются перегруженными, предоставляя заданные пользователем преобразования ([заданные пользователем преобразования](conversions.md#user-defined-conversions)).

Доступ к элементу, такие как `a[x]`, не считается перегружаемый оператор. Вместо этого пользовательские индексирования поддерживается с помощью индексаторов ([индексаторы](classes.md#indexers)).

В выражениях операторы, указываются нотация оператора, а в объявлениях, операторы, указываются функциональная нотация. В следующей таблице показана связь между оператором и записью для унарные и бинарные операторы. В первой записи *op* обозначает перегружаемый унарный оператор, префикс. Во второй строке *op* обозначает унарное Постфиксное `++` и `--` операторы. В третьей записи *op* обозначает любой требуется перегружаемый бинарный оператор.


| __Нотация оператора__ | __Функциональная нотация__ |
|-----------------------|-------------------------|
| `op x`                | `operator op(x)`        | 
| `x op`                | `operator op(x)`        | 
| `x op y`              | `operator op(x,y)`      | 

Определяемый пользователем оператор объявления всегда требуется хотя бы один параметр типа класса или структуры, содержащий объявления оператора. Таким образом он не поддерживается для определяемого пользователем оператора иметь ту же сигнатуру, что встроенному оператору.

Определяемый пользователем оператор объявления не может изменить синтаксис, приоритет и ассоциативность оператора. Например `/` оператор всегда является бинарным оператором, всегда имеет уровень приоритета, указанное в [приоритет и ассоциативность операторов](expressions.md#operator-precedence-and-associativity)и всегда левую ассоциативность.

Хотя для определяемого пользователем оператора для выполнения любых вычислений, что, реализаций, которые формируют результаты, отличные от тех, которые ожидаются интуитивно понятным образом не рекомендуется. Например, реализация `operator ==` следует сравнить два операнда на предмет равенства и возвращает соответствующий `bool` результат.

Описания отдельных операторов в [основные выражения](expressions.md#primary-expressions) через [условные логические операторы](expressions.md#conditional-logical-operators) указать операторы и любые дополнительные правила, которые применяются стандартные реализации для каждого оператора. Описания использовать условий ***разрешение перегрузки унарного оператора***, ***разрешить перегрузку бинарного оператора***, и ***Числовое расширение***, определения элементов найти в следующих разделах.

### <a name="unary-operator-overload-resolution"></a>Разрешение перегрузки унарного оператора

Операции формы `op x` или `x op`, где `op` перегружаемый унарный оператор, и `x` является выражением типа `X`, обрабатывается следующим образом:

*  Набор кандидатов определяемые пользователем операторы, предоставляемые `X` для операции `operator op(x)` определяется с использованием правил [кандидата определяемых пользователем операторов](expressions.md#candidate-user-defined-operators).
*  Если набор кандидатов определяемые пользователем операторы не пустой, это становится набор операторов-кандидатов для операции. В противном случае заранее определенной унарной `operator op` становятся реализации, поднятые формы, включая набор операторов-кандидатов для операции. Стандартные реализации данного оператора указаны в описании оператора ([основные выражения](expressions.md#primary-expressions) и [унарные операторы](expressions.md#unary-operators)).
*  Правила разрешения перегрузки из [разрешение перегрузки](expressions.md#overload-resolution) применяются к набору операторов кандидатов, чтобы выбрать подходящий оператор списка аргументов `(x)`, и этот оператор становится результатом перегрузки процесс разрешения. Если разрешение перегрузки оканчивается неудачей выбрать один подходящий оператор, возникает ошибка времени привязки.

### <a name="binary-operator-overload-resolution"></a>Разрешение перегрузки бинарного оператора

Операции формы `x op y`, где `op` является требуется перегружаемый бинарный оператор `x` является выражением типа `X`, и `y` является выражением типа `Y`, обрабатывается следующим образом:

*  Набор кандидатов определяемые пользователем операторы, предоставляемые `X` и `Y` для операции `operator op(x,y)` определяется. Набор состоит из объединения операторов-кандидатов, предоставляемые `X` и потенциальных операторы, предоставляемые `Y`, каждый определенный, используя правила [кандидата определяемых пользователем операторов](expressions.md#candidate-user-defined-operators). Если `X` и `Y` относятся к одному типу, или если `X` и `Y` являются производными от общего базового типа, а затем Общие операторы-кандидаты произведен только в объединенном наборе один раз.
*  Если набор кандидатов определяемые пользователем операторы не пустой, это становится набор операторов-кандидатов для операции. В противном случае двоичные стандартные `operator op` становятся реализации, поднятые формы, включая набор операторов-кандидатов для операции. Стандартные реализации данного оператора указаны в описании оператора ([арифметические операторы](expressions.md#arithmetic-operators) через [условные логические операторы](expressions.md#conditional-logical-operators)). Для стандартных операторов перечислений и делегатов Единственными операторами считается определяются перечисление или делегат типа, который является типом времени привязки одного из операндов.
*  Правила разрешения перегрузки из [разрешение перегрузки](expressions.md#overload-resolution) применяются к набору операторов кандидатов, чтобы выбрать подходящий оператор списка аргументов `(x,y)`, и этот оператор становится результатом перегрузки процесс разрешения. Если разрешение перегрузки оканчивается неудачей выбрать один подходящий оператор, возникает ошибка времени привязки.

### <a name="candidate-user-defined-operators"></a>Определяемые пользователем операторы кандидатов

Типом `T` , операция `operator op(A)`, где `op` перегружаемый оператор и `A` является список аргументов, набор кандидатов, определяемые пользователем операторы, предоставляемые `T` для `operator op(A)` определяется как показано ниже:

*  Определить тип `T0`. Если `T` является тип nullable `T0` является его базовым типом, в противном случае `T0` равен `T`.
*  Для всех `operator op` объявления в `T0` и все удален виды таких операторов, если хотя бы один оператор ([применимого члена функции](expressions.md#applicable-function-member)) списка аргументов `A`, то набор операторы кандидатов состоит из таких применимых операторов в `T0`.
*  В противном случае, если `T0` является `object`, набор операторов-кандидатов пуст.
*  В противном случае набор операторов кандидатов, предоставляемые `T0` — это набор операторов-кандидатов, предоставляемые прямой базовый класс для `T0`, или эффективный базовый класс `T0` Если `T0` является параметром типа.

### <a name="numeric-promotions"></a>Восходящие приведения числовых типов

Числовое расширение состоит из автоматически выполняет определенные неявные преобразования предопределенные унарные и бинарные операторы числовых операндов. Числовое расширение — это не отдельный механизм, а скорее эффект применения разрешения перегрузки для стандартных операторов. Числовое расширение специально не влияет на вычисления определяемых пользователем операторов, несмотря на то, что определяемые пользователем операторы можно реализовать для получения похожих эффектов.

В качестве примера числовых повышения роли, рассмотрим стандартные реализации двоичного файла `*` оператор:

```csharp
int operator *(int x, int y);
uint operator *(uint x, uint y);
long operator *(long x, long y);
ulong operator *(ulong x, ulong y);
float operator *(float x, float y);
double operator *(double x, double y);
decimal operator *(decimal x, decimal y);
```

Когда правила разрешения перегрузки ([разрешение перегрузки](expressions.md#overload-resolution)) применяются к этому набору операторов, применяется для выбора первого из операторов, для которых существуют неявные преобразования из типы операндов. Например, для операции `b * s`, где `b` — `byte` и `s` — `short`, разрешения перегрузки выбирается `operator *(int,int)` как оператор рекомендации. Таким образом, это действие соответствует `b` и `s` преобразуются в `int`, а тип результата — `int`. Аналогичным образом, для операции `i * d`, где `i` — `int` и `d` — `double`, разрешения перегрузки выбирается `operator *(double,double)` как оператор рекомендации.

#### <a name="unary-numeric-promotions"></a>Числовое расширение унарных операторов

Унарный Числовое расширение выполняется для операндов предопределенного `+`, `-`, и `~` унарные операторы. Числовое расширение унарный состоит всего лишь преобразования операндов типа `sbyte`, `byte`, `short`, `ushort`, или `char` ввода `int`. Кроме того, для унарных `-` оператор, унарный Числовое расширение преобразует операнды типа `uint` ввода `long`.

#### <a name="binary-numeric-promotions"></a>Числовое расширение бинарных операторов

Числовое расширение выполняется для операндов предопределенного `+`, `-`, `*`, `/`, `%`, `&`, `|`, `^`, `==`, `!=`, `>`, `<`, `>=`, и `<=` бинарных операторов. Числовое расширение оба операнда преобразуются в общий тип, который в случае операторов, также становится тип результата операции. Числовое расширение состоит в применении следующие правила, в порядке, в котором они отображаются здесь:

*  Если один из операндов имеет тип `decimal`, то другой операнд преобразуется в тип `decimal`, или возникает ошибка времени привязки, если другой операнд имеет тип `float` или `double`.
*  В противном случае, если один из операндов имеет тип `double`, то другой операнд преобразуется в тип `double`.
*  В противном случае, если один из операндов имеет тип `float`, то другой операнд преобразуется в тип `float`.
*  В противном случае, если один из операндов имеет тип `ulong`, то другой операнд преобразуется в тип `ulong`, или возникает ошибка времени привязки, если другой операнд имеет тип `sbyte`, `short`, `int`, или `long`.
*  В противном случае, если один из операндов имеет тип `long`, то другой операнд преобразуется в тип `long`.
*  В противном случае, если один из операндов имеет тип `uint` и другой операнд имеет тип `sbyte`, `short`, или `int`, оба операнда преобразуются в тип `long`.
*  В противном случае, если один из операндов имеет тип `uint`, то другой операнд преобразуется в тип `uint`.
*  В противном случае оба операнда преобразуются в тип `int`.

Обратите внимание, что первое правило запрещает любые операции, сочетающие в себе `decimal` тип с `double` и `float` типов. Это правило вытекает из тот факт, что отсутствуют неявные преобразования между `decimal` типа и `double` и `float` типов.

Также Обратите внимание, что операнд типа `ulong` Если другой операнд относится целочисленным типом со знаком. Причина в том, что целочисленный тип не существует, может представлять весь спектр `ulong` и целочисленных типов со знаком.

В обоих указанных случаях можно использовать для явного преобразования один операнд с типом, который совместим с другой операнд выражения приведения.

В примере
```csharp
decimal AddPercent(decimal x, double percent) {
    return x * (1.0 + percent / 100.0);
}
```
во время привязки возникает из-за `decimal` нельзя будет умножено на `double`. Эта ошибка устраняется путем явного преобразования второго операнда `decimal`, как показано ниже:

```csharp
decimal AddPercent(decimal x, double percent) {
    return x * (decimal)(1.0 + percent / 100.0);
}
```

### <a name="lifted-operators"></a>Поднятые операторы

***Снято операторы*** разрешить стандартные и определяемые пользователем операторы, которые работают с типами не поддерживающий значение NULL, также можно использовать с обнуляемых типов. Поднятые операторы формируются на основе предопределенных и определяемых пользователем операторов, которые соответствуют определенным требованиям, как описано в следующем примере:

*   Для унарных операторов

    ```csharp
    +  ++  -  --  !  ~
    ```

    поднятые форма оператора существует, если типы операнд и результат обоих типов не поддерживающий значение NULL. Поднятые формы строится путем добавления одного `?` модификатор типы операнд и результат. Поднятые оператор создает значение null, если операнд имеет значение null. В противном случае оператор ликвидированный распаковывает операнд, применяется базовый оператор и заключает результат.

*   Для бинарных операторов

    ```csharp
    +  -  *  /  %  &  |  ^  <<  >>
    ```

    поднятые форма оператора существует, если операнд и результат типы являются все типы значений, не допускающие значения NULL. Поднятые формы строится путем добавления одного `?` модификатор к каждому типу операнд и результат. Поднятые оператор создает значение null, если один или оба операнда имеют значение null (исключением `&` и `|` операторы `bool?` типов, как описано в [логические операторы](expressions.md#boolean-logical-operators)). В противном случае оператор ликвидированный распаковывает операндов, применяется базовый оператор и заключает результат.

*   Для операторов равенства

    ```csharp
    ==  !=
    ```

    поднятые форма оператора существует, если доступны типы операндов не поддерживающий значение NULL типов и если тип результата — `bool`. Поднятые формы строится путем добавления одного `?` модификатор для каждого типа операнда. Оператор ликвидированный считает, что два значения null равны и значение null не равны, если любое значение, отличное от null. Если оба операнда не равны null, оператор ликвидированный распаковывает операнды и применяется базовый оператор для создания `bool` результат.

*   Для операторов отношения

    ```csharp
    <  >  <=  >=
    ```

    поднятые форма оператора существует, если доступны типы операндов не поддерживающий значение NULL типов и если тип результата — `bool`. Поднятые формы строится путем добавления одного `?` модификатор для каждого типа операнда. Оператор ликвидированный создающее значение `false` Если один или оба операнда имеют значение null. В противном случае оператор ликвидированный распаковывает операнды и применяется базовый оператор для создания `bool` результат.

## <a name="member-lookup"></a>Поиск члена

Поиск члена — это процесс, посредством которого определяется значение имени в контексте типа. Поиск членов может выполняться как часть оценки *simple_name* ([простые имена](expressions.md#simple-names)) или *member_access* ([доступ к членам](expressions.md#member-access)) в выражение. Если *simple_name* или *member_access* возникает как *primary_expression* из *invocation_expression* ([ Вызовы методов](expressions.md#method-invocations)), говорят, что член должен быть вызван.

Если элемент является метод или событие, или в том случае, если это константа, поле или свойство типа делегата ([делегаты](delegates.md)) или тип `dynamic` ([динамический тип](types.md#the-dynamic-type)), то считается, что член является *invocable*.

Поиск члена считает, что не только имя члена, но число параметров типа, элемента и доступен ли элемент. В целях поиска членов универсальные методы и вложенные универсальные типы имеют число параметров типа, указанного в соответствующих объявлениях, и у всех остальных членов параметров типа.

Поиск члена с именем `N` с `K`  параметры типа в типе `T` обрабатывается следующим образом:

*  Во-первых, набор доступных членов с именем `N` определяется:
    * Если `T` является параметром типа, а затем набор представляет собой объединение наборов доступных членов с именем `N` в каждом из типов, заданный как ограничение первичного или вторичного ограничения ([ограничения параметров типа](classes.md#type-parameter-constraints)) для  `T`, а также набор доступных членов с именем `N` в `object`.
    * В противном случае набор включает все эти возможности доступны ([доступ к членам](basic-concepts.md#member-access)) члены с именем `N` в `T`, включая унаследованные члены и доступные члены с именем `N` в `object`. Если `T` — сконструированный тип, набор элементов получается путем замены аргументов типа, как описано в разделе [члены сконструированных типов](classes.md#members-of-constructed-types). Члены, включающие `override` модификатор исключаются из набора.
*  Далее, если `K` равно нулю, все вложенные типы, чьи объявления содержат параметры типа удаляются. Если `K` не равно 0, все члены с различным числом удалены параметры типа. Обратите внимание, что при `K` равно нулю, методы не тип параметров, не удаляются, так как процесс определения типа ([вывод типа](expressions.md#type-inference)) можно попытаться определить аргументы типа.
*  Затем, если член является *вызывается*, все-*invocable* элементы удаляются из набора.
*  Затем члены, которые скрыты другими членами удаляются из набора. Для каждого члена `S.M` в наборе, где `S` — это тип, в которой элемент `M` был объявлен, применяются следующие правила:
    * Если `M` является константой, поля, свойства, события или член перечисления, то все члены, объявленные в базовом типе `S` удаляются из набора.
    * Если `M` объявление типа, то все не типы, объявленные в базовом типе `S` удаляются из набора, и все объявления, с числом параметров типа в качестве типов `M` объявленный в базовом типе `S` удаляются из набора.
    * Если `M` является методом, а затем все не являющийся методом члены, объявленные в базовом типе `S` удаляются из набора.
*  После этого члены интерфейса, скрытые члены класса, удаляются из набора. Этот шаг действует только если `T` является параметром типа и `T` имеет оба действительного базового класса, отличное от `object` и эффективный интерфейс непустое значение ([ограничения параметров типа](classes.md#type-parameter-constraints)). Для каждого члена `S.M` в наборе, где `S` — это тип, в которой элемент `M` был объявлен, следующие правила применяются в том случае, если `S` является объявлением класса, отличного от `object`:
    * Если `M` является константой, поля, свойства, события, члена перечисления или объявление типа, то все члены, объявленные в объявлении интерфейса удаляются из набора.
    * Если `M` является методом, а затем из набора, а также все методы, имеющие ту же сигнатуру, что удаляются все не являющийся методом члены, объявленные в объявлении интерфейса `M` объявлен в интерфейсе объявления удаляются из набора.
*  Наконец после удаления скрытых членов, определяется результат уточняющего запроса.
    * Если набор состоит из одного члена, который не является методом, этот член является результатом поиска.
    * В противном случае если набор содержит только методы, эта группа методов является результатом поиска.
    * В противном случае уточняющего запроса является неоднозначным, и возникает ошибка во время привязки.

Для поиска элемента в типы, отличные от параметров типов и интерфейсов и член уточняющих запросов в интерфейсы, которые являются строго одиночным наследованием (каждый интерфейс в цепочке наследования имеет точно ноль или один прямой базовый интерфейс), в результате правила просто, производным скрыть члены базовых членов с тем же именем или сигнатурой. Такой поиск одиночного наследования никогда не являются неоднозначными. Неоднозначности, которые могут возникать из члена уточняющих запросов в интерфейсы множественного наследования, описаны в [доступ к членам интерфейса](interfaces.md#interface-member-access).

### <a name="base-types"></a>Базовые типы

Для поиска членов, тип `T` видимости, имеет следующие базовые типы:

*  Если `T` — `object`, затем `T` не имеет базового типа.
*  Если `T` — *enum_type*, базовые типы `T` относятся к типам классов `System.Enum`, `System.ValueType`, и `object`.
*  Если `T` — *struct_type*, базовые типы `T` относятся к типам классов `System.ValueType` и `object`.
*  Если `T` — *class_type*, базовые типы `T` являются базовыми классами из `T`, включая тип класса `object`.
*  Если `T` — *interface_type*, базовые типы `T` являются базовые интерфейсы `T` и тип класса `object`.
*  Если `T` — *array_type*, базовые типы `T` относятся к типам классов `System.Array` и `object`.
*  Если `T` — *delegate_type*, базовые типы `T` относятся к типам классов `System.Delegate` и `object`.

## <a name="function-members"></a>Функции-члены

Функции-члены — члены, содержащие исполняемые операторы. Функции-члены всегда являются членами типов и не может быть членами пространства имен. C# определяет следующие категории функций-членов:

*  Методы
*  Свойства
*  События
*  Индексаторы
*  Определяемые пользователем операторы
*  Конструкторы экземпляров
*  Статические конструкторы
*  Деструкторы

За исключением деструкторы и статические конструкторы (которые могут быть вызваны явно) инструкций, содержащихся в функции-члены, выполняются через вызовов функций-членов. Фактический синтаксис вызова функции-члена зависит от категории конкретной функции-члена.

Список аргументов ([списки аргументов](expressions.md#argument-lists)) функции-члена вызова предоставляет фактические значения или ссылки на переменные для параметров функции-члена.

Вызовы универсальных методов, могут использовать определение типа для определения набора аргументов типа для передачи в метод. Этот процесс описан в [вывод типа](expressions.md#type-inference).

Вызовы методов, индексаторов, операторов и конструкторов экземпляров использовать разрешение перегрузки, чтобы определить, какой набор кандидатов для вызова функций-членов. Этот процесс описан в [разрешение перегрузки](expressions.md#overload-resolution).

После определения конкретной функции-члена во время привязки, возможно через разрешения перегрузки, фактический процесс выполнения вызова функции-члена описан в [Проверка динамического разрешения перегрузкивовремякомпиляции](expressions.md#compile-time-checking-of-dynamic-overload-resolution).

В следующей таблице перечислены обработку, которая выполняется в конструкции, включающих шесть категорий функций-членов, которые можно вызвать явным образом. В таблице `e`, `x`, `y`, и `value` указания выражений, которые классифицируются как переменные или значения, `T` означает выражение как тип, `F` — простое имя метода и `P` — это простое имя свойства.


| __Конструкция__     | __Пример__    | __Описание__ |
|-------------------|----------------|-----------------|
| Вызов метода | `F(x,y)`       | Разрешение перегрузки применяется для выбора подходящего метода `F` в содержащем классе или структуре. Метод вызывается со списком аргументов `(x,y)`. Если метод не является `static`, выражение экземпляра имеет `this`. | 
|                   | `T.F(x,y)`     | Разрешение перегрузки применяется для выбора подходящего метода `F` в классе или структуре `T`. Ошибка времени привязки возникает, если метод не является `static`. Метод вызывается со списком аргументов `(x,y)`. | 
|                   | `e.F(x,y)`     | Разрешение перегрузки применяется для выбора наиболее подходящего метода F в класса, структуры или интерфейса, передаваемом типе `e`. Возникает ошибка времени привязки, если метод `static`. Метод вызывается с выражением экземпляра `e` и список аргументов `(x,y)`. | 
| Доступ к свойству   | `P`            | `get` Метод доступа свойства `P` вызывается в содержащем классе или структуре. Ошибка времени компиляции возникает, если `P` доступен только для записи. Если `P` не `static`, выражение экземпляра имеет `this`. | 
|                   | `P = value`    | `set` Метод доступа свойства `P` в содержащем классе или структуре вызывается со списком аргументов `(value)`. Ошибка времени компиляции возникает, если `P` доступен только для чтения. Если `P` не `static`, выражение экземпляра имеет `this`. | 
|                   | `T.P`          | `get` Метод доступа свойства `P` в классе или структуре `T` вызывается. Ошибка времени компиляции возникает, если `P` не `static` или, если `P` доступен только для записи. | 
|                   | `T.P = value`  | `set` Метод доступа свойства `P` в классе или структуре `T` вызывается со списком аргументов `(value)`. Ошибка времени компиляции возникает, если `P` не `static` или, если `P` доступен только для чтения. | 
|                   | `e.P`          | `get` Метод доступа свойства `P` в класса, структуры или интерфейса, передаваемом типе `e` вызывается с выражением экземпляра `e`. Ошибка во время привязки возникает, если `P` — `static` или, если `P` доступен только для записи. | 
|                   | `e.P = value`  | `set` Метод доступа свойства `P` в класса, структуры или интерфейса, передаваемом типе `e` вызывается с выражением экземпляра `e` и список аргументов `(value)`. Ошибка во время привязки возникает, если `P` — `static` или, если `P` доступен только для чтения. | 
| Доступ к событиям      | `E += value`   | `add` Метод доступа события `E` вызывается в содержащем классе или структуре. Если `E` является не статическим, выражение экземпляра имеет `this`. | 
|                   | `E -= value`   | `remove` Метод доступа события `E` вызывается в содержащем классе или структуре. Если `E` является не статическим, выражение экземпляра имеет `this`. | 
|                   | `T.E += value` | `add` Метод доступа события `E` в классе или структуре `T` вызывается. Ошибка во время привязки возникает, если `E` не является статическим. | 
|                   | `T.E -= value` | `remove` Метод доступа события `E` в классе или структуре `T` вызывается. Ошибка во время привязки возникает, если `E` не является статическим. | 
|                   | `e.E += value` | `add` Метод доступа события `E` в класса, структуры или интерфейса, передаваемом типе `e` вызывается с выражением экземпляра `e`. Ошибка во время привязки возникает, если `E` является статическим. | 
|                   | `e.E -= value` | `remove` Метод доступа события `E` в класса, структуры или интерфейса, передаваемом типе `e` вызывается с выражением экземпляра `e`. Ошибка во время привязки возникает, если `E` является статическим. | 
| Доступ к индексатору    | `e[x,y]`       | Разрешение перегрузки применяется для выбора наиболее подходящего индексатора в класса, структуры или интерфейса, передаваемом типе e. `get` С выражением экземпляра вызывается метод доступа индексатора `e` и список аргументов `(x,y)`. Ошибка времени привязки возникает, если индексатор доступен только для записи. | 
|                   | `e[x,y] = value` | Разрешение перегрузки применяется для выбора наиболее подходящего индексатора в класса, структуры или интерфейса, передаваемом типе `e`. `set` С выражением экземпляра вызывается метод доступа индексатора `e` и список аргументов `(x,y,value)`. Ошибка времени привязки возникает, если индексатор доступен только для чтения. | 
| Вызов оператора | `-x`         | Разрешение перегрузки применяется для выбора наиболее подходящего унарного оператора в классе или структуре, передаваемой по типу `x`. Выбранный оператор вызывается со списком аргументов `(x)`. | 
|                     | `x + y`      | Разрешение перегрузки применяется для выбора наиболее подходящего бинарного оператора в классах или структурах, передаваемых типы `x` и `y`. Выбранный оператор вызывается со списком аргументов `(x,y)`. | 
| Вызов конструктора экземпляра | `new T(x,y)` | Разрешение перегрузки применяется для выбора наиболее конструктор экземпляра в классе или структуре `T`. Конструктор экземпляра вызывается со списком аргументов `(x,y)`. | 

### <a name="argument-lists"></a>Списки аргументов

Каждый вызов функции члена и делегат содержит список аргументов, который предоставляет фактические значения или ссылки на переменные для параметров функции-члена. Синтаксис для указания списка аргументов вызова функции-члена зависит от категории функции-члена:

*  Для экземпляра конструкторов, методов, индексаторов и делегатов, аргументы указываются как *argument_list*, как описано ниже. Для индексаторов, при вызове `set` метода доступа, список аргументов дополнительно включает выражение, указанное в качестве правого операнда оператора присваивания.
*  Для свойств, список аргументов пуст, при вызове `get` метод доступа и состоит из выражения, указанного в качестве правого операнда оператора присваивания, при вызове `set` метода доступа.
*  Для событий, список аргументов, состоит из выражения, указанного в качестве правого операнда оператора `+=` или `-=` оператор.
*  Для определяемых пользователем операторов список аргументов состоит из одного операнда унарный оператор или два операнда бинарного оператора.

Аргументы свойств ([свойства](classes.md#properties)), события ([события](classes.md#events)) и определяемые пользователем операторы ([операторы](classes.md#operators)), всегда передаются в качестве значения параметров ([ Параметры по значению](classes.md#value-parameters)). Аргументы индексаторов ([индексаторы](classes.md#indexers)), всегда передаются в качестве значения параметров ([параметры по значению](classes.md#value-parameters)) или массивы параметров ([массивы параметров](classes.md#parameter-arrays)). Ссылки и выходные параметры не поддерживаются для следующих категорий функций-членов.

Аргументы вызова конструктора, метода, индексатора или делегата экземпляр указываются как *argument_list*:

```antlr
argument_list
    : argument (',' argument)*
    ;

argument
    : argument_name? argument_value
    ;

argument_name
    : identifier ':'
    ;

argument_value
    : expression
    | 'ref' variable_reference
    | 'out' variable_reference
    ;
```

*Argument_list* состоит из одного или нескольких *аргумент*s, разделенных запятыми. Каждый аргумент состоит из необязательного *имя_аргумента* следуют *argument_value*. *Аргумент* с *имя_аргумента* называется ***именованный аргумент***, тогда как *аргумент* без  *имя_аргумента* — ***позиционный аргумент***. Это ошибка для позиционного аргумента отображения после именованный аргумент в *argument_list*.

*Argument_value* может принимать одно из следующих форм:

*  *Выражение*, означает, что аргумент передается как параметр значения ([параметры по значению](classes.md#value-parameters)).
*  Ключевое слово `ref` следуют *variable_reference* ([ссылки на переменные](variables.md#variable-references)), означает, что аргумент передается как параметр по ссылке ([ссылочные параметры ](classes.md#reference-parameters)). Переменной должен быть явно присвоен ([определенного присваивания](variables.md#definite-assignment)), прежде чем их можно было передать в качестве ссылочного параметра. Ключевое слово `out` следуют *variable_reference* ([ссылки на переменные](variables.md#variable-references)), означает, что аргумент передается как выходной параметр ([выходных параметров](classes.md#output-parameters)). Переменная считается определенно присвоенной ([определенного присваивания](variables.md#definite-assignment)) следующий вызов члена функции, в котором переменная передается в качестве выходного параметра.

#### <a name="corresponding-parameters"></a>Соответствующие параметры

Для каждого аргумента в списке аргументов должен быть соответствующего параметра в функции-члена или вызываемого делегата.

Список параметров, используемые в следующем примере определяется следующим образом:

*  Виртуальные методы и индексаторы, определенные в классах список параметров выбирается из наиболее подходящего объявления или переопределить функции-члена, начиная с статический тип получателя и поиск в его базовых классов.
*  Методы интерфейса и индексаторы, выбирается в списке параметров формирования определение наиболее конкретный элемент, начиная с типом интерфейса и поиск в базовых интерфейсов. Если список уникальных параметров найден, создается список параметров с недоступными именами и без необязательных параметров, таким образом, чтобы вызовы нельзя использовать именованные параметры или пропустить необязательные аргументы.
*  Для разделяемых методов используется список параметров определяющее объявление разделяемого метода.
*  Для всех других функций-членов и делегаты имеется только один список параметров, который будет использоваться.

Позиция аргумента или параметра определяется как число аргументов или параметров, предшествует ей в списке аргументов или списка параметров.

Соответствующие параметры для аргументов членов функции устанавливаются следующим образом:

*  Аргументы в *argument_list* конструкторы экземпляров, методов, индексаторов и делегатов:
    * Позиционные аргументы, где происходит фиксированный параметр в той же позиции в списке параметров соответствует этому параметру.
    * Позиционный аргумент функции-члена с массивом параметров вызван в обычной форме соответствует в массив параметров, который должен находиться в той же позиции в списке параметров.
    * Позиционный аргумент функции-члена с массивом параметров вызывается в расширенной форме, где нет фиксированного параметра происходит в той же позиции в списке параметров, соответствующий элемент в массиве параметров.
    * Именованный аргумент соответствует параметру с тем же именем в списке параметров.
    * Для индексаторов, при вызове `set` метод доступа, выражение, указанное как правый операнд оператора присваивания соответствует неявный `value` параметр `set` объявление метода доступа.
*  Для свойств, при вызове `get` существует метода доступа — без аргументов. При вызове `set` метод доступа, выражение, указанное как правый операнд оператора присваивания соответствует неявный `value` параметр `set` объявление метода доступа.
*  Для пользовательских унарных операторов (включая преобразования) один операнд соответствует одному параметру объявления оператора.
*  Для пользовательских бинарных операторов левый операнд соответствует первому параметру, а правый операнд соответствует значению второго параметра объявления оператора.

#### <a name="run-time-evaluation-of-argument-lists"></a>Вычисление во время выполнения списков аргументов

Во время выполнения обработки вызова функции-члена ([Проверка динамического разрешения перегрузки во время компиляции](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), выражения или ссылки на переменные из списка аргументов оцениваются в порядке слева направо, как выглядит следующим образом:

*  Для параметра значения, вычисляется выражение аргумента и неявное преобразование ([неявные преобразования](conversions.md#implicit-conversions)) для соответствующего параметра типа выполняется. Результирующее значение становится начальное значение параметра в вызове функции-члена.
*  Для параметра ссылки или вывода вычисляется ссылка на переменную, и итоговое расположение хранилища становится место хранения, представленное параметром в вызове функции-члена. Если ссылка на переменную, заданной в качестве параметра ссылки или вывода является элементом массива *reference_type*, выполняется проверка во время выполнения, чтобы убедитесь, что тип элемента массива отличается от типа параметра. Если эта проверка завершается неудачно, `System.ArrayTypeMismatchException` возникает исключение.

Методов, индексаторов и конструкторы экземпляров может объявлять их крайнее правое параметр будет массивом параметров ([массивы параметров](classes.md#parameter-arrays)). Такие функции-члены вызываются нормальной форме или в их расширенными формами, в зависимости от того, который применяется ([применимого члена функции](expressions.md#applicable-function-member)):

*  Когда функция-член с массивом параметров вызывается в нормальной форме, аргумент массива параметров должно быть одно выражение, которое может быть неявно преобразован ([неявные преобразования](conversions.md#implicit-conversions)) в тип массива параметров. В этом случае в массиве параметров выступает точно параметра значения.
*  Когда функция-член с массивом параметров вызывается в расширенной форме, при вызове необходимо указать ноль или более позиционные аргументы для массива параметров, где каждый аргумент является выражение, которое может быть неявно преобразован ([неявные преобразования](conversions.md#implicit-conversions)) к типу элемента в массиве параметров. В этом случае вызов создает экземпляр типа массив с длиной, соответствующей числу аргументов, инициализирует элементы экземпляра массива с заданными значениями аргументов и использует вновь созданный экземпляр массива в качестве фактического аргумент.

Из списка аргументов всегда вычисляются в порядке, в котором они написаны. Таким образом пример
```csharp
class Test
{
    static void F(int x, int y = -1, int z = -2) {
        System.Console.WriteLine("x = {0}, y = {1}, z = {2}", x, y, z);
    }

    static void Main() {
        int i = 0;
        F(i++, i++, i++);
        F(z: i++, x: i++);
    }
}
```
выводятся следующие выходные данные
```
x = 0, y = 1, z = 2
x = 4, y = -1, z = 3
```

Правила совместного расхождения массива ([ковариацией](arrays.md#array-covariance)) разрешает значение типа массива `A[]` чтобы ссылаться на экземпляр типа массива `B[]`, если существует неявное преобразование ссылок из `B` для `A`. Из-за этих правил, когда элемент массива значений *reference_type* передается как параметр ссылки или вывода, необходимо обеспечить, что фактическим типом элемента массива идентична параметра проверки во время выполнения. В примере
```csharp
class Test
{
    static void F(ref object x) {...}

    static void Main() {
        object[] a = new object[10];
        object[] b = new string[10];
        F(ref a[0]);        // Ok
        F(ref b[1]);        // ArrayTypeMismatchException
    }
}
```
Второй вызов `F` вызывает `System.ArrayTypeMismatchException` исключение, так как тип фактического элемент `b` — `string` и не `object`.

Когда функция-член с массивом параметров вызывается в расширенной форме, вызов обрабатывается точно так, как если выражение создания массива с помощью инициализатора массива ([выражениях создания массива](expressions.md#array-creation-expressions)) была вставлена вокруг Расширенные параметры. Например при объявлении
```csharp
void F(int x, int y, params object[] args);
```
следующие вызовы расширенной формы метода
```csharp
F(10, 20);
F(10, 20, 30, 40);
F(10, 20, 1, "hello", 3.0);
```
в точности соответствуют
```csharp
F(10, 20, new object[] {});
F(10, 20, new object[] {30, 40});
F(10, 20, new object[] {1, "hello", 3.0});
```

В частности Обратите внимание на то, что создается пустой массив, при наличии ноль аргументов, вводимых для массива параметров.

Если аргументов опущены из функции-члена с соответствующими необязательными параметрами, неявно передаются аргументов по умолчанию объявления функции-члена. Так как они всегда постоянны, их оценки не влияет на порядок вычисления остальных аргументов.

### <a name="type-inference"></a>Вывод типа

При вызове универсального метода без указания аргументов типа, ***вывод типа*** процесс пытается определить аргументы типа для вызова. Наличие вывода типа позволяет использовать более удобный синтаксис для вызова универсального метода и позволяет программисту не указывать избыточных данных о типе. Например при объявлении метода:
```csharp
class Chooser
{
    static Random rand = new Random();

    public static T Choose<T>(T first, T second) {
        return (rand.Next(2) == 0)? first: second;
    }
}
```
можно вызвать `Choose` метод без явного указания аргумента типа:
```csharp
int i = Chooser.Choose(5, 213);                 // Calls Choose<int>

string s = Chooser.Choose("foo", "bar");        // Calls Choose<string>
```

Через вывод типа, аргументы типа `int` и `string` определяются из аргументов метода.

Вывод типа происходит в процессе обработки привязки во время вызова метода ([вызовы методов](expressions.md#method-invocations)) и выполняется до вызова этапе разрешения перегрузки. Если группа конкретного метода указывается в вызове метода и аргументы типа указаны как часть вызова метода, вывод типа применяется к каждый универсальный метод, в группу методов. Если вывод типа завершается успешно, выводимыми аргументами типа используются для определения типов аргументов для последующего разрешения перегрузки. Если разрешение перегрузки выбирает в качестве вызов универсального метода, выведенный тип аргументы используются как фактических аргументов для вызова. Если не удается вывести тип для конкретного метода, этот метод не участвует в разрешении перегрузки. Сбой определения типа, само по себе, не вызывает ошибку во время привязки. Тем не менее оно часто ведет к ошибке во время привязки при разрешении перегрузки не удается найти применимые методы.

Если предоставленное число аргументов отличается, чем число параметров в методе, затем определение немедленно завершается со сбоем. В противном случае предполагается, что универсальный метод имеет следующую сигнатуру:
```csharp
Tr M<X1,...,Xn>(T1 x1, ..., Tm xm)
```

При вызове метода формы `M(E1...Em)` задачей вывода типа является поиск аргументов уникальный тип `S1...Sn` для каждого параметра типа `X1...Xn` таким образом, вызов `M<S1...Sn>(E1...Em)` становится действительным.

Во время вывода каждый параметр типа `Xi` либо *фиксированной* к определенному типу `Si` или *нефиксированных* с связан набор *границы*. Каждая граница представляет собой определенный тип `T`. Изначально каждая переменная типа `Xi` является репликой с пустой набор границ.

Вывод типа происходит поэтапно. Каждый этап попытается определить аргументы типа для дополнительные переменные типа на основании результатов предыдущего этапа. На первом этапе делает некоторые начальной выводы границ, тогда как второй этап исправления переменных типа для конкретных типов и дополнительно определяет границы. Второй этап может потребоваться повторить несколько раз.

*Примечание.* Тип вывода происходит не только в том случае, при вызове универсального метода. Определение типа для преобразования групп методов описан в [вывод типа при преобразовании групп методов](expressions.md#type-inference-for-conversion-of-method-groups) и поиск это наиболее распространенный тип набора выражений, описан в [поиск это наиболее распространенный тип набора выражений](expressions.md#finding-the-best-common-type-of-a-set-of-expressions).

#### <a name="the-first-phase"></a>На первом этапе

Для каждого из аргументов метода `Ei`:

*   Если `Ei` представляет собой анонимную функцию, *явный вывод типа параметра* ([Вывод явных типов параметров](expressions.md#explicit-parameter-type-inferences)) осуществляется из `Ei` для `Ti`
*   В противном случае, если `Ei` с типом `U` и `xi` является параметром значения то *вывод по нижней границе* становится *из* `U` *для* `Ti`.
*   В противном случае, если `Ei` с типом `U` и `xi` — `ref` или `out` параметр исключение *точное определение* становится *из* `U` *для* `Ti`.
*   В противном случае — сделать вывод для этого аргумента.


#### <a name="the-second-phase"></a>Второй этап

Второй этап выполняется следующим образом:

*   Все *нефиксированных* переменных типа `Xi` какие не поддерживают *зависят от* ([зависимость](expressions.md#dependence)) любой `Xj` исправленные ([устранению](expressions.md#fixing)).
*   Если таких переменных типа не существует, все *нефиксированных* переменных типа `Xi` являются *фиксированной* для которого все указанные ниже хранения:
    *   Не существует по крайней мере один тип переменной `Xj` , зависящий от `Xi`
    *   `Xi` имеет непустой набор границ
*   Если таких переменных типа не существует и все еще существуют *нефиксированных* переменных типа, вывод типа завершается сбоем.
*   В противном случае, если нет ничего *нефиксированных* переменных типа существует, вывод типа завершается успешно.
*   В противном случае — для всех аргументов `Ei` с соответствующим типом параметра `Ti` где *выходных типов* ([выходных типов](expressions.md#output-types)) содержат *нефиксированных* переменные типа `Xj` , но *входных типов* ([входных типов](expressions.md#input-types)) этого не сделать, *вывода вывод типа* ([вывод типа вывода ](expressions.md#output-type-inferences)) становится *из* `Ei` *для* `Ti`. Затем второй этап повторяется.

#### <a name="input-types"></a>Типы входных данных

Если `E` является группой методов или неявно типизированные анонимная функция и `T` — это делегат, тип или тип дерева выражения, а затем все типы параметров `T` являются *входных типов* из `E` *с типом* `T`.

####  <a name="output-types"></a>Типы выходных данных

Если `E` группу методов или анонимной функции и `T` — это делегат, тип или тип дерева выражения, то тип возвращаемого значения `T` — *тип выходных данных* `E` *с типом*  `T`.

#### <a name="dependence"></a>Зависимость

*Нефиксированных* переменной типа `Xi` *напрямую зависит от* переменной нефиксированных типа `Xj` if для некоторых аргументов `Ek` с типом `Tk` `Xj` происходит в *тип входного* из `Ek` с типом `Tk` и `Xi` происходит в *тип выходных данных* из `Ek` с типом `Tk`.

`Xj` *зависит от* `Xi` Если `Xj` *напрямую зависит от* `Xi` или, если `Xi` *напрямую зависит от* `Xk` и `Xk` *зависит от* `Xj`. Таким образом, «зависит» является транзитивным, но не извлечение рефлексивных замыкание «напрямую зависит от».

#### <a name="output-type-inferences"></a>Вывод типа вывода

*Вывода вывод типа* становится *из* выражение `E` *для* типом `T` следующим образом:

*  Если `E` представляет собой анонимную функцию с возвращаемым типом, выводимым `U` ([выводимого возвращаемый тип](expressions.md#inferred-return-type)) и `T` — это тип делегата или тип дерева выражения с типом возвращаемого значения `Tb`, затем *вывод по нижней границе* ([нижней границам](expressions.md#lower-bound-inferences)) становится *из* `U` *для* `Tb`.
*  В противном случае, если `E` является группой методов и `T` — это тип делегата или тип дерева выражения с типами параметров `T1...Tk` и типом возвращаемого значения `Tb`и разрешение перегрузки `E` с типами `T1...Tk` дает единый метод с возвращаемым типом `U`, а затем *вывод по нижней границе* становится *из* `U` *для* `Tb`.
*  В противном случае, если `E` представляет собой выражение с типом `U`, а затем *вывод по нижней границе* становится *из* `U` *для* `T`.
*  В противном случае вывод не производится.

#### <a name="explicit-parameter-type-inferences"></a>Вывод явных типов параметров

*Явный вывод типа параметра* становится *из* выражение `E` *для* типом `T` следующим образом:

*  Если `E` является явным образом типизированной анонимной функцией с типами параметров `U1...Uk` и `T` — это тип делегата или тип дерева выражения с типами параметров `V1...Vk` затем для каждого `Ui` *точное Вывод* ([точные выводы](expressions.md#exact-inferences)) становится *из* `Ui` *для* соответствующего `Vi`.

#### <a name="exact-inferences"></a>Точный вывод

*Точное определение* *из* типом `U` *для* типом `V` выполняется следующим образом:

*  Если `V` является одним из *нефиксированных* `Xi` затем `U` добавляется к набору точное границы для `Xi`.

*  В противном случае задает `V1...Vk` и `U1...Uk` определяются путем проверки, если применим один из следующих случаев:

   *  `V` является типом массива `V1[...]` и `U` является типом массива `U1[...]` одинакового ранга кортежам
   *  `V` — Это тип `V1?` и `U` является типом `U1?`
   *  `V` — сконструированный тип `C<V1...Vk>`и `U` — сконструированный тип `C<U1...Uk>`

   Если какие-либо из этих случаев применимы затем *точное определение* становится *из* каждого `Ui` *для* соответствующего `Vi`.

*  В противном случае вывод не производится.

#### <a name="lower-bound-inferences"></a>Нижняя граница выводы

Объект *вывод по нижней границе* *из* типом `U` *для* типом `V` выполняется следующим образом:

*  Если `V` является одним из *нефиксированных* `Xi` затем `U` добавляется к набору нижней границы для `Xi`.
*  В противном случае, если `V` — это тип `V1?`и `U` — это тип `U1?` то нижняя граница вывод выполняется из `U1` для `V1`.
*  В противном случае задает `U1...Uk` и `V1...Vk` определяются путем проверки, если применим один из следующих случаев:
   *  `V` является типом массива `V1[...]` и `U` является типом массива `U1[...]` (или эффективный базовый тип которого является параметром-типом `U1[...]`) одинакового ранга кортежам
   *  `V` является одним из `IEnumerable<V1>`, `ICollection<V1>` или `IList<V1>` и `U` является одномерным массивом `U1[]`(или эффективный базовый тип которого является параметром-типом `U1[]`)
   *  `V` — сконструированный тип класса, структуры, интерфейса или делегата `C<V1...Vk>` и есть уникальный тип `C<U1...Uk>` таким образом, чтобы `U` (или, если `U` является параметром типа, его эффективным базовым классом или любым членом его эффективным набором интерфейса) — идентичен, наследует от (напрямую или косвенно), или реализует (напрямую или косвенно) `C<U1...Uk>`.

      (Ограничение «уникальности» означает, что в интерфейсе вариантов `C<T> {} class U: C<X>, C<Y> {}`, а затем сделать вывод, при выводе из `U` для `C<T>` поскольку `U1` может быть `X` или `Y`.)

   Если какие-либо из этих случаев применимы, а затем выполняется вывод *из* каждого `Ui` *для* соответствующего `Vi` следующим образом:

   *  Если `Ui` неизвестен быть ссылочным типом исключение *точное определение* выполняется
   *  В противном случае, если `U` является типом массива то *вывод по нижней границе* выполняется
   *  В противном случае, если `V` — `C<V1...Vk>` вывод зависит от параметра типа i й `C`:
      *  Если он является ковариантным то *вывод по нижней границе* выполняется.
      *  Если он является контравариантным, а затем *вывод по верхней границе* выполняется.
      *  Если он является инвариантным исключение *точное определение* выполняется.
*  В противном случае вывод не производится.

#### <a name="upper-bound-inferences"></a>Вывод верхней границы

*Вывод по верхней границе* *из* типом `U` *для* типом `V` выполняется следующим образом:

*  Если `V` является одним из *нефиксированных* `Xi` затем `U` добавляется к набору верхней границы для `Xi`.
*  В противном случае задает `V1...Vk` и `U1...Uk` определяются путем проверки, если применим один из следующих случаев:
   *  `U` является типом массива `U1[...]` и `V` является типом массива `V1[...]` одинакового ранга кортежам
   *  `U` является одним из `IEnumerable<Ue>`, `ICollection<Ue>` или `IList<Ue>` и `V` является одномерным массивом `Ve[]`
   *  `U` — Это тип `U1?` и `V` является типом `V1?`
   *  `U` — сконструированный класс, структура, интерфейс или делегат типа `C<U1...Uk>` и `V` — это класс, структура, интерфейс или делегат тип, который идентичен, наследует от (напрямую или косвенно) или реализует (напрямую или косвенно) уникальный тип `C<V1...Vk>`

      (Ограничение «уникальности» означает, что если у нас есть `interface C<T>{} class V<Z>: C<X<Z>>, C<Y<Z>>{}`, а затем сделать вывод, при выводе из `C<U1>` для `V<Q>`. Вывод не выполняется из `U1` либо `X<Q>` или `Y<Q>`.)

   Если какие-либо из этих случаев применимы, а затем выполняется вывод *из* каждого `Ui` *для* соответствующего `Vi` следующим образом:
   *  Если `Ui` неизвестен быть ссылочным типом исключение *точное определение* выполняется
   *  В противном случае, если `V` является типом массива элемент *вывод по верхней границе* выполняется
   *  В противном случае, если `U` — `C<U1...Uk>` вывод зависит от параметра типа i й `C`:
      *  Если он является ковариантным типом *вывод по верхней границе* выполняется.
      *  Если он является контравариантным, а затем *вывод по нижней границе* выполняется.
      *  Если он является инвариантным исключение *точное определение* выполняется.
*  В противном случае вывод не производится.   

#### <a name="fixing"></a>Исправления

*Нефиксированных* переменной типа `Xi` с набором границ — *фиксированной* следующим образом:

*  Набор *потенциальных типов* `Uj` начинается как набор всех типов в набор границ для `Xi`.
*  После этого будут рассмотрены каждая граница для `Xi` в свою очередь: Для каждого точного границы `U` из `Xi` все типы `Uj` которого не идентичны `U` удаляются из набора кандидатов. Для каждой нижней границы `U` из `Xi` все типы `Uj` которых является *не* неявное преобразование из `U` удаляются из набора кандидатов. Для каждой верхней границы `U` из `Xi` все типы `Uj` из которых является *не* неявное преобразование в `U` удаляются из набора кандидатов.
*  Если среди оставшихся типов-кандидатов `Uj` есть уникальный тип `V` из которой отсутствует неявное преобразование в все остальные типы-кандидаты, затем `Xi` Фиксированная `V`.
*  В противном случае — не удается вывести тип.

#### <a name="inferred-return-type"></a>Выведенный тип возвращаемого значения

Выведенный тип возвращаемого значения анонимная функция `F` используется при разрешении типа вывода и перегрузки. Выведенный тип возвращаемого значения можно определить только для анонимной функции, где все параметров, либо типы известны, так как они заданы явно, предоставляются через преобразование анонимной функции или определен во время вывода типа на во внешнем универсальный вызов метода.

***Выведен тип результата*** определяется следующим образом:

*  Если тело `F` — *выражение* с типом, то типом результата, выводимого `F` тип этого выражения.
*  Если тело `F` — *блок* и набор выражений в блоке `return` инструкции с типом наиболее распространенных `T` ([поиск это наиболее распространенный тип набора выражений](expressions.md#finding-the-best-common-type-of-a-set-of-expressions)), то типом результата, выводимого `F` является `T`.
*  В противном случае — тип результата не может быть определен для `F`.

***Вывести тип возвращаемого значения*** определяется следующим образом:

*  Если `F` является асинхронной и текст `F` является либо выражение классифицировано как nothing ([классификации выражений](expressions.md#expression-classifications)), или блок операторов, где нет операторов return содержат выражения, выводимые возвращаемого типа `System.Threading.Tasks.Task`
*  Если `F` является асинхронной и имеет тип результата, выводимого `T`, выводимые возвращаемого типа `System.Threading.Tasks.Task<T>`.
*  Если `F` синхронные и имеет тип результата, выводимого `T`, выводимые возвращаемого типа `T`.
*  В противном случае тип возвращаемого значения не может быть определен для `F`.

В качестве примера вывода типа с анонимных функций, рассмотрим `Select` метод расширения, объявленный в `System.Linq.Enumerable` класса:
```csharp
namespace System.Linq
{
    public static class Enumerable
    {
        public static IEnumerable<TResult> Select<TSource,TResult>(
            this IEnumerable<TSource> source,
            Func<TSource,TResult> selector)
        {
            foreach (TSource element in source) yield return selector(element);
        }
    }
}
```

При условии, что `System.Linq` пространство имен была импортирована с `using` предложение и имеется класс `Customer` с `Name` свойство типа `string`, `Select` метод может использоваться для выбора имен список клиентов:
```csharp
List<Customer> customers = GetCustomerList();
IEnumerable<string> names = customers.Select(c => c.Name);
```

Вызов метода расширения ([вызовы методов расширения](expressions.md#extension-method-invocations)) из `Select` обрабатывается, переписав вызова для вызова статического метода:
```csharp
IEnumerable<string> names = Enumerable.Select(customers, c => c.Name);
```

Так как аргументы типа не указаны явным образом, вывод типа позволяет определить аргументы типа. Во-первых, `customers` аргумент относится к `source` параметра, вывод типа `T` быть `Customer`. С помощью анонимной функции введите вывод процесс, описанный выше, `c` присваивается тип `Customer`и выражение `c.Name` связана с типом возвращаемого значения `selector` параметра, вывод типа `S` быть `string`. Таким образом вызов эквивалентен
```csharp
Sequence.Select<Customer,string>(customers, (Customer c) => c.Name)
```
и результат имеет тип `IEnumerable<string>`.

В следующем примере показано, как анонимный тип функции вывода позволяет информацию о типе для «поток» между аргументами в вызове универсального метода. Если метод:
```csharp
static Z F<X,Y,Z>(X value, Func<X,Y> f1, Func<Y,Z> f2) {
    return f2(f1(value));
}
```

Определение типа для вызова:
```csharp
double seconds = F("1:15:30", s => TimeSpan.Parse(s), t => t.TotalSeconds);
```
продолжается следующим образом. Во-первых, аргумент `"1:15:30"` связана с `value` параметра, вывод типа `X` быть `string`. Затем, параметр первого анонимной функции, `s`, предоставляется выведенный тип `string`и выражение `TimeSpan.Parse(s)` связана с типом возвращаемого значения `f1`, выведения `Y` быть `System.TimeSpan`. Наконец, параметр второй анонимной функции, `t`, предоставляется выведенный тип `System.TimeSpan`и выражение `t.TotalSeconds` связана с типом возвращаемого значения `f2`, выведения `Z` быть `double`. Таким образом, результат вызова имеет тип `double`.

#### <a name="type-inference-for-conversion-of-method-groups"></a>Определение типа для преобразования групп методов

Как и вызовы универсальных методов, вывод типа также должен применяться при группу методов `M` содержащий универсальный метод, преобразуется в данный тип делегата `D` ([преобразования групп методов](conversions.md#method-group-conversions)). Данного метода
```csharp
Tr M<X1...Xn>(T1 x1 ... Tm xm)
```
и группа методов `M` присваивается тип делегата `D` задачей вывода типа является поиск аргументов типа `S1...Sn` таким образом, выражение:
```csharp
M<S1...Sn>
```
становится совместимый ([объявления делегатов](delegates.md#delegate-declarations)) с `D`.

В отличие от алгоритма вывода для вызовов универсального метода, в этом случае существует только аргумент *типы*, аргумент *выражения*. В частности, нет анонимных функций и тем самым устраняет потребность в нескольких этапах вывода.

Вместо этого все `Xi` считаются *нефиксированных*и *вывод по нижней границе* становится *из* тип каждого аргумента `Uj` из `D` *для* соответствующего типа параметра `Tj` из `M`. Если для любого из `Xi` границы не найдены, не удается вывести тип. В противном случае все `Xi` являются *фиксированной* соответствующий `Si`, которой получены в результате вывода типа.

#### <a name="finding-the-best-common-type-of-a-set-of-expressions"></a>Это наиболее распространенный тип набора выражений, поиск

В некоторых случаях тип необходимо вывести для набора выражений. В частности, типы элементов этих неявно типизированные массивы и типы возвращаемого значения анонимных функций с *блок* тел находятся таким образом.

Интуитивно, исходя из набора выражений `E1...Em` этот вывод должен быть эквивалентен вызову метода
```csharp
Tr M<X>(X x1 ... X xm)
```
с помощью `Ei` как аргументы.

Точнее, вывод начинается с *нефиксированных* переменной типа `X`. *Вывод типа вывода* становятся *из* каждого `Ei` *для* `X`. Наконец `X` является *фиксированной* и в случае успеха, полученный в результате введите `S` является итоговый наиболее распространенным типом для выражений. Если нет такого `S` существует, выражения содержат наиболее общий тип отсутствует.

### <a name="overload-resolution"></a>Разрешение перегрузки

Разрешение перегрузки — это механизм времени привязки для выбора наилучший член функции для вызова при наличии списка аргументов и набора потенциальных членов функции. Разрешение перегрузки выбирает функцию-член для вызова в следующих отдельных контекстах в C#:

*  Вызов метода с именем в *invocation_expression* ([вызовы методов](expressions.md#method-invocations)).
*  Вызов конструктора экземпляра с именем в *object_creation_expression* ([выражения создания объектов](expressions.md#object-creation-expressions)).
*  Вызов метода доступа индексатора через *element_access* ([доступ к элементам](expressions.md#element-access)).
*  Вызов оператора предопределенные или определяемые пользователем, на которые ссылается выражение ([разрешение перегрузки унарного оператора](expressions.md#unary-operator-overload-resolution) и [разрешить перегрузку бинарного оператора](expressions.md#binary-operator-overload-resolution)).

Каждый из этих контекстов определяет набор потенциальных членов функции и список аргументов в своим уникальным способом, как подробно описывается в разделах, перечисленных выше. Например, набор кандидатов для вызова метода не включает методы, помеченные `override` ([поиск члена](expressions.md#member-lookup)), и методов в базовом классе не являются кандидатами, если применимо любой метод в производном классе ([ Вызовы методов](expressions.md#method-invocations)).

После определения потенциальных членов функции и список аргументов выбора наилучшего члена функции одинаков во всех случаях:

*  Имея набор применимых потенциальных членов функции, лучшие функции-члена в том, что находится набор. Если набор содержит только одну функцию-член, функция-член является наилучшим членом функции. В противном случае наилучшим членом функции является функция-член, который лучше, чем все другие функции-члены по отношению к списку аргументов при условии, что каждый член функции сравнивается со всех других функций-членов с помощью правил в [ Наилучший член функции](expressions.md#better-function-member). Если отсутствия ровно одну функцию-член, который лучше, чем все другие функции-члены, то вызов функции-члена является неоднозначным и возникает ошибка во время привязки.

В следующих разделах описывается значение условия ***применимого члена функции*** и ***наилучший член функции***.

#### <a name="applicable-function-member"></a>Применимый член функции

Функция-член считается ***применимого члена функции*** по отношению к список аргументов `A` если выполняются все следующие условия:

*  Каждый аргумент в `A` соответствует параметру в объявлении функции-члена, как описано в разделе [параметры соответствующий](expressions.md#corresponding-parameters), и любой параметр, которому соответствует аргумент является необязательным параметром.
*  Для каждого аргумента в `A`, передача режим для аргумента параметров (т. е. значение `ref`, или `out`) идентичен режиму передачи параметра для соответствующего параметра, и
   *  для параметра значение или массив параметров, неявное преобразование ([неявные преобразования](conversions.md#implicit-conversions)) существует аргумент к типу соответствующего параметра, или
   *  для `ref` или `out` параметра, тип аргумента отличается от типа соответствующего параметра. В конце концов `ref` или `out` является псевдонимом для передаваемых аргументов.

Для функции-члена, который включает массив параметров если применимо, приведенных выше правил функцию-член, он считается применимо в его ***обычной формой***. Если функция-член, которая включает массив параметров не применим в нормальной форме, функцию-член может быть применима в его ***расширенной форме***:

*  Расширенная форма создается путем замены массива параметров в объявлении функции-члена с нуля или больше параметров значение параметра типа элемента массива, например, число аргументов в списке аргументов `A` соответствует итог число параметров. Если `A` меньшее число аргументов, чем число основных параметров в объявлении функции-члена, расширенную форму функцию-член не может быть создан и таким образом не применяется.
*  В противном случае — расширенная форма применимо, если для каждого аргумента в `A` режим передачи параметра аргумента идентичен режиму передачи параметра для соответствующего параметра, и
   *  для параметра фиксированное значение или значение параметра, созданного при расширении, неявное преобразование ([неявные преобразования](conversions.md#implicit-conversions)) существует из типа аргумента в тип соответствующего параметра, или
   *  для `ref` или `out` параметра, тип аргумента отличается от типа соответствующего параметра.

#### <a name="better-function-member"></a>Наилучший член функции

В целях определения наилучшего члена функции список урезанная аргументов типа создается содержащий только сами выражения аргументов в порядке их следования в исходном списке аргументов.

Списки параметров для каждого кандидата функции-члена формируется следующим образом:

*  Расширенная форма используется в том случае, если функция-член была применимо только в расширенной форме.
*  Необязательные параметры без соответствующих аргументов удаляются из списка параметров
*  Параметры переупорядочиваются, чтобы они встречаются в той же позиции, что соответствующий аргумент в списке аргументов.

Получает список аргументов `A` с набором выражений аргумента `{E1, E2, ..., En}` и два применимых члена функции `Mp` и `Mq` с типами параметров `{P1, P2, ..., Pn}` и `{Q1, Q2, ..., Qn}`, `Mp` определяется как ***наилучший член функции*** чем `Mq` Если

*  для каждого аргумента неявное преобразование из `Ex` для `Qx` не лучше, чем неявное преобразование из `Ex` для `Px`, и
*  для по крайней мере один аргумент, преобразование из `Ex` для `Px` лучше, чем преобразование из `Ex` для `Qx`.

При проведении этой оценки, в том случае, если `Mp` или `Mq` применима в расширенной форме, затем `Px` или `Qx` ссылается на параметр в расширенной форме списка параметров.

В случае, если параметр типа последовательности `{P1, P2, ..., Pn}` и `{Q1, Q2, ..., Qn}` эквивалентны (т. е. каждый `Pi` имеет преобразование удостоверения в соответствующий `Qi`), применяются следующие правила разрешения ничьих, в порядке, чтобы определить, тем лучше функция-член.

*  Если `Mp` — это метод, не являющегося универсальным и `Mq` является универсальным методом, затем `Mp` лучше, чем `Mq`.
*  В противном случае, если `Mp` применима в нормальной форме и `Mq` имеет `params` массива и применяется только в расширенной форме, затем `Mp` лучше, чем `Mq`.
*  В противном случае, если `Mp` объявил ли несколько параметров, чем `Mq`, затем `Mp` лучше, чем `Mq`. Это может произойти, если оба метода имеют `params` массивов того на них применимо только в расширенных формах.
*  В противном случае если все параметры `Mp` есть соответствующий аргумент, тогда как аргументы по умолчанию должны быть заменены для по крайней мере один необязательный параметр в `Mq` затем `Mp` лучше, чем `Mq`.
*  В противном случае, если `Mp` имеет более конкретные типы параметров, чем `Mq`, затем `Mp` лучше, чем `Mq`. Позвольте `{R1, R2, ..., Rn}` и `{S1, S2, ..., Sn}` представляют типы параметров, у которого отсутствуют экземпляры и нерасширенных `Mp` и `Mq`. `Mp`в типы параметров: более специфичен, чем `Mq`Если для каждого параметра `Rx` не менее точно, чем `Sx`и по крайней мере один параметр `Rx` более специфичен, чем `Sx`:
   *  Параметр типа является менее точно, чем не являющегося типом параметра.
   *  Рекурсивно, сконструированный тип является более точным, чем другой сконструированный тип (с одинаковым числом аргументов типа) Если хотя бы один аргумент типа является более точным и менее точно, чем соответствующий аргумент типа в другой аргумент типа.
   *  Тип массива указывается более специфичен, чем другой тип массива (с таким же числом измерений), если точнее, чем тип элементов второй тип первого элемента.
*  В противном случае если один член — это оператор не удален, а другой — то оператор, лучше один не удален.
*  В противном случае лучше подходящую функцию-член.

#### <a name="better-conversion-from-expression"></a>Лучшее преобразование из выражения

Неявного преобразования `C1` , преобразующий из выражения `E` к типу `T1`и неявное преобразование `C2` , преобразующий из выражения `E` к типу `T2`, `C1` — ***лучше преобразования*** чем `C2` Если `E` полностью соответствует `T2` и содержит по крайней мере одно из следующих:

* `E` точно соответствует `T1` ([точно выражении](expressions.md#exactly-matching-expression))
* `T1` является целью преобразования, лучше, чем `T2` ([подходящей целью преобразования](expressions.md#better-conversion-target))

#### <a name="exactly-matching-expression"></a>Точно соответствующее выражение

Если выражение `E` и типом `T`, `E` точности соответствует `T` Если справедливо одно из следующих условий:

*  `E` имеет тип `S`, и существует преобразование удостоверения из `S` для `T`
*  `E` представляет собой анонимную функцию, `T` является типом делегата `D` или тип дерева выражения `Expression<D>` и содержит одно из следующих:
   *  Выведенный тип возвращаемого значения `X` существует для `E` в контексте в список параметров `D` ([выводимого возвращаемый тип](expressions.md#inferred-return-type)), и существует преобразование удостоверения из `X` в тип возвращаемого значения `D`
   *  Либо `E` является синхронные и `D` с типом возврата `Y` или `E` является асинхронной и `D` с типом возврата `Task<Y>`, и содержит одно из следующих:
      * Тело `E` представляет собой выражение, в точности соответствующего `Y`
      * Тело `E` — это блок операторов, где каждый оператор return Возвращает выражение, в точности соответствующего `Y`

#### <a name="better-conversion-target"></a>Лучшая цель для преобразования

Учитывая два разных типа `T1` и `T2`, `T1` является целью преобразования, лучше, чем `T2` Если неявное преобразование из `T2` для `T1` существует, и содержит по крайней мере одно из следующих:

*  Неявное преобразование из `T1` для `T2` существует
*  `T1` является типом делегата `D1` или тип дерева выражения `Expression<D1>`, `T2` является типом делегата `D2` или тип дерева выражения `Expression<D2>`, `D1` с типом возврата `S1` и одну из содержит следующие:
   * `D2` Возвращает ли void
   * `D2` имеет тип возвращаемого значения `S2`, и `S1` является целью преобразования, лучше, чем `S2`
*  `T1` — `Task<S1>`, `T2` — `Task<S2>`, и `S1` является целью преобразования, лучше, чем `S2`
*  `T1` — `S1` или `S1?` где `S1` является целочисленным типом со знаком, и `T2` — `S2` или `S2?` где `S2` является целочисленным типом без знака. В частности:
   * `S1` — `sbyte` и `S2` — `byte`, `ushort`, `uint`, или `ulong`
   * `S1` — `short` и `S2` — `ushort`, `uint`, или `ulong`
   * `S1` — `int` и `S2` является `uint`, или `ulong`
   * `S1` — `long` и `S2` — `ulong`

#### <a name="overloading-in-generic-classes"></a>Перегрузка в универсальных классах

Хотя сигнатуры при объявлении должно быть уникальным, вполне возможно, что подстановки аргументов типа приводит к одинаковые сигнатуры. В таких случаях конечные правила разрешения перегрузки выше выберет конкретный член.

Ниже приведены примеры допустимых и недопустимых согласно этому правилу перегрузки.

```csharp
interface I1<T> {...}

interface I2<T> {...}

class G1<U>
{
    int F1(U u);                  // Overload resolution for G<int>.F1
    int F1(int i);                // will pick non-generic

    void F2(I1<U> a);             // Valid overload
    void F2(I2<U> a);
}

class G2<U,V>
{
    void F3(U u, V v);            // Valid, but overload resolution for
    void F3(V v, U u);            // G2<int,int>.F3 will fail

    void F4(U u, I1<V> v);        // Valid, but overload resolution for    
    void F4(I1<V> v, U u);        // G2<I1<int>,int>.F4 will fail

    void F5(U u1, I1<V> v2);      // Valid overload
    void F5(V v1, U u2);

    void F6(ref U u);             // valid overload
    void F6(out V v);
}
```

### <a name="compile-time-checking-of-dynamic-overload-resolution"></a>Проверка динамического разрешения перегрузки во время компиляции

Для наиболее динамически связанных операций набор возможных кандидатов для разрешения во время компиляции неизвестен. В некоторых случаях Однако набор кандидатов известен во время компиляции:

*  Вызовов статических методов с динамическими аргументами
*  Вызовы методов экземпляра, когда получатель не является динамическим выражением
*  Вызовы индексатора, когда получатель не является динамическим выражением
*  Вызовы конструктора с динамическими аргументами

В таких случаях проверку только во время компиляции выполняется для каждого кандидата см. в разделе, если любой из них возможно применить во время выполнения. Эта проверка состоит из следующих действий:

*  Определение разделяемого типа: Любой тип, аргумент, который не зависит от прямо или косвенно аргумент типа `dynamic` определяется с помощью правил [вывод типа](expressions.md#type-inference). Остальные аргументы типа неизвестны.
*  Частичная проверка: Применимость проверяется в соответствии с [применимого члена функции](expressions.md#applicable-function-member), но параметры, типы которых неизвестны.
*  Если нет кандидата проходит этот тест, возникает ошибка времени компиляции.

### <a name="function-member-invocation"></a>Вызов функции-члена

В этом разделе описывается процесс, который происходит во время выполнения для вызова определенной функции-члена. Предполагается, что во время компиляции уже определил конкретный член для вызова, возможно, применив разрешения перегрузки для набора потенциальных членов функции.

В целях описания процесса вызова функции-члены можно разделить на две категории:

*  Статические функции-члены. Это конструкторы экземпляров, статические методы, статическим свойствам и определяемые пользователем операторы. Статические функции-члены всегда не являются виртуальными.
*  Функции-члены экземпляра. Это методы экземпляра, экземпляр доступа к свойствам и методам доступа индексаторов. Экземпляр функции-члены как физическую, так и виртуальным и всегда вызываются для конкретного экземпляра. Экземпляр вычисляется выражение экземпляра, и он станет доступным в функции-члена с `this` ([такой доступ](expressions.md#this-access)).

Во время выполнения обработки вызова функции-члена состоит из следующих действий, где `M` является функцией-членом и, если `M` является членом экземпляра, `E` выражение экземпляра:

*  Если `M` является статической функцией-членом:
   * Список аргументов вычисляется, как описано в разделе [списки аргументов](expressions.md#argument-lists).
   * `M` вызывается.

*  Если `M` объявляется в функции-члене экземпляра *value_type*:
   * `E` выполняется оценка. Если эта оценка вызывает исключение, никакие дополнительные действия выполняются.
   * Если `E` не классифицируется как переменная, а затем временные локальную переменную с `E`элемента создается тип и значение `E` присваивается этой переменной. `E` затем реклассифицировать как ссылку на временный локальная переменная. Временная переменная доступна в виде `this` в `M`, но не в любом другом. Таким образом, только если `E` является true переменной является возможным для вызывающего объекта увидеть изменения, `M` вносит `this`.
   * Список аргументов вычисляется, как описано в разделе [списки аргументов](expressions.md#argument-lists).
   * `M` вызывается. Переменная ссылается `E` становится ссылается переменная `this`.

*  Если `M` объявляется в функции-члене экземпляра *reference_type*:
   * `E` выполняется оценка. Если эта оценка вызывает исключение, никакие дополнительные действия выполняются.
   * Список аргументов вычисляется, как описано в разделе [списки аргументов](expressions.md#argument-lists).
   * Если тип `E` — *value_type*, упаковка-преобразование ([осуществлять преобразования-упаковки](types.md#boxing-conversions)) выполняется, чтобы преобразовать `E` ввода `object`, и `E` считается Тип `object` в следующих шагах. В этом случае `M` может быть только членом `System.Object`.
   * Значение `E` проверяется, чтобы быть допустимыми. Если значение `E` — `null`, `System.NullReferenceException` возникает исключение и никакие дополнительные действия не выполняются.
   * Реализация функции-члена для вызова определяется:
     * Если тип времени привязки `E` является интерфейсом, функция-член является реализацией `M` предоставляемые типом времени выполнения экземпляра ссылается `E`. Эта функция-член определяется применением правил сопоставления интерфейса ([сопоставление интерфейса](interfaces.md#interface-mapping)) для определения реализации `M` предоставляемые типом времени выполнения экземпляра ссылается `E`.
     * В противном случае, если `M` входит виртуальная функция, вызываемая функция-член является реализацией `M` предоставляемые типом времени выполнения экземпляра, на который указывает `E`. Эта функция-член определяется применением правил для определения наиболее производной реализацией ([виртуальных методов](classes.md#virtual-methods)) из `M` по отношению к времени выполнения тип экземпляра, `E`.
     * В противном случае `M` является членом невиртуальной функции, а функция-член для вызова `M` сам.
   * Вызывается реализация функции-члена, определенный на предыдущем шаге. Объект, упоминаемый в `E` становится объект, упоминаемый в `this`.

#### <a name="invocations-on-boxed-instances"></a>Вызов в упакованных экземплярах

Функция-член реализуется в *value_type* можно вызывать с помощью упакованный экземпляр, *value_type* в следующих ситуациях:

*  Если функция-член имеет `override` метода, унаследованного от типа `object` и вызывается через выражение экземпляра типа `object`.
*  Когда функция-член представляет собой реализацию функции-члена и вызывается через выражение экземпляра *interface_type*.
*  Когда функция-член вызывается через делегат.

В таких ситуациях упакованный экземпляр считается содержит переменную *value_type*, и эта переменная становится ссылается переменная `this` в вызове функции-члена. В частности это означает, что при вызове функции-члена на упакованный экземпляр возможна функцию-член изменить значение, содержащееся в упакованный экземпляр.

## <a name="primary-expressions"></a>Основные выражения

Первичные выражения включают простые формы выражений.

```antlr
primary_expression
    : primary_no_array_creation_expression
    | array_creation_expression
    ;

primary_no_array_creation_expression
    : literal
    | interpolated_string_expression
    | simple_name
    | parenthesized_expression
    | member_access
    | invocation_expression
    | element_access
    | this_access
    | base_access
    | post_increment_expression
    | post_decrement_expression
    | object_creation_expression
    | delegate_creation_expression
    | anonymous_object_creation_expression
    | typeof_expression
    | checked_expression
    | unchecked_expression
    | default_value_expression
    | nameof_expression
    | anonymous_method_expression
    | primary_no_array_creation_expression_unsafe
    ;
```

Первичные выражения разделяются между *array_creation_expression*s и *primary_no_array_creation_expression*s. Рассматривая выражение создания массива таким образом, вместо того чтобы, добавив его вместе с других форм простое выражение, позволяет в грамматике запретить может ввести в заблуждение кода, такие как
```csharp
object o = new int[3][1];
```
который в противном случае будет интерпретироваться как
```csharp
object o = (new int[3])[1];
```

### <a name="literals"></a>Литералы

Объект *primary_expression* , состоящий из *литерала* ([литералы](lexical-structure.md#literals)) классифицируется как значение.


### <a name="interpolated-strings"></a>Интерполированные строки

*Interpolated_string_expression* состоит из `$` входа следуют обычный или буквального строкового литерала, при котором бреши в системе, разделяемых строками `{` и `}`, заключите выражения и форматирование спецификации. Интерполированное строковое выражение является результатом *interpolated_string_literal* , был разбит на отдельные части, как описано в разделе [интерполированные строковые литералы](lexical-structure.md#interpolated-string-literals).

```antlr
interpolated_string_expression
    : '$' interpolated_regular_string
    | '$' interpolated_verbatim_string
    ;

interpolated_regular_string
    : interpolated_regular_string_whole
    | interpolated_regular_string_start interpolated_regular_string_body interpolated_regular_string_end
    ;

interpolated_regular_string_body
    : interpolation (interpolated_regular_string_mid interpolation)*
    ;

interpolation
    : expression
    | expression ',' constant_expression
    ;

interpolated_verbatim_string
    : interpolated_verbatim_string_whole
    | interpolated_verbatim_string_start interpolated_verbatim_string_body interpolated_verbatim_string_end
    ;

interpolated_verbatim_string_body
    : interpolation (interpolated_verbatim_string_mid interpolation)+
    ;
```

*Constant_expression* интерполяции должен иметь неявное преобразование в `int`.

*Interpolated_string_expression* классифицируется как значение. Если сразу же он преобразуется в `System.IFormattable` или `System.FormattableString` с преобразование неявных интерполированной строки ([неявные интерполированные преобразования строк](conversions.md#implicit-interpolated-string-conversions)), интерполированного строкового выражения имеет этот тип. В противном случае он имеет тип `string`.

Если тип интерполированной строки `System.IFormattable` или `System.FormattableString`, значение представляет собой вызов `System.Runtime.CompilerServices.FormattableStringFactory.Create`. Если тип является `string`, значение выражения представляет собой вызов `string.Format`. В обоих случаях списке аргументов вызова состоит из строковый литерал с заполнителями для каждого интерполяции и аргумент для каждого выражения, соответствующего заполнители формата.

Формат строкового литерала составляется следующим образом, где `N` число интерполяции в *interpolated_string_expression*:

*  Если *interpolated_regular_string_whole* или *interpolated_verbatim_string_whole* соответствует `$` подписать, строковый литерал формата, то этот маркер.
*  В противном случае формат строковый литерал состоит из: 
   *  Первый *interpolated_regular_string_start* или *interpolated_verbatim_string_start*
   *  Затем для каждого номера `I` из `0` для `N-1`: 
      * Десятичное представление `I`
      * Затем, если соответствующий *интерполяции* имеет *constant_expression*, `,` (запятая) следуют десятичное представление значение *constant_expression*
      * Затем *interpolated_regular_string_mid*, *interpolated_regular_string_end*, *interpolated_verbatim_string_mid* или *interpolated_ verbatim_string_end* сразу после соответствующего интерполяции.

Последующие аргументы представляют собой *выражения* из *интерполяций* (если таковые имеются), в порядке.

TODO: примеры.


### <a name="simple-names"></a>Простые имена

Объект *simple_name* состоит из идентификатора, необязательно следует список аргументов типа:

```antlr
simple_name
    : identifier type_argument_list?
    ;
```

Объект *simple_name* либо формы `I` или формы `I<A1,...,Ak>`, где `I` — отдельный идентификатор и `<A1,...,Ak>` не является обязательной *type_argument_list*. Если аргумент *type_argument_list* будет указано, рассмотрите возможность `K` должно быть равно нулю. *Simple_name* вычисляется и классифицируется следующим образом:

*  Если `K` равно нулю и *simple_name* отображается в *блок* и, если *блок*элемента (или во внешнем *блок*в) локальный объявление переменной пространства ([объявления](basic-concepts.md#declarations)) содержит локальную переменную, параметр или константа с именем `I`, а затем *simple_name* ссылается локальная переменная, параметр или константа и классифицируется как переменная или значение.
*  Если `K` равно нулю и *simple_name* отображается в основном тексте, входящем в объявление универсального метода и если это объявление включает параметр типа с именем `I`, а затем *simple_name*ссылается на этот параметр типа.
*  В противном случае — для каждого типа экземпляра `T` ([тип экземпляра](classes.md#the-instance-type)), начиная с типом экземпляра немедленно включающего объявления типа и продолжить с типом экземпляра каждого включающего класса или структуры объявления (при его наличии):
   *  Если `K` равно нулю и объявление `T` включает параметр типа с именем `I`, а затем *simple_name* ссылается на этот параметр типа.
   *  В противном случае, если поиск члена ([поиск члена](expressions.md#member-lookup)) из `I` в `T` с `K`  аргументы типа найдено соответствие:
      * Если `T` является тип экземпляра немедленно включающего типа класса или структуры и уточняющего запроса определяет одну или несколько методов, результат — это группа методов со связанным выражением экземпляра `this`. Если указан список аргументов типа, он используется в вызове универсального метода ([вызовы методов](expressions.md#method-invocations)).
      * В противном случае, если `T` не тип экземпляра немедленно включающего типа класса или структуры, в том случае, если уточняющего запроса определяет член экземпляра, и в том случае, если возникает в теле конструктора экземпляра, методе экземпляра или метода доступа к экземпляру Результатом является таким же, как доступ к члену ([доступ к членам](expressions.md#member-access)) формы `this.I`. Это может произойти, только когда `K` равно нулю.
      * В противном случае результат является таким же, как доступ к члену ([доступ к членам](expressions.md#member-access)) формы `T.I` или `T.I<A1,...,Ak>`. В этом случае является ошибкой времени привязки для *simple_name* для ссылки на член экземпляра.

*  В противном случае — для каждого пространства имен `N`, начиная с пространством имен, в котором *simple_name* происходит, продолжая каждого включающего пространства имен (если таковые имеются) и заканчивая глобальное пространство имен, выполнив следующие действия вычисления, пока не будет обнаружена сущность:
   *  Если `K` равно нулю и `I` имя пространства имен в `N`, затем:
      * Если расположение где *simple_name* происходит заключен в объявление пространства имен для `N` и содержит объявление пространства имен *extern_alias_directive* или  *using_alias_directive* , связывает имя `I` пространства имен или тип, а затем *simple_name* является неоднозначным и возникает ошибка времени компиляции.
      * В противном случае *simple_name* ссылается на пространство имен с именем `I` в `N`.
   *  В противном случае, если `N` содержит доступный тип с именем `I` и `K`  параметрами типа, то:
      * Если `K` равно нулю и расположение где *simple_name* происходит заключен в объявление пространства имен для `N` и содержит объявление пространства имен *extern_alias_directive*или *using_alias_directive* , связывает имя `I` пространства имен или тип, а затем *simple_name* является неоднозначным и возникает ошибка времени компиляции.
      * В противном случае *namespace_or_type_name* ссылается на тип, сформированный с заданными аргументами типа.
   *  В противном случае, если расположение где *simple_name* происходит заключен в объявление пространства имен для `N`:
      * Если `K` равен нулю и содержит объявление пространства имен *extern_alias_directive* или *using_alias_directive* , связывает имя `I` с импортированное пространство имен или тип, а затем *simple_name* ссылается на это пространство имен или тип.
      * В противном случае, если объявления типов и пространств имен, импортированные с *using_namespace_directive*s и *using_static_directive*объявления пространства имен содержат ровно один доступный тип или не являющийся расширением статический член, имеющий имя `I` и `K`  параметры типа, а затем *simple_name* ссылается на этот тип или член, сформированный с заданными аргументами типа.
      * В противном случае, если пространства имен и типы, импортированные с *using_namespace_directive*объявления пространства имен содержат более чем один доступный тип или расширение метод статический член, имеющий имя `I` и `K`  параметры типа, а затем *simple_name* является неоднозначным и возникает ошибка.

   Обратите внимание, что этот этап полностью повторяет соответствующий шаг в обработке *namespace_or_type_name* ([пространства имен и тип](basic-concepts.md#namespace-and-type-names)).

*  В противном случае *simple_name* — не определено и возникает ошибка времени компиляции.


### <a name="parenthesized-expressions"></a>Выражения в скобках

Объект *parenthesized_expression* состоит из *выражение* заключены в круглые скобки.

```antlr
parenthesized_expression
    : '(' expression ')'
    ;
```

Объект *parenthesized_expression* вычисляется путем вычисления *выражение* в круглых скобках. Если *выражение* в круглых скобках обозначает пространство имен или тип, возникает ошибка времени компиляции. В противном случае результат *parenthesized_expression* является результатом вычисления содержащегося *выражение*.

### <a name="member-access"></a>Доступ к членам

Объект *member_access* состоит из *primary_expression*, *predefined_type*, или *qualified_alias_member*, а затем«`.`"токена, за которым следует *идентификатор*, при необходимости за которым следует *type_argument_list*.

```antlr
member_access
    : primary_expression '.' identifier type_argument_list?
    | predefined_type '.' identifier type_argument_list?
    | qualified_alias_member '.' identifier
    ;

predefined_type
    : 'bool'   | 'byte'  | 'char'  | 'decimal' | 'double' | 'float' | 'int' | 'long'
    | 'object' | 'sbyte' | 'short' | 'string'  | 'uint'   | 'ulong' | 'ushort'
    ;
```

*Qualified_alias_member* рабочей определяется в [Квалификаторы псевдонима пространства имен](namespaces.md#namespace-alias-qualifiers).

Объект *member_access* либо формы `E.I` или формы `E.I<A1, ..., Ak>`, где `E` — это основное выражение, `I` — отдельный идентификатор и `<A1, ..., Ak>` не является обязательной  *type_argument_list*. Если аргумент *type_argument_list* будет указано, рассмотрите возможность `K` должно быть равно нулю.

Объект *member_access* с *primary_expression* типа `dynamic` является динамическим ([динамической привязки](expressions.md#dynamic-binding)). В этом случае компилятор классифицирует доступ к члену, как доступ к свойству типа `dynamic`. Правила для определения значения *member_access* применяются во время выполнения, используя тип времени выполнения вместо во время компиляции тип *primary_expression*. Если эта классификация во время выполнения приводит к группу методов, то должен быть доступ к членам *primary_expression* из *invocation_expression*.

*Member_access* вычисляется и классифицируется следующим образом:

*  Если `K` равно нулю и `E` — это пространство имен и `E` содержит вложенное пространство имен с именем `I`, то результат этого пространства имен.
*  В противном случае, если `E` — это пространство имен и `E` содержит доступный тип с именем `I` и `K`  параметры типа, то результат тоже этот тип, сформированный с заданными аргументами типа.
*  Если `E` — *predefined_type* или *primary_expression* классифицируется как тип, если `E` не является параметром типа и при поиске элемента ([поиск члена](expressions.md#member-lookup)) из `I` в `E` с `K`  параметров типа найдено соответствие, затем `E.I` вычисляется и классифицируется следующим образом:
   *  Если `I` определяет тип, то результат тоже этот тип, сформированный с заданными аргументами типа.
   *  Если `I` определяет один или несколько методов, то результат тоже группу методов с без связанного выражения экземпляра. Если указан список аргументов типа, он используется в вызове универсального метода ([вызовы методов](expressions.md#method-invocations)).
   *  Если `I` идентифицирует `static` свойство, то результат будет доступ к свойству без связанного экземпляра выражения.
   *  Если `I` идентифицирует `static` поля:
      * Если поле является `readonly` и возникает за пределами статическом конструкторе класса или структуры, в котором объявляется поле, то результатом является значение, а именно значение статического поля `I` в `E`.
      * В противном случае результат является переменная, а именно статическое поле `I` в `E`.
   *  Если `I` идентифицирует `static` событий:
      * Если возникает внутри класса или структуры, в котором объявлено событие, и это событие было объявлено без *event_accessor_declarations* ([события](classes.md#events)), затем `E.I` обрабатывается точно так, как если `I` были статического поля.
      * В противном случае результатом является доступ к событию с без связанного выражения экземпляра.
   *  Если `I` определяет константу, то результатом является значение, а именно значение этой константы.
    * Если `I` идентифицирует элемент перечисления, то результатом является значение, а именно значение этого члена перечисления.
    * В противном случае `E.I` является недопустимой ссылкой на член, и возникает ошибка времени компиляции.
*  Если `E` доступ к свойству, индексатору, переменная или значение, тип которого — `T`и поиск члена ([поиск члена](expressions.md#member-lookup)) из `I` в `T` с `K`  аргументы типа найдено соответствие, затем `E.I` вычисляется и классифицируется следующим образом:
   *  Во-первых, если `E` свойство или индексатор, то значение свойства или получения доступа к индексатору ([значения выражений](expressions.md#values-of-expressions)) и `E` реклассифицировать как значение.
   *  Если `I` определяет один или несколько методов, то результатом является группа методов со связанным выражением экземпляра `E`. Если указан список аргументов типа, он используется в вызове универсального метода ([вызовы методов](expressions.md#method-invocations)).
   *  Если `I` определяет свойство экземпляра,
      * Если `E` — `this`, `I` определяет автоматически реализуемого свойства ([автоматически реализуемые свойства](classes.md#automatically-implemented-properties)) без метода задания и ссылка на происходит внутри конструктора для экземпляра тип класса или структуры `T`, то результатом является переменной, а именно скрытые резервное поле для автоматически свойство, заданное параметром `I` в экземпляре `T` предоставленное `this`.
      * В противном случае результатом является доступ к свойству со связанным выражением экземпляра `E`.
   *  Если `T` — *class_type* и `I` определяет поле экземпляра, *class_type*:
      * Если значение `E` — `null`, а затем `System.NullReferenceException` возникает исключение.
      * В противном случае, если поле является `readonly` и возникает за пределами конструктора экземпляра класса, в котором объявляется поле, то результатом является значение, а именно значение поля `I` в объект, упоминаемый в `E`.
      * В противном случае результат является переменная, а именно поле `I` в объект, упоминаемый в `E`.
   *  Если `T` — *struct_type* и `I` определяет поле экземпляра, *struct_type*:
      * Если `E` является значением, или если поле является `readonly` и возникает за пределами конструктора экземпляра структуры, в котором объявляется поле, то результатом является значение, а именно значение поля `I` в экземпляре структуры  `E`.
      * В противном случае результат является переменная, а именно поле `I` в экземпляре структуры по `E`.
   *  Если `I` обозначает событие экземпляра:
      * Если возникает внутри класса или структуры, в котором объявлено событие, и это событие было объявлено без *event_accessor_declarations* ([события](classes.md#events)), и ссылки не выполняются от имени левый операнд оператора `+=` или `-=` оператор, затем `E.I` обрабатывается точно так, как если `I` был полем экземпляра.
      * В противном случае результатом является доступ к событию со связанным выражением экземпляра `E`.
*  В противном случае попытки для обработки `E.I` как вызов метода расширения ([вызовы методов расширения](expressions.md#extension-method-invocations)). В случае сбоя `E.I` является недопустимой ссылкой на член, и возникает ошибка во время привязки.

#### <a name="identical-simple-names-and-type-names"></a>Идентичные простые имена и имена типов

В доступ к члену в форме `E.I`, если `E` — отдельный идентификатор и, если значение `E` как *simple_name* ([простые имена](expressions.md#simple-names)) — это константы, поля, свойства, Локальная переменная или параметр с тем же типом, что значение `E` как *type_name* ([пространства имен и тип](basic-concepts.md#namespace-and-type-names)), то оба значения из `E` , разрешено. Два возможных значения `E.I` никогда не являются неоднозначными, так как `I` обязательно должен быть членом типа `E` в обоих случаях. Другими словами, правило просто разрешает доступ к статическим членам и вложенные типы `E` где во время компиляции в противном случае возникает ошибка. Пример:
```csharp
struct Color
{
    public static readonly Color White = new Color(...);
    public static readonly Color Black = new Color(...);

    public Color Complement() {...}
}

class A
{
    public Color Color;                // Field Color of type Color

    void F() {
        Color = Color.Black;           // References Color.Black static member
        Color = Color.Complement();    // Invokes Complement() on Color field
    }

    static void G() {
        Color c = Color.White;         // References Color.White static member
    }
}
```

#### <a name="grammar-ambiguities"></a>Неоднозначность грамматики

Порождения для *simple_name* ([простые имена](expressions.md#simple-names)) и *member_access* ([доступ к членам](expressions.md#member-access)) может привести к появлению неоднозначности в Грамматика для выражений. Например оператор:
```
F(G<A,B>(7));
```
может быть интерпретирован как вызов `F` с двумя аргументами `G < A` и `B > (7)`. Кроме того, он может быть интерпретирован как вызов `F` с одним аргументом, который представляет собой вызов универсального метода `G` с двумя аргументами типа и одним обычным аргументом.

Если последовательность токенов может быть проанализировано как (в контексте) *simple_name* ([простые имена](expressions.md#simple-names)), *member_access* ([доступ к членам](expressions.md#member-access)), или *pointer_member_access* ([доступа к членам указателей](unsafe-code.md#pointer-member-access)) заканчивается *type_argument_list* ([аргументы типа](types.md#type-arguments)), токен сразу после закрывающего `>` маркер проверяется. Если он является одним из
```csharp
(  )  ]  }  :  ;  ,  .  ?  ==  !=  |  ^
```
затем *type_argument_list* сохраняется как часть *simple_name*, *member_access* или *pointer_member_access* , а также другой возможный разбор последовательность токенов, отбрасываются. В противном случае *type_argument_list* не считается частью *simple_name*, *member_access* или *pointer_member_access*, даже если нет других возможных синтаксического анализа последовательности маркеров. Обратите внимание, что эти правила не применяются при разборе *type_argument_list* в *namespace_or_type_name* ([пространства имен и тип](basic-concepts.md#namespace-and-type-names)). Оператор
```csharp
F(G<A,B>(7));
```
согласно этому правилу, интерпретируются как вызов `F` с одним аргументом, который представляет собой вызов универсального метода `G` с двумя аргументами типа и одним обычным аргументом. Операторы
```csharp
F(G < A, B > 7);
F(G < A, B >> 7);
```
будет интерпретирован как вызов `F` с двумя аргументами. Оператор
```csharp
x = F < A > +y;
```
будут интерпретироваться как оператор, больше, чем оператор и унарный оператор «плюс», «меньше», как если бы выражение было записано `x = (F < A) > (+y)`, а не как *simple_name* с *type_argument_list* следует оператор сложения двоичный файл. В инструкции
```csharp
x = y is C<T> + z;
```
токены `C<T>` интерпретируются как *namespace_or_type_name* с *type_argument_list*.

### <a name="invocation-expressions"></a>Выражения вызова

*Invocation_expression* используется для вызова метода.

```antlr
invocation_expression
    : primary_expression '(' argument_list? ')'
    ;
```

*Invocation_expression* является динамическим ([динамической привязки](expressions.md#dynamic-binding)) Если содержит по крайней мере одно из следующих:

* *Primary_expression* имеет тип времени компиляции `dynamic`.
* По крайней мере один аргумент в необязательный *argument_list* имеет тип времени компиляции `dynamic` и *primary_expression* имеет тип делегата.

В этом случае компилятор классифицирует *invocation_expression* как значение типа `dynamic`. Правила для определения значения *invocation_expression* применяются во время выполнения, используя тип времени выполнения вместо компиляции типа *primary_expression* и аргументы, которые имеют тип времени компиляции `dynamic`. Если *primary_expression* не имеет типа во время компиляции `dynamic`, то вызов метода выполнена ограниченная проверка времени компиляции, как описано в разделе [Проверка динамического разрешения перегрузки во время компиляции ](expressions.md#compile-time-checking-of-dynamic-overload-resolution).

*Primary_expression* из *invocation_expression* должно быть группой методов или значение *delegate_type*. Если *primary_expression* является группой методов *invocation_expression* вызовом метода ([вызовы методов](expressions.md#method-invocations)). Если *primary_expression* представляет собой значение *delegate_type*, *invocation_expression* является вызовом делегата ([вызовыделегатов](expressions.md#delegate-invocations)). Если *primary_expression* не является ни группу методов, ни значение *delegate_type*, возникает ошибка во время привязки.

Необязательный *argument_list* ([списки аргументов](expressions.md#argument-lists)) предоставляет значения или ссылки на переменные для параметров метода.

Результат вычисления *invocation_expression* классифицируется следующим образом:

*  Если *invocation_expression* вызывает метод или делегат, который возвращает `void`, ничего не возвращается. Выражение, которое классифицируется допускается только в контексте *statement_expression* ([операторы выражений](statements.md#expression-statements)) или в теле *lambda_expression*([Выражения анонимных функций](expressions.md#anonymous-function-expressions)). В противном случае возникает ошибка времени привязки.
*  В противном случае результатом является значение типа, возвращаемого методом или делегата.

#### <a name="method-invocations"></a>Вызовы методов

Для вызова метода *primary_expression* из *invocation_expression* должно быть группой методов. Группа методов определяет один метод для вызова или набор перегруженных методов с возможностью выбора для вызова определенного метода. В последнем случае определение метода, определенного для вызова строится на основе контекста, предоставленных типов аргументов в *argument_list*.

Во время привязки обработка вызова метода формы `M(A)`, где `M` является группой методов (возможно, включающий *type_argument_list*), и `A` не является обязательной *argument_ список*, состоит из следующих действий:

*  Создается набор методов-кандидатов для вызова метода. Для каждого метода `F` связанные с группой метод `M`:
   *  Если `F` является неуниверсальным `F` является кандидатом при:
      * `M` список аргументов типа не имеет и
      * `F` применяется по отношению к `A` ([применимого члена функции](expressions.md#applicable-function-member)).
   *  Если `F` является универсальным и `M` имеет список аргументов типа не `F` является кандидатом при:
      * Определение типа ([вывод типа](expressions.md#type-inference)) завершается успешно, предоставляющий список аргументов типа для вызова, и
      * После замены аргументов выведенный тип соответствующие параметры типа для метода, все сформированные типы в списке параметров F соответствуют их ограничений ([удовлетворяющий ограничениям](types.md#satisfying-constraints)) и список параметров `F` применяется по отношению к `A` ([применимого члена функции](expressions.md#applicable-function-member)).
   *  Если `F` является универсальным и `M` включает список аргументов типа `F` является кандидатом при:
      * `F` имеет тот же номер, тип параметров метода, как указано в списке аргументов типа, и
      * После замены аргументов типа для соответствующих параметров типа метода, все сформированные типы в списке параметров F соответствуют своим ограничениям ([удовлетворяющий ограничениям](types.md#satisfying-constraints)) и список параметров `F` применяется по отношению к `A` ([применимого члена функции](expressions.md#applicable-function-member)).
*  Набор методов-кандидатов уменьшается, чтобы содержать только методы из большинства производных типов: Для каждого метода `C.F` в наборе, где `C` — это тип, в которой метод `F` был объявлен, все методы, объявленные в базовом типе `C` удаляются из набора. Кроме того Если `C` не является типом класса `object`, все методы, объявленные в типе интерфейса удаляются из набора. (Последнее правило только влияет при группа методов является результатом поиск члена в параметр типа с действительного базового класса, отличного от объекта и эффективный интерфейс непустое значение.)
*  Если результирующий набор методов-кандидатов пуст, оставляются дальнейшей обработки по инструкциям ниже, и вместо этого будет предпринята попытка обработать вызов в виде вызова метода расширения ([вызовы методов расширения](expressions.md#extension-method-invocations)). Если это не удается, то применимых методов не существует, и возникает ошибка во время привязки.
*  Лучше всего подходит набор методов-кандидатов определяется с помощью правил разрешения перегрузки [разрешение перегрузки](expressions.md#overload-resolution). Если подходящий метод не может быть определен, вызов метода является неоднозначным, и возникает ошибка во время привязки. При разрешении перегрузки параметров универсального метода, считаются после замены аргументов типа (предоставленных или выведенных) соответствующие параметры типа метода.
*  Последняя проверка выбранного лучшего метода выполняется:
   * Метод проверяется в контексте группы методов: Если лучшим способом является статическим методом, группа методов получилась из *simple_name* или *member_access* через тип. Если лучший метод является методом экземпляра, группа методов получилась из *simple_name*, *member_access* через переменной или значения, или *base_access*. Если ни один из этих требований имеет значение true, то возникает ошибка времени привязки.
   * Если лучшим способом является универсальным методом, аргументы типа (предоставленных или выведенных) проходят проверку на соответствие ограничениям ([удовлетворяющий ограничениям](types.md#satisfying-constraints)) объявлены в универсальном методе. Если любой аргумент типа не удовлетворяет соответствующим ограничениям для параметра типа, возникает ошибка времени привязки.

После выбора метода и проверены описанные выше действия во время привязки, фактический вызов во время выполнения обрабатывается в соответствии с правилами описано в вызове функции-члена [Проверка динамического разрешения перегрузки во время компиляции ](expressions.md#compile-time-checking-of-dynamic-overload-resolution).

Интуитивно понятный правила разрешения, описанные выше действует следующим образом: Чтобы найти конкретный метод, вызванный при вызове метода, начните с тип, указанный в вызове метода и перейти вверх по цепочке наследования, пока не будет найдено объявление по крайней мере один метод применимо, доступный, отличных от переопределения. Затем выполняется вывод типа и разрешение перегрузки для набора применимо, доступный, отличных от переопределения методов, объявленных в типе и вызвать метод выбранный таким образом. Если метод не найден, предпринимается попытка обработать вызов в виде вызова метода расширения.

#### <a name="extension-method-invocations"></a>Вызовы методов расширения

При вызове метода ([вызов в упакованных экземплярах](expressions.md#invocations-on-boxed-instances)) из одной из форм
```csharp
expr . identifier ( )

expr . identifier ( args )

expr . identifier < typeargs > ( )

expr . identifier < typeargs > ( args )
```
При обычной обработке вызова применимые методы не найдены, будет предпринята попытка обработать конструкцию в виде вызова метода расширения. Если *expr* или любой из *args* имеет тип времени компиляции `dynamic`, методы расширения не будут применяться.

Целью является найти наиболее *type_name* `C`, таким образом, соответствующим вызовом статического метода могут иметь место:
```csharp
C . identifier ( expr )

C . identifier ( expr , args )

C . identifier < typeargs > ( expr )

C . identifier < typeargs > ( expr , args )
```

Метод расширения `Ci.Mj` — ***право*** если:

*  `Ci` представляет собой нестандартную невложенными класс
*  Имя `Mj` является *идентификатор*
*  `Mj` доступен и применим, при применении к аргументам, как статический метод, как показано выше
*  Существует неявное идентификаторов, ссылки или упаковки-преобразования *expr* в тип первого параметра `Mj`.

Поиск `C` продолжается следующим образом:

*  Начиная с ближайшим включающего объявление пространства имен, продолжая каждого включающего объявления пространства имен и заканчивая содержащую единицу компиляции, последующие попытки найти набор кандидатов методов расширения:
   * Если заданного пространства имен или блоке компиляции напрямую содержит объявления неуниверсального типа `Ci` с доступными методами расширения `Mj`, то набор этих методов является набор кандидатов.
   * Если типы `Ci` импортировано *using_static_declarations* и непосредственно объявлены в пространствах имен, импортированных с *using_namespace_directive*s в заданного пространства имен или блоке компиляции напрямую содержит методы расширения право `Mj`, то набор этих методов является набор кандидатов.
*  Если нет набор кандидатов не найден в любой включающего пространства имен объявление или блоке компиляции, возникает ошибка времени компиляции.
*  В противном случае разрешение перегрузки применяется к набору, как описано в разделе кандидатов ([разрешение перегрузки](expressions.md#overload-resolution)). Если один лучший метод не найден, возникает ошибка времени компиляции.
*  `C` — тип, в котором лучший метод объявлен как метод расширения.

С помощью `C` как целевой объект вызова метода затем обрабатывается как вызов статического метода ([Проверка динамического разрешения перегрузки во время компиляции](expressions.md#compile-time-checking-of-dynamic-overload-resolution)).

Указанные выше правила означают, что методы экземпляра имеют приоритет по сравнению с методами расширения, что методы расширения, доступные в объявлениях внутреннее пространство имен имеют приоритет над методы расширения, доступные в внешних объявлениях пространств имен и это расширение методы, объявленные непосредственно в пространстве имен имеют приоритет по сравнению с методами расширения, импортируются в этом же пространстве имен с помощью директивы пространства имен. Пример:
```csharp
public static class E
{
    public static void F(this object obj, int i) { }

    public static void F(this object obj, string s) { }
}

class A { }

class B
{
    public void F(int i) { }
}

class C
{
    public void F(object obj) { }
}

class X
{
    static void Test(A a, B b, C c) {
        a.F(1);              // E.F(object, int)
        a.F("hello");        // E.F(object, string)

        b.F(1);              // B.F(int)
        b.F("hello");        // E.F(object, string)

        c.F(1);              // C.F(object)
        c.F("hello");        // C.F(object)
    }
}
```

В примере `B`метод имеет приоритет над первый метод расширения, и `C`метод имеет приоритет над обоими методами расширения.

```csharp
public static class C
{
    public static void F(this int i) { Console.WriteLine("C.F({0})", i); }
    public static void G(this int i) { Console.WriteLine("C.G({0})", i); }
    public static void H(this int i) { Console.WriteLine("C.H({0})", i); }
}

namespace N1
{
    public static class D
    {
        public static void F(this int i) { Console.WriteLine("D.F({0})", i); }
        public static void G(this int i) { Console.WriteLine("D.G({0})", i); }
    }
}

namespace N2
{
    using N1;

    public static class E
    {
        public static void F(this int i) { Console.WriteLine("E.F({0})", i); }
    }

    class Test
    {
        static void Main(string[] args)
        {
            1.F();
            2.G();
            3.H();
        }
    }
}
```

Выходные данные этого примера является:
```
E.F(1)
D.G(2)
C.H(3)
```
`D.G` имеет приоритет над `C.G`, и `E.F` имеет приоритет над оба `D.F` и `C.F`.

#### <a name="delegate-invocations"></a>Вызовы делегатов

Для вызова делегата *primary_expression* из *invocation_expression* должно быть значение *delegate_type*. Кроме того, учитывая *delegate_type* быть функция-член с такой же список параметров, как *delegate_type*, *delegate_type* должно быть применимо () [Применимого члена функции](expressions.md#applicable-function-member)) по отношению к *argument_list* из *invocation_expression*.

Обработка времени выполнения вызова делегата формы `D(A)`, где `D` — *primary_expression* из *delegate_type* и `A` является необязательным *argument_list*, состоит из следующих действий:

*  `D` выполняется оценка. Если эта оценка вызывает исключение, никакие дополнительные действия выполняются.
*  Значение `D` проверяется, чтобы быть допустимыми. Если значение `D` — `null`, `System.NullReferenceException` возникает исключение и никакие дополнительные действия не выполняются.
*  В противном случае `D` является ссылкой на экземпляр делегата. Вызовы функций-членов ([Проверка динамического разрешения перегрузки во время компиляции](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) выполняются на каждом из вызываемые объекты в списке вызова делегата. Для вызываемых сущностей, состоящих из экземпляра и метод экземпляра экземпляр для вызова является экземпляром, содержащимся в вызываемая сущность.

### <a name="element-access"></a>Доступ к элементам

*Element_access* состоит из *primary_no_array_creation_expression*, за которым следует "`[`" токена, за которым следует *argument_list*, за которым следует " `]`«token. *Argument_list* состоит из одного или нескольких *аргумент*s, разделенных запятыми.

```antlr
element_access
    : primary_no_array_creation_expression '[' expression_list ']'
    ;
```

*Argument_list* из *element_access* не может содержать `ref` или `out` аргументы.

*Element_access* является динамическим ([динамической привязки](expressions.md#dynamic-binding)) Если содержит по крайней мере одно из следующих:

* *Primary_no_array_creation_expression* имеет тип времени компиляции `dynamic`.
* По крайней мере одно выражение *argument_list* имеет тип времени компиляции `dynamic` и *primary_no_array_creation_expression* не поддерживает тип массива.

В этом случае компилятор классифицирует *element_access* как значение типа `dynamic`. Правила для определения значения *element_access* применяются во время выполнения, используя тип времени выполнения вместо компиляции типа *primary_no_array_creation_expression*и *argument_list* выражения, которые имеют тип времени компиляции `dynamic`. Если *primary_no_array_creation_expression* не имеет типа во время компиляции `dynamic`, то доступ к элементам выполнена ограниченная проверка времени компиляции, как описано в разделе [проверка динамической компиляции разрешение перегрузки](expressions.md#compile-time-checking-of-dynamic-overload-resolution).

Если *primary_no_array_creation_expression* из *element_access* представляет собой значение *array_type*, *element_access* — Массив доступа ([массива доступа](expressions.md#array-access)). В противном случае *primary_no_array_creation_expression* должно быть переменной или значения из класса, структуры или тип интерфейса, который содержит один или несколько членов индексатора, в этом случае *element_access* — доступ к индексатору ([доступа к индексатору](expressions.md#indexer-access)).

#### <a name="array-access"></a>Доступ к массиву

Для доступа к массиву *primary_no_array_creation_expression* из *element_access* должно быть значение *array_type*. Кроме того *argument_list* массива не разрешен доступ должен содержать именованные аргументы. Количество выражений в *argument_list* должен быть таким же, как ранг *array_type*, и каждое выражение должно иметь тип `int`, `uint`, `long`, `ulong`, или должен неявно преобразовываться в один или несколько из этих типов.

Результат вычисления доступа к массиву является переменной типа элемента массива, а именно элемент массива, выбранный по значениям выражений в *argument_list*.

Обработка времени выполнения доступа к массиву формы `P[A]`, где `P` — *primary_no_array_creation_expression* из *array_type* и `A` является *argument_list*, состоит из следующих действий:

*  `P` выполняется оценка. Если эта оценка вызывает исключение, никакие дополнительные действия выполняются.
*  Выражения индекса *argument_list* вычисляются в порядке слева направо. После вычисления каждого выражения индекса, неявное преобразование ([неявные преобразования](conversions.md#implicit-conversions)) выполняется одно из следующих типов: `int`, `uint`, `long`, `ulong`. Будет выбран первый тип, в этом списке, для которого существует неявное преобразование. Например если выражение индекса имеет тип `short` затем неявное преобразование в `int` выполняется, так как неявные преобразования из `short` для `int` и из `short` для `long` возможны. При вычислении выражения индекса или последующих неявное преобразование возникает исключение, оцениваются следующие выражения индекса, и дальнейшие действия не выполняются.
*  Значение `P` проверяется, чтобы быть допустимыми. Если значение `P` — `null`, `System.NullReferenceException` возникает исключение и никакие дополнительные действия не выполняются.
*  Значение каждого выражения в *argument_list* проверяются на соответствие фактические границы каждого измерения массива экземпляра массива, `P`. Если одно или несколько значений выходят за пределы диапазона, `System.IndexOutOfRangeException` возникает исключение и никакие дополнительные действия не выполняются.
*  Расположение элемента массива, заданного выражениями индекса является вычисляемым, и оно становится результатом доступ к массиву.

#### <a name="indexer-access"></a>Доступ к индексатору

Для доступа к индексатору *primary_no_array_creation_expression* из *element_access* должно быть переменной или значения из класса, структуры или тип интерфейса, и этот тип должен реализовывать один или несколько индексаторы, которые можно использовать по отношению к *argument_list* из *element_access*.

Обработка времени привязки доступа к индексатору формы `P[A]`, где `P` — *primary_no_array_creation_expression* класса, структуры или тип интерфейса `T`, и `A` — *argument_list*, состоит из следующих действий:

*  Набор индексаторов, предоставляемых `T` создается. Набор состоит из всех индексаторов, объявленных в `T` или базовый тип `T` , которые не являются `override` объявления и доступны в текущем контексте ([доступ к членам](basic-concepts.md#member-access)).
*  Набор уменьшается до индексаторов, которые применимы и не скрыты другими индексаторами. Следующие правила применяются для каждого индексатора `S.I` в наборе, где `S` — это тип, в которой индексатор `I` объявляется:
   * Если `I` не применяется по отношению к `A` ([применимого члена функции](expressions.md#applicable-function-member)), затем `I` удаляется из набора.
   * Если `I` применяется по отношению к `A` ([применимого члена функции](expressions.md#applicable-function-member)), затем всех индексаторов, объявленных в базовом типе `S` удаляются из набора.
   * Если `I` применяется по отношению к `A` ([применимого члена функции](expressions.md#applicable-function-member)) и `S` не является типом класса `object`, всех индексаторов, объявленных в интерфейсе, удаляются из набора.
*  Если результирующий набор индексаторов-кандидатов пуст, то существовать нет применимых индексаторов, и возникает ошибка во время привязки.
*  Лучший индексатор из набора индексаторов-кандидатов определяется с помощью правил разрешения перегрузки [разрешение перегрузки](expressions.md#overload-resolution). Если не удается определить лучший один индексатор, доступа к индексатору является неоднозначным, и возникает ошибка во время привязки.
*  Выражения индекса *argument_list* вычисляются в порядке слева направо. Результат обработки доступа к индексатору — это выражение, которые классифицируются как доступ к индексатору. Выражения доступа к индексатору ссылается на индексатор, определенный на предыдущем шаге и имеет связанное выражение экземпляра из `P` и связанный список аргументов из `A`.

В зависимости от контекста, в котором оно использовано, доступ к индексатору приводит вызов либо *метод доступа get* или *метода доступа set* индексатора. Если доступ к индексатору является целевым объектом назначения, *метода доступа set* вызывается для присвоения нового значения ([простое присваивание](expressions.md#simple-assignment)). Во всех остальных случаях *метод доступа get* вызывается для получения текущего значения ([значения выражений](expressions.md#values-of-expressions)).

### <a name="this-access"></a>Такой доступ

Объект *this_access* состоит из ключевого слова `this`.

```antlr
this_access
    : 'this'
    ;
```

Объект *this_access* допускается только в *блок* конструктор экземпляра, методе экземпляра или метода доступа к экземпляру. Он имеет одно из следующих значений:

*  Когда `this` используется в *primary_expression* внутри конструктора экземпляра класса, он классифицируется как значение. Тип значения имеет тип экземпляра ([тип экземпляра](classes.md#the-instance-type)) класса, в котором происходит это использование, и значение является ссылкой на создаваемый объект.
*  Когда `this` используется в *primary_expression* внутри метода экземпляра или методе доступа экземпляра класса, он классифицируется как значение. Тип значения имеет тип экземпляра ([тип экземпляра](classes.md#the-instance-type)) класса, в котором происходит это использование, и значение является ссылкой на объект, для которого был вызван метод или метод доступа.
*  Когда `this` используется в *primary_expression* внутри конструктора экземпляра структуры, он классифицируется как переменная. Тип переменной является тип экземпляра ([тип экземпляра](classes.md#the-instance-type)) в течение которого происходит это использование, а переменная представляет структуры структуры. `this` Переменной конструктора экземпляра структуры ведет себя так же, как `out` параметр типа структуры — в частности, это означает, что переменной должен быть явно присвоен в каждом пути исполнения экземпляра конструктор.
*  Когда `this` используется в *primary_expression* внутри метода экземпляра или методе доступа экземпляра структуры, он классифицируется как переменная. Тип переменной является тип экземпляра ([тип экземпляра](classes.md#the-instance-type)) структуры, в котором осуществляется использование.
   * Если метод или метод доступа не является итератором ([итераторы](classes.md#iterators)), `this` переменная представляет структуру, для которого был вызван метод или метод доступа и ведет себя так же, как `ref` параметр типа структуры.
   * Если метод или метод доступа является итератором, `this` переменная представляет копию структуры, для которого был вызван метод или метод доступа и ведет себя так же, как значение параметра типа структуры.

Использование `this` в *primary_expression* в контексте, отличном от приведенных выше является ошибкой во время компиляции. В частности, это не можно будет ссылаться в `this` в статический метод, метод доступа статического свойства, или в *variable_initializer* объявления поля.

### <a name="base-access"></a>Доступ к базовым членам

Объект *base_access* состоит из ключевого слова `base` следуют либо "`.`" токена и идентификатор или значение *argument_list* заключенная в квадратные скобки:

```antlr
base_access
    : 'base' '.' identifier
    | 'base' '[' expression_list ']'
    ;
```

Объект *base_access* используется для доступа к членам базового класса, которые скрыты с такими же именами в текущем классе или структуре. Объект *base_access* допускается только в *блок* конструктор экземпляра, методе экземпляра или метода доступа к экземпляру. Когда `base.I` происходит в классе или структуре, `I` должно обозначать член базового класса этого класса или структуры. Аналогичным образом, если `base[E]` происходит в классе, применимый индексатор должен существовать в базовом классе.

Во время привязки *base_access* выражения формы `base.I` и `base[E]` вычисляются точно так же, как если бы они были написаны `((B)this).I` и `((B)this)[E]`, где `B` является базовым классом класса или структуры, в котором находится эта конструкция. Таким образом `base.I` и `base[E]` соответствуют `this.I` и `this[E]`, за исключением `this` рассматривается как экземпляр базового класса.

Когда *base_access* ссылается на элемент виртуальной функции (метода, свойства или индексатора), определение которого функции-члена для вызова во время выполнения ([Проверка динамического разрешения перегрузки во время компиляции ](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) изменяется. Функцию-член, вызываемая определяется путем нахождения наиболее производной реализацией ([виртуальных методов](classes.md#virtual-methods)) члена функции по отношению к `B` (а не по отношению к тип времени выполнения `this`, как бы обычным в системе счисления с основанием доступ). Таким образом, в пределах `override` из `virtual` функции-члена *base_access* может использоваться для вызова унаследованной реализации функции-члена. Если функция-член, на который ссылается *base_access* является абстрактным, возникает ошибка во время привязки.

### <a name="postfix-increment-and-decrement-operators"></a>Постфиксных инкремента и декремента

```antlr
post_increment_expression
    : primary_expression '++'
    ;

post_decrement_expression
    : primary_expression '--'
    ;
```

Операнд постфиксного инкремента или декремента должен быть выражением, классифицируется как переменная, доступ к свойству или индексатору. Результат операции является значение совпадает с типом операнда.

Если *primary_expression* имеет тип времени компиляции `dynamic` , а затем оператор является динамическим ([динамической привязки](expressions.md#dynamic-binding)), *post_increment_expression*или *post_decrement_expression* имеет тип времени компиляции `dynamic` и следующие правила применяются во время выполнения, используя тип среды выполнения *primary_expression*.

Если увеличить Операнд постфиксного оператора декремента является свойство или индексатор, свойство или индексатор должны иметь `get` и `set` метода доступа. Если это не так, возникает ошибка времени привязки.

Разрешение перегрузки унарного оператора ([разрешение перегрузки унарного оператора](expressions.md#unary-operator-overload-resolution)) применяется, чтобы выбрать конкретную реализацию оператора. Предопределенные `++` и `--` операторов существуют для следующих типов: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char` , `float`, `double`, `decimal`и любой тип перечисления. Предопределенный `++` операторы возвращают значение, полученное путем прибавления единицы к операнд и предварительно определенных `--` операторы возвращают значение, полученное путем вычитания 1 из операнда. В `checked` контекста, если результат сложения или вычитания находится вне диапазона типа результата, а тип результата — целый тип или тип перечисления, `System.OverflowException` возникает исключение.

Во время выполнения обработки Постфиксный инкремент или операция формы декремента `x++` или `x--` состоит из следующих действий:

*   Если `x` классифицируется как переменная:
    * `x` вычисляется для создания переменной.
    * Значение `x` сохраняется.
    * Выбранный оператор вызывается с сохраненным значением `x` аргументом.
    * Значение, возвращаемое оператором хранится в расположении, указанном при вычислении `x`.
    * Сохраненное значение `x` становится результатом операции.
*   Если `x` классифицируется как свойство или индексатор доступа:
    * Выражение экземпляра (если `x` не `static`) и список аргументов (если `x` имеет доступ к индексатору) связан `x` оцениваются, и полученные результаты используются в последующих `get` и `set` вызовы метода доступа.
    * `get` Метод доступа `x` вызывается и возвращаемое значение сохраняется.
    * Выбранный оператор вызывается с сохраненным значением `x` аргументом.
    * `set` Метод доступа `x` вызывается со значением, возвращенным оператором в качестве его `value` аргумент.
    * Сохраненное значение `x` становится результатом операции.

`++` И `--` операторы также поддерживают префикса ([префиксный инкремент и декремент операторы](expressions.md#prefix-increment-and-decrement-operators)). Как правило, результат `x++` или `x--` является значением `x` до операции, тогда как результат `++x` или `--x` является значением `x` после завершения операции. В любом случае `x` сам имеет то же значение после выполнения операции.

`operator ++` Или `operator --` реализации можно вызывать в префиксной и постфиксной форме. Это не могут существовать разные реализации операторов для обозначения.

### <a name="the-new-operator"></a>Оператор new

`new` Оператор используется для создания новых экземпляров типов.

Существует три формы `new` выражения:

*  Выражения создания объектов используются для создания новых экземпляров типов классов и типов значений.
*  Выражения создания массива используются для создания новых экземпляров типов массивов.
*  Выражения создания делегата используются для создания новых экземпляров делегатов типов.

`new` Оператор подразумевает создание экземпляра типа, но не подразумевает динамическое выделение памяти. В частности, экземпляры типов значений не требуют дополнительной памяти за пределами переменных, в которых они находятся, и динамическое распределение не происходит при `new` используется для создания экземпляров типов значений.

#### <a name="object-creation-expressions"></a>Выражения создания объектов

*Object_creation_expression* используется для создания нового экземпляра *class_type* или *value_type*.

```antlr
object_creation_expression
    : 'new' type '(' argument_list? ')' object_or_collection_initializer?
    | 'new' type object_or_collection_initializer
    ;

object_or_collection_initializer
    : object_initializer
    | collection_initializer
    ;
```

*Тип* из *object_creation_expression* должно быть *class_type*, *value_type* или *параметр_типа* . *Тип* не может быть `abstract` *class_type*.

Необязательный *argument_list* ([списки аргументов](expressions.md#argument-lists)) разрешается, только в том случае, если *тип* — *class_type* или *struct_ Тип*.

Выражения создания объекта можно опустить список аргументов конструктора и скобок при условии, что он включает в себя инициализатор объекта или коллекции. Пропуск список аргументов конструктора и скобок — эквивалентен предложению пустым списком аргументов.

Обработка выражения создания объекта, который включает в себя инициализатор объекта или коллекции включает сначала выполняется конструктор экземпляра, а затем обрабатывая инициализация члена или элемента, указанного в инициализаторе объекта ([ Инициализаторы объектов](expressions.md#object-initializers)) или коллекции ([инициализаторы](expressions.md#collection-initializers)).

Если любой из аргументов в необязательном *argument_list* имеет тип времени компиляции `dynamic` то *object_creation_expression* является динамическим ([динамической привязки](expressions.md#dynamic-binding)) следующие правила применяются во время выполнения с использованием типа во время выполнения эти аргументы *argument_list* , имеющих тип времени компиляции `dynamic`. Тем не менее, для создания объекта выполняется ограниченная проверка времени компиляции, как описано в разделе [Проверка динамического разрешения перегрузки во время компиляции](expressions.md#compile-time-checking-of-dynamic-overload-resolution).

Во время привязки обработка *object_creation_expression* формы `new T(A)`, где `T` — *class_type* или *value_type* и `A` не является обязательной *argument_list*, состоит из следующих действий:

*   Если `T` — *value_type* и `A` отсутствует:
    * *Object_creation_expression* является вызов конструктора по умолчанию. Результат *object_creation_expression* является значением типа `T`, то есть значение по умолчанию для `T` как определено в [типа System.ValueType](types.md#the-systemvaluetype-type).
*   В противном случае, если `T` — *параметр_типа* и `A` отсутствует:
    * Если нет ограничение типа значения или ограничение конструктора ([ограничения параметров типа](classes.md#type-parameter-constraints)) был указан для `T`, возникает ошибка во время привязки.
    * Результат *object_creation_expression* является значение типа времени выполнения, привязанного параметра типа, а именно результат вызова конструктора по умолчанию этого типа. Тип времени выполнения может быть ссылочным типом или типом значения.
*   В противном случае, если `T` — *class_type* или *struct_type*:
    * Если `T` — `abstract` *class_type*, возникает ошибка времени компиляции.
    * Вызываемый конструктор экземпляра определяется с помощью правил разрешения перегрузки [разрешение перегрузки](expressions.md#overload-resolution). Набор кандидатов конструкторов экземпляров состоит из всех доступный экземпляр конструкторов, объявленных в `T` по отношению к которому применимы `A` ([применимого члена функции](expressions.md#applicable-function-member)). Если набор кандидатов конструкторов экземпляров пуст или не может быть определен один лучший конструктор экземпляра, возникает ошибка времени привязки.
    * Результат *object_creation_expression* является значением типа `T`, а именно: значение, создаваемое путем вызова конструктора экземпляра, определенного в предыдущем шаге.
*  В противном случае *object_creation_expression* является недопустимым, и возникает ошибка во время привязки.

Даже если *object_creation_expression* динамически привязаны, во время компиляции тип — по-прежнему `T`.

Во время выполнения обработки *object_creation_expression* формы `new T(A)`, где `T` — *class_type* или *struct_type* и `A` не является обязательной *argument_list*, состоит из следующих действий:

*   Если `T` — *class_type*:
    * Новый экземпляр класса `T` выделяется. Если не хватает памяти для выделения нового экземпляра, `System.OutOfMemoryException` возникает исключение и никакие дополнительные действия не выполняются.
    * Все поля нового экземпляра инициализируются со значениями по умолчанию ([значения по умолчанию](variables.md#default-values)).
    * Конструктор экземпляра вызывается в соответствии с правилами вызова функции-члена ([Проверка динамического разрешения перегрузки во время компиляции](expressions.md#compile-time-checking-of-dynamic-overload-resolution)). Ссылку на созданный экземпляр автоматически передается конструктору экземпляра и экземпляр может осуществляться из этого конструктора с `this`.
*   Если `T` — *struct_type*:
    * Экземпляр типа `T` создается путем выделения временной локальной переменной. Так как конструктор экземпляра *struct_type* для явного присвоения значений для каждого поля экземпляра, необходима инициализация временной переменной не требуется.
    * Конструктор экземпляра вызывается в соответствии с правилами вызова функции-члена ([Проверка динамического разрешения перегрузки во время компиляции](expressions.md#compile-time-checking-of-dynamic-overload-resolution)). Ссылку на созданный экземпляр автоматически передается конструктору экземпляра и экземпляр может осуществляться из этого конструктора с `this`.

#### <a name="object-initializers"></a>Инициализаторы объектов

***Инициализатора объекта*** указывает значения для ноль или более полей, свойств или индексированными элементами объекта.

```antlr
object_initializer
    : '{' member_initializer_list? '}'
    | '{' member_initializer_list ',' '}'
    ;

member_initializer_list
    : member_initializer (',' member_initializer)*
    ;

member_initializer
    : initializer_target '=' initializer_value
    ;

initializer_target
    : identifier
    | '[' argument_list ']'
    ;

initializer_value
    : expression
    | object_or_collection_initializer
    ;
```

Инициализатор объекта состоит из последовательности инициализаторов членов, заключенных `{` и `}` маркеров и разделены запятыми. Каждый *member_initializer* определяет целевой объект для инициализации. *Идентификатор* необходимо присвоить имя к доступному полю или свойству объекта выполняется инициализация, тогда как *argument_list* заключены в квадратные скобки необходимо указать аргументы для индексатора доступны на инициализируемый объект. Это ошибка для инициализатора объекта для включения более чем один инициализатор элементов по одному полю или свойству.

Каждый *initializer_target* следуют знак равенства и выражение, инициализатора объекта или инициализатор коллекции. Не поддерживается для выражений внутри инициализатора объекта для ссылки на только что созданный объект, который он инициализируется.

Инициализатор члена, который указывает выражение после знака равенства обрабатывается так же, как и присваивание ([простое присваивание](expressions.md#simple-assignment)) к целевому объекту.

Инициализатор члена, который указывает инициализатора объекта, после знака равенства ***инициализатора вложенного объекта***, т. е. инициализация внедренный объект. Вместо присвоения нового значения для поля или свойства, назначения в инициализаторе вложенного объекта, рассматриваются как назначения для элементов поля или свойства. Инициализаторы вложенных объектов не может применяться к свойствам с типом значения или только для чтения полям с типом значения.

Инициализатор члена, который определяет инициализатор коллекции после знака равенства, выполняет инициализацию внедренной коллекции. Вместо назначения новой коллекции для целевого поля, свойства или индексатора, элементы, указанные в инициализаторе добавляются в коллекцию, ссылается на целевой объект. Целевой объект должен иметь тип коллекции, который удовлетворяет требованиям, указанным в [Инициализаторы коллекций](expressions.md#collection-initializers).

Аргументы для инициализатора индекса всегда вычисляется только один раз. Таким образом даже если аргументы в итоге никогда не используется начало (например, из-за пустого инициализатора вложенной), они будут вычисляться для побочного эффекта.

Следующий класс представляет точку с помощью двух координат:
```csharp
public class Point
{
    int x, y;

    public int X { get { return x; } set { x = value; } }
    public int Y { get { return y; } set { y = value; } }
}
```

Экземпляр `Point` можно создавать и инициализировать следующим образом:
```csharp
Point a = new Point { X = 0, Y = 1 };
```
который имеет тот же эффект, что
```csharp
Point __a = new Point();
__a.X = 0;
__a.Y = 1; 
Point a = __a;
```
где `__a` является невидимой и недоступной временной переменной. Следующий класс представляет собой прямоугольник, созданный из двух точек:
```csharp
public class Rectangle
{
    Point p1, p2;

    public Point P1 { get { return p1; } set { p1 = value; } }
    public Point P2 { get { return p2; } set { p2 = value; } }
}
```

Экземпляр `Rectangle` можно создавать и инициализировать следующим образом:
```csharp
Rectangle r = new Rectangle {
    P1 = new Point { X = 0, Y = 1 },
    P2 = new Point { X = 2, Y = 3 }
};
```
который имеет тот же эффект, что
```csharp
Rectangle __r = new Rectangle();
Point __p1 = new Point();
__p1.X = 0;
__p1.Y = 1;
__r.P1 = __p1;
Point __p2 = new Point();
__p2.X = 2;
__p2.Y = 3;
__r.P2 = __p2; 
Rectangle r = __r;
```
где `__r`, `__p1` и `__p2` являются временные переменные, которые в противном случае и недоступными.

Если `Rectangle`в конструктор выделяет два внедренных `Point` экземпляров
```csharp
public class Rectangle
{
    Point p1 = new Point();
    Point p2 = new Point();

    public Point P1 { get { return p1; } }
    public Point P2 { get { return p2; } }
}
```
Следующая конструкция может использоваться для инициализации внедренный `Point` экземпляров, вместо назначения новых экземпляров:
```csharp
Rectangle r = new Rectangle {
    P1 = { X = 0, Y = 1 },
    P2 = { X = 2, Y = 3 }
};
```
который имеет тот же эффект, что
```csharp
Rectangle __r = new Rectangle();
__r.P1.X = 0;
__r.P1.Y = 1;
__r.P2.X = 2;
__r.P2.Y = 3;
Rectangle r = __r;
```

Если определение соответствующего языка c, в следующем примере:
```csharp
var c = new C {
    x = true,
    y = { a = "Hello" },
    z = { 1, 2, 3 },
    ["x"] = 5,
    [0,0] = { "a", "b" },
    [1,2] = {}
};
```
эквивалентно эту серию назначения:
```csharp
C __c = new C();
__c.x = true;
__c.y.a = "Hello";
__c.z.Add(1); 
__c.z.Add(2);
__c.z.Add(3);
string __i1 = "x";
__c[__i1] = 5;
int __i2 = 0, __i3 = 0;
__c[__i2,__i3].Add("a");
__c[__i2,__i3].Add("b");
int __i4 = 1, __i5 = 2;
var c = __c;
```
где `__c`и пр., созданные переменные, которые являются и недоступными к исходному коду. Обратите внимание, что аргументы для `[0,0]` вычисляется только один раз и аргументы для `[1,2]` вычисляются один раз несмотря на то, что они никогда не используются.

#### <a name="collection-initializers"></a>Инициализаторы коллекций

Инициализатор коллекции определяет элементы в коллекцию.

```antlr
collection_initializer
    : '{' element_initializer_list '}'
    | '{' element_initializer_list ',' '}'
    ;

element_initializer_list
    : element_initializer (',' element_initializer)*
    ;

element_initializer
    : non_assignment_expression
    | '{' expression_list '}'
    ;

expression_list
    : expression (',' expression)*
    ;
```

Инициализатор коллекции состоит из последовательности инициализаторов элементов, заключенных `{` и `}` маркеров и разделены запятыми. Каждый инициализатор элемента задает элемент для добавления инициализируемый объект коллекции и состоит из списка выражений, заключенных `{` и `}` маркеров и разделены запятыми.  Инициализатор элемента с одним выражением можно записать и без фигурных скобок, но не может быть выражением присваивания, чтобы избежать неоднозначности с инициализаторы членов. *Non_assignment_expression* рабочей определяется в [выражение](expressions.md#expression).

Ниже приведен пример выражения создания объекта, который включает в себя инициализатор коллекции:
```csharp
List<int> digits = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
```

Объект коллекции, к которому применяется инициализатор коллекции должны иметь тип, реализующий `System.Collections.IEnumerable` или возникает ошибка времени компиляции. Для каждого выбранного элемента в порядке, инициализатор вызывает `Add` метод для целевого объекта со списком выражения инициализатора элементов как список аргументов, применение поиске обычного элемента и разрешение для каждого вызова перегрузки. Таким образом, объект коллекции должен иметь соответствующий экземпляр или расширение метод с именем `Add` для каждого элемента инициализатора.

Следующий класс представляет контакт с именем и список номеров телефонов:
```csharp
public class Contact
{
    string name;
    List<string> phoneNumbers = new List<string>();

    public string Name { get { return name; } set { name = value; } }

    public List<string> PhoneNumbers { get { return phoneNumbers; } }
}
```

Объект `List<Contact>` можно создавать и инициализировать следующим образом:
```csharp
var contacts = new List<Contact> {
    new Contact {
        Name = "Chris Smith",
        PhoneNumbers = { "206-555-0101", "425-882-8080" }
    },
    new Contact {
        Name = "Bob Harris",
        PhoneNumbers = { "650-555-0199" }
    }
};
```
который имеет тот же эффект, что
```csharp
var __clist = new List<Contact>();
Contact __c1 = new Contact();
__c1.Name = "Chris Smith";
__c1.PhoneNumbers.Add("206-555-0101");
__c1.PhoneNumbers.Add("425-882-8080");
__clist.Add(__c1);
Contact __c2 = new Contact();
__c2.Name = "Bob Harris";
__c2.PhoneNumbers.Add("650-555-0199");
__clist.Add(__c2);
var contacts = __clist;
```
где `__clist`, `__c1` и `__c2` являются временные переменные, которые в противном случае и недоступными.

#### <a name="array-creation-expressions"></a>Выражения создания массива

*Array_creation_expression* используется для создания нового экземпляра *array_type*.

```antlr
array_creation_expression
    : 'new' non_array_type '[' expression_list ']' rank_specifier* array_initializer?
    | 'new' array_type array_initializer
    | 'new' rank_specifier array_initializer
    ;
```

Выражение создания массива из первой формы выделяет экземпляр массива тип, полученный в результате удаления всех отдельных выражений из списка выражений. Например, выражение создания массива `new int[10,20]` создает экземпляр массива типа `int[,]`и выражение создания массива `new int[10][,]` создает массив объектов типа `int[][,]`. Каждое выражение в списке выражений должен иметь тип `int`, `uint`, `long`, или `ulong`, или неявно преобразуется в один или несколько из этих типов. Значение каждого выражения определяет длину соответствующего измерения в экземпляре во вновь выделенный массива. Так как длина размерности массива должны быть неотрицательными, является ошибкой во время компиляции для *constant_expression* с отрицательными значениями в списке выражений.

Только в небезопасном контексте ([небезопасных контекстах](unsafe-code.md#unsafe-contexts)), макет массивов не определен.

Если выражение создания массива первого типа включает в себя инициализатор массива, каждое выражение в списке выражений должно быть константой, и ранга и размерности длины, указанные в списке выражений должны совпадать с инициализатором массива.

В выражение создания массива в форме во втором и третьем ранг спецификатора типа "или" ранг заданного массива должна соответствовать инициализатора массива. Длины отдельных измерений выводятся из числа элементов в каждом из соответствующих уровней вложения инициализатора массива. Таким образом выражение
```csharp
new int[,] {{0, 1}, {2, 3}, {4, 5}}
```
в точности соответствует
```csharp
new int[3, 2] {{0, 1}, {2, 3}, {4, 5}}
```

Выражение создания массива третьего типа называется ***неявно типизированные выражение создания массива***. Это похоже на второй форме, за исключением того, что тип элемента массива не указан явно, но определяется как наиболее общий тип ([поиск это наиболее распространенный тип набора выражений](expressions.md#finding-the-best-common-type-of-a-set-of-expressions)) из набора выражений в массиве инициализатор. Для многомерного массива т. е. один where *rank_specifier* содержит по крайней мере одна запятая этот набор включает в себя все *выражение*s из вложенных *array_initializer*s.

Инициализаторы массивов описаны далее в [Инициализаторы массивов](arrays.md#array-initializers).

Результат вычисления выражения создания массива классифицируется как значение, а именно: ссылка на экземпляр вновь выделенный массив. Во время выполнения обработки выражение создания массива состоит из следующих действий:

*  Длина выражения измерений *список_выражений* вычисляются в порядке слева направо. После вычисления каждого выражения, неявное преобразование ([неявные преобразования](conversions.md#implicit-conversions)) выполняется одно из следующих типов: `int`, `uint`, `long`, `ulong`. Будет выбран первый тип, в этом списке, для которого существует неявное преобразование. Если вычисление выражения или последующих неявное преобразование возникает исключение, следующие выражения оцениваются, и никакие дополнительные действия выполняются.
*  Вычисленные значения для длины по измерениям проверяются следующим образом. Если один или несколько значений меньше нуля, `System.OverflowException` возникает исключение и никакие дополнительные действия не выполняются.
*  Выделяется экземпляр массива с заданной длины по измерениям. Если не хватает памяти для выделения нового экземпляра, `System.OutOfMemoryException` возникает исключение и никакие дополнительные действия не выполняются.
*  Все элементы нового экземпляра массива инициализируются значениями по умолчанию ([значения по умолчанию](variables.md#default-values)).
*  Если выражение создания массива содержит инициализатор массива, каждое выражение в инициализаторе массива вычисляются и присваиваются соответствующим элементом массива. Вычисления и присваивания выполняются в порядке, при написании выражения в инициализаторе массива — другими словами, элементы инициализируются в порядке по возрастанию индекса, с самого правого измерения, первым. Если вычисления данного выражения или последующем присваивании в соответствующий элемент массива приводит к возникновению исключения, последующих элементов не инициализируются (и остальные элементы таким образом будут иметь значения по умолчанию).

Выражение создания массива разрешает создание экземпляра массива с элементами типа массива, но элементы такого массива должны инициализироваться вручную. Например инструкция
```csharp
int[][] a = new int[100][];
```
Создает одномерный массив с 100 элементов типа `int[]`. Начальное значение каждого элемента является `null`. Невозможно для же выражение создания массива инициализировать подмассивов и инструкции
```csharp
int[][] a = new int[100][5];        // Error
```
приводит к ошибке времени компиляции. При создании экземпляра подмассивов вместо должна выполняться вручную, как и в
```csharp
int[][] a = new int[100][];
for (int i = 0; i < 100; i++) a[i] = new int[5];
```

Массив массивов имеет форму «прямоугольная», то есть когда вложенные массивы имеют одинаковую длину, при более эффективно использовать многомерный массив. В приведенном выше примере при инициализации массива массивов создается 101 объект — один внешний массив и 100 вложенных массивов. Напротив,
```csharp
int[,] = new int[100, 5];
```
создает только один объект, двумерный массив и выполняет распределение в одной инструкции.

Ниже приведены примеры выражений создание неявно типизированного массива:
```csharp
var a = new[] { 1, 10, 100, 1000 };                       // int[]

var b = new[] { 1, 1.5, 2, 2.5 };                         // double[]

var c = new[,] { { "hello", null }, { "world", "!" } };   // string[,]

var d = new[] { 1, "one", 2, "two" };                     // Error
```

Последнее выражение вызывает ошибку времени компиляции, поскольку ни `int` , ни `string` может быть неявно преобразован в другой и введите там нет, наиболее часто. Выражение создания массива явным образом типизированной необходимо использовать таким образом, например указав используется тип `object[]`. Кроме того один из элементов можно привести к общему базовому типу, который затем станет выведенным типом элемента.

Неявно типизированный массив создания выражения можно объединить с помощью инициализатора анонимных объектов ([выражения создания анонимных объектов](expressions.md#anonymous-object-creation-expressions)) для создания анонимно типизированных структур данных. Пример:
```csharp
var contacts = new[] {
    new {
        Name = "Chris Smith",
        PhoneNumbers = new[] { "206-555-0101", "425-882-8080" }
    },
    new {
        Name = "Bob Harris",
        PhoneNumbers = new[] { "650-555-0199" }
    }
};
```

#### <a name="delegate-creation-expressions"></a>Выражения создания делегата

Объект *delegate_creation_expression* используется для создания нового экземпляра *delegate_type*.

```antlr
delegate_creation_expression
    : 'new' delegate_type '(' expression ')'
    ;
```

Аргумент выражения создания делегата должен быть группу методов, анонимная функция или значение типа времени компиляции `dynamic` или *delegate_type*. Если аргумент представляет группу методов, он определяет метод и метод экземпляра, объект, для которого создается делегат. Если аргумент представляет собой анонимную функцию непосредственно определяет параметры и тело метода целевого делегата. Если аргумент имеет значение, он определяет экземпляр делегата, для которого необходимо создать копию.

Если *выражение* имеет тип времени компиляции `dynamic`, *delegate_creation_expression* является динамическим ([динамической привязки](expressions.md#dynamic-binding)) и правил, приведенных ниже применяются во время выполнения, используя тип среды выполнения *выражение*. В противном случае правила применяются во время компиляции.

Во время привязки обработка *delegate_creation_expression* формы `new D(E)`, где `D` — *delegate_type* и `E` — *выражение* , состоит из следующих действий:

*  Если `E` является группой методов выражения создания делегата обрабатывается так же, как преобразования группы методов ([преобразования групп методов](conversions.md#method-group-conversions)) из `E` для `D`.
*  Если `E` является анонимной функцией, выражение создания делегата обрабатывается так же, как преобразование анонимной функции ([преобразования анонимных функций](conversions.md#anonymous-function-conversions)) из `E` для `D`.
*  Если `E` является значением, `E` должно быть совместимо ([объявления делегатов](delegates.md#delegate-declarations)) с `D`, и результатом является ссылкой на только что созданный делегат типа `D` , ссылающийся на вызовов в списке `E`. Если `E` не совместим с `D`, возникает ошибка времени компиляции.

Во время выполнения обработки *delegate_creation_expression* формы `new D(E)`, где `D` — *delegate_type* и `E` — *выражение* , состоит из следующих действий:

*   Если `E` является группой методов выражения создания делегата вычисляется как преобразования группы методов ([преобразования групп методов](conversions.md#method-group-conversions)) из `E` для `D`.
*   Если `E` представляет собой анонимную функцию создания делегата обрабатывается как преобразование анонимной функции из `E` для `D` ([преобразования анонимных функций](conversions.md#anonymous-function-conversions)).
*   Если `E` представляет собой значение *delegate_type*:
    * `E` выполняется оценка. Если эта оценка вызывает исключение, никакие дополнительные действия выполняются.
    * Если значение `E` — `null`, `System.NullReferenceException` возникает исключение и никакие дополнительные действия не выполняются.
    * Новый экземпляр типа делегата `D` выделяется. Если не хватает памяти для выделения нового экземпляра, `System.OutOfMemoryException` возникает исключение и никакие дополнительные действия не выполняются.
    * Новый экземпляр делегата инициализируется с такой же список вызова, как экземпляр делегата, выданный `E`.

Список вызовов делегата определяется при создании экземпляра делегата и остается неизменным в течение всего времени существования делегата. Другими словами не сможете изменить целевые вызываемые сущности делегата после его создания. При объединении двух делегатов или удалении одного из другого ([объявления делегатов](delegates.md#delegate-declarations)), результаты новый делегат, не существующий делегат имеет его содержимое изменены.

Это не позволяет создать делегат, который ссылается на свойство, индексатор, определяемого пользователем оператора, конструктор экземпляра, деструктор или статический конструктор.

Как описано выше, если делегат создается из группы методов, список формальных параметров и тип возвращаемого значения делегата определить, какой из перегруженных методов для выбора. В примере
```csharp
delegate double DoubleFunc(double x);

class A
{
    DoubleFunc f = new DoubleFunc(Square);

    static float Square(float x) {
        return x * x;
    }

    static double Square(double x) {
        return x * x;
    }
}
```
`A.f` поле инициализируется с делегатом, который ссылается на второй `Square` метод, так как этот метод точно соответствует списку формальных параметров и тип возвращаемого значения `DoubleFunc`. Второй `Square` отсутствует, во время компиляции возникает ошибка.

#### <a name="anonymous-object-creation-expressions"></a>Выражения создания анонимных объектов

*Anonymous_object_creation_expression* используется для создания объекта анонимного типа.

```antlr
anonymous_object_creation_expression
    : 'new' anonymous_object_initializer
    ;

anonymous_object_initializer
    : '{' member_declarator_list? '}'
    | '{' member_declarator_list ',' '}'
    ;

member_declarator_list
    : member_declarator (',' member_declarator)*
    ;

member_declarator
    : simple_name
    | member_access
    | base_access
    | null_conditional_member_access
    | identifier '=' expression
    ;
```

Инициализатор анонимного объекта объявляет анонимный тип и возвращает экземпляр этого типа. Анонимный тип является типом безымянного класса, который напрямую наследует от `object`. Члены анонимного типа представляют собой последовательность свойств только для чтения, которые получены из инициализатора анонимный объект, используемый для создания экземпляра типа. В частности инициализатор анонимного объекта формы
```csharp
new { p1 = e1, p2 = e2, ..., pn = en }
```
Объявляет анонимный тип формы
```csharp
class __Anonymous1
{
    private readonly T1 f1;
    private readonly T2 f2;
    ...
    private readonly Tn fn;

    public __Anonymous1(T1 a1, T2 a2, ..., Tn an) {
        f1 = a1;
        f2 = a2;
        ...
        fn = an;
    }

    public T1 p1 { get { return f1; } }
    public T2 p2 { get { return f2; } }
    ...
    public Tn pn { get { return fn; } }

    public override bool Equals(object __o) { ... }
    public override int GetHashCode() { ... }
}
```
где каждый `Tx` — это тип соответствующее выражение `ex`. Выражение, используемое в *member_declarator* должно иметь тип. Таким образом, это ошибка времени компиляции для выражения в *member_declarator* быть null или анонимной функции. Это также ошибка времени компиляции иметь небезопасный тип выражения.

Имена анонимного типа и параметра для его `Equals` метод автоматически создаются компилятором и нельзя ссылаться в тексте программы.

В той же программе два инициализатора анонимных объектов, указывающих последовательность свойств одинаковые имена и типы времени компиляции, в том же порядке, будут создавать экземпляры того же анонимного типа.

В примере
```csharp
var p1 = new { Name = "Lawnmower", Price = 495.00 };
var p2 = new { Name = "Shovel", Price = 26.95 };
p1 = p2;
```
Назначение в последней строке разрешен, так как `p1` и `p2` имеют одинаковый анонимный тип.

`Equals` И `GetHashcode` методы в анонимных типах переопределить эти методы, унаследованные от `object`и определяются на основе `Equals` и `GetHashcode` свойства, таким образом, чтобы два экземпляра одного анонимного типа равны Если и только в том случае, если равны их свойства.

Объявление члена можно сократить до простого имени ([вывод типа](expressions.md#type-inference)), доступ к членам ([Проверка динамического разрешения перегрузки во время компиляции](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), доступ к базовым членам ([базового доступа](expressions.md#base-access)) или доступ к члену с условием null ([выражения условием Null как инициализаторы проекций](expressions.md#null-conditional-expressions-as-projection-initializers)). Это называется ***инициализации проекции*** и является сокращением для объявления и назначения к свойству с тем же именем. В частности деклараторы элементов из форм
```csharp
identifier
expr.identifier
```
будут точными эквивалентами следующих, соответственно:
```csharp
identifier = identifier
identifier = expr.identifier
```

Таким образом, при инициализации проекции *идентификатор* выбирает как значение и поле или свойство, которому присваивается значение. Интуитивно понятным образом инициализатор проекции проектов не только значение, а также имя параметра.

### <a name="the-typeof-operator"></a>Оператор typeof

`typeof` Оператор используется для получения `System.Type` объекта для типа.

```antlr
typeof_expression
    : 'typeof' '(' type ')'
    | 'typeof' '(' unbound_type_name ')'
    | 'typeof' '(' 'void' ')'
    ;

unbound_type_name
    : identifier generic_dimension_specifier?
    | identifier '::' identifier generic_dimension_specifier?
    | unbound_type_name '.' identifier generic_dimension_specifier?
    ;

generic_dimension_specifier
    : '<' comma* '>'
    ;

comma
    : ','
    ;
```

В первой форме *typeof_expression* состоит из `typeof` ключевое слово и заключенные в круглые скобки *тип*. Результатом выражения этой формы является `System.Type` объект для определенного типа. Имеется только один `System.Type` объекта для любого типа. Это означает, что для типа `T`, `typeof(T) == typeof(T)` всегда имеет значение true. *Тип* не может быть `dynamic`.

Вторая форма *typeof_expression* состоит из `typeof` ключевое слово и заключенные в круглые скобки *unbound_type_name*. *Unbound_type_name* очень похожа на *type_name* ([пространства имен и тип](basic-concepts.md#namespace-and-type-names)) за исключением того, что *unbound_type_name* содержит *generic_dimension_specifier*s где *type_name* содержит *type_argument_list*s. Когда операнд *typeof_expression* представляет собой последовательность токенов, удовлетворяющий грамматики обоих *unbound_type_name* и *type_name*, а именно при нем ни *generic_dimension_specifier* ни *type_argument_list*, рассматривается как последовательность токенов *type_name*. Значение *unbound_type_name* определяется следующим образом:

*  Преобразовать последовательность токенов *type_name* путем замены каждой *generic_dimension_specifier* с *type_argument_list* с таким же числом запятых и Ключевое слово `object` каждого *type_argument*.
*  Оцените итоговый *type_name*, игнорируя все ограничения параметра типа.
*  *Unbound_type_name* разрешается несвязанного универсального типа, связанный с итоговый сконструированный тип ([привязан и несвязанные типы](types.md#bound-and-unbound-types)).

Результат *typeof_expression* является `System.Type` объект, полученный в результате непривязанным универсального типа.

Третья форма из *typeof_expression* состоит из `typeof` ключевое слово и заключенные в круглые скобки `void` ключевое слово. Результатом выражения этой формы является `System.Type` объект, представляющий отсутствие типа. Тип объекта, возвращаемого `typeof(void)` отличается от объекта типа, возвращаемого для любого типа. Этот специальный объект типа полезно в библиотеках классов, которые допускают отражение в методы на языке, где этих методов желательно иметь способ представления типа возвращаемого значения, включая void методы, с помощью экземпляра `System.Type`.

`typeof` Оператор может использоваться для параметра типа. В результате `System.Type` объект типа времени выполнения, который был привязан к параметру типа. `typeof` Оператор также может использоваться для сконструированного типа или несвязанного универсального типа ([привязан и несвязанные типы](types.md#bound-and-unbound-types)). `System.Type` Объекта для несвязанного универсального типа не является таким же, как `System.Type` объект типа экземпляра. Тип экземпляра всегда является закрытым сконструированным типом во время выполнения таким образом его `System.Type` объект зависит от выполнения аргументов типа, хотя несвязанного универсального типа не имеет типа аргументов.

Пример
```csharp
using System;

class X<T>
{
    public static void PrintTypes() {
        Type[] t = {
            typeof(int),
            typeof(System.Int32),
            typeof(string),
            typeof(double[]),
            typeof(void),
            typeof(T),
            typeof(X<T>),
            typeof(X<X<T>>),
            typeof(X<>)
        };
        for (int i = 0; i < t.Length; i++) {
            Console.WriteLine(t[i]);
        }
    }
}

class Test
{
    static void Main() {
        X<int>.PrintTypes();
    }
}
```
получается следующий результат:
```
System.Int32
System.Int32
System.String
System.Double[]
System.Void
System.Int32
X`1[System.Int32]
X`1[X`1[System.Int32]]
X`1[T]
```

Обратите внимание, что `int` и `System.Int32` относятся к одному типу.

Также Обратите внимание, что результат `typeof(X<>)` не зависит от аргумента типа, а результат `typeof(X<T>)` does.

### <a name="the-checked-and-unchecked-operators"></a>Операторы checked и unchecked

`checked` И `unchecked` операторы используются для управления ***контекстом проверки переполнения*** для целочисленных арифметических операций и преобразований.

```antlr
checked_expression
    : 'checked' '(' expression ')'
    ;

unchecked_expression
    : 'unchecked' '(' expression ')'
    ;
```

`checked` Оператор вычисляет выражение, содержащиеся в проверяемом контексте и `unchecked` оператор вычисляет содержащегося выражения в непроверенном контексте. Объект *checked_expression* или *unchecked_expression* в точности соответствует *parenthesized_expression* ([выражения в скобках](expressions.md#parenthesized-expressions)), за исключением того, что автономной выражение вычисляется в заданной контекста проверки переполнения.

Контекст проверки переполнения можно также управлять с помощью `checked` и `unchecked` инструкций ([операторы checked и unchecked](statements.md#the-checked-and-unchecked-statements)).

Следующие операции зависят от контекста, опубликованный консорциумом проверки переполнения `checked` и `unchecked` операторы и операторы:

*  Предопределенный `++` и `--` унарные операторы ([постфиксных инкремента и декремента](expressions.md#postfix-increment-and-decrement-operators) и [префиксный инкремент и декремент операторы](expressions.md#prefix-increment-and-decrement-operators)), если операнд имеет целый тип.
*  Предопределенный `-` унарный оператор ([унарный минус-оператор](expressions.md#unary-minus-operator)), если операнд является целочисленного типа.
*  Предопределенный `+`, `-`, `*`, и `/` бинарные операторы ([арифметические операторы](expressions.md#arithmetic-operators)), если оба операнда принадлежат целочисленному типу.
*  Явных числовых преобразований ([явных числовых преобразований](conversions.md#explicit-numeric-conversions)) из одного целого типа в другой целочисленный тип или из `float` или `double` в целочисленный тип.

Когда один из указанных выше операций произвести результат, слишком велико для представления в целевом типе, контекст, в котором операция управляет результирующее поведение:

*  В `checked` контекста, если операция является константным выражением ([константные выражения](expressions.md#constant-expressions)), возникает ошибка времени компиляции. В противном случае, когда выполняется операция во время выполнения, `System.OverflowException` возникает исключение.
*  В `unchecked` контекста, результат усекается путем удаления старших разрядов, которые не помещаются в целевой тип.

Для Неконстантные выражения (выражения, которые вычисляются во время выполнения), которые не заключаются по любому `checked` или `unchecked` операторы или операторы, контекстом проверки переполнения по умолчанию является `unchecked` Если внешние факторы (например, компилятор Переключение и конфигурацией среды выполнения) вызвать для `checked` оценки.

Относительно константных выражений (выражения, которые можно полностью вычислить во время компиляции), всегда является контекстом проверки переполнения по умолчанию `checked`. Если константное выражение явным образом помещается в `unchecked` контекста, переполнения, возникающие во время компиляции вычисления выражения всегда вызывать ошибки времени компиляции.

Тело анонимной функции не зависит от `checked` или `unchecked` контексты, в которых происходит анонимной функции.

В примере
```csharp
class Test
{
    static readonly int x = 1000000;
    static readonly int y = 1000000;

    static int F() {
        return checked(x * y);      // Throws OverflowException
    }

    static int G() {
        return unchecked(x * y);    // Returns -727379968
    }

    static int H() {
        return x * y;               // Depends on default
    }
}
```
ошибки компиляции не выводятся, поскольку ни одно из выражений может быть вычислено во время компиляции. Во время выполнения `F` вызывает метод `System.OverflowException`и `G` метод возвращает-727379968 (младшие 32 бита результата out of range). Поведение `H` метод зависит от контекста для компиляции проверки переполнения по умолчанию, но это либо совпадает `F` или так же, как `G`.

В примере
```csharp
class Test
{
    const int x = 1000000;
    const int y = 1000000;

    static int F() {
        return checked(x * y);      // Compile error, overflow
    }

    static int G() {
        return unchecked(x * y);    // Returns -727379968
    }

    static int H() {
        return x * y;               // Compile error, overflow
    }
}
```
переполнения, возникающие при вычислении константных выражений в `F` и `H` привести к ошибкам во время компиляции, потому что выражения вычисляются в `checked` контекста. Также может произойти переполнение при вычислении константного выражения в `G`, но поскольку вычисление выполняется `unchecked` контекста, переполнение не сообщается.

`checked` И `unchecked` операторы влияют только на контекст для тех операций, содержащихся в текстовой форме проверки переполнения "`(`«и»`)`" маркеров. Операторы не оказывают влияния на функции-члены, которые будут вызываться в результате вычисления выражения автономной. В примере
```csharp
class Test
{
    static int Multiply(int x, int y) {
        return x * y;
    }

    static int F() {
        return checked(Multiply(1000000, 1000000));
    }
}
```
Использование `checked` в `F` не влияет на вычисления `x * y` в `Multiply`, поэтому `x * y` вычисляется в контекст проверки переполнения по умолчанию.

`unchecked` Оператор удобно при написании константы целочисленных типов со знаком в шестнадцатеричном формате. Пример:
```csharp
class Test
{
    public const int AllBits = unchecked((int)0xFFFFFFFF);

    public const int HighBit = unchecked((int)0x80000000);
}
```

Оба шестнадцатеричные константы выше относятся к типу `uint`. Так как используются следующие константы за пределами `int` диапазон "," без `unchecked` оператор, приведения в `int` будет приводить к ошибкам компиляции.

`checked` И `unchecked` операторы и операторы позволяют программистам управлять некоторыми аспектами некоторых числовых вычислений. Тем не менее поведение некоторых числовых операторов зависит от типов данных их операндов. Например, умножение двух десятичных чисел всегда вызывает исключение в случае переполнения даже в явно `unchecked` построения. Аналогичным образом, умножение двух смещает никогда не результатов в исключение в случае переполнения даже в явно `checked` построения. Кроме того, другие операторы никогда не затрагивает режимом проверки, как по умолчанию или неявным.

### <a name="default-value-expressions"></a>Выражения значения по умолчанию

Выражение значения по умолчанию используется для получения значения по умолчанию ([значения по умолчанию](variables.md#default-values)) типа. Обычно выражение значения по умолчанию используется для параметров типа, так как он не может быть известен, если параметр типа является типом значения или ссылочным типом. (Не существует преобразования из `null` литерала к параметру типа, если не известно, параметр типа ссылочным типом.)

```antlr
default_value_expression
    : 'default' '(' type ')'
    ;
```

Если *тип* в *default_value_expression* оценивает во время выполнения для ссылочного типа, результатом является `null` привести к этому типу. Если *тип* в *default_value_expression* оценивает во время выполнения к типу значения, результатом является *value_type*значение по умолчанию ([по умолчанию конструкторы](types.md#default-constructors)).

Объект *default_value_expression* является константным выражением ([константные выражения](expressions.md#constant-expressions)) Если тип является ссылочным типом или параметром типа, который известен быть ссылочным типом ([параметр типа ограничения](classes.md#type-parameter-constraints)). Кроме того *default_value_expression* является константным выражением, в том случае, если тип является одним из следующих типов значений: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal`, `bool`, или любой тип перечисления.


### <a name="nameof-expressions"></a>Выражения Nameof

Объект *nameof_expression* используется для получения имени сущность программы как строковую константу.

```antlr
nameof_expression
    : 'nameof' '(' named_entity ')'
    ;

named_entity
    : simple_name
    | named_entity_target '.' identifier type_argument_list?
    ;

named_entity_target
    : 'this'
    | 'base'
    | named_entity 
    | predefined_type 
    | qualified_alias_member
    ;
```

Грамматически говоря, *named_entity* операнд всегда представляет собой выражение. Так как `nameof` не является зарезервированным ключевым словом выражения nameof всегда синтаксически неоднозначно в вызов простое имя `nameof`. По причинам совместимости, если при поиске имени ([простые имена](expressions.md#simple-names)) с именем `nameof` завершается успешно, выражение рассматривается как *invocation_expression* — независимо от того, является ли вызов Юридические. В противном случае это *nameof_expression*.

Значение *named_entity* из *nameof_expression* означает его как выражение; то есть, либо как *simple_name*, *base_access*  или *member_access*. Тем не менее, где поиска описано в разделе [простые имена](expressions.md#simple-names) и [доступ к членам](expressions.md#member-access) приводит к ошибке, так как член экземпляра был найден в статическом контексте *nameof_expression*создает ошибки не.

Произошла ошибка во время компиляции для *named_entity* обозначающий группу методов, чтобы *type_argument_list*. Это ошибка времени компиляции для *named_entity_target* как имеющие тип `dynamic`.

Объект *nameof_expression* — это константное выражение типа `string`, и не оказывает влияния во время выполнения. В частности его *named_entity* не вычисляется и учитывается для целей анализа определенного присваивания ([общие правила для простых выражений](variables.md#general-rules-for-simple-expressions)). Его значение является идентификатором последнего *named_entity* необязательно окончательной *type_argument_list*, преобразованные следующим образом:

* Префикс "`@`«, если используется, удаляется.
* Каждый *unicode_escape_sequence* преобразуется в соответствующий символ Юникода.
* Любой *formatting_characters* удаляются.

Это те же преобразования, примененные в [идентификаторы](lexical-structure.md#identifiers) при тестировании равенства между идентификаторами.

TODO: примеры

### <a name="anonymous-method-expressions"></a>Выражения анонимного метода

*Anonymous_method_expression* является одним из двух способов определения анонимной функции. Более подробно они описаны в [выражения анонимных функций](expressions.md#anonymous-function-expressions).

## <a name="unary-operators"></a>Унарные операторы

`?`, `+`, `-`, `!`, `~`, `++`, `--`, Приведите, и `await` называются унарные операторы.

```antlr
unary_expression
    : primary_expression
    | null_conditional_expression
    | '+' unary_expression
    | '-' unary_expression
    | '!' unary_expression
    | '~' unary_expression
    | pre_increment_expression
    | pre_decrement_expression
    | cast_expression
    | await_expression
    | unary_expression_unsafe
    ;
```

Если операнд *unary_expression* имеет тип времени компиляции `dynamic`, он является динамическим ([динамической привязки](expressions.md#dynamic-binding)). В этом случае тип времени компиляции *unary_expression* является `dynamic`, а разрешение, приведенное ниже будет иметь место во время выполнения, используя тип времени выполнения операнда.

### <a name="null-conditional-operator"></a>Условного оператора

Условного оператора применяется список операций для своего операнда, только в том случае, если этот операнд не равно null. В противном случае результатом применения оператора является `null`.

```antlr
null_conditional_expression
    : primary_expression null_conditional_operations
    ;

null_conditional_operations
    : null_conditional_operations? '?' '.' identifier type_argument_list?
    | null_conditional_operations? '?' '[' argument_list ']'
    | null_conditional_operations '.' identifier type_argument_list?
    | null_conditional_operations '[' argument_list ']'
    | null_conditional_operations '(' argument_list? ')'
    ;
```

Список операций можно включить доступ к членам и операции с элементами доступа (которые могут быть условием null), а также вызова.

Например, выражение `a.b?[0]?.c()` — *null_conditional_expression* с *primary_expression* `a.b` и *null_conditional_operations* `?[0]` (доступ к элементам с условием null), `?.c` (доступ к членам условием null) и `()` (вызов).

Для *null_conditional_expression* `E` с *primary_expression* `P`, позволяют `E0` быть выражением, полученные в текстовой форме, удалив в начале `?`от каждого из *null_conditional_operations* из `E` , имеющих одно. По существу `E0` — это выражение, которое должно быть вычислено, если ни одна из проверок значений null, представленный `?`s найти `null`.

Кроме того, предоставить `E1` быть выражением, полученные в текстовой форме, удалив в начале `?` из только первый из *null_conditional_operations* в `E`. Это может привести к *основное выражение* (если он был только что `?`) или на другой *null_conditional_expression*.

Например если `E` выражение `a.b?[0]?.c()`, затем `E0` выражение `a.b[0].c()` и `E1` выражение `a.b[0]?.c()`.

Если `E0` классифицируется как nothing, затем `E` классифицируется как nothing. В противном случае E классифицируется как значение.

`E0` и `E1` используются для определения значения `E`:

*  Если `E` возникает как *statement_expression* значение `E` является таким же, как инструкция

   ```csharp
   if ((object)P != null) E1;
   ```

   за исключением того, что P вычисляется только один раз.

*  В противном случае, если `E0` классифицируется как ничего не происходит ошибка времени компиляции.

*  В противном случае позволить `T0` быть типом значения `E0`.

   *  Если `T0` является параметром типа, быть ссылочным типом или типом значения, не допускающие значения NULL, возникает ошибка во время компиляции неизвестен.

   *  Если `T0` является типом значения, не допускающие значения NULL, то тип `E` — `T0?`и значение `E` совпадает со значением

      ```csharp
      ((object)P == null) ? (T0?)null : E1
      ```

      за исключением того, что `P` вычисляется только один раз.

   *  В противном случае тип E — T0, а значение E — так же, как

      ```csharp
      ((object)P == null) ? null : E1
      ```

      за исключением того, что `P` вычисляется только один раз.

Если `E1` сам *null_conditional_expression*, после чего эти правила применяются опять же, вложение тесты для `null` до более нет `?`элемента, и выражение было сокращено вниз Чтобы основное выражение `E0`.

Например если выражение `a.b?[0]?.c()` возникает как оператор выражение, AS в инструкции:
```csharp
a.b?[0]?.c();
```
его значение эквивалентно:
```csharp
if (a.b != null) a.b[0]?.c();
```
что еще раз эквивалентно:
```csharp
if (a.b != null) if (a.b[0] != null) a.b[0].c();
```
За исключением того, что `a.b` и `a.b[0]` вычисляются только один раз.

Если он находится в контексте, где его значение используется, как в:
```csharp
var x = a.b?[0]?.c();
```
и Предположим, что тип последний вызов не является типом не поддерживающий значение NULL, его значение эквивалентно:
```csharp
var x = (a.b == null) ? null : (a.b[0] == null) ? null : a.b[0].c();
```
За исключением того, что `a.b` и `a.b[0]` вычисляются только один раз.

#### <a name="null-conditional-expressions-as-projection-initializers"></a>Выражения с условием NULL как инициализаторы проекций

Null условное выражение можно использовать только как *member_declarator* в *anonymous_object_creation_expression* ([выражения создания анонимных объектов](expressions.md#anonymous-object-creation-expressions)) Если заканчивается доступ к членам (при необходимости условием null). Грамматически это требование можно выразить следующим образом.

```antlr
null_conditional_member_access
    : primary_expression null_conditional_operations? '?' '.' identifier type_argument_list?
    | primary_expression null_conditional_operations '.' identifier type_argument_list?
    ;
```

Это особый случай грамматики для *null_conditional_expression* выше. Производство для *member_declarator* в [выражения создания анонимных объектов](expressions.md#anonymous-object-creation-expressions) затем включает в себя только *null_conditional_member_access*.

#### <a name="null-conditional-expressions-as-statement-expressions"></a>Выражения условием NULL в качестве выражения с оператором

Null условное выражение можно использовать только как *statement_expression* ([операторы выражений](statements.md#expression-statements)), если оно станет вызовом. Грамматически это требование можно выразить следующим образом.

```antlr
null_conditional_invocation_expression
    : primary_expression null_conditional_operations '(' argument_list? ')'
    ;
```

Это особый случай грамматики для *null_conditional_expression* выше. Производство для *statement_expression* в [операторы выражений](statements.md#expression-statements) затем включает в себя только *null_conditional_invocation_expression*.


### <a name="unary-plus-operator"></a>Оператор унарного сложения

Для операции в виде `+x`, разрешение перегрузки унарного оператора ([разрешение перегрузки унарного оператора](expressions.md#unary-operator-overload-resolution)) применяется, чтобы выбрать конкретную реализацию оператора. Операнд преобразуется в тип параметра выбранного оператора и типом результата является тип возвращаемого значения оператора. Предопределенные унарные и операторы являются:

```csharp
int operator +(int x);
uint operator +(uint x);
long operator +(long x);
ulong operator +(ulong x);
float operator +(float x);
double operator +(double x);
decimal operator +(decimal x);
```

Для каждого из этих операторов результатом является просто значение операнда.

### <a name="unary-minus-operator"></a>Унарный минус-оператор

Для операции в виде `-x`, разрешение перегрузки унарного оператора ([разрешение перегрузки унарного оператора](expressions.md#unary-operator-overload-resolution)) применяется, чтобы выбрать конкретную реализацию оператора. Операнд преобразуется в тип параметра выбранного оператора и типом результата является тип возвращаемого значения оператора. Ниже перечислены операторы предопределенные отрицания.

*  Отрицание целое число:

   ```csharp
   int operator -(int x);
   long operator -(long x);
   ```

   Результат вычисляется путем вычитания `x` с нуля. Если значение `x` является наименьшим представимым значением для типа операнда (-2 ^ 31 для `int` или -2 ^ 63 для `long`), затем математического отрицания `x` не может быть представлен в тип операнда. В этом случае в `checked` контекста, `System.OverflowException` возникает исключение; если он встречается в `unchecked` контекст, результатом является значение операнда и о переполнении не сообщается.

   Если оператор отрицания операнд имеет тип `uint`, он преобразуется в тип `long`, а тип результата — `long`. Исключением является правило, которое позволяет `int` значение от -2147483648 (-2 ^ 31) для записи в качестве Десятичный целочисленный литерал ([Целочисленные литералы](lexical-structure.md#integer-literals)).

   Если оператор отрицания операнд имеет тип `ulong`, возникает ошибка времени компиляции. Исключением является правило, которое позволяет `long` значение от -9223372036854775808 (-2 ^ 63) для записи в качестве Десятичный целочисленный литерал ([Целочисленные литералы](lexical-structure.md#integer-literals)).

*  С плавающей запятой отрицания:

   ```csharp
   float operator -(float x);
   double operator -(double x);
   ```

   Результатом является значение `x` с обратным знаком. Если `x` имеет значение NaN, результат также имеет значение NaN.

*  Decimal отрицания:

   ```csharp
   decimal operator -(decimal x);
   ```

   Результат вычисляется путем вычитания `x` с нуля. Равнозначно использованию унарный минус-оператор типа Decimal отрицания `System.Decimal`.

### <a name="logical-negation-operator"></a>Оператор логического отрицания

Для операции в виде `!x`, разрешение перегрузки унарного оператора ([разрешение перегрузки унарного оператора](expressions.md#unary-operator-overload-resolution)) применяется, чтобы выбрать конкретную реализацию оператора. Операнд преобразуется в тип параметра выбранного оператора и типом результата является тип возвращаемого значения оператора. Существует только один стандартный оператор логического отрицания:
```csharp
bool operator !(bool x);
```

Этот оператор вычисляет логическое отрицание операнда: Если операнд является `true`, в результате `false`. Если операнд является `false`, в результате `true`.

### <a name="bitwise-complement-operator"></a>Оператор поразрядного дополнения

Для операции в виде `~x`, разрешение перегрузки унарного оператора ([разрешение перегрузки унарного оператора](expressions.md#unary-operator-overload-resolution)) применяется, чтобы выбрать конкретную реализацию оператора. Операнд преобразуется в тип параметра выбранного оператора и типом результата является тип возвращаемого значения оператора. Ниже перечислены операторы предопределенные поразрядным дополнением значения.
```csharp
int operator ~(int x);
uint operator ~(uint x);
long operator ~(long x);
ulong operator ~(ulong x);
```

Для каждого из этих операторов, результатом операции является побитовым дополнением `x`.

Каждый тип перечисления `E` неявно предоставляется следующий оператор поразрядного дополнения:

```csharp
E operator ~(E x);
```

Результат вычисления `~x`, где `x` является выражением типа перечисления `E` с базовым типом `U`, именно так же, как оценка `(E)(~(U)x)`, за исключением того, что преобразование в `E` — всегда выполняется в случае, если `unchecked` контекста ([операторы checked и unchecked](expressions.md#the-checked-and-unchecked-operators)).

### <a name="prefix-increment-and-decrement-operators"></a>Префиксный инкремент и декремент операторы

```antlr
pre_increment_expression
    : '++' unary_expression
    ;

pre_decrement_expression
    : '--' unary_expression
    ;
```

Операнд префикс инкремента или декремента операции должно быть выражением, классифицируется как переменная, доступ к свойству или индексатору. Результат операции является значение совпадает с типом операнда.

Если увеличить операнд префикса или декремента является свойство или индексатор, свойство или индексатор должны иметь `get` и `set` метода доступа. Если это не так, возникает ошибка времени привязки.

Разрешение перегрузки унарного оператора ([разрешение перегрузки унарного оператора](expressions.md#unary-operator-overload-resolution)) применяется, чтобы выбрать конкретную реализацию оператора. Предопределенные `++` и `--` операторов существуют для следующих типов: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char` , `float`, `double`, `decimal`и любой тип перечисления. Предопределенный `++` операторы возвращают значение, полученное путем прибавления единицы к операнд и предварительно определенных `--` операторы возвращают значение, полученное путем вычитания 1 из операнда. В `checked` контекста, если результат сложения или вычитания находится вне диапазона типа результата, а тип результата — целый тип или тип перечисления, `System.OverflowException` возникает исключение.

Во время выполнения обработки приращения префикс или операция формы декремента `++x` или `--x` состоит из следующих действий:

*   Если `x` классифицируется как переменная:
    * `x` вычисляется для создания переменной.
    * Выбранный оператор вызывается со значением `x` аргументом.
    * Значение, возвращаемое оператором хранится в расположении, указанном при вычислении `x`.
    * Значение, возвращаемое оператором становится результатом операции.
*   Если `x` классифицируется как свойство или индексатор доступа:
    * Выражение экземпляра (если `x` не `static`) и список аргументов (если `x` имеет доступ к индексатору) связан `x` оцениваются, и полученные результаты используются в последующих `get` и `set` вызовы метода доступа.
    * `get` Метод доступа `x` вызывается.
    * Выбранный оператор вызывается с помощью значения, возвращенного `get` доступа в качестве аргумента.
    * `set` Метод доступа `x` вызывается со значением, возвращенным оператором в качестве его `value` аргумент.
    * Значение, возвращаемое оператором становится результатом операции.

`++` И `--` операторы также поддерживают постфиксная нотация ([постфиксных инкремента и декремента](expressions.md#postfix-increment-and-decrement-operators)). Как правило, результат `x++` или `x--` является значением `x` до операции, тогда как результат `++x` или `--x` является значением `x` после завершения операции. В любом случае `x` сам имеет то же значение после выполнения операции.

`operator++` Или `operator--` реализации можно вызывать в префиксной и постфиксной форме. Это не могут существовать разные реализации операторов для обозначения.

### <a name="cast-expressions"></a>Выражения приведения

Объект *cast_expression* используется для явного преобразования выражения в заданный тип.

```antlr
cast_expression
    : '(' type ')' unary_expression
    ;
```

Объект *cast_expression* формы `(T)E`, где `T` — *тип* и `E` — *unary_expression*, выполняет явно преобразование ([явные преобразования](conversions.md#explicit-conversions)) значения `E` ввода `T`. Если существует явное преобразование из `E` для `T`, возникает ошибка во время привязки. В противном случае результатом является значение, произведенное явное преобразование. Результат всегда классифицируется как значение, даже если `E` обозначает переменную.

Грамматика для *cast_expression* приводит к определенным синтаксической неоднозначности. Например, выражение `(x)-y` можно интерпретировать как *cast_expression* (приведение `-y` ввода `x`) или как *additive_expression* в сочетании с *parenthesized_expression* (который вычисляет значение `x - y)`.

Чтобы устранить *cast_expression* существует неоднозначность, следующее правило: Последовательность из одного или нескольких *маркера*s ([пробелы](lexical-structure.md#white-space)) заключены в круглые скобки, считается начала *cast_expression* только в том случае, если хотя бы одно из следующих условий:

*  Последовательность лексем имеет правильную грамматику для *тип*, но не для *выражение*.
*  Последовательность лексем имеет правильную грамматику для *тип*, и сразу после закрывающей круглой скобки маркер является маркером "`~`», маркер"`!`», маркер "`(`«,  *Идентификатор* ([последовательностей escape-символов Юникода](lexical-structure.md#unicode-character-escape-sequences)), *литерала* ([литералы](lexical-structure.md#literals)), или любой *ключевое слово*([Ключевые слова](lexical-structure.md#keywords)) за исключением `as` и `is`.

Термин «правильную грамматику» выше означает только то, что последовательность токенов должны соответствовать конкретного грамматических производства. Он специально не учитывает фактическое значение все составные идентификаторы. Например если `x` и `y` являются идентификаторами, затем `x.y` имеет правильную грамматику для типа, даже если `x.y` фактически не указывает на тип.

Из правила устранения неоднозначности следует, что если `x` и `y` являются идентификаторами, `(x)y`, `(x)(y)`, и `(x)(-y)` являются *cast_expression*s, но `(x)-y` — нет, даже если `x` определяет тип. Тем не менее если `x` является ключевым словом, идентифицирующим Предопределенный тип (такие как `int`), а затем все четыре формы являются *cast_expression*s (поскольку такое ключевое слово не может быть выражением само по себе).

### <a name="await-expressions"></a>Выражения await

Оператор await используется для приостановки вычислений, включающей функции async до завершения асинхронной операции, представленное операндом.

```antlr
await_expression
    : 'await' unary_expression
    ;
```

*Await_expression* допускается только в теле функции async ([итераторы](classes.md#iterators)). В ближайшем вложенном асинхронной функции *await_expression* не может указываться в этих местах:

*  Анонимные функции вложенные (синхронные)
*  Внутри блока *lock_statement*
*  В небезопасном контексте.

Обратите внимание, что *await_expression* не может использоваться в большинстве мест в *query_expression*, так как их синтаксически преобразуются использовать синхронные лямбда-выражения.

В функцию с модификатором async `await` нельзя использовать в качестве идентификатора. Таким образом является не синтаксической неоднозначности между await выражения и различных выражений, содержащих идентификаторы. За пределами асинхронные функции `await` выступает в качестве обычного идентификатора.

Операнд *await_expression* называется ***задачи***. Он представляет асинхронную операцию, которая может быть не завершено во время *await_expression* вычисляется. Оператор await предназначена для приостановки выполнения включающей функции async, пока не будет завершена ожидаемая задача, а затем получать его результат.

#### <a name="awaitable-expressions"></a>Awaitable выражения

Задача выражения await должен быть ***awaitable***. Выражение `t` несинхронизируемый, если справедливо одно из следующих условий:

*  `t` имеет тип времени компиляции `dynamic`
*  `t` имеет доступный метод экземпляра или расширения вызывается `GetAwaiter` без параметров и без параметров типа и типом возвращаемого значения `A` для которого все указанные ниже хранения:
   * `A` реализует интерфейс `System.Runtime.CompilerServices.INotifyCompletion` (Далее — `INotifyCompletion` для краткости)
   * `A` имеет свойство доступным для чтения экземпляр `IsCompleted` типа `bool`
   * `A` имеет доступным методом экземпляра `GetResult` без параметров и без параметров типа

Цель `GetAwaiter` метод должен получать ***awaiter*** для задачи. Тип `A` называется ***типа awaiter*** для выражения await.

Цель `IsCompleted` свойство является определение того, если задача уже завершена. Если Да, нет необходимости для приостановки вычислений.

Цель `INotifyCompletion.OnCompleted` метод — зарегистрироваться «продолжение» для задачи; т. е. делегат (типа `System.Action`), будет вызываться после завершения задачи.

Цель `GetResult` является метод получения результата задачи, после его завершения. Этот результат может быть завершен успешно, возможно, с результирующее значение, или может быть исключение, которое вызывается `GetResult` метод.

#### <a name="classification-of-await-expressions"></a>Классификация выражениях await

Выражение `await t` классифицируется так же, как выражение `(t).GetAwaiter().GetResult()`. Таким образом Если тип возвращаемого значения `GetResult` — `void`, *await_expression* классифицируется как nothing. Если он имеет тип возврата, отличный от void `T`, *await_expression* классифицируется как значение типа `T`.

#### <a name="runtime-evaluation-of-await-expressions"></a>Выражения await вычисления среды выполнения

Во время выполнения выражение `await t` вычисляется следующим образом:

*  Объект типа awaiter `a` получается путем вычисления выражения `(t).GetAwaiter()`.
*  Объект `bool` `b` получается путем вычисления выражения `(a).IsCompleted`.
*  Если `b` — `false` то оценки зависит от того `a` реализует интерфейс `System.Runtime.CompilerServices.ICriticalNotifyCompletion` (Далее — `ICriticalNotifyCompletion` для краткости). Эта проверка выполняется при привязке; т. е. во время выполнения при `a` имеет тип времени компиляции `dynamic`и во время компиляции в противном случае. Позвольте `r` обозначения возобновления делегат ([итераторы](classes.md#iterators)):
    * Если `a` не реализует `ICriticalNotifyCompletion`, то результатом выражения `(a as (INotifyCompletion)).OnCompleted(r)` вычисляется.
    * Если `a` реализовать `ICriticalNotifyCompletion`, то результатом выражения `(a as (ICriticalNotifyCompletion)).UnsafeOnCompleted(r)` вычисляется.
    * Оценки затем приостанавливается и управление возвращается вызывающему объекту текущего асинхронной функции.
*  Либо сразу же после (если `b` был `true`), или после последующего вызова делегата возобновления (если `b` был `false`), выражение `(a).GetResult()` вычисляется. Если он возвращает значение, это значение является результатом *await_expression*. В противном случае результатом будет ничего.

Объект типа awaiter реализации методов интерфейса `INotifyCompletion.OnCompleted` и `ICriticalNotifyCompletion.UnsafeOnCompleted` должна вызывать делегат `r` вызываемого не более одного раза. В противном случае поведение включающей функции async не определено.

## <a name="arithmetic-operators"></a>Арифметические операторы

`*`, `/`, `%`, `+`, И `-` называются арифметические операторы.

```antlr
multiplicative_expression
    : unary_expression
    | multiplicative_expression '*' unary_expression
    | multiplicative_expression '/' unary_expression
    | multiplicative_expression '%' unary_expression
    ;

additive_expression
    : multiplicative_expression
    | additive_expression '+' multiplicative_expression
    | additive_expression '-' multiplicative_expression
    ;
```

Если операнд арифметический оператор имеет тип времени компиляции `dynamic`, а затем он динамически связан ([динамической привязки](expressions.md#dynamic-binding)). В данном случае является типов во время компиляции выражения `dynamic`, а разрешение, приведенное ниже будет иметь место во время выполнения, используя тип времени выполнения операндов, имеющих указанный тип времени компиляции `dynamic`.

### <a name="multiplication-operator"></a>Оператор умножения

Для операции в виде `x * y`, разрешение перегрузки бинарного оператора ([разрешить перегрузку бинарного оператора](expressions.md#binary-operator-overload-resolution)) применяется, чтобы выбрать конкретную реализацию оператора. Операнды преобразуются в типы параметров выбранного оператора и типом результата является тип возвращаемого значения оператора.

Ниже перечислены стандартные операторы произведения. Все операторы вычислить произведение `x` и `y`.

*  Произведение целых чисел:

   ```csharp
   int operator *(int x, int y);
   uint operator *(uint x, uint y);
   long operator *(long x, long y);
   ulong operator *(ulong x, ulong y);
   ```

   В `checked` контекста, если продукт за пределами диапазона типа результата, `System.OverflowException` возникает исключение. В `unchecked` контекст, переполнение не выводятся и удаляются любые существенные старшие разряды вне диапазона типа результата.


*  Умножения с плавающей запятой:

   ```csharp
   float operator *(float x, float y);
   double operator *(double x, double y);
   ```

   Произведение вычисляется в соответствии с правилами стандарта IEEE 754 арифметические. Ниже перечислены все возможные сочетания ненулевых значений ограниченная, нули, бесконечностей и NaN результаты. В таблице `x` и `y` являются положительными значениями. `z` является результатом `x * y`. Если результат слишком велик для целевого типа, `z` равно бесконечности. Если результат слишком мал для целевого типа, `z` равно нулю.

   |      |      |      |     |     |      |      |     |
   |:----:|-----:|:----:|:---:|:---:|:----:|:----:|:----|
   |      | + y   | -y   | +0  | -0  | +inf | -inf | NaN | 
   | + x   | + z   | -z   | +0  | -0  | +inf | -inf | NaN | 
   | -x   | -z   | + z   | -0  | +0  | -inf | +inf | NaN | 
   | +0   | +0   | -0   | +0  | -0  | NaN  | NaN  | NaN | 
   | -0   | -0   | +0   | -0  | +0  | NaN  | NaN  | NaN | 
   | +inf | +inf | -inf | NaN | NaN | +inf | -inf | NaN | 
   | -inf | -inf | +inf | NaN | NaN | -inf | +inf | NaN | 
   | NaN  | NaN  | NaN  | NaN | NaN | NaN  | NaN  | NaN | 

*  Произведение десятичных чисел.

   ```csharp
   decimal operator *(decimal x, decimal y);
   ```

   Если полученное значение слишком велико для представления в `decimal` формат, `System.OverflowException` возникает исключение. Если результат слишком мал для представления в `decimal` формате, результат равен нулю. Масштаб результата, до округления равно сумме шкал двух операндов.

   Равнозначно использованию оператор умножения типа Decimal умножения `System.Decimal`.


### <a name="division-operator"></a>Оператор деления

Для операции в виде `x / y`, разрешение перегрузки бинарного оператора ([разрешить перегрузку бинарного оператора](expressions.md#binary-operator-overload-resolution)) применяется, чтобы выбрать конкретную реализацию оператора. Операнды преобразуются в типы параметров выбранного оператора и типом результата является тип возвращаемого значения оператора.

Ниже перечислены стандартные операторы деления. Все операторы вычисляют частное `x` и `y`.

*  Деление целых чисел:

   ```csharp
   int operator /(int x, int y);
   uint operator /(uint x, uint y);
   long operator /(long x, long y);
   ulong operator /(ulong x, ulong y);
   ```

   Если значение правый операнд равен нулю, `System.DivideByZeroException` возникает исключение.

   Деление округляет результат в сторону нуля. Таким образом абсолютное значение результата является наибольшее целое число, меньше или равно абсолютному значению частного двух операндов. Результатом будет нуль или положительное число, если два операнда имеют тот же знак и ноль или отрицательное значение, если два операнда имеют противоположные знаки.

   Если левый операнд является наименьшим представимым `int` или `long` значение и правый операнд является `-1`, возникает переполнение. В `checked` контекст, в результате `System.ArithmeticException` (или его подкласс) исключение. В `unchecked` контекста, он определяется реализацией указатель, является ли `System.ArithmeticException` (или его подкласс) возникает исключение или недокументированных этим значением, что левого операнда.

*  Деление с плавающей запятой:

   ```csharp
   float operator /(float x, float y);
   double operator /(double x, double y);
   ```

   Частное вычисляется в соответствии с правилами стандарта IEEE 754 арифметические. Ниже перечислены все возможные сочетания ненулевых значений ограниченная, нули, бесконечностей и NaN результаты. В таблице `x` и `y` являются положительными значениями. `z` является результатом `x / y`. Если результат слишком велик для целевого типа, `z` равно бесконечности. Если результат слишком мал для целевого типа, `z` равно нулю.

   |      |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | + y   | -y   | +0   | -0   | +inf | -inf | NaN  | 
   | + x   | + z   | -z   | +inf | -inf | +0   | -0   | NaN  | 
   | -x   | -z   | + z   | -inf | +inf | -0   | +0   | NaN  | 
   | +0   | +0   | -0   | NaN  | NaN  | +0   | -0   | NaN  | 
   | -0   | -0   | +0   | NaN  | NaN  | -0   | +0   | NaN  | 
   | +inf | +inf | -inf | +inf | -inf | NaN  | NaN  | NaN  | 
   | -inf | -inf | +inf | -inf | +inf | NaN  | NaN  | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  Деление десятичных чисел:

   ```csharp
   decimal operator /(decimal x, decimal y);
   ```

   Если значение правый операнд равен нулю, `System.DivideByZeroException` возникает исключение. Если полученное значение слишком велико для представления в `decimal` формат, `System.OverflowException` возникает исключение. Если результат слишком мал для представления в `decimal` формате, результат равен нулю. Масштаб результата является наименьшим шкалы, сохранит результат равен ближайшему представимым десятичное значение для true математический результат.

   Деление десятичных чисел эквивалентно использованию оператора деления типа `System.Decimal`.


### <a name="remainder-operator"></a>Оператор остатка

Для операции в виде `x % y`, разрешение перегрузки бинарного оператора ([разрешить перегрузку бинарного оператора](expressions.md#binary-operator-overload-resolution)) применяется, чтобы выбрать конкретную реализацию оператора. Операнды преобразуются в типы параметров выбранного оператора и типом результата является тип возвращаемого значения оператора.

Ниже перечислены стандартные операторы остатка. Все операторы вычисления остатка от деления `x` и `y`.

*  Целочисленный остаток:

   ```csharp
   int operator %(int x, int y);
   uint operator %(uint x, uint y);
   long operator %(long x, long y);
   ulong operator %(ulong x, ulong y);
   ```

   Результат `x % y` является значение, полученное путем `x - (x / y) * y`. Если `y` равен нулю, `System.DivideByZeroException` возникает исключение.

   Если левый операнд — наименьшей `int` или `long` значение и правый операнд является `-1`, `System.OverflowException` возникает исключение. В любом случае выполняет `x % y` создания исключения, где `x / y` не вызовет исключение.

*  Остаток с плавающей запятой:

   ```csharp
   float operator %(float x, float y);
   double operator %(double x, double y);
   ```

   Ниже перечислены все возможные сочетания ненулевых значений ограниченная, нули, бесконечностей и NaN результаты. В таблице `x` и `y` являются положительными значениями. `z` является результатом `x % y` и вычисляется как `x - n * y`, где `n` наибольшее возможных целое число, которое меньше или равно `x / y`. Этот метод вычисления остатка аналогично тому, который использовался для целочисленных операнда, но отличается от определения IEEE 754 (в котором `n` — целое число, ближайшее к `x / y`).

   |      |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | + y   | -y   | +0   | -0   | +inf | -inf | NaN  | 
   | + x   | + z   | + z   | NaN  | NaN  | x    | x    | NaN  | 
   | -x   | -z   | -z   | NaN  | NaN  | -x   | -x   | NaN  | 
   | +0   | +0   | +0   | NaN  | NaN  | +0   | +0   | NaN  | 
   | -0   | -0   | -0   | NaN  | NaN  | -0   | -0   | NaN  | 
   | +inf | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 
   | -inf | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  Остаток для десятичных чисел:

   ```csharp
   decimal operator %(decimal x, decimal y);
   ```

   Если значение правый операнд равен нулю, `System.DivideByZeroException` возникает исключение. Масштаб результата, до округления равен большему из масштабов двух операндов, а знак результата, если ненулевое значение, является таким же, как `x`.

   Равнозначно использованию оператора вычисления остатка типа Decimal остаток `System.Decimal`.


### <a name="addition-operator"></a>Оператор сложения

Для операции в виде `x + y`, разрешение перегрузки бинарного оператора ([разрешить перегрузку бинарного оператора](expressions.md#binary-operator-overload-resolution)) применяется, чтобы выбрать конкретную реализацию оператора. Операнды преобразуются в типы параметров выбранного оператора и типом результата является тип возвращаемого значения оператора.

Ниже перечислены стандартные операторы сложения. Для числовые типы и типы перечисления стандартные операторы сложения вычисляет сумму двух операндов. Если один или оба операнда имеют строковый тип, стандартные операторы сложения СЦЕПИТЬ строковым представлением операндов.

*  Сложение целых чисел:

   ```csharp
   int operator +(int x, int y);
   uint operator +(uint x, uint y);
   long operator +(long x, long y);
   ulong operator +(ulong x, ulong y);
   ```

   В `checked` контекста, если сумма находится вне диапазона типа результата, `System.OverflowException` возникает исключение. В `unchecked` контекст, переполнение не выводятся и удаляются любые существенные старшие разряды вне диапазона типа результата.

*  Сложение чисел с плавающей запятой:

   ```csharp
   float operator +(float x, float y);
   double operator +(double x, double y);
   ```

   Сумма вычисляется в соответствии с правилами стандарта IEEE 754 арифметические. Ниже перечислены все возможные сочетания ненулевых значений ограниченная, нули, бесконечностей и NaN результаты. В таблице `x` и `y` являются ненулевыми значениями конечное, и `z` является результатом `x + y`. Если `x` и `y` имеют одинаковую величину, но противоположные знаки, `z` -положительный ноль. Если `x + y` слишком велико для представления в целевом типе, `z` является бесконечным с тот же знак, что `x + y`.

   |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | y    | +0   | -0   | +inf | -inf | NaN  | 
   | x    | з    | x    | x    | +inf | -inf | NaN  | 
   | +0   | y    | +0   | +0   | +inf | -inf | NaN  | 
   | -0   | y    | +0   | -0   | +inf | -inf | NaN  | 
   | +inf | +inf | +inf | +inf | +inf | NaN  | NaN  | 
   | -inf | -inf | -inf | -inf | NaN  | -inf | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  Сложение десятичных чисел:

   ```csharp
   decimal operator +(decimal x, decimal y);
   ```

   Если полученное значение слишком велико для представления в `decimal` формат, `System.OverflowException` возникает исключение. Масштаб результата, до округления равен большему из масштабов двух операндов.

   Decimal эквивалентно использование оператора сложения типа `System.Decimal`.

*  Помимо этого перечисления. Каждый тип перечисления неявно предоставляет следующие предварительно определенные операторы, где `E` является типом перечисления и `U` является базовым типом объекта `E`:

   ```csharp
   E operator +(E x, U y);
   E operator +(U x, E y);
   ```

   Во время выполнения эти операторы выполняются точно так, как `(E)((U)x + (U)y)`.

*  Объединение строк:

   ```csharp
   string operator +(string x, string y);
   string operator +(string x, object y);
   string operator +(object x, string y);
   ```

   Эти перегрузки двоичного файла `+` оператор выполняют объединение строк. Если операнд операции объединения строк `null`, подставляется пустой строкой. В противном случае любой аргумент нестроковых преобразуется в строковое представление путем вызова виртуального `ToString` метод наследуется от типа `object`. Если `ToString` возвращает `null`, подставляется пустой строкой.

   ```csharp
   using System;
   
   class Test
   {
       static void Main() {
           string s = null;
           Console.WriteLine("s = >" + s + "<");        // displays s = ><
           int i = 1;
           Console.WriteLine("i = " + i);               // displays i = 1
           float f = 1.2300E+15F;
           Console.WriteLine("f = " + f);               // displays f = 1.23E+15
           decimal d = 2.900m;
           Console.WriteLine("d = " + d);               // displays d = 2.900
       }
   }
   ```

   Результат оператора объединения строк является строка, состоящая из символов левого операнда следуют символы правого операнда. Оператор объединения строк никогда не возвращает `null` значение. Объект `System.OutOfMemoryException` может быть вызвано, если не хватает памяти для выделения результирующая строка.

*  Объединению делегатов. Каждый тип делегата неявно предоставляется следующий стандартный оператор, где `D` является типом делегата:

   ```csharp
   D operator +(D x, D y);
   ```

   Двоичный файл `+` оператор выполняет объединение делегатов, когда оба операнда имеют некоторый тип делегата `D`. (Если операнды имеют разные типы делегатов, происходит ошибка времени привязки.) Если первый операнд имеет `null`, результатом операции является значение второго операнда (даже если это также `null`). В противном случае, если второй операнд является `null`, то результатом операции является значение первого операнда. В противном случае результатом операции является новый экземпляр делегата, который, при вызове, вызывает первый операнд и затем вызывает второго операнда. Примеры объединение делегатов, см. в разделе [оператор вычитания](expressions.md#subtraction-operator) и [вызов делегата](delegates.md#delegate-invocation). Так как `System.Delegate` не является типом делегата `operator`  `+` для него не определен.

### <a name="subtraction-operator"></a>Оператор вычитания

Для операции в виде `x - y`, разрешение перегрузки бинарного оператора ([разрешить перегрузку бинарного оператора](expressions.md#binary-operator-overload-resolution)) применяется, чтобы выбрать конкретную реализацию оператора. Операнды преобразуются в типы параметров выбранного оператора и типом результата является тип возвращаемого значения оператора.

Ниже перечислены стандартные операторы вычитания. Операторы, все вычесть `y` из `x`.

*  Вычитание целых чисел:

   ```csharp
   int operator -(int x, int y);
   uint operator -(uint x, uint y);
   long operator -(long x, long y);
   ulong operator -(ulong x, ulong y);
   ```

   В `checked` контекста, если разница находится вне диапазона типа результата, `System.OverflowException` возникает исключение. В `unchecked` контекст, переполнение не выводятся и удаляются любые существенные старшие разряды вне диапазона типа результата.

*  Вычитания с плавающей запятой:

   ```csharp
   float operator -(float x, float y);
   double operator -(double x, double y);
   ```

   Разность вычисляется в соответствии с правилами стандарта IEEE 754 арифметические. Ниже перечислены результаты всех возможных сочетаний ненулевых значений ограниченная, нули, бесконечности и значения NaN. В таблице `x` и `y` являются ненулевыми значениями конечное, и `z` является результатом `x - y`. Если `x` и `y` равны, `z` -положительный ноль. Если `x - y` слишком велико для представления в целевом типе, `z` является бесконечным с тот же знак, что `x - y`.

   |      |      |      |      |      |      |     |
   |:----:|:----:|:----:|:----:|:----:|:----:|:---:|
   | NaN  | y    | +0   | -0   | +inf | -inf | NaN | 
   | x    | з    | x    | x    | -inf | +inf | NaN | 
   | +0   | -y   | +0   | +0   | -inf | +inf | NaN | 
   | -0   | -y   | -0   | +0   | -inf | +inf | NaN | 
   | +inf | +inf | +inf | +inf | NaN  | +inf | NaN | 
   | -inf | -inf | -inf | -inf | -inf | NaN  | NaN | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN | 

*  Вычитание десятичных чисел.

   ```csharp
   decimal operator -(decimal x, decimal y);
   ```

   Если полученное значение слишком велико для представления в `decimal` формат, `System.OverflowException` возникает исключение. Масштаб результата, до округления равен большему из масштабов двух операндов.

   Вычитание десятичных чисел эквивалентно использованию оператора вычитания типа `System.Decimal`.

*  Вычитание перечисления. Каждый тип перечисления неявно предоставляется следующий стандартный оператор, где `E` является типом перечисления и `U` является базовым типом объекта `E`:

   ```csharp
   U operator -(E x, E y);
   ```

   Этот оператор выполняется точно так, как `(U)((U)x - (U)y)`. Другими словами, оператор вычисляет разницу между порядковыми значениями `x` и `y`, а тип результата — базовый тип перечисления.

   ```csharp
   E operator -(E x, U y);
   ```

   Этот оператор выполняется точно так, как `(E)((U)x - y)`. Другими словами оператор вычитает значение из базового типа перечисления, выдавая значение перечисления.

*  Удаление делегатов. Каждый тип делегата неявно предоставляется следующий стандартный оператор, где `D` является типом делегата:

   ```csharp
   D operator -(D x, D y);
   ```

   Двоичный файл `-` оператор выполняет удаление делегатов, когда оба операнда имеют некоторый тип делегата `D`. Если операнды имеют разные типы делегатов, возникает ошибка времени привязки. Если первый операнд имеет `null`, результатом операции является `null`. В противном случае, если второй операнд является `null`, то результатом операции является значение первого операнда. В противном случае оба операнда представляют списки вызовов ([объявления делегатов](delegates.md#delegate-declarations)) наличие одной или несколькими записями, а результат является новый список вызовов, состоящая из первого операнда со второго операнда элементов, удаленных из предоставленный список второго операнда это правильное смежных подсписок первого элемента.     (Для определения равенства подсписка, сравнение соответствующих записей, как и для оператора равенства делегатов ([делегировать операторы равенства](expressions.md#delegate-equality-operators)).) В противном случае результатом является значение левого операнда. Ни один из операндов списки изменяется в процессе. Если список второго операнда соответствует несколько подсписка последовательных записей в списке первого операнда, крайнего правого сопоставления подсписок последовательных записей удаляется. Если для удаления получается пустой список, возвращается `null`. Пример:

   ```csharp
   delegate void D(int x);
   
   class C
   {
       public static void M1(int i) { /* ... */ }
       public static void M2(int i) { /* ... */ }
   }

   class Test
   {
       static void Main() { 
           D cd1 = new D(C.M1);
           D cd2 = new D(C.M2);
           D cd3 = cd1 + cd2 + cd2 + cd1;   // M1 + M2 + M2 + M1
           cd3 -= cd1;                      // => M1 + M2 + M2
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd1 + cd2;                // => M2 + M1
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd2 + cd2;                // => M1 + M1
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd2 + cd1;                // => M1 + M2
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd1 + cd1;                // => M1 + M2 + M2 + M1
       }
   }
   ```

## <a name="shift-operators"></a>Операторы сдвига

`<<` И `>>` операторы используются для выполнения операции сдвига разрядов.

```antlr
shift_expression
    : additive_expression
    | shift_expression '<<' additive_expression
    | shift_expression right_shift additive_expression
    ;
```

Если операнд *shift_expression* имеет тип времени компиляции `dynamic`, а затем он динамически связан ([динамической привязки](expressions.md#dynamic-binding)). В данном случае является типов во время компиляции выражения `dynamic`, а разрешение, приведенное ниже будет иметь место во время выполнения, используя тип времени выполнения операндов, имеющих указанный тип времени компиляции `dynamic`.

Для операции в виде `x << count` или `x >> count`, разрешение перегрузки бинарного оператора ([разрешить перегрузку бинарного оператора](expressions.md#binary-operator-overload-resolution)) применяется, чтобы выбрать конкретную реализацию оператора. Операнды преобразуются в типы параметров выбранного оператора и типом результата является тип возвращаемого значения оператора.

При объявлении перегруженного оператора сдвига, тип первого операнда всегда должен быть класс или структура, содержащая объявление оператора, а тип второго операнда должен всегда быть `int`.

Предопределенные операторы перечислены ниже.

*  Сдвиг влево:

   ```csharp
   int operator <<(int x, int count);
   uint operator <<(uint x, int count);
   long operator <<(long x, int count);
   ulong operator <<(ulong x, int count);
   ```

   `<<` Смены оператор `x` влево на количество битов, которое вычисляется, как описано ниже.

   Старшие разряды вне диапазона типа результата `x` будут удалены, а оставшиеся биты сдвигаются влево и позиции битов пустые младшие присваивается нулевое значение.

*  Сдвиг вправо:

   ```csharp
   int operator >>(int x, int count);
   uint operator >>(uint x, int count);
   long operator >>(long x, int count);
   ulong operator >>(ulong x, int count);
   ```

   `>>` Смены оператор `x` вправо на количество битов, которое вычисляется, как описано ниже.

   Когда `x` имеет тип `int` или `long`, младшие биты `x` , удален, а оставшиеся биты сдвигаются вправо и позиции пустой бит высокого порядка устанавливаются в нуль, если `x` неотрицательное он имеет значение, если один `x` является отрицательным.

   Когда `x` имеет тип `uint` или `ulong`, младшие биты `x` будут удалены, а оставшиеся биты сдвигаются вправо, и пустой бит высокого порядка позиций присваивается нулевое значение.

Для стандартных операторов количество битов для сдвига вычисляется следующим образом:

*  Если тип `x` — `int` или `uint`, величина сдвига определяется пятью младшими разрядами из `count`. Другими словами, величина сдвига вычисляется на основе `count & 0x1F`.
*  Если тип `x` — `long` или `ulong`, величина сдвига определяется шестью младшими разрядами из `count`. Другими словами, величина сдвига вычисляется на основе `count & 0x3F`.

Если счетчик принял shift равно нулю, операторы сдвига просто возвращают значение `x`.

Операции сдвига никогда не вызывают переполнение и дают одинаковые результаты в `checked` и `unchecked` контекстов.

Если левый операнд `>>` оператор имеет целочисленный тип со знаком, оператор выполняет арифметический сдвиг вправо при котором значение значащий бит (бит знака) операнда распространяется на позиции пустой бит высокого порядка. Если левый операнд `>>` оператор имеет целочисленный тип без знака, оператор выполняет логическим сдвигом вправо при котором позиции пустой битов высокого порядка всегда присваивается нулевое значение. Для выполнения обратной операции выводится из типа операнда, можно использовать явные приведения. Например если `x` является переменной типа `int`, операция `unchecked((int)((uint)x >> y))` выполняет логическим сдвигом справа от `x`.

## <a name="relational-and-type-testing-operators"></a>Операторы отношения и проверки типа

`==`, `!=`, `<`, `>`, `<=`, `>=`, `is` И `as` называются операторами отношения и проверки типа.

```antlr
relational_expression
    : shift_expression
    | relational_expression '<' shift_expression
    | relational_expression '>' shift_expression
    | relational_expression '<=' shift_expression
    | relational_expression '>=' shift_expression
    | relational_expression 'is' type
    | relational_expression 'as' type
    ;

equality_expression
    : relational_expression
    | equality_expression '==' relational_expression
    | equality_expression '!=' relational_expression
    ;
```

`is` Разделе [является оператором](expressions.md#the-is-operator) и `as` разделе [оператор As](expressions.md#the-as-operator).

`==`, `!=`, `<`, `>`, `<=` И `>=` операторы ***операторы сравнения***.

Если операнд оператора сравнения имеет тип времени компиляции `dynamic`, а затем он динамически связан ([динамической привязки](expressions.md#dynamic-binding)). В данном случае является типов во время компиляции выражения `dynamic`, а разрешение, приведенное ниже будет иметь место во время выполнения, используя тип времени выполнения операндов, имеющих указанный тип времени компиляции `dynamic`.

Для операции в виде `x` *op* `y`, где *op* является оператором сравнения, разрешение перегрузки ([Разрешитьперегрузкубинарногооператора](expressions.md#binary-operator-overload-resolution)) применяется, чтобы выбрать конкретную реализацию оператора. Операнды преобразуются в типы параметров выбранного оператора и типом результата является тип возвращаемого значения оператора.

Стандартные операторы сравнения описаны в следующих разделах. Все стандартные операторы сравнения возвращают результат типа `bool`, как описано в следующей таблице.


| __Операция__ | __Результат__                                                       |
|---------------|------------------------------------------------------------------|
| `x == y`      | `true` Если `x` равен `y`, `false` в противном случае                 | 
| `x != y`      | `true` Если `x` не равно `y`, `false` в противном случае             | 
| `x < y`       | `true` Если `x` — меньше, чем `y`, `false` в противном случае                | 
| `x > y`       | `true` Если `x` больше, чем `y`, `false` в противном случае             | 
| `x <= y`      | `true` Если `x` меньше или равно `y`, `false` в противном случае    | 
| `x >= y`      | `true` Если `x` больше или равно `y`, `false` в противном случае | 

### <a name="integer-comparison-operators"></a>Операторы сравнения целое число

Ниже перечислены операторы сравнения предопределенные целочисленные.
```csharp
bool operator ==(int x, int y);
bool operator ==(uint x, uint y);
bool operator ==(long x, long y);
bool operator ==(ulong x, ulong y);

bool operator !=(int x, int y);
bool operator !=(uint x, uint y);
bool operator !=(long x, long y);
bool operator !=(ulong x, ulong y);

bool operator <(int x, int y);
bool operator <(uint x, uint y);
bool operator <(long x, long y);
bool operator <(ulong x, ulong y);

bool operator >(int x, int y);
bool operator >(uint x, uint y);
bool operator >(long x, long y);
bool operator >(ulong x, ulong y);

bool operator <=(int x, int y);
bool operator <=(uint x, uint y);
bool operator <=(long x, long y);
bool operator <=(ulong x, ulong y);

bool operator >=(int x, int y);
bool operator >=(uint x, uint y);
bool operator >=(long x, long y);
bool operator >=(ulong x, ulong y);
```

Каждый из этих операторов сравнивает числовые значения двух целочисленных операндов и возвращает `bool` значение, указывающее, является ли соответствующее отношение `true` или `false`.

### <a name="floating-point-comparison-operators"></a>Операторы сравнения с плавающей запятой

Ниже перечислены операторы предопределенные сравнения с плавающей запятой.
```csharp
bool operator ==(float x, float y);
bool operator ==(double x, double y);

bool operator !=(float x, float y);
bool operator !=(double x, double y);

bool operator <(float x, float y);
bool operator <(double x, double y);

bool operator >(float x, float y);
bool operator >(double x, double y);

bool operator <=(float x, float y);
bool operator <=(double x, double y);

bool operator >=(float x, float y);
bool operator >=(double x, double y);
```

Операторы сравнивают операнды в соответствии с правилами стандарта IEEE 754:

*  Если один из операндов имеет значение NaN, результатом является `false` для всех операторов, за исключением `!=`, для которого получается `true`. Для любых двух операндов `x != y` всегда дает тот же результат, как `!(x == y)`. Тем не менее, в том случае, когда один или оба операнда имеют значения NaN, `<`, `>`, `<=`, и `>=` операторы не производят те же результаты, что логическое отрицание оператора. Например, если любой из `x` и `y` имеет значение NaN, затем `x < y` — `false`, но `!(x >= y)` является `true`.
*  Если ни один из операндов имеет значение NaN, операторы сравнения значений двух операндов с плавающей запятой с точки зрения упорядочение

   ```
   -inf < -max < ... < -min < -0.0 == +0.0 < +min < ... < +max < +inf
   ```

   где `min` и `max` являются наименьшую и наибольшую положительными значениями, которые могут быть представлены в заданном формате с плавающей запятой. Ниже приведены важные последствия этот порядок.
   * Положительные и отрицательные нули, считаются равными.
   * Отрицательная бесконечность, считается меньше, чем все остальные значения, но равным другой минус бесконечности.
   * Положительная бесконечность считается больше, чем все остальные значения, но равным другой положительной бесконечности.

### <a name="decimal-comparison-operators"></a>Операторы сравнения десятичных чисел

Ниже перечислены операторы сравнения предопределенные десятичных чисел.
```csharp
bool operator ==(decimal x, decimal y);
bool operator !=(decimal x, decimal y);
bool operator <(decimal x, decimal y);
bool operator >(decimal x, decimal y);
bool operator <=(decimal x, decimal y);
bool operator >=(decimal x, decimal y);
```

Каждый из этих операторов сравнивает числовые значения двух десятичных операндов и возвращает `bool` значение, указывающее, является ли соответствующее отношение `true` или `false`. Decimal сравнение эквивалентно значению с помощью соответствующего реляционного или оператор равенства типа `System.Decimal`.

### <a name="boolean-equality-operators"></a>Логические операторы равенства

Ниже приведены стандартные логические операторы равенства.
```csharp
bool operator ==(bool x, bool y);
bool operator !=(bool x, bool y);
```

Результат `==` — `true` Если оба `x` и `y` являются `true` или если оба `x` и `y` являются `false`. В противном случае результат будет `false`.

Результат `!=` — `false` Если оба `x` и `y` являются `true` или если оба `x` и `y` являются `false`. В противном случае результат будет `true`. Если операнды имеют тип `bool`, `!=` оператор дает тот же результат, как `^` оператор.

### <a name="enumeration-comparison-operators"></a>Операторы сравнения перечисления

Каждый тип перечисления неявно предоставляет следующие стандартные операторы сравнения:
```csharp
bool operator ==(E x, E y);
bool operator !=(E x, E y);
bool operator <(E x, E y);
bool operator >(E x, E y);
bool operator <=(E x, E y);
bool operator >=(E x, E y);
```

Результат вычисления `x op y`, где `x` и `y` являются выражениями типа перечисления `E` с базовым типом `U`, и `op` является один из операторов сравнения, точно так же, как Оценка `((U)x) op ((U)y)`. Другими словами операторы сравнения для типа перечисления просто сравнивать базовые целые значения двух операндов.

### <a name="reference-type-equality-operators"></a>Операторы равенства ссылочного типа

Приведены стандартные операторы ссылочного типа проверки на равенство.
```csharp
bool operator ==(object x, object y);
bool operator !=(object x, object y);
```

Операторы возвращают результат сравнения двух ссылок на идентичность.

Так как стандартные операторы ссылочного типа равенства принимает операнды типа `object`, они применяются ко всем типам, не объявляйте применимо `operator ==` и `operator !=` членов. И наоборот любые применимые равенства, определяемые пользователем операторы скрывают стандартные операторы ссылочного типа проверки на равенство.

Стандартные операторы ссылочного типа равенства требуется одно из следующих:

*  Оба операнда имеют значение типа, известные как *reference_type* или литерала `null`. Кроме того неявное преобразование ([явные преобразования ссылочных типов](conversions.md#explicit-reference-conversions)) существует тип один из операндов на тип значение второго операнда.
*  Один операнд является значение типа `T` где `T` — *параметр_типа* и другой операнд является литералом `null`. Кроме того `T` имеет ограничение типа значения.

Если одно из этих условий не true, происходит ошибка времени привязки. Ниже приведены важные последствия этих правил.

*  Является ошибкой времени привязки для использования стандартных операторов ссылочного типа равенства для сравнения двух ссылок, которые заведомо отличаться во время привязки. Например, если во время привязки типы операндов два типа класса `A` и `B`и если ни один из `A` , ни `B` является производным от другого, то он может быть организовано два операнда для ссылки на тот же объект. Таким образом операция вызовет ошибку во время привязки.
*  Операторы равенства предопределенные ссылочного типа не допускают значение операнды типа для сравнения. Таким образом Если тип структуры объявляет свои собственные операторы равенства, он не поддерживается для сравнения значений этого типа структуры.
*  Операторы равенства предопределенные ссылочного типа никогда не вызывают операции упаковки-преобразования, чтобы для своих операндов. Было бы смысла для выполнения такой операции упаковки-преобразования, так как ссылки на создаваемые упакованные экземпляры обязательно будут отличаться от всех остальных ссылок.
*  Если операнд с типом параметра типа `T` сравнивается с `null`и тип времени выполнения `T` является типом значения, результатом сравнения является `false`.

В следующем примере проверяется, является ли аргумент параметра неограниченного типа `null`.
```csharp
class C<T>
{
    void F(T x) {
        if (x == null) throw new ArgumentNullException();
        ...
    }
}
```

`x == null` Конструкция разрешено, даже если `T` может представлять тип значения, и результат просто определяется как `false` при `T` является типом значения.

Для операции в виде `x == y` или `x != y`, если всем применимым `operator ==` или `operator !=` существует, разрешение перегрузки оператора ([разрешить перегрузку бинарного оператора](expressions.md#binary-operator-overload-resolution)), выберет правила оператор, а не стандартный оператор ссылочного типа проверки на равенство. Тем не менее, это всегда можно выбрать оператор равенства Предопределенная ссылка типа явным образом привести один или оба операнда к типу `object`. Пример
```csharp
using System;

class Test
{
    static void Main() {
        string s = "Test";
        string t = string.Copy(s);
        Console.WriteLine(s == t);
        Console.WriteLine((object)s == t);
        Console.WriteLine(s == (object)t);
        Console.WriteLine((object)s == (object)t);
    }
}
```
выводятся следующие выходные данные
```
True
False
False
False
```

`s` И `t` переменные ссылаются на два отдельных `string` экземпляров, содержащую те же символы. Выводит первое сравнение `True` так как оператор равенства заранее определенной строки ([строковые операторы равенства](expressions.md#string-equality-operators)) выбран, если оба операнда имеют тип `string`. Все оставшиеся сравнения вывода `False` так как стандартный оператор ссылочного типа равенства выбрана в том случае, если один или оба операнда имеют тип `object`.

Обратите внимание на то, что указанная процедура не имеет смысла для типов значений. Пример
```csharp
class Test
{
    static void Main() {
        int i = 123;
        int j = 123;
        System.Console.WriteLine((object)i == (object)j);
    }
}
```
Выводит `False` из-за приведения создание ссылок на два отдельных экземпляра упакованных `int` значения.

### <a name="string-equality-operators"></a>Операторы равенства строк

Ниже перечислены операторы равенства заранее определенной строки.
```csharp
bool operator ==(string x, string y);
bool operator !=(string x, string y);
```

Два `string` значения считаются равными, если выполняется одно из следующих:

*  Оба значения равны `null`.
*  Оба значения являются ненулевой ссылками на экземпляры строк с одинаковой длиной и идентичные символы в каждой позиции.

Операторы равенства строк сравнения строковых значений, а не ссылки на строки. Если два разных экземпляра строк содержат та же последовательность символов, значения строк равны, но ссылки отличаются. Как описано в разделе [операторы равенства ссылочного типа](expressions.md#reference-type-equality-operators), операторы равенства ссылочного типа можно использовать для сравнения ссылки на строки вместо строковых значений.

### <a name="delegate-equality-operators"></a>Операторы равенства делегатов

Каждый тип делегата неявно предоставляет следующие стандартные операторы сравнения:

```csharp
bool operator ==(System.Delegate x, System.Delegate y);
bool operator !=(System.Delegate x, System.Delegate y);
```

Два делегата считаются равными следующим образом:

*  Если экземпляры делегата являются `null`, они равны, только в том случае, если выполняются оба `null`.
*  Если делегаты имеют другой тип времени выполнения, они никогда не равны.
*  Если у обоих экземпляров делегата есть список вызова ([объявления делегатов](delegates.md#delegate-declarations)), то они равны только в том случае, если их списки вызовов имеют одинаковую длину и каждая запись в список вызова равно (как определено ниже) для соответствующей записи в порядке, в списке вызова другого.

Следующие правила определяют равенство записей списка вызова:

*  Если две записи списка вызова ссылается на тот же статический метод, а затем записи считаются равными.
*  Если две записи списка вызова ссылаются на один и тот же метод статическим на тот же целевой объект (в соответствии с операторов равенства ссылок) записи считаются равными.
*  Полученные записи списка вызова при вычислении семантически идентичных *anonymous_method_expression*s или *lambda_expression*s с тем же набором (возможно, пустой), записанный внешней переменной. экземпляры разрешены (но не требуются) должны совпадать.

### <a name="equality-operators-and-null"></a>Операторы равенства и значение null

`==` И `!=` операторы позволяют один операнд должен быть значение типа, допускающего значение NULL, а другой быть `null` литерал, даже если существует предопределенные или определяемые пользователем оператор не (обычного или с ликвидированный формы) для операции.

Для операции в одной из форм
```csharp
x == null
null == x
x != null
null != x
```
где `x` — это выражение типа, допускающего значение NULL, если разрешение перегрузки оператора ([разрешить перегрузку бинарного оператора](expressions.md#binary-operator-overload-resolution)) не удалось найти соответствующий оператор, результат вместо этого вычисляется на основе `HasValue` Свойство `x`. В частности, первые две формы преобразуются в `!x.HasValue`, и два последних преобразуются в `x.HasValue`.

### <a name="the-is-operator"></a>Является оператором

`is` Оператор используется для динамической проверки, совместим ли тип времени выполнения объекта с заданным типом. Результат операции `E is T`, где `E` — это выражение и `T` — это тип, возвращается логическое значение, указывающее, ли `E` можно успешно преобразовать в тип `T` с помощью преобразования ссылок, упаковки-преобразования преобразования или распаковки-преобразования. После замены аргументов типа для всех параметров типа, операция вычисляется следующим образом:

*  Если `E` является анонимной функцией, возникает ошибка времени компиляции
*  Если `E` является группой методов или `null` литерал, если тип `E` — это ссылочный тип или тип, допускающий значение NULL и значение `E` имеет значение null, результат имеет значение false.
*  В противном случае позволить `D` представляют динамический тип `E` следующим образом:
   * Если тип `E` является ссылочным типом, `D` является типом времени выполнения ссылка на экземпляр, `E`.
   * Если тип `E` является тип nullable `D` — базовый тип этого типа, допускающего значение NULL.
   * Если тип `E` является типом значения, не допускающие значения NULL, `D` — это тип `E`.
*  Результат операции зависит от `D` и `T` следующим образом:
   * Если `T` является ссылочным типом, результат равен true, если `D` и `T` относятся к одному типу, в том случае, если `D` является ссылочным типом и и неявное ссылочное преобразование из `D` для `T` существует, или если `D` является типом значения и преобразования-упаковки из `D` для `T` существует.
   * Если `T` является типом, допускающий значение NULL, результат равен true, если `D` является базовым типом объекта `T`.
   * Если `T` является типом значения, не допускающие значения NULL, результат равен true, если `D` и `T` относятся к одному типу.
   * В противном случае результат имеет значение false.

Обратите внимание, что пользовательские преобразования не рассматривает `is` оператор.

### <a name="the-as-operator"></a>Оператор as

`as` Оператор используется для явного преобразования значения в указанный ссылочный тип или тип, допускающий значение NULL. В отличие от выражения приведения ([выражения приведения](expressions.md#cast-expressions)), `as` оператор никогда не создает исключение. Вместо этого, если указанное преобразование невозможно, то результирующее значение равно `null`.

В операции формы `E as T`, `E` должно быть выражением и `T` должен быть ссылочного типа, параметром типа, быть ссылочным типом или типом, допускающий значение NULL. Кроме того по крайней мере одно из следующих должен иметь значение true, или иначе возникает ошибка времени компиляции:

*  Удостоверение ([преобразование идентификации](conversions.md#identity-conversion)), неявное допускает значения NULL ([неявные преобразования обнуляемых типов](conversions.md#implicit-nullable-conversions)), неявные ссылки ([неявные преобразования ссылочных типов](conversions.md#implicit-reference-conversions)), упаковка-преобразование ([ Осуществлять преобразования-упаковки](conversions.md#boxing-conversions)) явный допускает значения NULL ([явные преобразования обнуляемых типов](conversions.md#explicit-nullable-conversions)), явная ссылка ([преобразования явной ссылки](conversions.md#explicit-reference-conversions)), или распаковка-преобразование ([Преобразования, распаковки-преобразования](conversions.md#unboxing-conversions)) существует преобразование из `E` для `T`.
*  Тип `E` или `T` является открытым типом.
*  `E` является `null` литерала.

Если тип времени компиляции `E` не `dynamic`, операция `E as T` дает тот же результат, как
```csharp
E is T ? (T)(E) : (T)null
```
за исключением того, что `E` вычисляется только один раз. Компилятор может проводить оптимизацию `E as T` для проверки не более одного динамического типа в отличие от двух динамических проверок типа в расширении выше.

Если тип времени компиляции `E` — `dynamic`, в отличие от оператора приведения `as` оператор не имеет динамической привязки ([динамической привязки](expressions.md#dynamic-binding)). Поэтому расширение в данном случае является:
```csharp
E is T ? (T)(object)(E) : (T)null
```

Обратите внимание, что некоторые преобразования, например определенные пользователем, не поддерживаемых в средстве `as` оператор и следует выполнять с помощью выражения приведения.

В примере
```csharp
class X
{

    public string F(object o) {
        return o as string;        // OK, string is a reference type
    }

    public T G<T>(object o) where T: Attribute {
        return o as T;             // Ok, T has a class constraint
    }

    public U H<U>(object o) {
        return o as U;             // Error, U is unconstrained 
    }
}
```
параметр типа `T` из `G` известно, быть ссылочным типом, так как он имеет ограничения класса. Параметр типа `U` из `H` не является тем не менее, поэтому использование `as` оператор в `H` запрещено.

## <a name="logical-operators"></a>Логические операторы

`&`, `^`, И `|` называются логическими операторами.

```antlr
and_expression
    : equality_expression
    | and_expression '&' equality_expression
    ;

exclusive_or_expression
    : and_expression
    | exclusive_or_expression '^' and_expression
    ;

inclusive_or_expression
    : exclusive_or_expression
    | inclusive_or_expression '|' exclusive_or_expression
    ;
```

Если операнд логического оператора имеет тип времени компиляции `dynamic`, а затем он динамически связан ([динамической привязки](expressions.md#dynamic-binding)). В данном случае является типов во время компиляции выражения `dynamic`, а разрешение, приведенное ниже будет иметь место во время выполнения, используя тип времени выполнения операндов, имеющих указанный тип времени компиляции `dynamic`.

Для операции в виде `x op y`, где `op` является одним из логических операторов, разрешение перегрузки ([разрешить перегрузку бинарного оператора](expressions.md#binary-operator-overload-resolution)) применяется, чтобы выбрать конкретную реализацию оператора. Операнды преобразуются в типы параметров выбранного оператора и типом результата является тип возвращаемого значения оператора.

Стандартные логические операторы описаны в следующих разделах.

### <a name="integer-logical-operators"></a>Логические операторы целое число

Предопределенные целочисленные перечислены логические операторы:
```csharp
int operator &(int x, int y);
uint operator &(uint x, uint y);
long operator &(long x, long y);
ulong operator &(ulong x, ulong y);

int operator |(int x, int y);
uint operator |(uint x, uint y);
long operator |(long x, long y);
ulong operator |(ulong x, ulong y);

int operator ^(int x, int y);
uint operator ^(uint x, uint y);
long operator ^(long x, long y);
ulong operator ^(ulong x, ulong y);
```

`&` Оператор выполняет побитовую операцию логического `AND` двух операндов, `|` оператор выполняет побитовую операцию логического `OR` двух операндов и `^` оператор вычисляет побитового логического исключающего `OR` двух операндов. Не порождают переполнения из этих операций.

### <a name="enumeration-logical-operators"></a>Перечисление логических операторов

Каждый тип перечисления `E` неявно предоставляет следующие предварительно определенные логические операторы:

```csharp
E operator &(E x, E y);
E operator |(E x, E y);
E operator ^(E x, E y);
```

Результат вычисления `x op y`, где `x` и `y` являются выражениями типа перечисления `E` с базовым типом `U`, и `op` является одним из логических операторов, именно так же, как Оценка `(E)((U)x op (U)y)`. Другими словами логические операторы типа перечисления просто выполняют логические операции в базовом типе двух операндов.

### <a name="boolean-logical-operators"></a>Логические операторы

Ниже приведены стандартные логические операторы.
```csharp
bool operator &(bool x, bool y);
bool operator |(bool x, bool y);
bool operator ^(bool x, bool y);
```

Результат операции `x & y` принимает значение `true`, если оба оператора `x` и `y` имеют значение `true`. В противном случае результат будет `false`.

Результат `x | y` — `true` Если `x` или `y` является `true`. В противном случае результат будет `false`.

Результат `x ^ y` — `true` Если `x` — `true` и `y` — `false`, или `x` — `false` и `y` является `true`. В противном случае результат будет `false`. Если операнды имеют тип `bool`, `^` оператор вычисляет тот же результат, как `!=` оператор.

### <a name="nullable-boolean-logical-operators"></a>Обнуляемые логические операторы

Допускающий значение NULL тип данных boolean `bool?` может представлять три значения `true`, `false`, и `null`и принципиально подобен классу для трех значений типа, используемого для логических выражений в SQL. Чтобы убедиться, что результаты `&` и `|` операторов для `bool?` операндов, соответствуют SQL троичную логику, предоставляются следующие предопределенные операторы:

```csharp
bool? operator &(bool? x, bool? y);
bool? operator |(bool? x, bool? y);
```

В следующей таблице перечислены результаты этих операторов для всех сочетаний значений `true`, `false`, и `null`.

| `x`     | `y`     | `x & y` | <code>x &#124; y</code> |
|:-------:|:-------:|:-------:|:-------:|
| `true`  | `true`  | `true`  | `true`  | 
| `true`  | `false` | `false` | `true`  | 
| `true`  | `null`  | `null`  | `true`  | 
| `false` | `true`  | `false` | `true`  | 
| `false` | `false` | `false` | `false` | 
| `false` | `null`  | `false` | `null`  | 
| `null`  | `true`  | `null`  | `true`  | 
| `null`  | `false` | `false` | `null`  | 
| `null`  | `null`  | `null`  | `null`  | 

## <a name="conditional-logical-operators"></a>Условные логические операторы

`&&` И `||` называются условные логические операторы. Они также называются «Упрощенные» логические операторы.

```antlr
conditional_and_expression
    : inclusive_or_expression
    | conditional_and_expression '&&' inclusive_or_expression
    ;

conditional_or_expression
    : conditional_and_expression
    | conditional_or_expression '||' conditional_and_expression
    ;
```

`&&` И `||` операторы представляют собой условное версии `&` и `|` операторы:

*  Операция `x && y` соответствующей операции `x & y`, за исключением того, что `y` вычисляется только в том случае, если `x` не `false`.
*  Операция `x || y` соответствующей операции `x | y`, за исключением того, что `y` вычисляется только в том случае, если `x` не `true`.

Если операнд условного логического оператора имеет тип времени компиляции `dynamic`, а затем он динамически связан ([динамической привязки](expressions.md#dynamic-binding)). В данном случае является типов во время компиляции выражения `dynamic`, а разрешение, приведенное ниже будет иметь место во время выполнения, используя тип времени выполнения операндов, имеющих указанный тип времени компиляции `dynamic`.

Операции формы `x && y` или `x || y` обрабатывается с применением разрешение перегрузки ([разрешить перегрузку бинарного оператора](expressions.md#binary-operator-overload-resolution)) как если бы операция была `x & y` или `x | y`. Затем,

*  Если разрешение перегрузки не удается найти один подходящий оператор или разрешение перегрузки выбирает одну из предопределенные целочисленные логические операторы, возникает ошибка времени привязки.
*  В противном случае, если выбранный оператор является одним из предопределенных логических операторов ([логические операторы](expressions.md#boolean-logical-operators)) или по Обнуляемые логические операторы ([Обнуляемые логические операторы](expressions.md#nullable-boolean-logical-operators)), операция обрабатывается, как описано в разделе [условные логические операторы](expressions.md#boolean-conditional-logical-operators).
*  В противном случае выбранный оператор является оператором определяемые пользователем, и эта операция обрабатывается, как описано в разделе [пользовательские условные логические операторы](expressions.md#user-defined-conditional-logical-operators).

Это не позволяет непосредственно перегрузить условные логические операторы. Тем не менее поскольку условные логические операторы вычисляются с точки зрения регулярных логических операторов, перегрузки регулярных логических операторов с некоторыми ограничениями, считаться перегрузками условных логических операторов. Это описано далее в [пользовательские условные логические операторы](expressions.md#user-defined-conditional-logical-operators).

### <a name="boolean-conditional-logical-operators"></a>Условные логические операторы

При операндов `&&` или `||` относятся к типу `bool`, или если операнды имеют типы, которые не определяют соответствующем `operator &` или `operator |`, но определить неявные преобразования в `bool`, операция обработан следующим образом:

*  Операция `x && y` вычисляется как `x ? y : false`. Другими словами `x` сначала вычисляется и преобразуется в тип `bool`. Затем, если `x` — `true`, `y` вычисляется и преобразуется в тип `bool`, и это становится результатом операции. В противном случае результатом операции является `false`.
*  Операция `x || y` вычисляется как `x ? true : y`. Другими словами `x` сначала вычисляется и преобразуется в тип `bool`. Затем, если `x` — `true`, результатом операции является `true`. В противном случае `y` вычисляется и преобразуется в тип `bool`, и это становится результатом операции.

### <a name="user-defined-conditional-logical-operators"></a>Пользовательские условные логические операторы

Когда операндов `&&` или `||` типов, которые объявляют соответствующем определяются пользователем `operator &` или `operator |`, оба следующих должен иметь значение true, где `T` является типом, в котором объявлен выбранного оператора:

*  Тип возвращаемого значения и тип каждого параметра, выбранного оператора должны быть `T`. Другими словами, следует вычислять логического оператора `AND` или логической `OR` двух операндов типа `T`и должен возвращать результат типа `T`.
*  `T` должен содержать объявления `operator true` и `operator false`.

Ошибка времени привязки возникает, если любой из этих требований не выполнено. В противном случае `&&` или `||` операция вычисляется путем объединения, определяемые пользователем `operator true` или `operator false` с выбранной определяемого пользователем оператора:

*  Операция `x && y` вычисляется как `T.false(x) ? x : T.&(x, y)`, где `T.false(x)` является вызовом `operator false` объявленные в `T`, и `T.&(x, y)` является вызовом выбранного `operator &`. Другими словами `x` сначала оценивается и `operator false` вызывается на результат на предмет `x` имеет значение false. Затем, если `x` имеет значение false, результатом операции является значение, ранее вычисленное для `x`. В противном случае `y` вычисляется и выбранным `operator &` вызывается на значение, ранее вычисленное для `x` и вычисленного значения `y` для получения результата операции.
*  Операция `x || y` вычисляется как `T.true(x) ? x : T.|(x, y)`, где `T.true(x)` является вызовом `operator true` объявленные в `T`, и `T.|(x,y)` является вызовом выбранного `operator|`. Другими словами `x` сначала оценивается и `operator true` вызывается на результат на предмет `x` имеет значение true. Затем, если `x` имеет значение true, результатом операции является значение, ранее вычисленное для `x`. В противном случае `y` вычисляется и выбранным `operator |` вызывается на значение, ранее вычисленное для `x` и вычисленного значения `y` для получения результата операции.

В этих операций, выражение в `x` только вычисляется один раз и выражение в `y` либо не вычисляется или вычисляется только один раз.

Например, тип, реализующий `operator true` и `operator false`, см. в разделе [базы данных логического типа](structs.md#database-boolean-type).

## <a name="the-null-coalescing-operator"></a>Оператор объединения со значением null

`??` Оператор был вызван оператор объединения со значением null.

```antlr
null_coalescing_expression
    : conditional_or_expression
    | conditional_or_expression '??' null_coalescing_expression
    ;
```

Null объединения со значением выражения вида `a ?? b` требует `a` как обнуляемый тип или ссылку. Если `a` отлично от NULL, результат `a ?? b` — `a`; в противном случае результатом является `b`. Эта операция проверяет `b` только если `a` имеет значение null.

Оператор объединения со значением null является правоассоциативным, это означает, что операции группируются слева направо. Например, выражение в форме `a ?? b ?? c` вычисляется как `a ?? (b ?? c)`. В целом, условия выражения формы `E1 ?? E2 ?? ... ?? En` возвращаются первые операндов, отличных от null, или значение null, если все операнды имеют значение null.

Тип выражения `a ?? b` зависит от того, какие неявные преобразования доступны с операндами. В порядке предпочтения, тип `a ?? b` — `A0`, `A`, или `B`, где `A` — это тип `a` (при условии, что `a` с типом), `B` — это тип `b` () при условии, что `b` с типом), и `A0` является базовым типом объекта `A` Если `A` является типом, допускающий значение NULL, или `A` в противном случае. В частности `a ?? b` обрабатывается следующим образом:

*  Если `A` существует и не является обнуляемым типом или ссылочным типом, возникает ошибка времени компиляции.
*  Если `b` является динамическим выражением, тип результата — `dynamic`. Во время выполнения `a` сначала оценивается. Если `a` не равно null, `a` преобразуется в динамический, и это становится результатом. В противном случае `b` вычисляется, и это становится результатом.
*  В противном случае, если `A` существует и допускает значение NULL, и существует неявное преобразование из `b` для `A0`, тип результата — `A0`. Во время выполнения `a` сначала оценивается. Если `a` не равно null, `a` распаковывается в тип `A0`, и это становится результатом. В противном случае `b` вычисляется и преобразуется в тип `A0`, и это становится результатом.
*  В противном случае, если `A` существует и существует неявное преобразование из `b` для `A`, тип результата — `A`. Во время выполнения `a` сначала оценивается. Если `a` не равно null, `a` становится результатом. В противном случае `b` вычисляется и преобразуется в тип `A`, и это становится результатом.
*  В противном случае, если `b` с типом `B` и существует неявное преобразование из `a` для `B`, тип результата — `B`. Во время выполнения `a` сначала оценивается. Если `a` не равно null, `a` распаковывается в тип `A0` (если `A` существует и допускает значения NULL) и он преобразуется в тип `B`, и это становится результатом. В противном случае `b` вычисляется и становится результатом.
*  В противном случае `a` и `b` являются несовместимыми и ошибка времени компиляции возникает.

## <a name="conditional-operator"></a>Условный оператор

`?:` Оператор был вызван условного оператора. Также в некоторых случаях он называется троичный оператор.

```antlr
conditional_expression
    : null_coalescing_expression
    | null_coalescing_expression '?' expression ':' expression
    ;
```

Условное выражение в форме `b ? x : y` сначала оценивает условие `b`. Затем, если `b` — `true`, `x` вычисляется и становится результатом операции. В противном случае `y` вычисляется и становится результатом операции. Условное выражение вычислено, никогда не оба `x` и `y`.

Условный оператор имеет правую ассоциативность, это означает, что операции группируются слева направо. Например, выражение в форме `a ? b : c ? d : e` вычисляется как `a ? b : (c ? d : e)`.

Первый операнд `?:` оператор должен быть выражением, которое может быть неявно преобразован в `bool`, или выражение типа, который реализует `operator true`. Если не выполняется ни одно из этих требований, возникает ошибка времени компиляции.

Второй и третий операнды, `x` и `y`, из `?:` оператор управления тип условного выражения.

*  Если `x` имеет тип `X` и `y` имеет тип `Y` затем
   * Если неявное преобразование ([неявные преобразования](conversions.md#implicit-conversions)) существует из `X` для `Y`, но не из `Y` для `X`, затем `Y` тип условного выражения.
   * Если неявное преобразование ([неявные преобразования](conversions.md#implicit-conversions)) существует из `Y` для `X`, но не из `X` для `Y`, затем `X` тип условного выражения.
   * В противном случае можно определить тип выражения, и возникает ошибка времени компиляции.
*  Если только один из `x` и `y` имеет тип и оба `x` и `y`, из неявно преобразуются к этому типу, а затем этот тип условного выражения.
*  В противном случае можно определить тип выражения, и возникает ошибка времени компиляции.

Обработка времени выполнения условного выражения формы `b ? x : y` состоит из следующих действий:

*  Во-первых, `b` вычисляется и `bool` значение `b` определяется:
   * Если неявное преобразование из типа `b` для `bool` существует, то это неявное преобразование выполняется для создания `bool` значение.
   * В противном случае `operator true` определяется тип `b` вызываемый для получения `bool` значение.
*  Если `bool` является значение, созданное на предыдущем шаге `true`, затем `x` вычисляется и преобразуется в тип условного выражения, и это становится результатом условного выражения.
*  В противном случае `y` вычисляется и преобразуется в тип условного выражения, и это становится результатом условного выражения.

## <a name="anonymous-function-expressions"></a>Выражения анонимных функций

***Анонимная функция*** выражение, которое представляет определение метода «в строке». Анонимная функция не имеет значения или тип само по себе, но можно преобразовать в совместимый тип делегата или выражения дерева. Вычисление преобразование анонимной функции зависит от целевой тип преобразования: Если он является типом делегата, преобразование результатом которого является значение делегата, ссылке на метод, который определяет анонимной функции. Если это тип дерева выражения, то результатом преобразования в дерево выражения, которое представляет структуру метода в виде структуры объекта.

По историческим причинам существует два синтаксический варианта анонимных функций, а именно *lambda_expression*s и *anonymous_method_expression*s. Практически для любых целей *lambda_expression*s являются более четкими и выразительной, чем *anonymous_method_expression*s, которые остаются в язык для обеспечения обратной совместимости.

```antlr
lambda_expression
    : anonymous_function_signature '=>' anonymous_function_body
    ;

anonymous_method_expression
    : 'delegate' explicit_anonymous_function_signature? block
    ;

anonymous_function_signature
    : explicit_anonymous_function_signature
    | implicit_anonymous_function_signature
    ;

explicit_anonymous_function_signature
    : '(' explicit_anonymous_function_parameter_list? ')'
    ;

explicit_anonymous_function_parameter_list
    : explicit_anonymous_function_parameter (',' explicit_anonymous_function_parameter)*
    ;

explicit_anonymous_function_parameter
    : anonymous_function_parameter_modifier? type identifier
    ;

anonymous_function_parameter_modifier
    : 'ref'
    | 'out'
    ;

implicit_anonymous_function_signature
    : '(' implicit_anonymous_function_parameter_list? ')'
    | implicit_anonymous_function_parameter
    ;

implicit_anonymous_function_parameter_list
    : implicit_anonymous_function_parameter (',' implicit_anonymous_function_parameter)*
    ;

implicit_anonymous_function_parameter
    : identifier
    ;

anonymous_function_body
    : expression
    | block
    ;
```

`=>` Оператор имеет тот же приоритет, как и присваивание (`=`) и является правоассоциативным.

Анонимная функция с `async` модификатор является асинхронной функции и следует правилам, описанным в [итераторы](classes.md#iterators).

Параметры анонимной функции в виде *lambda_expression* может быть явно или неявно типизированы. В списке параметров явным образом типизированной явно указан тип каждого параметра. В списке неявно типизированных параметров, типы параметров выводятся из контекста, в котором происходит анонимная функция — в частности, если анонимная функция преобразуется в совместимый тип делегата или тип дерева выражения, предоставляющий тип типы параметров ([преобразования анонимных функций](conversions.md#anonymous-function-conversions)).

В анонимную функцию с параметром единый, неявно типизированные скобки можно опустить из списка параметров. Другими словами анонимная функция формы
```csharp
( param ) => expr
```
можно сократить до
```csharp
param => expr
```

Список параметров анонимной функции в виде *anonymous_method_expression* является необязательным. Если он задан, параметры должны быть явно типизированы. Если нет, можно преобразовать в делегат с помощью любого параметра анонимной функции, список, не содержащий `out` параметры.

Объект *блок* доступен тело анонимная функция ([конечные точки и доступность](statements.md#end-points-and-reachability)) пока не произойдет анонимной функции внутри инструкции недоступен.

Ниже приведены некоторые примеры анонимных функций ниже:

```csharp
x => x + 1                              // Implicitly typed, expression body
x => { return x + 1; }                  // Implicitly typed, statement body
(int x) => x + 1                        // Explicitly typed, expression body
(int x) => { return x + 1; }            // Explicitly typed, statement body
(x, y) => x * y                         // Multiple parameters
() => Console.WriteLine()               // No parameters
async (t1,t2) => await t1 + await t2    // Async
delegate (int x) { return x + 1; }      // Anonymous method expression
delegate { return 1 + 1; }              // Parameter list omitted
```

Поведение *lambda_expression*s и *anonymous_method_expression*s различается только следующие моменты:

*  *anonymous_method_expression*s разрешить список параметров, чтобы опустить целиком, обеспечивая возможность делегировать типы любой список параметров значение преобразования.
*  *lambda_expression*s разрешения типов параметр опущен и вывести, тогда как *anonymous_method_expression*s требуется явно указывать типы параметров.
*  Тело *lambda_expression* может быть выражение или блок операторов, тогда как тело *anonymous_method_expression* должен быть блок операторов.
*  Только *lambda_expression*имеют преобразования в типы дерева выражений, совместимый ([типы дерева выражений](types.md#expression-tree-types)).

### <a name="anonymous-function-signatures"></a>Сигнатуры анонимных функций

Необязательный *anonymous_function_signature* анонимной функции определяет имена и при необходимости типы формальных параметров для анонимной функции. Область параметров анонимной функции — *anonymous_function_body*. ([Областей](basic-concepts.md#scopes)) совместно со списком параметров (если есть) в тексте анонимного метода задает пространство объявления ([объявления](basic-concepts.md#declarations)). Таким образом является ошибкой во время компиляции для имени параметра анонимной функции в соответствии с именем локальной переменной, локальной константы или параметра, область которого входят *anonymous_method_expression* или *lambda_ выражение*.

Если анонимная функция *explicit_anonymous_function_signature*, а затем набор совместимых типов делегатов и типы дерева выражений, ограничены теми, которые с такими же типами параметров и модификаторы в том же порядке. В отличие от преобразования групп методов ([преобразования групп методов](conversions.md#method-group-conversions)), контрвариантность типов параметра анонимная функция не поддерживается. Если анонимная функция не имеет *anonymous_function_signature*, а затем набор совместимых типов делегатов и типы дерева выражений, ограничены теми, которые не имеют `out` параметров.

Обратите внимание, что *anonymous_function_signature* не может включать атрибуты или массивом параметров. Тем не менее *anonymous_function_signature* могут быть совместимы с типом делегата, список параметров которого содержит массив параметров.

Обратите внимание, что преобразование в тип дерева выражения, даже если совместимость, может привести к сбою во время компиляции ([типы дерева выражений](types.md#expression-tree-types)).

### <a name="anonymous-function-bodies"></a>Тела анонимных функций

Текст (*выражение* или *блок*) анонимной функции, регулируется следующими правилами:

*  Если анонимная функция включает сигнатуру, параметрам, указанным в сигнатуре доступны в тексте. Если анонимная функция не имеет подписи его можно преобразовать в тип делегата или тип выражения с параметрами ([преобразования анонимных функций](conversions.md#anonymous-function-conversions)), но параметры не в тексте.
*  За исключением `ref` или `out` параметров, указанных в сигнатуре (если таковые имеются) ближайшего внешнего анонимная функция, это ошибка времени компиляции для текста для доступа к `ref` или `out` параметра.
*  Если тип `this` является типом структуры, это ошибка времени компиляции для текста для доступа к `this`. Это верно, является ли доступ явные (как в `this.x`) или неявными (как в `x` где `x` является членом экземпляра структуры). Это правило просто запрещает такой доступ и не влияет на поиске члена является членом структуры.
*  Тело имеет доступ к внешним переменным ([переменные Outer](expressions.md#outer-variables)) анонимной функции. Доступ к внешней переменной будет ссылаться на экземпляр переменной, которая активна на момент *lambda_expression* или *anonymous_method_expression* вычисляется ([оценки выражения анонимных функций](expressions.md#evaluation-of-anonymous-function-expressions)).
*  Произошла ошибка во время компиляции, для текста, который содержит `goto` инструкции `break` инструкции или `continue` инструкции, целевой объект которого находится вне тела либо в теле содержащейся анонимной функции.
*  Объект `return` оператор в теле возвращает управление из вызова ближайшего внешнего оператора анонимной функции, не из включающей функции-члена. Выражения, указанного в `return` инструкция должна быть неявно преобразуемым в возвращаемый тип, тип делегата или тип дерева выражения, к которому ближайшего внешнего оператора *lambda_expression* или *anonymous_ method_expression* преобразуется ([преобразования анонимных функций](conversions.md#anonymous-function-conversions)).

Не явно указано, есть ли способ выполнить блок анонимной функции отличный от вычисления и вызов *lambda_expression* или *anonymous_method_expression*. В частности компилятор может реализовать анонимную функцию, создав один или несколько именованных методов или типов. Имена таких созданных элементов должны быть зарезервированы для внутреннего использования компиляторами формы.

### <a name="overload-resolution-and-anonymous-functions"></a>Разрешение перегрузки и анонимных функций

Анонимные функции в списке аргументов участвуют в выводе типа и разрешении перегрузки. Обратитесь к [вывод типа](expressions.md#type-inference) и [разрешение перегрузки](expressions.md#overload-resolution) конкретные правила.

В следующем примере показано влияние анонимных функций на разрешение перегрузки.

```csharp
class ItemList<T>: List<T>
{
    public int Sum(Func<T,int> selector) {
        int sum = 0;
        foreach (T item in this) sum += selector(item);
        return sum;
    }

    public double Sum(Func<T,double> selector) {
        double sum = 0;
        foreach (T item in this) sum += selector(item);
        return sum;
    }
}
```

`ItemList<T>` Класс имеет два `Sum` методы. Каждое принимает `selector` аргументом, который извлекает значение для суммы на из элемента списка. Извлеченное значение может быть либо `int` или `double` и Результирующая сумма равна точно так же `int` или `double`.

`Sum` Методы, например может использоваться для вычисления суммы из списка значений строк детализации в порядке.

```csharp
class Detail
{
    public int UnitCount;
    public double UnitPrice;
    ...
}

void ComputeSums() {
    ItemList<Detail> orderDetails = GetOrderDetails(...);
    int totalUnits = orderDetails.Sum(d => d.UnitCount);
    double orderTotal = orderDetails.Sum(d => d.UnitPrice * d.UnitCount);
    ...
}
```

В первом вызове `orderDetails.Sum`, оба `Sum` методы применимы так как анонимная функция `d => d. UnitCount` совместима с обоими `Func<Detail,int>` и `Func<Detail,double>`. Тем не менее, разрешение перегрузки выбирает первый `Sum` метод так как преобразование в `Func<Detail,int>` лучше, чем преобразование в `Func<Detail,double>`.

При втором вызове рабочих `orderDetails.Sum`, только второй `Sum` метод применим так как анонимная функция `d => d.UnitPrice * d.UnitCount` создает значение типа `double`. Таким образом, перегрузки при разрешении выбран второй `Sum` метод для вызова.

### <a name="anonymous-functions-and-dynamic-binding"></a>Анонимные функции и динамическая привязка

Анонимная функция не может быть получателем, аргументом или операнд динамически связанные операции.

### <a name="outer-variables"></a>Внешние переменные

Любой локальной переменной, значение параметра или массив параметров, область которого входят *lambda_expression* или *anonymous_method_expression* называется ***внешней переменной*** Анонимные функции. В экземпляр функции-члене класса `this` значение считается параметром значения и является внешней переменной любой анонимной функции, содержащиеся в функцию-член.

#### <a name="captured-outer-variables"></a>Захваченные внешние переменные

Если внешняя переменная ссылается анонимная функция, внешней переменной называется были ***захвата*** анонимной функцией. Как правило, время существования локальной переменной ограничен выполнения блока или инструкции, с которым он связан ([локальные переменные](variables.md#local-variables)). Тем не менее время существования захваченной внешней переменной увеличивается по крайней мере, пока делегат или дерево выражения, созданного из анонимная функция становится пригодным для сборки мусора.

В примере
```csharp
using System;

delegate int D();

class Test
{
    static D F() {
        int x = 0;
        D result = () => ++x;
        return result;
    }

    static void Main() {
        D d = F();
        Console.WriteLine(d());
        Console.WriteLine(d());
        Console.WriteLine(d());
    }
}
```
Локальная переменная `x` захвачена анонимной функции и время существования `x` расширяется по крайней мере, пока делегат, возвращенный `F` становится пригодным для сборки мусора (что произойдет до самого конца Программа). Поскольку каждый вызов анонимная функция работает на том же экземпляре `x`, выходные данные примера:
```
1
2
3
```

При локальной переменной или параметром записанным анонимную функцию, локальную переменную или параметр больше не считается фиксированная переменная ([атрибутов неизменности и перемещаемые переменные](unsafe-code.md#fixed-and-moveable-variables)), но вместо этого считается moveable переменная. Таким образом любой `unsafe` необходимо сначала использовать код, который принимает адрес захваченной внешней переменной `fixed` инструкцию, чтобы зафиксировать переменную.

Обратите внимание, что в отличие от переменной uncaptured, захваченной локальной переменной может быть открыт одновременно для нескольких потоков выполнения.

#### <a name="instantiation-of-local-variables"></a>Создание экземпляров локальных переменных

Локальная переменная считается ***экземпляр*** при выполнения входит в область действия переменной. Например, при вызове следующий метод, локальной переменной `x` создается и инициализируется три раза — один раз для каждой итерации цикла.

```csharp
static void F() {
    for (int i = 0; i < 3; i++) {
        int x = i * 2 + 1;
        ...
    }
}
```

Тем не менее, переместив объявления `x` за пределами цикла результаты в один экземпляр `x`:
```csharp
static void F() {
    int x;
    for (int i = 0; i < 3; i++) {
        x = i * 2 + 1;
        ...
    }
}
```

Когда не захвачена, не существует способа для наблюдения за точно, как часто создается локальная переменная, так как время существования экземпляров не существует вероятность для каждого экземпляра, чтобы просто использовать то же место хранения. Тем не менее когда анонимная функция захватывает локальную переменную, результат создания экземпляра становятся очевидными.

Пример
```csharp
using System;

delegate void D();

class Test
{
    static D[] F() {
        D[] result = new D[3];
        for (int i = 0; i < 3; i++) {
            int x = i * 2 + 1;
            result[i] = () => { Console.WriteLine(x); };
        }
        return result;
    }

    static void Main() {
        foreach (D d in F()) d();
    }
}
```
выводятся следующие выходные данные:
```
1
3
5
```

Тем не менее, если объявление `x` перемещается за пределы цикла:
```csharp
static D[] F() {
    D[] result = new D[3];
    int x;
    for (int i = 0; i < 3; i++) {
        x = i * 2 + 1;
        result[i] = () => { Console.WriteLine(x); };
    }
    return result;
}
```
Выводится следующий результат:
```
5
5
5
```

Цикл for объявляется переменная итерации, что сама переменная считается объявляться вне цикла. Таким образом Если изменить пример, чтобы записать и сама переменная итерации:

```csharp
static D[] F() {
    D[] result = new D[3];
    for (int i = 0; i < 3; i++) {
        result[i] = () => { Console.WriteLine(i); };
    }
    return result;
}
```
регистрируются только один экземпляр переменной итерации, в результате получается.
```
3
3
3
```

Делегаты анонимных функций могут совместно использовать некоторые захваченные переменные еще нет отдельные экземпляры других возможна. Например если `F` изменяется на
```csharp
static D[] F() {
    D[] result = new D[3];
    int x = 0;
    for (int i = 0; i < 3; i++) {
        int y = 0;
        result[i] = () => { Console.WriteLine("{0} {1}", ++x, ++y); };
    }
    return result;
}
```
три делегаты записи тот же экземпляр `x` но отдельным экземплярам `y`, и выходные данные:
```
1 1
2 1
3 1
```

Отдельные анонимные функции могут захватывать один экземпляр внешней переменной. В данном примере:
```csharp
using System;

delegate void Setter(int value);

delegate int Getter();

class Test
{
    static void Main() {
        int x = 0;
        Setter s = (int value) => { x = value; };
        Getter g = () => { return x; };
        s(5);
        Console.WriteLine(g());
        s(10);
        Console.WriteLine(g());
    }
}
```
две анонимные функции захватывают один экземпляр локальной переменной `x`, и таким образом «связи» через эту переменную. Выходные данные этого примера является:
```
5
10
```

### <a name="evaluation-of-anonymous-function-expressions"></a>Вычисление выражения анонимных функций

Анонимная функция `F` всегда должен преобразовываться в тип делегата `D` или тип дерева выражения `E`, либо непосредственно, либо с помощью выполнения выражения создания делегата `new D(F)`. Это преобразование определяет результат анонимной функции, как описано в разделе [преобразования анонимных функций](conversions.md#anonymous-function-conversions).

## <a name="query-expressions"></a>Выражения запросов

***Выражения запросов*** предоставляют встроенные в язык синтаксис для запросов, которые аналогичны языки реляционные и иерархические запросов, таких как SQL и XQuery.

```antlr
query_expression
    : from_clause query_body
    ;

from_clause
    : 'from' type? identifier 'in' expression
    ;

query_body
    : query_body_clauses? select_or_group_clause query_continuation?
    ;

query_body_clauses
    : query_body_clause
    | query_body_clauses query_body_clause
    ;

query_body_clause
    : from_clause
    | let_clause
    | where_clause
    | join_clause
    | join_into_clause
    | orderby_clause
    ;

let_clause
    : 'let' identifier '=' expression
    ;

where_clause
    : 'where' boolean_expression
    ;

join_clause
    : 'join' type? identifier 'in' expression 'on' expression 'equals' expression
    ;

join_into_clause
    : 'join' type? identifier 'in' expression 'on' expression 'equals' expression 'into' identifier
    ;

orderby_clause
    : 'orderby' orderings
    ;

orderings
    : ordering (',' ordering)*
    ;

ordering
    : expression ordering_direction?
    ;

ordering_direction
    : 'ascending'
    | 'descending'
    ;

select_or_group_clause
    : select_clause
    | group_clause
    ;

select_clause
    : 'select' expression
    ;

group_clause
    : 'group' expression 'by' expression
    ;

query_continuation
    : 'into' identifier query_body
    ;
```

Выражение запроса начинается с `from` предложения и заканчивается либо `select` или `group` предложение. Начальный `from` предложение может следовать ноль или более `from`, `let`, `where`, `join` или `orderby` предложения. Каждый `from` предложение является генератором Знакомство с ***переменная диапазона*** диапазоне для элементов ***последовательности***. Каждый `let` предложение вводит переменную диапазона, представляющее значение, вычисляемое с помощью предыдущих переменных диапазона. Каждый `where` выражение является фильтром для исключения элементов из результата. Каждый `join` предложение сравнивает указанные ключи исходной последовательности с ключами другой последовательности, выдавая совпадающие пары. Каждый `orderby` предложение изменяет порядок элементов в соответствии с указанными критериями. Конечный `select` или `group` предложение указывает форму результата с точки зрения переменных диапазона. Наконец `into` предложение может использоваться для «splice» запросов, рассматривая результаты одного запроса как генератор в последующем запросе.

### <a name="ambiguities-in-query-expressions"></a>Неоднозначность в выражениях запросов

Выражения запросов содержат «контекстными ключевыми словами», т. е. идентификаторы, которые имеют особое значение в заданном контексте. В частности это `from`, `where`, `join`, `on`, `equals`, `into`, `let`, `orderby`, `ascending`, `descending`, `select`, `group` и `by`. Во избежание неоднозначности в выражениях запросов, из-за смешанных эти идентификаторы используются как ключевые слова или простые имена, эти идентификаторы считаются ключевые слова, при выполнении в любом месте в выражении запроса.

Для этой цели, выражение запроса является любое выражение, которое начинается с "`from identifier`«следуют любому маркеру, за исключением»`;`«,»`=`«или»`,`«.

Чтобы использовать эти слова в качестве идентификаторов в выражении запроса, они могут быть с префиксом "`@`" ([идентификаторы](lexical-structure.md#identifiers)).

### <a name="query-expression-translation"></a>Преобразования выражения запроса

В языке C# не указывайте семантика выполнения выражения запроса. Вместо этого выражения запроса преобразуются в вызовы методов, которые соответствуют *модели выражений запросов* ([шаблон выражения запроса](expressions.md#the-query-expression-pattern)). В частности, выражения запроса преобразуются в вызовы методов с именами `Where`, `Select`, `SelectMany`, `Join`, `GroupJoin`, `OrderBy`, `OrderByDescending`, `ThenBy`, `ThenByDescending`, `GroupBy`, и `Cast`. Эти методы должны иметь определенный подписи и типы результатов, как описано в разделе [шаблон выражения запроса](expressions.md#the-query-expression-pattern). Эти методы могут быть методами экземпляра запрашиваемого объекта или методов расширения, которые являются внешними по отношению к объекту, и они реализуют фактическое выполнение запроса.

Перевод из выражения запроса на вызовы методов — это синтаксические сопоставление, которое происходит перед любой тип привязки, или разрешение перегрузки выполнено. Перевод обязательно является синтаксически правильным, но не обязательно создавать семантически правильный код C#. Итоговый вызовы методов, обрабатываются как вызовы методов регулярных перевод выражений запросов, и это в свою очередь позволит обнаружить ошибки, например, если методы не существуют, если аргументы имеют неправильный типы или методы являются универсальными и не удается вывести тип.

Выражение запроса обрабатывается несколько раз, пока не удается выполнить дальнейшее сокращение возможны, применяя следующие переводы. Переводы, перечислены в порядке приложения: в каждом разделе предполагается, что переводы в предыдущих разделах выполнено тщательное и когда исчерпан, раздел будет не позже потребуется пересмотреть в обработке одном выражении запроса.

Назначение переменных диапазона не допускается в выражениях запросов. Тем не менее реализацию на C# может не всегда выполнять это ограничение, так как это иногда не возможно с помощью синтаксического преобразования схемы, представленных здесь.

При некоторых переводах вставляются переменные диапазона с прозрачного идентификаторами, обозначенное с помощью `*`. Особые свойства прозрачных идентификаторов рассматриваются в разделе [прозрачного идентификаторами](expressions.md#transparent-identifiers).

#### <a name="select-and-groupby-clauses-with-continuations"></a>Предложения SELECT и groupby с продолжениями

Выражение запроса с продолжением
```csharp
from ... into x ...
```
преобразуется в
```csharp
from x in ( from ... ) ...
```

Переводы в следующих разделах предполагается, что запросы не имеют `into` продолжений.

Пример
```csharp
from c in customers
group c by c.Country into g
select new { Country = g.Key, CustCount = g.Count() }
```
преобразуется в
```csharp
from g in
    from c in customers
    group c by c.Country
select new { Country = g.Key, CustCount = g.Count() }
```
Окончательный перевод, из которых —
```csharp
customers.
GroupBy(c => c.Country).
Select(g => new { Country = g.Key, CustCount = g.Count() })
```

#### <a name="explicit-range-variable-types"></a>Явные типы переменных диапазона

Объект `from` предложение, которая явно задает тип переменной диапазона
```csharp
from T x in e
```
преобразуется в
```csharp
from x in ( e ) . Cast < T > ( )
```

Объект `join` предложение, которая явно задает тип переменной диапазона
```
join T x in e on k1 equals k2
```
преобразуется в
```
join x in ( e ) . Cast < T > ( ) on k1 equals k2
```

Переводы в следующих разделах предполагается, что запросы не явные типы переменных диапазона.

Пример
```csharp
from Customer c in customers
where c.City == "London"
select c
```
преобразуется в
```csharp
from c in customers.Cast<Customer>()
where c.City == "London"
select c
```
Окончательный перевод, из которых —
```csharp
customers.
Cast<Customer>().
Where(c => c.City == "London")
```

Явные типы переменных диапазона полезны для выполнения запросов к коллекциям, которые реализуют неуниверсальный `IEnumerable` интерфейс, но не универсальный `IEnumerable<T>` интерфейс. В приведенном выше примере это будет том случае, если `customers` имели тип `ArrayList`.

#### <a name="degenerate-query-expressions"></a>Выражения вырожденных запросов

Выражение запроса формы
```csharp
from x in e select x
```
преобразуется в
```csharp
( e ) . Select ( x => x )
```

Пример
```csharp
from c in customers
select c
```
преобразуется в
```csharp
customers.Select(c => c)
```

Выражение вырожденного запроса является просто выбирает элементы источника. На более позднем этапе перевода удаляет вырожденных запросов, созданных на других этапах перевода, заменив их с их источником. Тем не менее важно, чтобы убедиться, что результат запроса выражение никогда не является исходный объект, как это раскроет тип и идентификатор источника для запроса клиента. Таким образом, этот шаг защищает вырожденный запросы, написанные непосредственно в исходном коде, путем явного вызова `Select` в источнике. Сами объекты, реализующие `Select` и других операторов запроса, чтобы убедиться, что эти методы возвращают никогда не самого объекта источника.

#### <a name="from-let-where-join-and-orderby-clauses"></a>Let, where, предложения join и orderby

Выражение запроса с секунды `from` предложение, за которым следует `select` предложение
```csharp
from x1 in e1
from x2 in e2
select v
```
преобразуется в
```csharp
( e1 ) . SelectMany( x1 => e2 , ( x1 , x2 ) => v )
```

Выражение запроса с секунды `from` предложение следуют что-то отличное от `select` предложение:

```csharp
from x1 in e1
from x2 in e2
...
```
преобразуется в
```csharp
from * in ( e1 ) . SelectMany( x1 => e2 , ( x1 , x2 ) => new { x1 , x2 } )
...
```

Выражение запроса с `let` предложение
```csharp
from x in e
let y = f
...
```
преобразуется в
```csharp
from * in ( e ) . Select ( x => new { x , y = f } )
...
```

Выражение запроса с `where` предложение
```csharp
from x in e
where f
...
```
преобразуется в
```csharp
from x in ( e ) . Where ( x => f )
...
```

Выражение запроса с `join` предложения без `into` следуют `select` предложение
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2
select v
```
преобразуется в
```csharp
( e1 ) . Join( e2 , x1 => k1 , x2 => k2 , ( x1 , x2 ) => v )
```

Выражение запроса с `join` предложения без `into` следуют что-то отличное от `select` предложение
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2
...
```
преобразуется в
```csharp
from * in ( e1 ) . Join( e2 , x1 => k1 , x2 => k2 , ( x1 , x2 ) => new { x1 , x2 })
...
```

Выражение запроса с `join` предложение with `into` следуют `select` предложение
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2 into g
select v
```
преобразуется в
```csharp
( e1 ) . GroupJoin( e2 , x1 => k1 , x2 => k2 , ( x1 , g ) => v )
```

Выражение запроса с `join` предложение with `into` следуют что-то отличное от `select` предложение
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2 into g
...
```
преобразуется в
```csharp
from * in ( e1 ) . GroupJoin( e2 , x1 => k1 , x2 => k2 , ( x1 , g ) => new { x1 , g })
...
```

Выражение запроса с `orderby` предложение
```csharp
from x in e
orderby k1 , k2 , ..., kn
...
```
преобразуется в
```csharp
from x in ( e ) . 
OrderBy ( x => k1 ) . 
ThenBy ( x => k2 ) .
... .
ThenBy ( x => kn )
...
```

Если упорядочение предложение задает `descending` индикатором направления, как вызов `OrderByDescending` или `ThenByDescending` вместо этого создается.

Следующие переводы предполагается, что не `let`, `where`, `join` или `orderby` предложения, а не более одного начального `from` предложение в каждое выражение запроса.

Пример
```csharp
from c in customers
from o in c.Orders
select new { c.Name, o.OrderID, o.Total }
```
преобразуется в
```csharp
customers.
SelectMany(c => c.Orders,
     (c,o) => new { c.Name, o.OrderID, o.Total }
)
```

Пример
```csharp
from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
```
преобразуется в
```csharp
from * in customers.
    SelectMany(c => c.Orders, (c,o) => new { c, o })
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
```
Окончательный перевод, из которых —
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(x => x.o.Total).
Select(x => new { x.c.Name, x.o.OrderID, x.o.Total })
```
где `x` идентификатор созданный компилятором, в противном случае и недоступными.

Пример
```csharp
from o in orders
let t = o.Details.Sum(d => d.UnitPrice * d.Quantity)
where t >= 1000
select new { o.OrderID, Total = t }
```
преобразуется в
```csharp
from * in orders.
    Select(o => new { o, t = o.Details.Sum(d => d.UnitPrice * d.Quantity) })
where t >= 1000 
select new { o.OrderID, Total = t }
```
Окончательный перевод, из которых —
```csharp
orders.
Select(o => new { o, t = o.Details.Sum(d => d.UnitPrice * d.Quantity) }).
Where(x => x.t >= 1000).
Select(x => new { x.o.OrderID, Total = x.t })
```
где `x` идентификатор созданный компилятором, в противном случае и недоступными.

Пример
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID
select new { c.Name, o.OrderDate, o.Total }
```
преобразуется в
```csharp
customers.Join(orders, c => c.CustomerID, o => o.CustomerID,
    (c, o) => new { c.Name, o.OrderDate, o.Total })
```

Пример
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID into co
let n = co.Count()
where n >= 10
select new { c.Name, OrderCount = n }
```
преобразуется в
```csharp
from * in customers.
    GroupJoin(orders, c => c.CustomerID, o => o.CustomerID,
        (c, co) => new { c, co })
let n = co.Count()
where n >= 10 
select new { c.Name, OrderCount = n }
```
Окончательный перевод, из которых —
```csharp
customers.
GroupJoin(orders, c => c.CustomerID, o => o.CustomerID,
    (c, co) => new { c, co }).
Select(x => new { x, n = x.co.Count() }).
Where(y => y.n >= 10).
Select(y => new { y.x.c.Name, OrderCount = y.n)
```
где `x` и `y` являются идентификаторы, созданные компилятором, в противном случае и недоступными.

Пример
```csharp
from o in orders
orderby o.Customer.Name, o.Total descending
select o
```
имеет конечный перевод
```csharp
orders.
OrderBy(o => o.Customer.Name).
ThenByDescending(o => o.Total)
```

#### <a name="select-clauses"></a>Выберите предложения

Выражение запроса формы
```csharp
from x in e select v
```
преобразуется в
```csharp
( e ) . Select ( x => v )
```
Кроме случаев, когда v идентификатор x, перевод — это просто
```csharp
( e )
```

Пример
```csharp
from c in customers.Where(c => c.City == "London")
select c
```
просто преобразуется в
```csharp
customers.Where(c => c.City == "London")
```

#### <a name="groupby-clauses"></a>Предложения GroupBy

Выражение запроса формы
```csharp
from x in e group v by k
```
преобразуется в
```csharp
( e ) . GroupBy ( x => k , x => v )
```
Кроме случаев, когда v идентификатор x, преобразование является
```csharp
( e ) . GroupBy ( x => k )
```

Пример
```csharp
from c in customers
group c.Name by c.Country
```
преобразуется в
```csharp
customers.
GroupBy(c => c.Country, c => c.Name)
```

#### <a name="transparent-identifiers"></a>Прозрачные идентификаторы

При некоторых переводах вставляются переменные диапазона с ***прозрачного идентификаторами*** обозначается `*`. Прозрачные идентификаторы не являются компонентом языка; они существуют только в качестве промежуточного шага в процессе преобразования выражения запроса.

При переводе запроса вставляется прозрачный идентификатор, дальнейшие этапы перевода распространяют прозрачный идентификатор в анонимные функции и инициализатора анонимных объектов. В таких контекстах прозрачные идентификаторы имеют следующие особенности:

*  Когда прозрачный идентификатор как параметр в анонимную функцию, члены связанного анонимного типа автоматически находятся в области действия в теле анонимной функции.
*  Когда член с прозрачным идентификатором находится в области, члены этого члена находятся в области также.
*  Когда прозрачный идентификатор роли декларатора члена в инициализаторе анонимного объекта, он создает член с прозрачным идентификатором.
*  В трансляции действия, описанные выше прозрачные идентификаторы всегда вводятся вместе с анонимными типами, с целью сохранить несколько переменных диапазона в качестве членов объекта. Реализация C# может использовать другой механизм от анонимных типов, чтобы сгруппировать несколько переменных диапазона. В следующих примерах перевода предполагается, что анонимные типы используются и Показать как прозрачные идентификаторы могут быть немедленно переведены.

Пример
```csharp
from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.Total }
```
преобразуется в
```csharp
from * in customers.
    SelectMany(c => c.Orders, (c,o) => new { c, o })
orderby o.Total descending
select new { c.Name, o.Total }
```

еще более преобразуется в
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(* => o.Total).
Select(* => new { c.Name, o.Total })
```
что, когда удаления прозрачных идентификаторов, эквивалентно
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(x => x.o.Total).
Select(x => new { x.c.Name, x.o.Total })
```
где `x` идентификатор созданный компилятором, в противном случае и недоступными.

Пример
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
```
преобразуется в
```csharp
from * in customers.
    Join(orders, c => c.CustomerID, o => o.CustomerID, 
        (c, o) => new { c, o })
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
```
что дальше сокращается до
```csharp
customers.
Join(orders, c => c.CustomerID, o => o.CustomerID, (c, o) => new { c, o }).
Join(details, * => o.OrderID, d => d.OrderID, (*, d) => new { *, d }).
Join(products, * => d.ProductID, p => p.ProductID, (*, p) => new { *, p }).
Select(* => new { c.Name, o.OrderDate, p.ProductName })
```
Окончательный перевод, из которых —
```csharp
customers.
Join(orders, c => c.CustomerID, o => o.CustomerID,
    (c, o) => new { c, o }).
Join(details, x => x.o.OrderID, d => d.OrderID,
    (x, d) => new { x, d }).
Join(products, y => y.d.ProductID, p => p.ProductID,
    (y, p) => new { y, p }).
Select(z => new { z.y.x.c.Name, z.y.x.o.OrderDate, z.p.ProductName })
```
где `x`, `y`, и `z` являются идентификаторы, созданные компилятором, в противном случае и недоступными.

### <a name="the-query-expression-pattern"></a>Шаблон выражения запроса

***Модели выражений запросов*** задает шаблон методы, реализующие типы для поддержки выражений запросов. Так как выражения запроса преобразуются в вызовы методов с помощью синтаксического сопоставления, типы имеют значительную гибкость в реализации модели выражений запросов. Например методы шаблона можно реализовать как методы экземпляра или как методы расширения, так как они имеют одинаковый синтаксис вызова, и методы могут запрашивать делегаты или в деревья выражений, поскольку анонимные функции могут быть преобразованы в обоих.

Рекомендуемый формат универсального типа `C<T>` что поддерживает шаблон выражения запроса показан ниже. Универсальный тип используется, чтобы продемонстрировать правильные отношения между типами параметров и результатов, но это можно реализовать шаблон для неуниверсальных типов, а также.

```csharp
delegate R Func<T1,R>(T1 arg1);

delegate R Func<T1,T2,R>(T1 arg1, T2 arg2);

class C
{
    public C<T> Cast<T>();
}

class C<T> : C
{
    public C<T> Where(Func<T,bool> predicate);

    public C<U> Select<U>(Func<T,U> selector);

    public C<V> SelectMany<U,V>(Func<T,C<U>> selector,
        Func<T,U,V> resultSelector);

    public C<V> Join<U,K,V>(C<U> inner, Func<T,K> outerKeySelector,
        Func<U,K> innerKeySelector, Func<T,U,V> resultSelector);

    public C<V> GroupJoin<U,K,V>(C<U> inner, Func<T,K> outerKeySelector,
        Func<U,K> innerKeySelector, Func<T,C<U>,V> resultSelector);

    public O<T> OrderBy<K>(Func<T,K> keySelector);

    public O<T> OrderByDescending<K>(Func<T,K> keySelector);

    public C<G<K,T>> GroupBy<K>(Func<T,K> keySelector);

    public C<G<K,E>> GroupBy<K,E>(Func<T,K> keySelector,
        Func<T,E> elementSelector);
}

class O<T> : C<T>
{
    public O<T> ThenBy<K>(Func<T,K> keySelector);

    public O<T> ThenByDescending<K>(Func<T,K> keySelector);
}

class G<K,T> : C<T>
{
    public K Key { get; }
}
```

Выше методы используют типы универсальных делегатов `Func<T1,R>` и `Func<T1,T2,R>`, но также их можно одинаково хорошо использовать другие типы дерева делегата или выражения с тем же связи в типы параметров и результата.

Обратите внимание на рекомендуемые соотношение `C<T>` и `O<T>` гарантирует, что `ThenBy` и `ThenByDescending` методы доступны только на результат `OrderBy` или `OrderByDescending`. Также Обратите внимание на рекомендуемый результата `GroupBy` --последовательности массивов, где каждая внутренняя последовательность имеет дополнительный `Key` свойство.

`System.Linq` Пространство имен предоставляет реализацию шаблона запроса оператор для любого типа, реализующего `System.Collections.Generic.IEnumerable<T>` интерфейс.

## <a name="assignment-operators"></a>Операторы присваивания

Операторы присваивания назначить новое значение переменной, свойства, события или элемента индексатора.

```antlr
assignment
    : unary_expression assignment_operator expression
    ;

assignment_operator
    : '='
    | '+='
    | '-='
    | '*='
    | '/='
    | '%='
    | '&='
    | '|='
    | '^='
    | '<<='
    | right_shift_assignment
    ;
```

Левый операнд присваивания должен быть выражением, классифицируется как переменная, доступ к свойству, индексатору или доступ к событию.

`=` Оператор был вызван ***оператор простого присваивания***. Значение правого операнда присваивается переменной, свойством или индексатором элемент, учитывая левым операндом. Левый операнд оператора простого присваивания не может быть доступ к событию (кроме случаев, описанных в [подобные полям события](classes.md#field-like-events)). Оператор простого присваивания описан в [простое присваивание](expressions.md#simple-assignment).

Операторы присваивания, отличных от `=` оператор называются ***составные операторы присваивания***. Эти операторы выполняют указанную операцию с двумя операндами и назначьте результирующее значение переменной, свойством или индексатором элемент, учитывая левым операндом. Составные операторы присваивания, описаны в [Составное присваивание](expressions.md#compound-assignment).

`+=` И `-=` операторы с выражением доступа события как левый операнд называются *операторы присваивания событий*. Ни один другой оператор присваивания допустим для доступа к событию в качестве левого операнда. Операторы присваивания событий описаны в [назначения события](expressions.md#event-assignment).

Операторы присваивания имеют правую ассоциативность, это означает, что операции группируются слева направо. Например, выражение в форме `a = b = c` вычисляется как `a = (b = c)`.

### <a name="simple-assignment"></a>Простое присваивание

`=` Оператор был вызван оператор простого присваивания.

Если левый операнд выражения простого присваивания имеет форму `E.P` или `E[Ei]` где `E` имеет тип времени компиляции `dynamic`, а затем назначения является динамическим ([динамической привязки](expressions.md#dynamic-binding)). В данном случае является типов во время компиляции выражения присваивания `dynamic`, а разрешение, приведенное ниже будет иметь место во время выполнения, исходя из типа времени выполнения `E`.

При простом присваивании правый операнд должен быть выражением, который может быть неявно преобразован в тип левого операнда. Операции значение правого операнда присваивается переменной, свойством или индексатором элемент, учитывая левым операндом.

Результат выражения простого присваивания имеет значение, присваиваемое левый операнд. Результат имеет тот же тип, что и левый операнд и всегда классифицируется как значение.

Если левый операнд является обращение к свойство или индексатор, свойство или индексатор должны `set` метода доступа. Если это не так, возникает ошибка времени привязки.

Во время выполнения обработки простого присваивания вида `x = y` состоит из следующих действий:

*  Если `x` классифицируется как переменная:
   * `x` вычисляется для создания переменной.
   * `y` вычисляется и, при необходимости, преобразуется в тип `x` через неявное преобразование ([неявные преобразования](conversions.md#implicit-conversions)).
   * Если переменная, представленная `x` элементом массива является *reference_type*, проводится проверка во время выполнения, чтобы убедиться, что значение, вычисленное для `y` совместима с экземпляр массива, из которых `x` — элемент. Проверка завершится успешно, если `y` — `null`, или если и неявное ссылочное преобразование ([неявные преобразования ссылочных типов](conversions.md#implicit-reference-conversions)) из фактический тип экземпляра, существует `y` к фактическим типом элемента экземпляр массива, содержащего `x`. В противном случае возникает исключение `System.ArrayTypeMismatchException`.
   * Значение, являющееся результатом вычисления и преобразования `y` хранится в расположении, указанном вычисления `x`.
*  Если `x` классифицируется как свойство или индексатор доступа:
   * Выражение экземпляра (если `x` не `static`) и список аргументов (если `x` имеет доступ к индексатору) связанные с `x` оцениваются, и полученные результаты используются в последующих `set` вызов метода доступа.
   * `y` вычисляется и, при необходимости, преобразуется в тип `x` через неявное преобразование ([неявные преобразования](conversions.md#implicit-conversions)).
   * `set` Метод доступа `x` вызывается со значением, вычисленным для `y` как его `value` аргумент.

Правила совместного расхождения массива ([ковариацией](arrays.md#array-covariance)) разрешает значение типа массива `A[]` чтобы ссылаться на экземпляр типа массива `B[]`, если существует неявное преобразование ссылок из `B` для `A`. Из-за этих правил назначения на элемент массива из *reference_type* требует проверки во время выполнения, чтобы убедиться, что значения, присваиваемого совместима с экземпляром массива. В примере
```csharp
string[] sa = new string[10];
object[] oa = sa;

oa[0] = null;               // Ok
oa[1] = "Hello";            // Ok
oa[2] = new ArrayList();    // ArrayTypeMismatchException
```
Последнее присваивание вызывает `System.ArrayTypeMismatchException` исключение, так как экземпляр `ArrayList` не могут храниться в элементе `string[]`.

Если свойство или индексатор, объявленный в *struct_type* является целевым объектом назначения, выражение экземпляра, связанное со свойством или доступа к индексатору должно быть классифицировано как переменную. Если экземпляр выражение классифицируется как значение, возникает ошибка времени привязки. Из-за [доступ к членам](expressions.md#member-access), то же правило также применяется к полям.

В объявлениях:
```csharp
struct Point
{
    int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int X {
        get { return x; }
        set { x = value; }
    }

    public int Y {
        get { return y; }
        set { y = value; }
    }
}

struct Rectangle
{
    Point a, b;

    public Rectangle(Point a, Point b) {
        this.a = a;
        this.b = b;
    }

    public Point A {
        get { return a; }
        set { a = value; }
    }

    public Point B {
        get { return b; }
        set { b = value; }
    }
}
```
В примере
```csharp
Point p = new Point();
p.X = 100;
p.Y = 100;
Rectangle r = new Rectangle();
r.A = new Point(10, 10);
r.B = p;
```
назначения, которые `p.X`, `p.Y`, `r.A`, и `r.B` разрешены, так как `p` и `r` являются переменными. Тем не менее в примере
```csharp
Rectangle r = new Rectangle();
r.A.X = 10;
r.A.Y = 10;
r.B.X = 100;
r.B.Y = 100;
```
назначения будут недопустимы, так как `r.A` и `r.B` не являются переменными.

### <a name="compound-assignment"></a>Составное присваивание

Если левый операнд составного оператора присваивания имеет форму `E.P` или `E[Ei]` где `E` имеет тип времени компиляции `dynamic`, а затем назначения является динамическим ([динамической привязки](expressions.md#dynamic-binding)). В данном случае является типов во время компиляции выражения присваивания `dynamic`, а разрешение, приведенное ниже будет иметь место во время выполнения, исходя из типа времени выполнения `E`.

Операции формы `x op= y` обрабатывается путем применения бинарного оператора перегрузках ([разрешить перегрузку бинарного оператора](expressions.md#binary-operator-overload-resolution)) как если бы операция была `x op y`. Затем,

*  Если тип возвращаемого значения выбранного оператора неявно преобразуется в тип `x`, операция вычисляется как `x = x op y`, за исключением того, что `x` вычисляется только один раз.
*  В противном случае, если выбранный оператор является определенного оператора, если тип возвращаемого значения выбранного оператора явно преобразуется в тип `x`и если `y` неявно преобразуется в тип `x` или оператор оператор, сдвига, то операция вычисляется как `x = (T)(x op y)`, где `T` — это тип `x`, за исключением того, что `x` вычисляется только один раз.
*  В противном случае составного присваивания является недопустимым, и возникает ошибка во время привязки.

Термин «вычисляется только один раз» означает, что при вычислении `x op y`, результаты все составные выражения `x` временно сохраняются и повторно при выполнении назначения `x`. Например, в назначении `A()[B()] += C()`, где `A` — это метод, возвращающий `int[]`, и `B` и `C` являются методами, возвращающими `int`, эти методы вызываются только один раз, в том порядке, `A`, `B`, `C`.

Если левый операнд составного оператора присваивания доступ к свойству или индексатору, свойство или индексатор должны иметь `get` метода доступа и `set` метода доступа. Если это не так, возникает ошибка времени привязки.

Второе правило выше разрешает `x op= y` для оценки в качестве `x = (T)(x op y)` в определенных контекстах. Правило существует, таким образом, что стандартные операторы можно использовать как составные операторы, если левый операнд имеет тип `sbyte`, `byte`, `short`, `ushort`, или `char`. Даже если оба аргумента имеют один из таких типов, стандартные операторы дают результат типа `int`, как описано в разделе [Числовое расширение бинарных операторов](expressions.md#binary-numeric-promotions). Таким образом без приведения не было бы невозможно присвоить результат левому операнду.

Интуитивно понятный правила для стандартных операторов действует так просто, `x op= y` разрешается, если оба объекта `x op y` и `x = y` разрешены. В примере
```csharp
byte b = 0;
char ch = '\0';
int i = 0;

b += 1;             // Ok
b += 1000;          // Error, b = 1000 not permitted
b += i;             // Error, b = i not permitted
b += (byte)i;       // Ok

ch += 1;            // Error, ch = 1 not permitted
ch += (char)1;      // Ok
```
интуитивно понятный для каждой ошибки связано с тем что соответствующее простое присваивание также было бы ошибку.

Это также означает, что составной операции присваивания поддерживают ликвидированный операций. В примере
```csharp
int? i = 0;
i += 1;             // Ok
```
оператор ликвидированный `+(int?,int?)` используется.

### <a name="event-assignment"></a>Назначение событий

Если левый операнд `+=` или `-=` оператор классифицируется как доступ к событию, то выражение вычисляется следующим образом:

*  Экземпляр, если таковые имеются, доступа к событию выражение.
*  Правый операнд `+=` или `-=` оператор вычисляется и, при необходимости, преобразуется в тип левого операнда через неявное преобразование ([неявные преобразования](conversions.md#implicit-conversions)).
*  Вызывается метод доступа события, события, со списком аргументов, состоящая из правого операнда, после оценки и, при необходимости преобразования. Если оператор был `+=`, `add` вызывается метод доступа; Если оператор был `-=`, `remove` вызывается метод доступа.

Выражение присваивания события не использовать оператор yield. Таким образом, выражение присваивания события допустимо только в контексте *statement_expression* ([операторы выражений](statements.md#expression-statements)).

## <a name="expression"></a>Выражение

*Выражение* либо *non_assignment_expression* или *назначения*.

```antlr
expression
    : non_assignment_expression
    | assignment
    ;

non_assignment_expression
    : conditional_expression
    | lambda_expression
    | query_expression
    ;
```

## <a name="constant-expressions"></a>Константные выражения

Объект *constant_expression* выражение, которое можно полностью вычислить во время компиляции.

```antlr
constant_expression
    : expression
    ;
```

Константное выражение должно быть `null` литерал или значение с одним из следующих типов: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char` , `float`, `double`, `decimal`, `bool`, `object`, `string`, или любой тип перечисления. В константных выражениях допустимы только следующие конструкции:

*  Литералы (включая `null` литерал).
*  Ссылки на `const` члены класса и структуры типов.
*  Ссылки на члены типов перечисления.
*  Ссылки на `const` параметры или локальные переменные
*  Вложенные выражения в скобках, которые сами являются константными выражениями.
*  Выражения приведения, предоставленный тип объекта является одним из перечисленных выше типов.
*  `checked` и `unchecked` выражения
*  Выражения значения по умолчанию
*  Выражения Nameof
*  Предопределенный `+`, `-`, `!`, и `~` унарные операторы.
*  Предопределенный `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `&`, `|`, `^`, `&&`, `||`, `==`, `!=`, `<`, `>`, `<=`, и `>=` бинарные операторы, предоставляемые каждый операнд имеет тип, перечисленных выше.
*  `?:` Условного оператора.

В константных выражениях допустимы следующие преобразования:

*  Преобразования идентификатора
*  Числовые преобразования
*  Преобразование перечисления
*  Константное выражение преобразования
*  Явные и неявные преобразования ссылочных типов, указано, что источник преобразования является константным выражением, результатом которого является значение null.

Другие преобразования, включая упаковки-преобразования, распаковки-преобразования и неявные преобразования ссылочных типов значений, отличных от null не разрешены в константных выражениях. Пример:
```csharp
class C {
    const object i = 5;         // error: boxing conversion not permitted
    const object str = "hello"; // error: implicit reference conversion
}
```
Инициализация i является ошибкой, поскольку необходима упаковка-преобразование. Инициализация str является ошибкой, так как требуется и неявное ссылочное преобразование из значения, отличное от null.

Если выражение соответствует требованиям, перечисленным выше, выражение вычисляется во время компиляции. Это справедливо, даже если выражение вложенного выражения содержит конструкции Неконстантные выражения.

Вычисление во время компиляции постоянных выражений использует те же правила в качестве времени выполнения вычисления Неконстантные выражения, за исключением того, что где возвращал исключение времени выполнения вычисления исключение, вычисление во время компиляции вызовет ошибку компиляции возникает.

Если константное выражение явным образом помещается в `unchecked` контекста, переполнения, возникающие в целочисленных арифметических операций и преобразований во время компиляции вычисления выражения всегда вызывать ошибки времени компиляции ([Константные выражения](expressions.md#constant-expressions)).

Константные выражения находятся в контекстах, перечисленных ниже. В таких контекстах ошибка времени компиляции возникает, если выражение не удается полностью вычислить во время компиляции.

*  Объявления констант ([константы](classes.md#constants)).
*  Объявления членов перечисления ([члены перечисления](enums.md#enum-members)).
*  Аргументы списков формальных параметров по умолчанию ([параметры метода](classes.md#method-parameters))
*  `case` метки `switch` инструкции ([оператора switch](statements.md#the-switch-statement)).
*  `goto case` операторы ([инструкцию goto](statements.md#the-goto-statement)).
*  Длины измерений в выражение создания массива ([выражениях создания массива](expressions.md#array-creation-expressions)), включает в себя инициализатор.
*  Атрибуты ([атрибуты](attributes.md)).

Неявные преобразования выражений констант ([неявные преобразования выражений констант](conversions.md#implicit-constant-expression-conversions)) позволяет константное выражение типа `int` для преобразования в `sbyte`, `byte`, `short`, `ushort`, `uint`, или `ulong`, если значение константного выражения находится в диапазоне конечного типа.

## <a name="boolean-expressions"></a>логические выражения

Объект *boolean_expression* представляет собой выражение, результатом выполнения тип `bool`; либо напрямую или путем применения `operator true` в определенных контекстах, как указано ниже.

```antlr
boolean_expression
    : expression
    ;
```

Управляющее выражение условного оператора *if_statement* ([if инструкции](statements.md#the-if-statement)), *while_statement* ([оператор while](statements.md#the-while-statement)), *do_statement* ([инструкции do](statements.md#the-do-statement)), или *for_statement* ([для инструкции](statements.md#the-for-statement)) является *boolean_ выражение*. Управляющее выражение условного оператора `?:` оператор ([условный оператор](expressions.md#conditional-operator)) работает так же как *boolean_expression*, но по соображениям оператора классифицируется приоритет как *conditional_or_expression*.

Объект *boolean_expression* `E` должен иметь возможность получения значения типа `bool`, как показано ниже:

*  Если `E` неявно преобразуется к типу `bool` во время выполнения применяется это неявное преобразование.
*  В противном случае разрешение перегрузки унарного оператора ([разрешение перегрузки унарного оператора](expressions.md#unary-operator-overload-resolution)) используется для поиска наиболее уникальную реализацию оператора `true` на `E`, и что реализация применяется во время выполнения.
*  Если оператор не найден, возникает ошибка времени привязки.

`DBBool` Типа структуры в [базы данных логического типа](structs.md#database-boolean-type) является примером типа, который реализует `operator true` и `operator false`.
