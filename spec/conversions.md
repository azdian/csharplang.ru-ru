# <a name="conversions"></a><span data-ttu-id="d11f1-101">Преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-101">Conversions</span></span>

<span data-ttu-id="d11f1-102">Объект ***преобразования*** позволяет выражению могут обрабатываться как определенного типа.</span><span class="sxs-lookup"><span data-stu-id="d11f1-102">A ***conversion*** enables an expression to be treated as being of a particular type.</span></span> <span data-ttu-id="d11f1-103">Преобразование может вызвать выражение типа, заданного для рассматриваться как имеющий другой тип, иначе могут возникнуть выражение без типа, определенного типа.</span><span class="sxs-lookup"><span data-stu-id="d11f1-103">A conversion may cause an expression of a given type to be treated as having a different type, or it may cause an expression without a type to get a type.</span></span> <span data-ttu-id="d11f1-104">Преобразования могут быть ***неявное*** или ***явные***, и это определяет, является ли обязательным явное приведение.</span><span class="sxs-lookup"><span data-stu-id="d11f1-104">Conversions can be ***implicit*** or ***explicit***, and this determines whether an explicit cast is required.</span></span> <span data-ttu-id="d11f1-105">Например, преобразование из типа `int` ввода `long` является неявным, Да выражения типа `int` неявно могут рассматриваться как тип `long`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-105">For instance, the conversion from type `int` to type `long` is implicit, so expressions of type `int` can implicitly be treated as type `long`.</span></span> <span data-ttu-id="d11f1-106">Обратное преобразование из типа `long` ввода `int`, является явным и поэтому не требуется явное приведение.</span><span class="sxs-lookup"><span data-stu-id="d11f1-106">The opposite conversion, from type `long` to type `int`, is explicit and so an explicit cast is required.</span></span>

```csharp
int a = 123;
long b = a;         // implicit conversion from int to long
int c = (int) b;    // explicit conversion from long to int
```

<span data-ttu-id="d11f1-107">Некоторые преобразования определяются языком.</span><span class="sxs-lookup"><span data-stu-id="d11f1-107">Some conversions are defined by the language.</span></span> <span data-ttu-id="d11f1-108">Программы могут также определять собственные преобразования ([заданные пользователем преобразования](conversions.md#user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-108">Programs may also define their own conversions ([User-defined conversions](conversions.md#user-defined-conversions)).</span></span>

## <a name="implicit-conversions"></a><span data-ttu-id="d11f1-109">Неявные преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-109">Implicit conversions</span></span>

<span data-ttu-id="d11f1-110">Неявные преобразования относятся следующие преобразования:</span><span class="sxs-lookup"><span data-stu-id="d11f1-110">The following conversions are classified as implicit conversions:</span></span>

*  <span data-ttu-id="d11f1-111">Преобразования идентификатора</span><span class="sxs-lookup"><span data-stu-id="d11f1-111">Identity conversions</span></span>
*  <span data-ttu-id="d11f1-112">Неявные числовые преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-112">Implicit numeric conversions</span></span>
*  <span data-ttu-id="d11f1-113">Неявные преобразования перечисляемых типов.</span><span class="sxs-lookup"><span data-stu-id="d11f1-113">Implicit enumeration conversions.</span></span>
*  <span data-ttu-id="d11f1-114">Неявные преобразования, допускающие значение NULL</span><span class="sxs-lookup"><span data-stu-id="d11f1-114">Implicit nullable conversions</span></span>
*  <span data-ttu-id="d11f1-115">Преобразования литерала NULL.</span><span class="sxs-lookup"><span data-stu-id="d11f1-115">Null literal conversions</span></span>
*  <span data-ttu-id="d11f1-116">Неявные преобразования ссылочных типов</span><span class="sxs-lookup"><span data-stu-id="d11f1-116">Implicit reference conversions</span></span>
*  <span data-ttu-id="d11f1-117">Упаковки-преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-117">Boxing conversions</span></span>
*  <span data-ttu-id="d11f1-118">Неявные преобразования динамических типов</span><span class="sxs-lookup"><span data-stu-id="d11f1-118">Implicit dynamic conversions</span></span>
*  <span data-ttu-id="d11f1-119">Неявные преобразования выражений констант</span><span class="sxs-lookup"><span data-stu-id="d11f1-119">Implicit constant expression conversions</span></span>
*  <span data-ttu-id="d11f1-120">Определяемые пользователем неявные преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-120">User-defined implicit conversions</span></span>
*  <span data-ttu-id="d11f1-121">Преобразования анонимных функций</span><span class="sxs-lookup"><span data-stu-id="d11f1-121">Anonymous function conversions</span></span>
*  <span data-ttu-id="d11f1-122">Преобразования групп методов</span><span class="sxs-lookup"><span data-stu-id="d11f1-122">Method group conversions</span></span>

<span data-ttu-id="d11f1-123">Неявные преобразования могут происходить в разнообразных ситуациях, включая вызовов функций-членов ([Проверка динамического разрешения перегрузки во время компиляции](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), выражения приведения ([выражения приведения](expressions.md#cast-expressions)), и назначения ([операторы присваивания](expressions.md#assignment-operators)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-123">Implicit conversions can occur in a variety of situations, including function member invocations ([Compile-time checking of dynamic overload resolution](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), and assignments ([Assignment operators](expressions.md#assignment-operators)).</span></span>

<span data-ttu-id="d11f1-124">Предопределенные неявные преобразования всегда выполняются успешно и никогда не вызывают исключений.</span><span class="sxs-lookup"><span data-stu-id="d11f1-124">The pre-defined implicit conversions always succeed and never cause exceptions to be thrown.</span></span> <span data-ttu-id="d11f1-125">Правильно спроектированное определяемые пользователем неявные преобразования должен продемонстрировать эти характеристики.</span><span class="sxs-lookup"><span data-stu-id="d11f1-125">Properly designed user-defined implicit conversions should exhibit these characteristics as well.</span></span>

<span data-ttu-id="d11f1-126">В целях преобразования, типы `object` и `dynamic` считаются эквивалентными.</span><span class="sxs-lookup"><span data-stu-id="d11f1-126">For the purposes of conversion, the types `object` and `dynamic` are considered equivalent.</span></span>

<span data-ttu-id="d11f1-127">Тем не менее динамическое преобразование ([неявные преобразования динамических](conversions.md#implicit-dynamic-conversions) и [явные преобразования динамических](conversions.md#explicit-dynamic-conversions)) применяются только к выражениям типа `dynamic` ([динамический тип](types.md#the-dynamic-type)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-127">However, dynamic conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)) apply only to expressions of type `dynamic` ([The dynamic type](types.md#the-dynamic-type)).</span></span>

### <a name="identity-conversion"></a><span data-ttu-id="d11f1-128">Преобразование удостоверения</span><span class="sxs-lookup"><span data-stu-id="d11f1-128">Identity conversion</span></span>

<span data-ttu-id="d11f1-129">Преобразование удостоверения преобразует из любого типа в тот же тип.</span><span class="sxs-lookup"><span data-stu-id="d11f1-129">An identity conversion converts from any type to the same type.</span></span> <span data-ttu-id="d11f1-130">Это преобразование используется таким образом, что сущность, которая уже имеет требуемый тип можно сказать, что быть преобразуемым к этому типу.</span><span class="sxs-lookup"><span data-stu-id="d11f1-130">This conversion exists such that an entity that already has a required type can be said to be convertible to that type.</span></span>

*  <span data-ttu-id="d11f1-131">Так как объект и динамические типы считаются эквивалентными является преобразование идентификации между `object` и `dynamic`, а также между сконструированных типов, которые повторяются при замене всех вхождений `dynamic` с `object`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-131">Because object and dynamic are considered equivalent there is an identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing all occurrences of `dynamic` with `object`.</span></span>

### <a name="implicit-numeric-conversions"></a><span data-ttu-id="d11f1-132">Неявные числовые преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-132">Implicit numeric conversions</span></span>

<span data-ttu-id="d11f1-133">Неявные числовые преобразования являются:</span><span class="sxs-lookup"><span data-stu-id="d11f1-133">The implicit numeric conversions are:</span></span>

*  <span data-ttu-id="d11f1-134">Из `sbyte` для `short`, `int`, `long`, `float`, `double`, или `decimal`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-134">From `sbyte` to `short`, `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="d11f1-135">Из `byte` для `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, или `decimal`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-135">From `byte` to `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="d11f1-136">Из `short` для `int`, `long`, `float`, `double`, или `decimal`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-136">From `short` to `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="d11f1-137">Из `ushort` для `int`, `uint`, `long`, `ulong`, `float`, `double`, или `decimal`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-137">From `ushort` to `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="d11f1-138">Из `int` для `long`, `float`, `double`, или `decimal`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-138">From `int` to `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="d11f1-139">Из `uint` для `long`, `ulong`, `float`, `double`, или `decimal`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-139">From `uint` to `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="d11f1-140">Из `long` для `float`, `double`, или `decimal`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-140">From `long` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="d11f1-141">Из `ulong` для `float`, `double`, или `decimal`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-141">From `ulong` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="d11f1-142">Из `char` для `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, или `decimal`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-142">From `char` to `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="d11f1-143">Из `float` для `double`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-143">From `float` to `double`.</span></span>

<span data-ttu-id="d11f1-144">Преобразования из `int`, `uint`, `long`, или `ulong` для `float` и из `long` или `ulong` для `double` может привести к потере точности, но никогда не причина потере значения.</span><span class="sxs-lookup"><span data-stu-id="d11f1-144">Conversions from `int`, `uint`, `long`, or `ulong` to `float` and from `long` or `ulong` to `double` may cause a loss of precision, but will never cause a loss of magnitude.</span></span> <span data-ttu-id="d11f1-145">Все данные не потеряны других неявных числовых преобразований.</span><span class="sxs-lookup"><span data-stu-id="d11f1-145">The other implicit numeric conversions never lose any information.</span></span>

<span data-ttu-id="d11f1-146">Не поддерживается неявное преобразование, чтобы `char` тип, поэтому значения других целочисленных типов не преобразуются автоматически `char` типа.</span><span class="sxs-lookup"><span data-stu-id="d11f1-146">There are no implicit conversions to the `char` type, so values of the other integral types do not automatically convert to the `char` type.</span></span>

### <a name="implicit-enumeration-conversions"></a><span data-ttu-id="d11f1-147">Неявные преобразования перечисляемых типов</span><span class="sxs-lookup"><span data-stu-id="d11f1-147">Implicit enumeration conversions</span></span>

<span data-ttu-id="d11f1-148">Обеспечивает преобразование неявное перечисление *decimal_integer_literal* `0` для преобразования в любой *enum_type* и в любой *nullable_type* которого базовый тип является *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="d11f1-148">An implicit enumeration conversion permits the *decimal_integer_literal* `0` to be converted to any *enum_type* and to any *nullable_type* whose underlying type is an *enum_type*.</span></span> <span data-ttu-id="d11f1-149">В последнем случае преобразование вычисляется путем преобразования в базовый *enum_type* и упаковки результат ([обнуляемые типы](types.md#nullable-types)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-149">In the latter case the conversion is evaluated by converting to the underlying *enum_type* and wrapping the result ([Nullable types](types.md#nullable-types)).</span></span>

### <a name="implicit-interpolated-string-conversions"></a><span data-ttu-id="d11f1-150">Преобразования неявных интерполированную строку</span><span class="sxs-lookup"><span data-stu-id="d11f1-150">Implicit interpolated string conversions</span></span>

<span data-ttu-id="d11f1-151">Неявный интерполированные строки преобразования разрешает *interpolated_string_expression* ([интерполированные строки](expressions.md#interpolated-strings)) для преобразования в `System.IFormattable` или `System.FormattableString` (который реализует `System.IFormattable`).</span><span class="sxs-lookup"><span data-stu-id="d11f1-151">An implicit interpolated string conversion permits an *interpolated_string_expression* ([Interpolated strings](expressions.md#interpolated-strings)) to be converted to `System.IFormattable` or `System.FormattableString` (which implements `System.IFormattable`).</span></span>

<span data-ttu-id="d11f1-152">При применении этого преобразования в строковое значение не состоит из интерполированной строки.</span><span class="sxs-lookup"><span data-stu-id="d11f1-152">When this conversion is applied a string value is not composed from the interpolated string.</span></span> <span data-ttu-id="d11f1-153">Вместо этого экземпляр `System.FormattableString` будет создана, как более подробно описано в [интерполированные строки](expressions.md#interpolated-strings).</span><span class="sxs-lookup"><span data-stu-id="d11f1-153">Instead an instance of `System.FormattableString` is created, as further described in [Interpolated strings](expressions.md#interpolated-strings).</span></span>

### <a name="implicit-nullable-conversions"></a><span data-ttu-id="d11f1-154">Неявные преобразования, допускающие значение NULL</span><span class="sxs-lookup"><span data-stu-id="d11f1-154">Implicit nullable conversions</span></span>

<span data-ttu-id="d11f1-155">Предопределенные неявные преобразования, которые работают с типами, не поддерживающий значение NULL может также использоваться с обнуляемых типов.</span><span class="sxs-lookup"><span data-stu-id="d11f1-155">Predefined implicit conversions that operate on non-nullable value types can also be used with nullable forms of those types.</span></span> <span data-ttu-id="d11f1-156">Для каждого из предопределенные неявные идентификации и числовых преобразований, преобразование типа не поддерживающий значение NULL `S` типу, не поддерживающий значение NULL `T`, существуют следующие неявные преобразования допускает значения NULL:</span><span class="sxs-lookup"><span data-stu-id="d11f1-156">For each of the predefined implicit identity and numeric conversions that convert from a non-nullable value type `S` to a non-nullable value type `T`, the following implicit nullable conversions exist:</span></span>

*  <span data-ttu-id="d11f1-157">Неявное преобразование из `S?` для `T?`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-157">An implicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="d11f1-158">Неявное преобразование из `S` для `T?`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-158">An implicit conversion from `S` to `T?`.</span></span>

<span data-ttu-id="d11f1-159">На основе оценки неявного преобразования допускает значения NULL на преобразовании из `S` для `T` продолжается следующим образом:</span><span class="sxs-lookup"><span data-stu-id="d11f1-159">Evaluation of an implicit nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="d11f1-160">Если преобразование допускает значения NULL из `S?` для `T?`:</span><span class="sxs-lookup"><span data-stu-id="d11f1-160">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="d11f1-161">Если значение источника равно null (`HasValue` свойство имеет значение false), возвращается значение null типа `T?`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-161">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="d11f1-162">В противном случае преобразование вычисляется как развертывание из `S?` для `S`, а затем преобразовании из `S` для `T`, а затем оболочки ([обнуляемые типы](types.md#nullable-types)) из `T` для `T?`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-162">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping ([Nullable types](types.md#nullable-types)) from `T` to `T?`.</span></span>

*  <span data-ttu-id="d11f1-163">При преобразовании допускает значения NULL из `S` для `T?`, считается, что преобразование преобразовании из `S` для `T` следуют перенос из `T` для `T?`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-163">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>

### <a name="null-literal-conversions"></a><span data-ttu-id="d11f1-164">Преобразования литерала NULL.</span><span class="sxs-lookup"><span data-stu-id="d11f1-164">Null literal conversions</span></span>

<span data-ttu-id="d11f1-165">Существует неявное преобразование из `null` литерала для любого типа, допускающего значение NULL.</span><span class="sxs-lookup"><span data-stu-id="d11f1-165">An implicit conversion exists from the `null` literal to any nullable type.</span></span> <span data-ttu-id="d11f1-166">Это преобразование создает значение null ([обнуляемые типы](types.md#nullable-types)) заданного типа, допускающего значение NULL.</span><span class="sxs-lookup"><span data-stu-id="d11f1-166">This conversion produces the null value ([Nullable types](types.md#nullable-types)) of the given nullable type.</span></span>

### <a name="implicit-reference-conversions"></a><span data-ttu-id="d11f1-167">Неявные преобразования ссылочных типов</span><span class="sxs-lookup"><span data-stu-id="d11f1-167">Implicit reference conversions</span></span>

<span data-ttu-id="d11f1-168">Неявные преобразования являются:</span><span class="sxs-lookup"><span data-stu-id="d11f1-168">The implicit reference conversions are:</span></span>

*  <span data-ttu-id="d11f1-169">Из любого *reference_type* для `object` и `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-169">From any *reference_type* to `object` and `dynamic`.</span></span>
*  <span data-ttu-id="d11f1-170">Из любого *class_type* `S` к любому *class_type* `T`, в который `S` является производным от `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-170">From any *class_type* `S` to any *class_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="d11f1-171">Из любого *class_type* `S` к любому *interface_type* `T`, в который `S` реализует `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-171">From any *class_type* `S` to any *interface_type* `T`, provided `S` implements `T`.</span></span>
*  <span data-ttu-id="d11f1-172">Из любого *interface_type* `S` к любому *interface_type* `T`, в который `S` является производным от `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-172">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="d11f1-173">Из *array_type* `S` с типом элемента `SE` для *array_type* `T` с типом элемента `TE`, если выполняются все следующие условия:</span><span class="sxs-lookup"><span data-stu-id="d11f1-173">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="d11f1-174">`S` и `T` различаются только по типу элементов.</span><span class="sxs-lookup"><span data-stu-id="d11f1-174">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="d11f1-175">Другими словами `S` и `T` имеют одинаковое количество измерений.</span><span class="sxs-lookup"><span data-stu-id="d11f1-175">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="d11f1-176">Оба `SE` и `TE` являются *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="d11f1-176">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="d11f1-177">Существует и неявное ссылочное преобразование из `SE` для `TE`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-177">An implicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="d11f1-178">Из любого *array_type* для `System.Array` и он реализует интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="d11f1-178">From any *array_type* to `System.Array` and the interfaces it implements.</span></span>
*  <span data-ttu-id="d11f1-179">Одномерный массив типа `S[]` для `System.Collections.Generic.IList<T>` и его базовые интерфейсы, если существует неявное преобразование идентификатора или ссылки из `S` для `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-179">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an implicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="d11f1-180">Из любого *delegate_type* для `System.Delegate` и он реализует интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="d11f1-180">From any *delegate_type* to `System.Delegate` and the interfaces it implements.</span></span>
*  <span data-ttu-id="d11f1-181">От литерала null к любому *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="d11f1-181">From the null literal to any *reference_type*.</span></span>
*  <span data-ttu-id="d11f1-182">Из любого *reference_type* для *reference_type* `T` если он имеет неявное преобразование идентификатора или ссылки в *reference_type* `T0` и `T0` имеет преобразование удостоверения для `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-182">From any *reference_type* to a *reference_type* `T` if it has an implicit identity or reference conversion to a *reference_type* `T0` and `T0` has an identity conversion to `T`.</span></span>
*  <span data-ttu-id="d11f1-183">Из любого *reference_type* в интерфейсе или делегате тип `T` если он имеет неявное преобразование идентификатора или ссылки на тип интерфейса или делегата `T0` и `T0` является вариантно преобразуемым ([ Вариантное преобразование](interfaces.md#variance-conversion)) для `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-183">From any *reference_type* to an interface or delegate type `T` if it has an implicit identity or reference conversion to an interface or delegate type `T0` and `T0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `T`.</span></span>
*  <span data-ttu-id="d11f1-184">Неявные преобразования, включающие параметры типа, которые являются ссылочными типами.</span><span class="sxs-lookup"><span data-stu-id="d11f1-184">Implicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="d11f1-185">См. в разделе [неявные преобразования, включающие параметры типа](conversions.md#implicit-conversions-involving-type-parameters) узнать больше о неявные преобразования, включающие параметры типа.</span><span class="sxs-lookup"><span data-stu-id="d11f1-185">See [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) for more details on implicit conversions involving type parameters.</span></span>

<span data-ttu-id="d11f1-186">Неявные преобразования являются такие преобразования между *reference_type*, могут быть установлены всегда выполняются успешно и не требуют проверки во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="d11f1-186">The implicit reference conversions are those conversions between *reference_type*s that can be proven to always succeed, and therefore require no checks at run-time.</span></span>

<span data-ttu-id="d11f1-187">Преобразования ссылок, явные и неявные, никогда не изменяют ссылочный идентификатор преобразуемого объекта.</span><span class="sxs-lookup"><span data-stu-id="d11f1-187">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="d11f1-188">Другими словами преобразование ссылки может изменить тип ссылки, он никогда не изменяет тип или значение объекта, на которую выполняется ссылка.</span><span class="sxs-lookup"><span data-stu-id="d11f1-188">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="d11f1-189">Упаковки-преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-189">Boxing conversions</span></span>

<span data-ttu-id="d11f1-190">Упаковка-преобразование позволяет *value_type* должен неявно преобразовываться к ссылочному типу.</span><span class="sxs-lookup"><span data-stu-id="d11f1-190">A boxing conversion permits a *value_type* to be implicitly converted to a reference type.</span></span> <span data-ttu-id="d11f1-191">Существует преобразования-упаковки из любого *non_nullable_value_type* для `object` и `dynamic`, `System.ValueType` и в любой *interface_type* реализуется *non_ nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="d11f1-191">A boxing conversion exists from any *non_nullable_value_type* to `object` and `dynamic`, to `System.ValueType` and to any *interface_type* implemented by the *non_nullable_value_type*.</span></span> <span data-ttu-id="d11f1-192">Кроме того *enum_type* можно преобразовать в тип `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-192">Furthermore an *enum_type* can be converted to the type `System.Enum`.</span></span>

<span data-ttu-id="d11f1-193">Существует преобразования-упаковки из *nullable_type* к ссылочному типу, если и только если упаковка-преобразование существует базового *non_nullable_value_type* в ссылочный тип.</span><span class="sxs-lookup"><span data-stu-id="d11f1-193">A boxing conversion exists from a *nullable_type* to a reference type, if and only if a boxing conversion exists from the underlying *non_nullable_value_type* to the reference type.</span></span>

<span data-ttu-id="d11f1-194">Тип значения имеет упаковки-преобразования к типу интерфейса `I` наличия упаковки-преобразования к типу интерфейса `I0` и `I0` имеет преобразование удостоверения для `I`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-194">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="d11f1-195">Тип значения имеет упаковки-преобразования к типу интерфейса `I` при наличии упаковки-преобразования в тип интерфейса или делегата `I0` и `I0` является вариантно преобразуемым ([Вариантное преобразование](interfaces.md#variance-conversion)) для `I`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-195">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface or delegate type `I0` and `I0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `I`.</span></span>

<span data-ttu-id="d11f1-196">Упаковка значения *non_nullable_value_type* состоит выделение экземпляра объекта и копирование *value_type* значение в этом экземпляре.</span><span class="sxs-lookup"><span data-stu-id="d11f1-196">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *value_type* value into that instance.</span></span> <span data-ttu-id="d11f1-197">Структура допускает упаковку-преобразование к типу `System.ValueType`, так как это базовый класс для всех структур ([наследования](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-197">A struct can be boxed to the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="d11f1-198">Упаковка значения *nullable_type* продолжается следующим образом:</span><span class="sxs-lookup"><span data-stu-id="d11f1-198">Boxing a value of a *nullable_type* proceeds as follows:</span></span>

*  <span data-ttu-id="d11f1-199">Если значение источника равно null (`HasValue` свойство имеет значение false), результатом является пустой ссылкой типа целевого объекта.</span><span class="sxs-lookup"><span data-stu-id="d11f1-199">If the source value is null (`HasValue` property is false), the result is a null reference of the target type.</span></span>
*  <span data-ttu-id="d11f1-200">В противном случае результат — это ссылка на упакованное `T` созданные развертывания и упаковки исходного значения.</span><span class="sxs-lookup"><span data-stu-id="d11f1-200">Otherwise, the result is a reference to a boxed `T` produced by unwrapping and boxing the source value.</span></span>

<span data-ttu-id="d11f1-201">Упаковки-преобразования описаны далее в [осуществлять преобразования-упаковки](types.md#boxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="d11f1-201">Boxing conversions are described further in [Boxing conversions](types.md#boxing-conversions).</span></span>

### <a name="implicit-dynamic-conversions"></a><span data-ttu-id="d11f1-202">Неявные преобразования динамических типов</span><span class="sxs-lookup"><span data-stu-id="d11f1-202">Implicit dynamic conversions</span></span>

<span data-ttu-id="d11f1-203">Существует неявное преобразование динамических из выражения типа `dynamic` к любому типу `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-203">An implicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="d11f1-204">Преобразование является динамическим ([динамической привязки](expressions.md#dynamic-binding)), что означает, что неявное преобразование будет использоваться во время выполнения из типа времени выполнения выражения `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-204">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an implicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="d11f1-205">Если преобразование не найдено, создается исключение времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="d11f1-205">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="d11f1-206">Обратите внимание, что это неявное преобразование противоречит рекомендации, приведенные в начале [неявные преобразования](conversions.md#implicit-conversions) неявное преобразование не должно вызывать исключение.</span><span class="sxs-lookup"><span data-stu-id="d11f1-206">Note that this implicit conversion seemingly violates the advice in the beginning of [Implicit conversions](conversions.md#implicit-conversions) that an implicit conversion should never cause an exception.</span></span> <span data-ttu-id="d11f1-207">Однако это не преобразование, но *поиск* преобразования, который вызывает исключение.</span><span class="sxs-lookup"><span data-stu-id="d11f1-207">However it is not the conversion itself, but the *finding* of the conversion that causes the exception.</span></span> <span data-ttu-id="d11f1-208">Риск возникновения исключения во время выполнения присущих использование динамической привязки.</span><span class="sxs-lookup"><span data-stu-id="d11f1-208">The risk of run-time exceptions is inherent in the use of dynamic binding.</span></span> <span data-ttu-id="d11f1-209">Если динамическую привязку преобразования не требуется, то можно быть сначала преобразовано в `object`, а затем к требуемому типу.</span><span class="sxs-lookup"><span data-stu-id="d11f1-209">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="d11f1-210">Следующий пример иллюстрирует неявное динамическое преобразование:</span><span class="sxs-lookup"><span data-stu-id="d11f1-210">The following example illustrates implicit dynamic conversions:</span></span>

```csharp
object o  = "object"
dynamic d = "dynamic";

string s1 = o; // Fails at compile-time -- no conversion exists
string s2 = d; // Compiles and succeeds at run-time
int i     = d; // Compiles but fails at run-time -- no conversion exists
```

<span data-ttu-id="d11f1-211">Назначения, которые `s2` и `i` оба применять неявные преобразования динамических, в которой привязки операций приостанавливается до времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="d11f1-211">The assignments to `s2` and `i` both employ implicit dynamic conversions, where the binding of the operations is suspended until run-time.</span></span> <span data-ttu-id="d11f1-212">Во время выполнения, неявные преобразования выполняется поиск типа во время выполнения `d`  --  `string` --в целевой тип.</span><span class="sxs-lookup"><span data-stu-id="d11f1-212">At run-time, implicit conversions are sought from the run-time type of `d` -- `string` -- to the target type.</span></span> <span data-ttu-id="d11f1-213">Обнаружено, преобразование `string` , но не к `int`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-213">A conversion is found to `string` but not to `int`.</span></span>

### <a name="implicit-constant-expression-conversions"></a><span data-ttu-id="d11f1-214">Неявные преобразования выражений констант</span><span class="sxs-lookup"><span data-stu-id="d11f1-214">Implicit constant expression conversions</span></span>

<span data-ttu-id="d11f1-215">Неявные преобразования выражений констант обеспечивают следующие преобразования:</span><span class="sxs-lookup"><span data-stu-id="d11f1-215">An implicit constant expression conversion permits the following conversions:</span></span>

*  <span data-ttu-id="d11f1-216">Объект *constant_expression* ([константные выражения](expressions.md#constant-expressions)) типа `int` можно преобразовать в тип `sbyte`, `byte`, `short`, `ushort`, `uint`, или `ulong`, если значение *constant_expression* находится в диапазоне конечного типа.</span><span class="sxs-lookup"><span data-stu-id="d11f1-216">A *constant_expression* ([Constant expressions](expressions.md#constant-expressions)) of type `int` can be converted to type `sbyte`, `byte`, `short`, `ushort`, `uint`, or `ulong`, provided the value of the *constant_expression* is within the range of the destination type.</span></span>
*  <span data-ttu-id="d11f1-217">Объект *constant_expression* типа `long` можно преобразовать в тип `ulong`, если значение *constant_expression* не отрицательна.</span><span class="sxs-lookup"><span data-stu-id="d11f1-217">A *constant_expression* of type `long` can be converted to type `ulong`, provided the value of the *constant_expression* is not negative.</span></span>

### <a name="implicit-conversions-involving-type-parameters"></a><span data-ttu-id="d11f1-218">Неявные преобразования, включающие параметры типа</span><span class="sxs-lookup"><span data-stu-id="d11f1-218">Implicit conversions involving type parameters</span></span>

<span data-ttu-id="d11f1-219">Существуют следующие неявные преобразования для заданного параметра типа `T`:</span><span class="sxs-lookup"><span data-stu-id="d11f1-219">The following implicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="d11f1-220">Из `T` для его эффективным базовым классом `C`, из `T` любой базовый класс `C`и из `T` любой интерфейс, реализуемый `C`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-220">From `T` to its effective base class `C`, from `T` to any base class of `C`, and from `T` to any interface implemented by `C`.</span></span> <span data-ttu-id="d11f1-221">Если время выполнения, AT `T` является типом значения, преобразование выполняется как упаковка-преобразование.</span><span class="sxs-lookup"><span data-stu-id="d11f1-221">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="d11f1-222">В противном случае преобразование выполняется как неявное преобразование ссылок или преобразование идентификации.</span><span class="sxs-lookup"><span data-stu-id="d11f1-222">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="d11f1-223">Из `T` к типу интерфейса `I` в `T`настройки и эффективный интерфейс и из `T` любой базовый интерфейс `I`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-223">From `T` to an interface type `I` in `T`'s effective interface set and from `T` to any base interface of `I`.</span></span> <span data-ttu-id="d11f1-224">Если время выполнения, AT `T` является типом значения, преобразование выполняется как упаковка-преобразование.</span><span class="sxs-lookup"><span data-stu-id="d11f1-224">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="d11f1-225">В противном случае преобразование выполняется как неявное преобразование ссылок или преобразование идентификации.</span><span class="sxs-lookup"><span data-stu-id="d11f1-225">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="d11f1-226">Из `T` к параметру типа `U`, в который `T` зависит от `U` ([ограничения параметров типа](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-226">From `T` to a type parameter `U`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="d11f1-227">Если время выполнения, AT `U` является типом значения, затем `T` и `U` обязательно относятся к одному типу и не выполняют никаких преобразований.</span><span class="sxs-lookup"><span data-stu-id="d11f1-227">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="d11f1-228">В противном случае, если `T` является типом значения, преобразование выполняется как упаковка-преобразование.</span><span class="sxs-lookup"><span data-stu-id="d11f1-228">Otherwise, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="d11f1-229">В противном случае преобразование выполняется как неявное преобразование ссылок или преобразование идентификации.</span><span class="sxs-lookup"><span data-stu-id="d11f1-229">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="d11f1-230">От литерала null в `T`, в который `T` известно, быть ссылочным типом.</span><span class="sxs-lookup"><span data-stu-id="d11f1-230">From the null literal to `T`, provided `T` is known to be a reference type.</span></span>
*  <span data-ttu-id="d11f1-231">Из `T` к ссылочному типу `I` если он имеет неявное преобразование к ссылочному типу `S0` и `S0` имеет преобразование удостоверения для `S`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-231">From `T` to a reference type `I` if it has an implicit conversion to a reference type `S0` and `S0` has an identity conversion to `S`.</span></span> <span data-ttu-id="d11f1-232">Во время выполнения преобразование выполняется так же, как преобразование в `S0`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-232">At run-time the conversion is executed the same way as the conversion to `S0`.</span></span>
*  <span data-ttu-id="d11f1-233">Из `T` к типу интерфейса `I` если он имеет неявное преобразование к типу интерфейса или делегата `I0` и `I0` является вариантно преобразуемым к `I` ([Вариантное преобразование](interfaces.md#variance-conversion) ).</span><span class="sxs-lookup"><span data-stu-id="d11f1-233">From `T` to an interface type `I` if it has an implicit conversion to an interface or delegate type `I0` and `I0` is variance-convertible to `I` ([Variance conversion](interfaces.md#variance-conversion)).</span></span> <span data-ttu-id="d11f1-234">Если время выполнения, AT `T` является типом значения, преобразование выполняется как упаковка-преобразование.</span><span class="sxs-lookup"><span data-stu-id="d11f1-234">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="d11f1-235">В противном случае преобразование выполняется как неявное преобразование ссылок или преобразование идентификации.</span><span class="sxs-lookup"><span data-stu-id="d11f1-235">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="d11f1-236">Если `T` известно, быть ссылочным типом ([ограничения параметров типа](classes.md#type-parameter-constraints)), описанные выше преобразования классифицируются как неявные преобразования ссылочных типов ([неявные преобразования ссылочных типов](conversions.md#implicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-236">If `T` is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)), the conversions above are all classified as implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions)).</span></span> <span data-ttu-id="d11f1-237">Если `T` является не известно, быть ссылочным типом, описанные выше преобразования классифицируются как осуществлять преобразования-упаковки ([осуществлять преобразования-упаковки](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-237">If `T` is not known to be a reference type, the conversions above are classified as boxing conversions ([Boxing conversions](conversions.md#boxing-conversions)).</span></span>

### <a name="user-defined-implicit-conversions"></a><span data-ttu-id="d11f1-238">Определяемые пользователем неявные преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-238">User-defined implicit conversions</span></span>

<span data-ttu-id="d11f1-239">Неявное преобразование, определяемые пользователем состоит из необязательно стандартный неявное преобразование, следуют выполнения оператора определяемые пользователем неявные преобразования, следуют другой необязательно стандартное неявное преобразование.</span><span class="sxs-lookup"><span data-stu-id="d11f1-239">A user-defined implicit conversion consists of an optional standard implicit conversion, followed by execution of a user-defined implicit conversion operator, followed by another optional standard implicit conversion.</span></span> <span data-ttu-id="d11f1-240">Точные правила вычисления определяемые пользователем неявные преобразования описаны в [обработку определяемые пользователем неявные преобразования](conversions.md#processing-of-user-defined-implicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="d11f1-240">The exact rules for evaluating user-defined implicit conversions are described in [Processing of user-defined implicit conversions](conversions.md#processing-of-user-defined-implicit-conversions).</span></span>

### <a name="anonymous-function-conversions-and-method-group-conversions"></a><span data-ttu-id="d11f1-241">Преобразования анонимных функций и преобразования групп методов</span><span class="sxs-lookup"><span data-stu-id="d11f1-241">Anonymous function conversions and method group conversions</span></span>

<span data-ttu-id="d11f1-242">Анонимные функции групп методов имеют сами по себе, но может быть неявно преобразован к типу делегата или типы дерева выражений.</span><span class="sxs-lookup"><span data-stu-id="d11f1-242">Anonymous functions and method groups do not have types in and of themselves, but may be implicitly converted to delegate types or expression tree types.</span></span> <span data-ttu-id="d11f1-243">Преобразования анонимных функций описаны более подробно в [преобразования анонимных функций](conversions.md#anonymous-function-conversions) и преобразования групп методов в [преобразования групп методов](conversions.md#method-group-conversions).</span><span class="sxs-lookup"><span data-stu-id="d11f1-243">Anonymous function conversions are described in more detail in [Anonymous function conversions](conversions.md#anonymous-function-conversions) and method group conversions in [Method group conversions](conversions.md#method-group-conversions).</span></span>

## <a name="explicit-conversions"></a><span data-ttu-id="d11f1-244">Явные преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-244">Explicit conversions</span></span>

<span data-ttu-id="d11f1-245">Явные преобразования относятся следующие преобразования:</span><span class="sxs-lookup"><span data-stu-id="d11f1-245">The following conversions are classified as explicit conversions:</span></span>

*  <span data-ttu-id="d11f1-246">Все неявные преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-246">All implicit conversions.</span></span>
*  <span data-ttu-id="d11f1-247">Явные числовые преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-247">Explicit numeric conversions.</span></span>
*  <span data-ttu-id="d11f1-248">Явные преобразования перечисляемых типов.</span><span class="sxs-lookup"><span data-stu-id="d11f1-248">Explicit enumeration conversions.</span></span>
*  <span data-ttu-id="d11f1-249">Явные преобразования типов, допускающий значение NULL.</span><span class="sxs-lookup"><span data-stu-id="d11f1-249">Explicit nullable conversions.</span></span>
*  <span data-ttu-id="d11f1-250">Явные преобразования ссылочных типов.</span><span class="sxs-lookup"><span data-stu-id="d11f1-250">Explicit reference conversions.</span></span>
*  <span data-ttu-id="d11f1-251">Явные преобразования типов интерфейса.</span><span class="sxs-lookup"><span data-stu-id="d11f1-251">Explicit interface conversions.</span></span>
*  <span data-ttu-id="d11f1-252">Распаковки-преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-252">Unboxing conversions.</span></span>
*  <span data-ttu-id="d11f1-253">Явные преобразования динамических</span><span class="sxs-lookup"><span data-stu-id="d11f1-253">Explicit dynamic conversions</span></span>
*  <span data-ttu-id="d11f1-254">Пользовательские явные преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-254">User-defined explicit conversions.</span></span>

<span data-ttu-id="d11f1-255">Явные преобразования могут произойти в выражения приведения ([выражения приведения](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-255">Explicit conversions can occur in cast expressions ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="d11f1-256">Набор явные преобразования включает все неявные преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-256">The set of explicit conversions includes all implicit conversions.</span></span> <span data-ttu-id="d11f1-257">Это означает, что разрешены избыточные выражения приведения.</span><span class="sxs-lookup"><span data-stu-id="d11f1-257">This means that redundant cast expressions are allowed.</span></span>

<span data-ttu-id="d11f1-258">Явные преобразования типов, которые не являются неявные преобразования, преобразования, которые невозможно подтвердить всегда выполняются успешно, преобразования, которые заведомо привести к потере данных и преобразования в областях типов, существенно различающихся для явной позволил компании merit нотация.</span><span class="sxs-lookup"><span data-stu-id="d11f1-258">The explicit conversions that are not implicit conversions are conversions that cannot be proven to always succeed, conversions that are known to possibly lose information, and conversions across domains of types sufficiently different to merit explicit notation.</span></span>

### <a name="explicit-numeric-conversions"></a><span data-ttu-id="d11f1-259">Явные числовые преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-259">Explicit numeric conversions</span></span>

<span data-ttu-id="d11f1-260">Явные числовые преобразования преобразовывают из *numeric_type* в другой *numeric_type* для которого неявное числовое преобразование ([неявных числовых преобразований](conversions.md#implicit-numeric-conversions)) еще не существует:</span><span class="sxs-lookup"><span data-stu-id="d11f1-260">The explicit numeric conversions are the conversions from a *numeric_type* to another *numeric_type* for which an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) does not already exist:</span></span>

*  <span data-ttu-id="d11f1-261">Из `sbyte` для `byte`, `ushort`, `uint`, `ulong`, или `char`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-261">From `sbyte` to `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="d11f1-262">Из `byte` для `sbyte` и `char`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-262">From `byte` to `sbyte` and `char`.</span></span>
*  <span data-ttu-id="d11f1-263">Из `short` для `sbyte`, `byte`, `ushort`, `uint`, `ulong`, или `char`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-263">From `short` to `sbyte`, `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="d11f1-264">Из `ushort` для `sbyte`, `byte`, `short`, или `char`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-264">From `ushort` to `sbyte`, `byte`, `short`, or `char`.</span></span>
*  <span data-ttu-id="d11f1-265">Из `int` для `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, или `char`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-265">From `int` to `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="d11f1-266">Из `uint` для `sbyte`, `byte`, `short`, `ushort`, `int`, или `char`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-266">From `uint` to `sbyte`, `byte`, `short`, `ushort`, `int`, or `char`.</span></span>
*  <span data-ttu-id="d11f1-267">Из `long` для `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, или `char`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-267">From `long` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="d11f1-268">Из `ulong` для `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, или `char`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-268">From `ulong` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, or `char`.</span></span>
*  <span data-ttu-id="d11f1-269">Из `char` для `sbyte`, `byte`, или `short`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-269">From `char` to `sbyte`, `byte`, or `short`.</span></span>
*  <span data-ttu-id="d11f1-270">Из `float` для `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, или `decimal`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-270">From `float` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, or `decimal`.</span></span>
*  <span data-ttu-id="d11f1-271">Из `double` для `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, или `decimal`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-271">From `double` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `decimal`.</span></span>
*  <span data-ttu-id="d11f1-272">Из `decimal` для `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, или `double`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-272">From `decimal` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `double`.</span></span>

<span data-ttu-id="d11f1-273">Так как явные преобразования всех явных и неявных числовых преобразований, всегда есть возможность для преобразования из любых *numeric_type* любым другим *numeric_type* using (выражения приведения [Выражения приведения](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-273">Because the explicit conversions include all implicit and explicit numeric conversions, it is always possible to convert from any *numeric_type* to any other *numeric_type* using a cast expression ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="d11f1-274">Явные числовые преобразования привести к потере данных или привести исключения.</span><span class="sxs-lookup"><span data-stu-id="d11f1-274">The explicit numeric conversions possibly lose information or possibly cause exceptions to be thrown.</span></span> <span data-ttu-id="d11f1-275">Явное числовое преобразование обрабатывается следующим образом:</span><span class="sxs-lookup"><span data-stu-id="d11f1-275">An explicit numeric conversion is processed as follows:</span></span>

*  <span data-ttu-id="d11f1-276">Для преобразования из целого типа в другой целочисленный тип, выполнения зависит от контекста проверки переполнения ([операторы checked и unchecked](expressions.md#the-checked-and-unchecked-operators)) в котором оно выполняется:</span><span class="sxs-lookup"><span data-stu-id="d11f1-276">For a conversion from an integral type to another integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="d11f1-277">В `checked` контекста, преобразование выполняется успешно, если значение исходного операнда находится в диапазоне конечного типа, но создает `System.OverflowException` Если значение исходного операнда находится вне диапазона целевого типа.</span><span class="sxs-lookup"><span data-stu-id="d11f1-277">In a `checked` context, the conversion succeeds if the value of the source operand is within the range of the destination type, but throws a `System.OverflowException` if the value of the source operand is outside the range of the destination type.</span></span>
    * <span data-ttu-id="d11f1-278">В `unchecked` контекст, преобразование всегда завершается успешно и выполняется следующим образом.</span><span class="sxs-lookup"><span data-stu-id="d11f1-278">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="d11f1-279">Если исходный тип больше целевого, исходное значение усекается путем отбрасывания его "лишних" самых значимых битов.</span><span class="sxs-lookup"><span data-stu-id="d11f1-279">If the source type is larger than the destination type, then the source value is truncated by discarding its "extra" most significant bits.</span></span> <span data-ttu-id="d11f1-280">Результат затем обрабатывается как значение целевого типа.</span><span class="sxs-lookup"><span data-stu-id="d11f1-280">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="d11f1-281">Если исходный тип меньше целевого, исходное значение дополняется знаками или нулями, чтобы иметь тот же размер, что и целевой тип.</span><span class="sxs-lookup"><span data-stu-id="d11f1-281">If the source type is smaller than the destination type, then the source value is either sign-extended or zero-extended so that it is the same size as the destination type.</span></span> <span data-ttu-id="d11f1-282">Знаки добавляются, если исходный тип имеет знак. Если у исходного типа нет знака, добавляются нули.</span><span class="sxs-lookup"><span data-stu-id="d11f1-282">Sign-extension is used if the source type is signed; zero-extension is used if the source type is unsigned.</span></span> <span data-ttu-id="d11f1-283">Результат затем обрабатывается как значение целевого типа.</span><span class="sxs-lookup"><span data-stu-id="d11f1-283">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="d11f1-284">Если исходный тип совпадает по размеру с целевым, исходное значение обрабатывается как значение целевого типа.</span><span class="sxs-lookup"><span data-stu-id="d11f1-284">If the source type is the same size as the destination type, then the source value is treated as a value of the destination type.</span></span>
*  <span data-ttu-id="d11f1-285">Для преобразования из `decimal` в целочисленный тип, исходное значение округляется в сторону нуля до ближайшего целого значения, и которое становится результатом преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-285">For a conversion from `decimal` to an integral type, the source value is rounded towards zero to the nearest integral value, and this integral value becomes the result of the conversion.</span></span> <span data-ttu-id="d11f1-286">Если полученное целое значение находится вне диапазона целевого типа, `System.OverflowException` возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="d11f1-286">If the resulting integral value is outside the range of the destination type, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="d11f1-287">Для преобразования из `float` или `double` в целочисленный тип, выполнения зависит от контекста проверки переполнения ([операторы checked и unchecked](expressions.md#the-checked-and-unchecked-operators)) в котором оно выполняется:</span><span class="sxs-lookup"><span data-stu-id="d11f1-287">For a conversion from `float` or `double` to an integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="d11f1-288">В `checked` контекста, преобразование продолжается следующим образом:</span><span class="sxs-lookup"><span data-stu-id="d11f1-288">In a `checked` context, the conversion proceeds as follows:</span></span>
        * <span data-ttu-id="d11f1-289">Если значение операнда NaN или infinite, `System.OverflowException` возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="d11f1-289">If the value of the operand is NaN or infinite, a `System.OverflowException` is thrown.</span></span>
        * <span data-ttu-id="d11f1-290">В противном случае исходного операнда округляется в сторону нуля до ближайшего целого значения.</span><span class="sxs-lookup"><span data-stu-id="d11f1-290">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="d11f1-291">Если это целочисленное значение находится в диапазоне конечного типа это значение является результатом преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-291">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="d11f1-292">В противном случае возникает исключение `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-292">Otherwise, a `System.OverflowException` is thrown.</span></span>
    * <span data-ttu-id="d11f1-293">В `unchecked` контекст, преобразование всегда завершается успешно и выполняется следующим образом.</span><span class="sxs-lookup"><span data-stu-id="d11f1-293">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="d11f1-294">Если значение операнда имеет значение NaN или бесконечным, результатом преобразования является неопределенное значение целевого типа.</span><span class="sxs-lookup"><span data-stu-id="d11f1-294">If the value of the operand is NaN or infinite, the result of the conversion is an unspecified value of the destination type.</span></span>
        * <span data-ttu-id="d11f1-295">В противном случае исходного операнда округляется в сторону нуля до ближайшего целого значения.</span><span class="sxs-lookup"><span data-stu-id="d11f1-295">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="d11f1-296">Если это целочисленное значение находится в диапазоне конечного типа это значение является результатом преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-296">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="d11f1-297">В противном случае результатом преобразования является неопределенное значение целевого типа.</span><span class="sxs-lookup"><span data-stu-id="d11f1-297">Otherwise, the result of the conversion is an unspecified value of the destination type.</span></span>
*  <span data-ttu-id="d11f1-298">Для преобразования из `double` для `float`, `double` значение округляется до ближайшего `float` значение.</span><span class="sxs-lookup"><span data-stu-id="d11f1-298">For a conversion from `double` to `float`, the `double` value is rounded to the nearest `float` value.</span></span> <span data-ttu-id="d11f1-299">Если `double` значение слишком мал для представления в виде `float`, результат становится равным нулю положительный или отрицательный нуль.</span><span class="sxs-lookup"><span data-stu-id="d11f1-299">If the `double` value is too small to represent as a `float`, the result becomes positive zero or negative zero.</span></span> <span data-ttu-id="d11f1-300">Если `double` значение слишком велико для представления в виде `float`, результатом становится положительная бесконечность или отрицательная бесконечность.</span><span class="sxs-lookup"><span data-stu-id="d11f1-300">If the `double` value is too large to represent as a `float`, the result becomes positive infinity or negative infinity.</span></span> <span data-ttu-id="d11f1-301">Если `double` значение NaN, результат также имеет значение NaN.</span><span class="sxs-lookup"><span data-stu-id="d11f1-301">If the `double` value is NaN, the result is also NaN.</span></span>
*  <span data-ttu-id="d11f1-302">Для преобразования из `float` или `double` для `decimal`, исходное значение преобразуется в `decimal` представление и округляется до ближайшего числа после 28-го десятичного разряда, при необходимости ([десятичного типа](types.md#the-decimal-type)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-302">For a conversion from `float` or `double` to `decimal`, the source value is converted to `decimal` representation and rounded to the nearest number after the 28th decimal place if required ([The decimal type](types.md#the-decimal-type)).</span></span> <span data-ttu-id="d11f1-303">Если исходное значение слишком мал для представления в виде `decimal`, результатом будет ноль.</span><span class="sxs-lookup"><span data-stu-id="d11f1-303">If the source value is too small to represent as a `decimal`, the result becomes zero.</span></span> <span data-ttu-id="d11f1-304">Если значение источника равно NaN, бесконечность, или слишком велико для представления в виде `decimal`, `System.OverflowException` возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="d11f1-304">If the source value is NaN, infinity, or too large to represent as a `decimal`, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="d11f1-305">Для преобразования из `decimal` для `float` или `double`, `decimal` значение округляется до ближайшего `double` или `float` значение.</span><span class="sxs-lookup"><span data-stu-id="d11f1-305">For a conversion from `decimal` to `float` or `double`, the `decimal` value is rounded to the nearest `double` or `float` value.</span></span> <span data-ttu-id="d11f1-306">Это преобразование может привести к потере точности, никогда не вызывает исключение, исключение.</span><span class="sxs-lookup"><span data-stu-id="d11f1-306">While this conversion may lose precision, it never causes an exception to be thrown.</span></span>

### <a name="explicit-enumeration-conversions"></a><span data-ttu-id="d11f1-307">Явные преобразования перечисляемых типов</span><span class="sxs-lookup"><span data-stu-id="d11f1-307">Explicit enumeration conversions</span></span>

<span data-ttu-id="d11f1-308">Явные преобразования перечисляемых типов являются:</span><span class="sxs-lookup"><span data-stu-id="d11f1-308">The explicit enumeration conversions are:</span></span>

*  <span data-ttu-id="d11f1-309">Из `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, или `decimal` для любого *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="d11f1-309">From `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal` to any *enum_type*.</span></span>
*  <span data-ttu-id="d11f1-310">Из любого *enum_type* для `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, или `decimal`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-310">From any *enum_type* to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="d11f1-311">Из любого *enum_type* любым другим *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="d11f1-311">From any *enum_type* to any other *enum_type*.</span></span>

<span data-ttu-id="d11f1-312">Явное преобразование между двумя типами обрабатывается, рассматривая все участвующие *enum_type* как базовый тип, *enum_type*и затем выполняет явный или неявный числовое преобразование результирующих типов.</span><span class="sxs-lookup"><span data-stu-id="d11f1-312">An explicit enumeration conversion between two types is processed by treating any participating *enum_type* as the underlying type of that *enum_type*, and then performing an implicit or explicit numeric conversion between the resulting types.</span></span> <span data-ttu-id="d11f1-313">Например, если *enum_type* `E` с и базовый тип `int`, преобразование из `E` для `byte` обрабатывается как явное числовое преобразование ([Explicit числовые преобразования](conversions.md#explicit-numeric-conversions)) из `int` для `byte`и преобразование из `byte` для `E` обрабатывается как неявное числовое преобразование ([неявных числовых преобразований](conversions.md#implicit-numeric-conversions)) из `byte` для `int`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-313">For example, given an *enum_type* `E` with and underlying type of `int`, a conversion from `E` to `byte` is processed as an explicit numeric conversion ([Explicit numeric conversions](conversions.md#explicit-numeric-conversions)) from `int` to `byte`, and a conversion from `byte` to `E` is processed as an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) from `byte` to `int`.</span></span>

### <a name="explicit-nullable-conversions"></a><span data-ttu-id="d11f1-314">Явные преобразования обнуляемых типов</span><span class="sxs-lookup"><span data-stu-id="d11f1-314">Explicit nullable conversions</span></span>

<span data-ttu-id="d11f1-315">***Явные преобразования обнуляемых типов*** permit предопределенные явные преобразования, которые работают с типами не поддерживающий значение NULL, также можно использовать с обнуляемых типов.</span><span class="sxs-lookup"><span data-stu-id="d11f1-315">***Explicit nullable conversions*** permit predefined explicit conversions that operate on non-nullable value types to also be used with nullable forms of those types.</span></span> <span data-ttu-id="d11f1-316">Для каждого из стандартных явные преобразования, преобразование типа не поддерживающий значение NULL `S` типу, не поддерживающий значение NULL `T` ([преобразование идентификации](conversions.md#identity-conversion), [неявных числовых преобразований](conversions.md#implicit-numeric-conversions), [Неявные преобразования перечисляемых типов](conversions.md#implicit-enumeration-conversions), [явных числовых преобразований](conversions.md#explicit-numeric-conversions), и [явные преобразования перечисляемых типов](conversions.md#explicit-enumeration-conversions)), следующие допускает значения NULL преобразований:</span><span class="sxs-lookup"><span data-stu-id="d11f1-316">For each of the predefined explicit conversions that convert from a non-nullable value type `S` to a non-nullable value type `T` ([Identity conversion](conversions.md#identity-conversion), [Implicit numeric conversions](conversions.md#implicit-numeric-conversions), [Implicit enumeration conversions](conversions.md#implicit-enumeration-conversions), [Explicit numeric conversions](conversions.md#explicit-numeric-conversions), and [Explicit enumeration conversions](conversions.md#explicit-enumeration-conversions)), the following nullable conversions exist:</span></span>

*  <span data-ttu-id="d11f1-317">Явное преобразование из `S?` для `T?`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-317">An explicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="d11f1-318">Явное преобразование из `S` для `T?`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-318">An explicit conversion from `S` to `T?`.</span></span>
*  <span data-ttu-id="d11f1-319">Явное преобразование из `S?` для `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-319">An explicit conversion from `S?` to `T`.</span></span>

<span data-ttu-id="d11f1-320">Вычисление допускает значения NULL преобразования на основе на преобразовании из `S` для `T` продолжается следующим образом:</span><span class="sxs-lookup"><span data-stu-id="d11f1-320">Evaluation of a nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="d11f1-321">Если преобразование допускает значения NULL из `S?` для `T?`:</span><span class="sxs-lookup"><span data-stu-id="d11f1-321">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="d11f1-322">Если значение источника равно null (`HasValue` свойство имеет значение false), возвращается значение null типа `T?`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-322">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="d11f1-323">В противном случае преобразование вычисляется как развертывание из `S?` для `S`, а затем преобразовании из `S` для `T`, а затем перенос из `T` для `T?`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-323">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="d11f1-324">При преобразовании допускает значения NULL из `S` для `T?`, считается, что преобразование преобразовании из `S` для `T` следуют перенос из `T` для `T?`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-324">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="d11f1-325">При преобразовании допускает значения NULL из `S?` для `T`, оно вычисляется как развертывание из `S?` для `S` следуют преобразовании из `S` для `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-325">If the nullable conversion is from `S?` to `T`, the conversion is evaluated as an unwrapping from `S?` to `S` followed by the underlying conversion from `S` to `T`.</span></span>

<span data-ttu-id="d11f1-326">Обратите внимание, что при попытке распаковки допускающее null значение приведет к возникновению исключения, если значение `null`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-326">Note that an attempt to unwrap a nullable value will throw an exception if the value is `null`.</span></span>

### <a name="explicit-reference-conversions"></a><span data-ttu-id="d11f1-327">Явные преобразования ссылочных типов</span><span class="sxs-lookup"><span data-stu-id="d11f1-327">Explicit reference conversions</span></span>

<span data-ttu-id="d11f1-328">Ниже приведены явных преобразований.</span><span class="sxs-lookup"><span data-stu-id="d11f1-328">The explicit reference conversions are:</span></span>

*  <span data-ttu-id="d11f1-329">Из `object` и `dynamic` любым другим *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="d11f1-329">From `object` and `dynamic` to any other *reference_type*.</span></span>
*  <span data-ttu-id="d11f1-330">Из любого *class_type* `S` к любому *class_type* `T`, в который `S` является базовым классом для `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-330">From any *class_type* `S` to any *class_type* `T`, provided `S` is a base class of `T`.</span></span>
*  <span data-ttu-id="d11f1-331">Из любого *class_type* `S` к любому *interface_type* `T`, в который `S` не запечатан и не предоставляются `S` не реализует `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-331">From any *class_type* `S` to any *interface_type* `T`, provided `S` is not sealed and provided `S` does not implement `T`.</span></span>
*  <span data-ttu-id="d11f1-332">Из любого *interface_type* `S` к любому *class_type* `T`, в который `T` не запечатан и не предоставляются `T` реализует `S`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-332">From any *interface_type* `S` to any *class_type* `T`, provided `T` is not sealed or provided `T` implements `S`.</span></span>
*  <span data-ttu-id="d11f1-333">Из любого *interface_type* `S` к любому *interface_type* `T`, в который `S` не является производным от `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-333">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is not derived from `T`.</span></span>
*  <span data-ttu-id="d11f1-334">Из *array_type* `S` с типом элемента `SE` для *array_type* `T` с типом элемента `TE`, если выполняются все следующие условия:</span><span class="sxs-lookup"><span data-stu-id="d11f1-334">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="d11f1-335">`S` и `T` различаются только по типу элементов.</span><span class="sxs-lookup"><span data-stu-id="d11f1-335">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="d11f1-336">Другими словами `S` и `T` имеют одинаковое количество измерений.</span><span class="sxs-lookup"><span data-stu-id="d11f1-336">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="d11f1-337">Оба `SE` и `TE` являются *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="d11f1-337">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="d11f1-338">Существует неявное преобразование из `SE` для `TE`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-338">An explicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="d11f1-339">Из `System.Array` и интерфейсы, который реализуется, чтобы любой *array_type*.</span><span class="sxs-lookup"><span data-stu-id="d11f1-339">From `System.Array` and the interfaces it implements to any *array_type*.</span></span>
*  <span data-ttu-id="d11f1-340">Одномерный массив типа `S[]` для `System.Collections.Generic.IList<T>` и его базовые интерфейсы, если существует неявное преобразование из `S` для `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-340">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an explicit reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="d11f1-341">Из `System.Collections.Generic.IList<S>` и его базовых интерфейсов в тип одномерного массива `T[]`при условии, что имеется явное преобразование идентификатора или ссылки из `S` для `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-341">From `System.Collections.Generic.IList<S>` and its base interfaces to a single-dimensional array type `T[]`, provided that there is an explicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="d11f1-342">Из `System.Delegate` и интерфейсы, который реализуется, чтобы любой *delegate_type*.</span><span class="sxs-lookup"><span data-stu-id="d11f1-342">From `System.Delegate` and the interfaces it implements to any *delegate_type*.</span></span>
*  <span data-ttu-id="d11f1-343">От ссылочного типа к ссылочному типу `T` если он имеет неявное преобразование к ссылочному типу `T0` и `T0` имеет преобразование идентификации `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-343">From a reference type to a reference type `T` if it has an explicit reference conversion to a reference type `T0` and `T0` has an identity conversion `T`.</span></span>
*  <span data-ttu-id="d11f1-344">От ссылочного типа в тип интерфейса или делегата `T` если он имеет неявное преобразование к типу интерфейса или делегата `T0` и либо `T0` является вариантно преобразуемым к `T` или `T` — вариантно преобразуемым к `T0` ([Вариантное преобразование](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-344">From a reference type to an interface or delegate type `T` if it has an explicit reference conversion to an interface or delegate type `T0` and either `T0` is variance-convertible to `T` or `T` is variance-convertible to `T0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>
*  <span data-ttu-id="d11f1-345">Из `D<S1...Sn>` для `D<T1...Tn>` где `D<X1...Xn>` является типом универсального метода-делегата, `D<S1...Sn>` несовместим с или идентичен `D<T1...Tn>`и для каждого параметра типа `Xi` из `D` содержит следующие:</span><span class="sxs-lookup"><span data-stu-id="d11f1-345">From `D<S1...Sn>` to `D<T1...Tn>` where `D<X1...Xn>` is a generic delegate type, `D<S1...Sn>` is not compatible with or identical to `D<T1...Tn>`, and for each type parameter `Xi` of `D` the following holds:</span></span>
    * <span data-ttu-id="d11f1-346">Если `Xi` является инвариантным, затем `Si` идентична `Ti`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-346">If `Xi` is invariant, then `Si` is identical to `Ti`.</span></span>
    * <span data-ttu-id="d11f1-347">Если `Xi` является ковариантным, то существует явное или неявное преобразование идентификатора или ссылки из `Si` для `Ti`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-347">If `Xi` is covariant, then there is an implicit or explicit identity or reference conversion from `Si` to `Ti`.</span></span>
    * <span data-ttu-id="d11f1-348">Если `Xi` является контравариантным, затем `Si` и `Ti` могут быть одинаковыми или обе ссылки на типы.</span><span class="sxs-lookup"><span data-stu-id="d11f1-348">If `Xi` is contravariant, then `Si` and `Ti` are either identical or both reference types.</span></span>
*  <span data-ttu-id="d11f1-349">Явные преобразования, включающие параметры типа, которые являются ссылочными типами.</span><span class="sxs-lookup"><span data-stu-id="d11f1-349">Explicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="d11f1-350">Дополнительные сведения о явных преобразованиях, включающие параметры типа, см. в разделе [явные преобразования, включающие параметры типа](conversions.md#explicit-conversions-involving-type-parameters).</span><span class="sxs-lookup"><span data-stu-id="d11f1-350">For more details on explicit conversions involving type parameters, see [Explicit conversions involving type parameters](conversions.md#explicit-conversions-involving-type-parameters).</span></span>

<span data-ttu-id="d11f1-351">Явных преобразований являются такие преобразования между ссылочными типами, которые требуют проверки времени выполнения, чтобы убедиться, что они верны.</span><span class="sxs-lookup"><span data-stu-id="d11f1-351">The explicit reference conversions are those conversions between reference-types that require run-time checks to ensure they are correct.</span></span>

<span data-ttu-id="d11f1-352">Для преобразования явной ссылки для успешного выполнения во время выполнения, значение исходного операнда должно быть `null`, или фактический тип объекта, который ссылается исходного операнда должен быть типом, который может быть преобразован в целевой тип путем неявную ссылку преобразование ([неявные преобразования ссылочных типов](conversions.md#implicit-reference-conversions)) или упаковка-преобразование ([осуществлять преобразования-упаковки](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-352">For an explicit reference conversion to succeed at run-time, the value of the source operand must be `null`, or the actual type of the object referenced by the source operand must be a type that can be converted to the destination type by an implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions)) or boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)).</span></span> <span data-ttu-id="d11f1-353">При сбое преобразования явной ссылки `System.InvalidCastException` возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="d11f1-353">If an explicit reference conversion fails, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="d11f1-354">Преобразования ссылок, явные и неявные, никогда не изменяют ссылочный идентификатор преобразуемого объекта.</span><span class="sxs-lookup"><span data-stu-id="d11f1-354">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="d11f1-355">Другими словами преобразование ссылки может изменить тип ссылки, он никогда не изменяет тип или значение объекта, на которую выполняется ссылка.</span><span class="sxs-lookup"><span data-stu-id="d11f1-355">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="d11f1-356">Распаковки-преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-356">Unboxing conversions</span></span>

<span data-ttu-id="d11f1-357">Распаковки-преобразования позволяет ссылочного типа явно преобразовать *value_type*.</span><span class="sxs-lookup"><span data-stu-id="d11f1-357">An unboxing conversion permits a reference type to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="d11f1-358">Существует распаковки-преобразования из типов `object`, `dynamic` и `System.ValueType` к любому *non_nullable_value_type*и из любого *interface_type* к любому *non_ nullable_value_type* , реализующий *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="d11f1-358">An unboxing conversion exists from the types `object`, `dynamic` and `System.ValueType` to any *non_nullable_value_type*, and from any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span> <span data-ttu-id="d11f1-359">Кроме того, введите `System.Enum` могут быть распакованы в любой *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="d11f1-359">Furthermore type `System.Enum` can be unboxed to any *enum_type*.</span></span>

<span data-ttu-id="d11f1-360">Существует распаковки-преобразования ссылочных типов для *nullable_type* существования распаковки-преобразования от ссылочного типа к базовому объекту *non_nullable_value_type* из  *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="d11f1-360">An unboxing conversion exists from a reference type to a *nullable_type* if an unboxing conversion exists from the reference type to the underlying *non_nullable_value_type* of the *nullable_type*.</span></span>

<span data-ttu-id="d11f1-361">Тип значения `S` имеет распаковки-преобразования из типа интерфейса `I` наличия распаковки-преобразования из типа интерфейса `I0` и `I0` имеет преобразование удостоверения для `I`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-361">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="d11f1-362">Тип значения `S` имеет распаковки-преобразования из типа интерфейса `I` при наличии распаковки-преобразования из типа интерфейса или делегата `I0` и либо `I0` является вариантно преобразуемым к `I` или `I`является вариантно преобразуемым к `I0` ([Вариантное преобразование](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-362">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface or delegate type `I0` and either `I0` is variance-convertible to `I` or `I` is variance-convertible to `I0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>

<span data-ttu-id="d11f1-363">Операция распаковки состоит из, что экземпляр объекта является упакованным значением заданного *value_type*, а затем скопировав значение из экземпляра.</span><span class="sxs-lookup"><span data-stu-id="d11f1-363">An unboxing operation consists of first checking that the object instance is a boxed value of the given *value_type*, and then copying the value out of the instance.</span></span> <span data-ttu-id="d11f1-364">Распаковка-преобразование пустая ссылка для *nullable_type* null значение *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="d11f1-364">Unboxing a null reference to a *nullable_type* produces the null value of the *nullable_type*.</span></span> <span data-ttu-id="d11f1-365">Структуры могут быть распакованы из типа `System.ValueType`, так как это базовый класс для всех структур ([наследования](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-365">A struct can be unboxed from the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="d11f1-366">Преобразования, распаковки-преобразования описаны далее в [преобразования, распаковки-преобразования](types.md#unboxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="d11f1-366">Unboxing conversions are described further in [Unboxing conversions](types.md#unboxing-conversions).</span></span>

### <a name="explicit-dynamic-conversions"></a><span data-ttu-id="d11f1-367">Явные преобразования динамических</span><span class="sxs-lookup"><span data-stu-id="d11f1-367">Explicit dynamic conversions</span></span>

<span data-ttu-id="d11f1-368">Существует явное преобразование динамических из выражения типа `dynamic` к любому типу `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-368">An explicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="d11f1-369">Преобразование является динамическим ([динамической привязки](expressions.md#dynamic-binding)), что означает, что во время выполнения из типа времени выполнения выражения будет использоваться явное преобразование `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-369">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an explicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="d11f1-370">Если преобразование не найдено, создается исключение времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="d11f1-370">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="d11f1-371">Если динамическую привязку преобразования не требуется, то можно быть сначала преобразовано в `object`, а затем к требуемому типу.</span><span class="sxs-lookup"><span data-stu-id="d11f1-371">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="d11f1-372">Предположим, что определен следующий класс:</span><span class="sxs-lookup"><span data-stu-id="d11f1-372">Assume the following class is defined:</span></span>
```csharp
class C
{
    int i;

    public C(int i) { this.i = i; }

    public static explicit operator C(string s) 
    {
        return new C(int.Parse(s));
    }
}
```

<span data-ttu-id="d11f1-373">В следующем примере показано явное динамическое преобразование:</span><span class="sxs-lookup"><span data-stu-id="d11f1-373">The following example illustrates explicit dynamic conversions:</span></span>
```csharp
object o  = "1";
dynamic d = "2";

var c1 = (C)o; // Compiles, but explicit reference conversion fails
var c2 = (C)d; // Compiles and user defined conversion succeeds
```

<span data-ttu-id="d11f1-374">Лучшее преобразование из `o` для `C` найден во время компиляции, чтобы выполнить преобразование явной ссылки.</span><span class="sxs-lookup"><span data-stu-id="d11f1-374">The best conversion of `o` to `C` is found at compile-time to be an explicit reference conversion.</span></span> <span data-ttu-id="d11f1-375">Это происходит сбой во время выполнения, так как `"1"` не является на самом деле `C`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-375">This fails at run-time, because `"1"` is not in fact a `C`.</span></span> <span data-ttu-id="d11f1-376">Преобразование `d` для `C` тем не менее, как явное преобразование динамических, приостанавливается на время выполнения, где пользовательское преобразование из типа времени выполнения `d`  --  `string` --до `C` найден, и завершается успешно.</span><span class="sxs-lookup"><span data-stu-id="d11f1-376">The conversion of `d` to `C` however, as an explicit dynamic conversion, is suspended to run-time, where a user defined conversion from the run-time type of `d` -- `string` -- to `C` is found, and succeeds.</span></span>

### <a name="explicit-conversions-involving-type-parameters"></a><span data-ttu-id="d11f1-377">Явные преобразования, включающие параметры типа</span><span class="sxs-lookup"><span data-stu-id="d11f1-377">Explicit conversions involving type parameters</span></span>

<span data-ttu-id="d11f1-378">Существуют следующие явные преобразования для заданного параметра типа `T`:</span><span class="sxs-lookup"><span data-stu-id="d11f1-378">The following explicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="d11f1-379">От действующих базового класса `C` из `T` для `T` и от базового класса из `C` для `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-379">From the effective base class `C` of `T` to `T` and from any base class of `C` to `T`.</span></span> <span data-ttu-id="d11f1-380">Если время выполнения, AT `T` является типом значения, преобразование выполняется как распаковки-преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-380">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="d11f1-381">В противном случае преобразование выполняется как преобразование явной ссылки или преобразование идентификации.</span><span class="sxs-lookup"><span data-stu-id="d11f1-381">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="d11f1-382">Из любой другой тип интерфейса, чтобы `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-382">From any interface type to `T`.</span></span> <span data-ttu-id="d11f1-383">Если время выполнения, AT `T` является типом значения, преобразование выполняется как распаковки-преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-383">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="d11f1-384">В противном случае преобразование выполняется как преобразование явной ссылки или преобразование идентификации.</span><span class="sxs-lookup"><span data-stu-id="d11f1-384">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="d11f1-385">Из `T` к любому *interface_type* `I` условии уже не существует неявное преобразование из `T` для `I`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-385">From `T` to any *interface_type* `I` provided there is not already an implicit conversion from `T` to `I`.</span></span> <span data-ttu-id="d11f1-386">Если время выполнения, AT `T` является типом значения, преобразование выполняется как упаковка-преобразование, а затем неявное преобразование.</span><span class="sxs-lookup"><span data-stu-id="d11f1-386">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion followed by an explicit reference conversion.</span></span> <span data-ttu-id="d11f1-387">В противном случае преобразование выполняется как преобразование явной ссылки или преобразование идентификации.</span><span class="sxs-lookup"><span data-stu-id="d11f1-387">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="d11f1-388">От параметра типа `U` для `T`, в который `T` зависит от `U` ([ограничения параметров типа](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-388">From a type parameter `U` to `T`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="d11f1-389">Если время выполнения, AT `U` является типом значения, затем `T` и `U` обязательно относятся к одному типу и не выполняют никаких преобразований.</span><span class="sxs-lookup"><span data-stu-id="d11f1-389">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="d11f1-390">В противном случае, если `T` является типом значения, преобразование выполняется как распаковки-преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-390">Otherwise, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="d11f1-391">В противном случае преобразование выполняется как преобразование явной ссылки или преобразование идентификации.</span><span class="sxs-lookup"><span data-stu-id="d11f1-391">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="d11f1-392">Если `T` является известно, быть ссылочным типом, описанные выше преобразования классифицируются как явные преобразования ссылочных типов ([явные преобразования ссылочных типов](conversions.md#explicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-392">If `T` is known to be a reference type, the conversions above are all classified as explicit reference conversions ([Explicit reference conversions](conversions.md#explicit-reference-conversions)).</span></span> <span data-ttu-id="d11f1-393">Если `T` является не известно, быть ссылочным типом, описанные выше преобразования классифицируются как распаковки-преобразования ([преобразования, распаковки-преобразования](conversions.md#unboxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-393">If `T` is not known to be a reference type, the conversions above are classified as unboxing conversions ([Unboxing conversions](conversions.md#unboxing-conversions)).</span></span>

<span data-ttu-id="d11f1-394">Приведенные выше правила не допускают прямого явного преобразования из безусловного параметра типа к типу без интерфейсов, которые могут быть неожиданными.</span><span class="sxs-lookup"><span data-stu-id="d11f1-394">The above rules do not permit a direct explicit conversion from an unconstrained type parameter to a non-interface type, which might be surprising.</span></span> <span data-ttu-id="d11f1-395">Причина для этого правила — избежать путаницы и семантика таких преобразований.</span><span class="sxs-lookup"><span data-stu-id="d11f1-395">The reason for this rule is to prevent confusion and make the semantics of such conversions clear.</span></span> <span data-ttu-id="d11f1-396">В качестве примера рассмотрим следующее объявление:</span><span class="sxs-lookup"><span data-stu-id="d11f1-396">For example, consider the following declaration:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)t;                // Error 
    }
}
```

<span data-ttu-id="d11f1-397">Если прямое явное преобразование из `t` для `int` были разрешены, можно легко предположить, что, `X<int>.F(7)` вернет `7L`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-397">If the direct explicit conversion of `t` to `int` were permitted, one might easily expect that `X<int>.F(7)` would return `7L`.</span></span> <span data-ttu-id="d11f1-398">Тем не менее это происходит, поскольку стандартные числовые преобразования применяются только в том случае, если известно, что типы числовыми во время привязки.</span><span class="sxs-lookup"><span data-stu-id="d11f1-398">However, it would not, because the standard numeric conversions are only considered when the types are known to be numeric at binding-time.</span></span> <span data-ttu-id="d11f1-399">Чтобы семантика clear, приведенном выше примере необходимо записать:</span><span class="sxs-lookup"><span data-stu-id="d11f1-399">In order to make the semantics clear, the above example must instead be written:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)(object)t;        // Ok, but will only work when T is long
    }
}
```

<span data-ttu-id="d11f1-400">Этот код теперь будет компилироваться но выполняемой `X<int>.F(7)` затем вызовет исключение во время выполнения, так как упакованное `int` не может быть преобразованы прямо в `long`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-400">This code will now compile but executing `X<int>.F(7)` would then throw an exception at run-time, since a boxed `int` cannot be converted directly to a `long`.</span></span>

### <a name="user-defined-explicit-conversions"></a><span data-ttu-id="d11f1-401">Пользовательские явные преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-401">User-defined explicit conversions</span></span>

<span data-ttu-id="d11f1-402">Явное преобразование, определяемые пользователем состоит из необязательно стандартный явное преобразование, следуют выполнения оператора пользовательские явного или неявного преобразования, следуют другой необязательно стандартное явное преобразование.</span><span class="sxs-lookup"><span data-stu-id="d11f1-402">A user-defined explicit conversion consists of an optional standard explicit conversion, followed by execution of a user-defined implicit or explicit conversion operator, followed by another optional standard explicit conversion.</span></span> <span data-ttu-id="d11f1-403">Точные правила вычисления пользовательские явные преобразования описаны в [обработку пользовательские явные преобразования](conversions.md#processing-of-user-defined-explicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="d11f1-403">The exact rules for evaluating user-defined explicit conversions are described in [Processing of user-defined explicit conversions](conversions.md#processing-of-user-defined-explicit-conversions).</span></span>

## <a name="standard-conversions"></a><span data-ttu-id="d11f1-404">Стандартные преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-404">Standard conversions</span></span>

<span data-ttu-id="d11f1-405">Стандартные преобразования — это предопределенные преобразования, которые могут возникать как часть определенного пользователем преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-405">The standard conversions are those pre-defined conversions that can occur as part of a user-defined conversion.</span></span>

### <a name="standard-implicit-conversions"></a><span data-ttu-id="d11f1-406">Стандартные неявные преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-406">Standard implicit conversions</span></span>

<span data-ttu-id="d11f1-407">Следующие неявных преобразований классифицируются как стандартные неявные преобразования:</span><span class="sxs-lookup"><span data-stu-id="d11f1-407">The following implicit conversions are classified as standard implicit conversions:</span></span>

*  <span data-ttu-id="d11f1-408">Преобразования идентификатора ([преобразование идентификации](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="d11f1-408">Identity conversions ([Identity conversion](conversions.md#identity-conversion))</span></span>
*  <span data-ttu-id="d11f1-409">Неявных числовых преобразований ([неявных числовых преобразований](conversions.md#implicit-numeric-conversions))</span><span class="sxs-lookup"><span data-stu-id="d11f1-409">Implicit numeric conversions ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions))</span></span>
*  <span data-ttu-id="d11f1-410">Неявные преобразования обнуляемых типов ([неявные преобразования обнуляемых типов](conversions.md#implicit-nullable-conversions))</span><span class="sxs-lookup"><span data-stu-id="d11f1-410">Implicit nullable conversions ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions))</span></span>
*  <span data-ttu-id="d11f1-411">Неявные преобразования ссылочных типов ([неявные преобразования ссылочных типов](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="d11f1-411">Implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
*  <span data-ttu-id="d11f1-412">Осуществлять преобразования-упаковки ([осуществлять преобразования-упаковки](conversions.md#boxing-conversions))</span><span class="sxs-lookup"><span data-stu-id="d11f1-412">Boxing conversions ([Boxing conversions](conversions.md#boxing-conversions))</span></span>
*  <span data-ttu-id="d11f1-413">Неявные преобразования выражений констант ([неявные преобразования динамических](conversions.md#implicit-dynamic-conversions))</span><span class="sxs-lookup"><span data-stu-id="d11f1-413">Implicit constant expression conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions))</span></span>
*  <span data-ttu-id="d11f1-414">Неявные преобразования, включающие параметры типа ([неявные преобразования, включающие параметры типа](conversions.md#implicit-conversions-involving-type-parameters))</span><span class="sxs-lookup"><span data-stu-id="d11f1-414">Implicit conversions involving type parameters ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters))</span></span>

<span data-ttu-id="d11f1-415">Стандартные неявные преобразования исключите определяемые пользователем неявные преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-415">The standard implicit conversions specifically exclude user-defined implicit conversions.</span></span>

### <a name="standard-explicit-conversions"></a><span data-ttu-id="d11f1-416">Стандартные явные преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-416">Standard explicit conversions</span></span>

<span data-ttu-id="d11f1-417">Стандартные явного преобразования являются все стандартные неявные преобразования, а также подмножество явных преобразований, для которых существует обратные стандартные неявные преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-417">The standard explicit conversions are all standard implicit conversions plus the subset of the explicit conversions for which an opposite standard implicit conversion exists.</span></span> <span data-ttu-id="d11f1-418">Другими словами, если стандартный неявный существует преобразование из типа `A` к типу `B`, то существует стандартное явное преобразование из типа `A` ввода `B` и от типа `B` ввода `A`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-418">In other words, if a standard implicit conversion exists from a type `A` to a type `B`, then a standard explicit conversion exists from type `A` to type `B` and from type `B` to type `A`.</span></span>

## <a name="user-defined-conversions"></a><span data-ttu-id="d11f1-419">Заданные пользователем преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-419">User-defined conversions</span></span>

<span data-ttu-id="d11f1-420">C# позволяет предварительно определенных явные и неявные преобразования можно дополнить ***заданные пользователем преобразования***.</span><span class="sxs-lookup"><span data-stu-id="d11f1-420">C# allows the pre-defined implicit and explicit conversions to be augmented by ***user-defined conversions***.</span></span> <span data-ttu-id="d11f1-421">Заданные пользователем преобразования вводятся, объявив операторы преобразования ([операторы преобразования](classes.md#conversion-operators)) в типах классов и структур.</span><span class="sxs-lookup"><span data-stu-id="d11f1-421">User-defined conversions are introduced by declaring conversion operators ([Conversion operators](classes.md#conversion-operators)) in class and struct types.</span></span>

### <a name="permitted-user-defined-conversions"></a><span data-ttu-id="d11f1-422">Разрешенные пользовательские преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-422">Permitted user-defined conversions</span></span>

<span data-ttu-id="d11f1-423">В C# допускается только определенные пользовательские преобразования для объявления.</span><span class="sxs-lookup"><span data-stu-id="d11f1-423">C# permits only certain user-defined conversions to be declared.</span></span> <span data-ttu-id="d11f1-424">В частности это не невозможно переопределить уже существующего явного или неявного преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-424">In particular, it is not possible to redefine an already existing implicit or explicit conversion.</span></span>

<span data-ttu-id="d11f1-425">Для заданного исходного типа `S` и целевого типа `T`, если `S` или `T` являются обнуляемые типы позволяют `S0` и `T0` называть их базовые типы, в противном случае `S0` и `T0` являются равным `S` и `T` соответственно.</span><span class="sxs-lookup"><span data-stu-id="d11f1-425">For a given source type `S` and target type `T`, if `S` or `T` are nullable types, let `S0` and `T0` refer to their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span> <span data-ttu-id="d11f1-426">Класс или структура может объявлять преобразование из типа источника `S` с целевым типом `T` только в том случае, если выполняются все следующие условия:</span><span class="sxs-lookup"><span data-stu-id="d11f1-426">A class or struct is permitted to declare a conversion from a source type `S` to a target type `T` only if all of the following are true:</span></span>

*  <span data-ttu-id="d11f1-427">`S0` и `T0` различных типов.</span><span class="sxs-lookup"><span data-stu-id="d11f1-427">`S0` and `T0` are different types.</span></span>
*  <span data-ttu-id="d11f1-428">Либо `S0` или `T0` — это тип класса или структуры, в котором происходит объявление оператора.</span><span class="sxs-lookup"><span data-stu-id="d11f1-428">Either `S0` or `T0` is the class or struct type in which the operator declaration takes place.</span></span>
*  <span data-ttu-id="d11f1-429">Ни `S0` , ни `T0` — *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="d11f1-429">Neither `S0` nor `T0` is an *interface_type*.</span></span>
*  <span data-ttu-id="d11f1-430">За исключением определенных пользователем преобразований, не существует преобразования из `S` для `T` или из `T` для `S`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-430">Excluding user-defined conversions, a conversion does not exist from `S` to `T` or from `T` to `S`.</span></span>

<span data-ttu-id="d11f1-431">Ограничения, которые применяются для определенных пользователем преобразований, рассматриваются далее в [операторы преобразования](classes.md#conversion-operators).</span><span class="sxs-lookup"><span data-stu-id="d11f1-431">The restrictions that apply to user-defined conversions are discussed further in [Conversion operators](classes.md#conversion-operators).</span></span>

### <a name="lifted-conversion-operators"></a><span data-ttu-id="d11f1-432">Операторы преобразования ликвидированный</span><span class="sxs-lookup"><span data-stu-id="d11f1-432">Lifted conversion operators</span></span>

<span data-ttu-id="d11f1-433">Оператор определенного пользователем преобразования, который преобразует тип значения, не допускающие значения NULL `S` типу, не поддерживающий значение NULL `T`, ***ликвидированный оператор преобразования*** существует, для преобразования из `S?` для `T?`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-433">Given a user-defined conversion operator that converts from a non-nullable value type `S` to a non-nullable value type `T`, a ***lifted conversion operator*** exists that converts from `S?` to `T?`.</span></span> <span data-ttu-id="d11f1-434">Этот оператор ликвидированный преобразование выполняет развертывание из `S?` для `S` следуют определенное пользователем преобразование из `S` для `T` следуют перенос из `T` для `T?`, за исключением того, что значение null с табличным значением `S?` преобразует непосредственно со значением null, в табличные значения `T?`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-434">This lifted conversion operator performs an unwrapping from `S?` to `S` followed by the user-defined conversion from `S` to `T` followed by a wrapping from `T` to `T?`, except that a null valued `S?` converts directly to a null valued `T?`.</span></span>

<span data-ttu-id="d11f1-435">Оператор преобразования ликвидированный имеет одной классификации явного или неявного как его базовый оператор определенного пользователем преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-435">A lifted conversion operator has the same implicit or explicit classification as its underlying user-defined conversion operator.</span></span> <span data-ttu-id="d11f1-436">Термин «определенное пользователем преобразование» применяется к использованию определяемых пользователем и ликвидируется операторы преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-436">The term "user-defined conversion" applies to the use of both user-defined and lifted conversion operators.</span></span>

### <a name="evaluation-of-user-defined-conversions"></a><span data-ttu-id="d11f1-437">Вычисление пользовательские преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-437">Evaluation of user-defined conversions</span></span>

<span data-ttu-id="d11f1-438">Определенное пользователем преобразование преобразует значение из собственного ***типа источника***, чтобы другой тип с именем ***целевой тип***.</span><span class="sxs-lookup"><span data-stu-id="d11f1-438">A user-defined conversion converts a value from its type, called the ***source type***, to another type, called the ***target type***.</span></span> <span data-ttu-id="d11f1-439">Вычисление определенного пользователем преобразования ориентирована на поиск ***наиболее конкретный*** оператор определенного пользователем преобразования для отдельных исходных и целевых типов.</span><span class="sxs-lookup"><span data-stu-id="d11f1-439">Evaluation of a user-defined conversion centers on finding the ***most specific*** user-defined conversion operator for the particular source and target types.</span></span> <span data-ttu-id="d11f1-440">Это определение разбивается на несколько шагов:</span><span class="sxs-lookup"><span data-stu-id="d11f1-440">This determination is broken into several steps:</span></span>

*  <span data-ttu-id="d11f1-441">Находит набор классов и структур, из которого будет считаться определенные пользователем операторы преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-441">Finding the set of classes and structs from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="d11f1-442">Этот набор состоит из исходного типа и его базовых классов и целевого типа и его базовых классов (с неявные предположения, что только классы и структуры можно объявить определяемых пользователем операторов, и у типов, не являющихся классами без базовых классов).</span><span class="sxs-lookup"><span data-stu-id="d11f1-442">This set consists of the source type and its base classes and the target type and its base classes (with the implicit assumptions that only classes and structs can declare user-defined operators, and that non-class types have no base classes).</span></span> <span data-ttu-id="d11f1-443">Этот шаг, если исходный или конечный тип — в рамках *nullable_type*, их вместо него базовый тип используется.</span><span class="sxs-lookup"><span data-stu-id="d11f1-443">For the purposes of this step, if either the source or target type is a *nullable_type*, their underlying type is used instead.</span></span>
*  <span data-ttu-id="d11f1-444">Из этого набора типов определение которого определяемых пользователем и ликвидируется операторы преобразования применяются.</span><span class="sxs-lookup"><span data-stu-id="d11f1-444">From that set of types, determining which user-defined and lifted conversion operators are applicable.</span></span> <span data-ttu-id="d11f1-445">Для оператора преобразования в силу, должна существовать возможность выполнить стандартное преобразование ([стандартные преобразования](conversions.md#standard-conversions)) из исходного типа операнда тип оператора, и она должна существовать возможность выполнить стандартное преобразование из результирующего типа оператора в целевой тип.</span><span class="sxs-lookup"><span data-stu-id="d11f1-445">For a conversion operator to be applicable, it must be possible to perform a standard conversion ([Standard conversions](conversions.md#standard-conversions)) from the source type to the operand type of the operator, and it must be possible to perform a standard conversion from the result type of the operator to the target type.</span></span>
*  <span data-ttu-id="d11f1-446">Набор применимых определяемых пользователем операторов определить, какой оператор однозначно наиболее подходящим.</span><span class="sxs-lookup"><span data-stu-id="d11f1-446">From the set of applicable user-defined operators, determining which operator is unambiguously the most specific.</span></span> <span data-ttu-id="d11f1-447">В общих чертах наиболее подходящий оператор является оператором типом операнда «ближайший» тип источника, а типом результат — «близко расположенные» в тип целевого объекта.</span><span class="sxs-lookup"><span data-stu-id="d11f1-447">In general terms, the most specific operator is the operator whose operand type is "closest" to the source type and whose result type is "closest" to the target type.</span></span> <span data-ttu-id="d11f1-448">Определенные пользователем операторы преобразования предпочтительнее, чем операторы ликвидированный преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-448">User-defined conversion operators are preferred over lifted conversion operators.</span></span> <span data-ttu-id="d11f1-449">Точные правила определения наиболее подходящего оператора определенное пользователем преобразование определяются в следующих разделах.</span><span class="sxs-lookup"><span data-stu-id="d11f1-449">The exact rules for establishing the most specific user-defined conversion operator are defined in the following sections.</span></span>

<span data-ttu-id="d11f1-450">После определения наиболее подходящего оператора определенное пользователем преобразование, фактическое выполнение определенного пользователем преобразования включает в себя в три этапа:</span><span class="sxs-lookup"><span data-stu-id="d11f1-450">Once a most specific user-defined conversion operator has been identified, the actual execution of the user-defined conversion involves up to three steps:</span></span>

*  <span data-ttu-id="d11f1-451">Во-первых Если это необходимо, выполняется стандартное преобразование из исходного типа в тип операнда оператора преобразования пользовательских или ликвидированный.</span><span class="sxs-lookup"><span data-stu-id="d11f1-451">First, if required, performing a standard conversion from the source type to the operand type of the user-defined or lifted conversion operator.</span></span>
*  <span data-ttu-id="d11f1-452">Затем вызывается преобразование определяемых пользователем или ликвидированный оператора для выполнения преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-452">Next, invoking the user-defined or lifted conversion operator to perform the conversion.</span></span>
*  <span data-ttu-id="d11f1-453">И, наконец при необходимости, выполняется стандартное преобразование из типа результата оператора преобразования пользовательских или поднятые в целевой тип.</span><span class="sxs-lookup"><span data-stu-id="d11f1-453">Finally, if required, performing a standard conversion from the result type of the user-defined or lifted conversion operator to the target type.</span></span>

<span data-ttu-id="d11f1-454">При оценке определенное пользователем преобразование никогда не используется более одного оператора преобразования пользовательских или ликвидированный.</span><span class="sxs-lookup"><span data-stu-id="d11f1-454">Evaluation of a user-defined conversion never involves more than one user-defined or lifted conversion operator.</span></span> <span data-ttu-id="d11f1-455">Другими словами, преобразование из типа `S` ввода `T` сначала никогда не будет выполнена определенное пользователем преобразование из `S` для `X` , а затем выполнять определенное пользователем преобразование из `X` для `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-455">In other words, a conversion from type `S` to type `T` will never first execute a user-defined conversion from `S` to `X` and then execute a user-defined conversion from `X` to `T`.</span></span>

<span data-ttu-id="d11f1-456">В следующих разделах предоставляется точного определения вычисления пользовательские явного или неявного преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-456">Exact definitions of evaluation of user-defined implicit or explicit conversions are given in the following sections.</span></span> <span data-ttu-id="d11f1-457">Условные обозначения использовать следующие термины:</span><span class="sxs-lookup"><span data-stu-id="d11f1-457">The definitions make use of the following terms:</span></span>

*  <span data-ttu-id="d11f1-458">Если стандартное неявное преобразование ([стандартные неявные преобразования](conversions.md#standard-implicit-conversions)) из типа `A` к типу `B`и если ни один из `A` , ни `B` являются *interface_type*s, затем `A` считается ***, охватываемого*** `B`, и `B` говорят, что ***encompass*** `A`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-458">If a standard implicit conversion ([Standard implicit conversions](conversions.md#standard-implicit-conversions)) exists from a type `A` to a type `B`, and if neither `A` nor `B` are *interface_type*s, then `A` is said to be ***encompassed by*** `B`, and `B` is said to ***encompass*** `A`.</span></span>
*  <span data-ttu-id="d11f1-459">***Наиболее включающий тип*** в набор типов является один тип, который включает все остальные типы в наборе.</span><span class="sxs-lookup"><span data-stu-id="d11f1-459">The ***most encompassing type*** in a set of types is the one type that encompasses all other types in the set.</span></span> <span data-ttu-id="d11f1-460">Если ни один тип включает все остальные типы, набор имеет тип, не включающим.</span><span class="sxs-lookup"><span data-stu-id="d11f1-460">If no single type encompasses all other types, then the set has no most encompassing type.</span></span> <span data-ttu-id="d11f1-461">Более интуитивно понятно, включающим тип является типом «наибольшее» в наборе — один тип, к которому каждый из других типов может быть неявно преобразован.</span><span class="sxs-lookup"><span data-stu-id="d11f1-461">In more intuitive terms, the most encompassing type is the "largest" type in the set—the one type to which each of the other types can be implicitly converted.</span></span>
*  <span data-ttu-id="d11f1-462">***Наиболее охватываемого типа*** в набор типов является один тип, который охватывается всех других типов в наборе.</span><span class="sxs-lookup"><span data-stu-id="d11f1-462">The ***most encompassed type*** in a set of types is the one type that is encompassed by all other types in the set.</span></span> <span data-ttu-id="d11f1-463">Если ни один тип охватывается всех других типов, а затем наборе нет наиболее охватываемого типа.</span><span class="sxs-lookup"><span data-stu-id="d11f1-463">If no single type is encompassed by all other types, then the set has no most encompassed type.</span></span> <span data-ttu-id="d11f1-464">Более интуитивно понятно, включаемый тип является типом «наименьшее» в наборе — один тип, который может быть неявно преобразован к каждому из других типов.</span><span class="sxs-lookup"><span data-stu-id="d11f1-464">In more intuitive terms, the most encompassed type is the "smallest" type in the set—the one type that can be implicitly converted to each of the other types.</span></span>

### <a name="processing-of-user-defined-implicit-conversions"></a><span data-ttu-id="d11f1-465">Обработка определяемые пользователем неявные преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-465">Processing of user-defined implicit conversions</span></span>

<span data-ttu-id="d11f1-466">Неявное преобразование из типа, определяемого пользователем `S` ввода `T` обрабатывается следующим образом:</span><span class="sxs-lookup"><span data-stu-id="d11f1-466">A user-defined implicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="d11f1-467">Определения типов `S0` и `T0`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-467">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="d11f1-468">Если `S` или `T` , допускающих значение NULL типов `S0` и `T0` являются их базовые типы, в противном случае `S0` и `T0` равны `S` и `T` соответственно.</span><span class="sxs-lookup"><span data-stu-id="d11f1-468">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="d11f1-469">Найти набор типов, `D`, из какой определенное пользователем преобразование будет считаться операторы.</span><span class="sxs-lookup"><span data-stu-id="d11f1-469">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="d11f1-470">Этот набор состоит из `S0` (если `S0` — это класс или структура), базовые классы для `S0` (если `S0` — это класс), и `T0` (если `T0` — это класс или структура).</span><span class="sxs-lookup"><span data-stu-id="d11f1-470">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), and `T0` (if `T0` is a class or struct).</span></span>
*  <span data-ttu-id="d11f1-471">Найти набор применимых определяемых пользователем и ликвидированный операторов преобразования, `U`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-471">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="d11f1-472">Этот набор состоит из определяемых пользователем и ликвидированный неявное преобразование операторы, объявленные в классах или структурах в `D` , преобразование из типа включающий `S` к типу, охватываемого `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-472">This set consists of the user-defined and lifted implicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing `S` to a type encompassed by `T`.</span></span> <span data-ttu-id="d11f1-473">Если `U` является пустым, преобразование не определено и возникает ошибка времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="d11f1-473">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="d11f1-474">Найти наиболее конкретный тип источника, `SX`, операторов в `U`:</span><span class="sxs-lookup"><span data-stu-id="d11f1-474">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="d11f1-475">Если какие-либо из операторов в `U` преобразования из `S`, затем `SX` является `S`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-475">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="d11f1-476">В противном случае `SX` является типом, включаемый в объединенном наборе исходных типов операторов в `U`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-476">Otherwise, `SX` is the most encompassed type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="d11f1-477">Если несколько включаемых не удается найти тип, то преобразование неоднозначно и возникает ошибка времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="d11f1-477">If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="d11f1-478">Найти наиболее конкретный конечный тип `TX`, операторов в `U`:</span><span class="sxs-lookup"><span data-stu-id="d11f1-478">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="d11f1-479">Если какие-либо из операторов в `U` преобразовать `T`, затем `TX` является `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-479">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="d11f1-480">В противном случае `TX` наиболее включающий тип в объединенном наборе конечных типов операторов в `U`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-480">Otherwise, `TX` is the most encompassing type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="d11f1-481">Если не удается найти ровно один тип наиболее охватывающий, затем преобразование неоднозначно и возникает ошибка во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="d11f1-481">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="d11f1-482">Найти наиболее подходящего оператора преобразования:</span><span class="sxs-lookup"><span data-stu-id="d11f1-482">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="d11f1-483">Если `U` содержит ровно один оператор определенного пользователем преобразования, который преобразует `SX` для `TX`, то это наиболее подходящего оператора преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-483">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="d11f1-484">В противном случае, если `U` содержит ровно один оператор ликвидированный преобразования, который преобразует `SX` для `TX`, то это наиболее подходящего оператора преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-484">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="d11f1-485">В противном случае преобразование неоднозначно и возникает ошибка времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="d11f1-485">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="d11f1-486">Наконец примените преобразование:</span><span class="sxs-lookup"><span data-stu-id="d11f1-486">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="d11f1-487">Если `S` не `SX`, затем стандартное неявное преобразование из `S` для `SX` выполняется.</span><span class="sxs-lookup"><span data-stu-id="d11f1-487">If `S` is not `SX`, then a standard implicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="d11f1-488">Наиболее подходящего оператора преобразования вызывается для преобразования из `SX` для `TX`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-488">The most specific conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="d11f1-489">Если `TX` не `T`, затем стандартное неявное преобразование из `TX` для `T` выполняется.</span><span class="sxs-lookup"><span data-stu-id="d11f1-489">If `TX` is not `T`, then a standard implicit conversion from `TX` to `T` is performed.</span></span>

### <a name="processing-of-user-defined-explicit-conversions"></a><span data-ttu-id="d11f1-490">Обработка пользовательские явные преобразования</span><span class="sxs-lookup"><span data-stu-id="d11f1-490">Processing of user-defined explicit conversions</span></span>

<span data-ttu-id="d11f1-491">Явное преобразование из типа, определяемого пользователем `S` ввода `T` обрабатывается следующим образом:</span><span class="sxs-lookup"><span data-stu-id="d11f1-491">A user-defined explicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="d11f1-492">Определения типов `S0` и `T0`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-492">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="d11f1-493">Если `S` или `T` , допускающих значение NULL типов `S0` и `T0` являются их базовые типы, в противном случае `S0` и `T0` равны `S` и `T` соответственно.</span><span class="sxs-lookup"><span data-stu-id="d11f1-493">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="d11f1-494">Найти набор типов, `D`, из какой определенное пользователем преобразование будет считаться операторы.</span><span class="sxs-lookup"><span data-stu-id="d11f1-494">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="d11f1-495">Этот набор состоит из `S0` (если `S0` — это класс или структура), базовые классы для `S0` (если `S0` — это класс), `T0` (если `T0` — это класс или структура) и базовые классы для `T0` (если `T0`— это класс).</span><span class="sxs-lookup"><span data-stu-id="d11f1-495">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), `T0` (if `T0` is a class or struct), and the base classes of `T0` (if `T0` is a class).</span></span>
*  <span data-ttu-id="d11f1-496">Найти набор применимых определяемых пользователем и ликвидированный операторов преобразования, `U`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-496">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="d11f1-497">Этот набор состоит из определяемых пользователем и ликвидированный неявные или операторы явного преобразования, объявленные классов или структур в `D` , преобразование из типа которая объединяет в себе или включенные в `S` типу, которая объединяет в себе или включенные в `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-497">This set consists of the user-defined and lifted implicit or explicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing or encompassed by `S` to a type encompassing or encompassed by `T`.</span></span> <span data-ttu-id="d11f1-498">Если `U` является пустым, преобразование не определено и возникает ошибка времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="d11f1-498">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="d11f1-499">Найти наиболее конкретный тип источника, `SX`, операторов в `U`:</span><span class="sxs-lookup"><span data-stu-id="d11f1-499">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="d11f1-500">Если какие-либо из операторов в `U` преобразования из `S`, затем `SX` является `S`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-500">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="d11f1-501">В противном случае, если любой из операторов в `U` преобразования из типов, охватывающих `S`, затем `SX` является типом, включаемый в объединенном наборе исходных типов этих операторов.</span><span class="sxs-lookup"><span data-stu-id="d11f1-501">Otherwise, if any of the operators in `U` convert from types that encompass `S`, then `SX` is the most encompassed type in the combined set of source types of those operators.</span></span> <span data-ttu-id="d11f1-502">Если не включаемый тип может быть найден, а затем преобразование неоднозначно и возникает ошибка во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="d11f1-502">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="d11f1-503">В противном случае `SX` наиболее включающий тип в объединенном наборе исходных типов операторов в `U`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-503">Otherwise, `SX` is the most encompassing type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="d11f1-504">Если не удается найти ровно один тип наиболее охватывающий, затем преобразование неоднозначно и возникает ошибка во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="d11f1-504">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="d11f1-505">Найти наиболее конкретный конечный тип `TX`, операторов в `U`:</span><span class="sxs-lookup"><span data-stu-id="d11f1-505">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="d11f1-506">Если какие-либо из операторов в `U` преобразовать `T`, затем `TX` является `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-506">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="d11f1-507">В противном случае, если любой из операторов в `U` преобразование в типы, которые охватываются `T`, затем `TX` наиболее включающий тип в объединенном наборе конечных типов этих операторов.</span><span class="sxs-lookup"><span data-stu-id="d11f1-507">Otherwise, if any of the operators in `U` convert to types that are encompassed by `T`, then `TX` is the most encompassing type in the combined set of target types of those operators.</span></span> <span data-ttu-id="d11f1-508">Если не удается найти ровно один тип наиболее охватывающий, затем преобразование неоднозначно и возникает ошибка во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="d11f1-508">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="d11f1-509">В противном случае `TX` является типом, включаемый в объединенном наборе конечных типов операторов в `U`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-509">Otherwise, `TX` is the most encompassed type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="d11f1-510">Если не включаемый тип может быть найден, а затем преобразование неоднозначно и возникает ошибка во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="d11f1-510">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="d11f1-511">Найти наиболее подходящего оператора преобразования:</span><span class="sxs-lookup"><span data-stu-id="d11f1-511">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="d11f1-512">Если `U` содержит ровно один оператор определенного пользователем преобразования, который преобразует `SX` для `TX`, то это наиболее подходящего оператора преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-512">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="d11f1-513">В противном случае, если `U` содержит ровно один оператор ликвидированный преобразования, который преобразует `SX` для `TX`, то это наиболее подходящего оператора преобразования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-513">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="d11f1-514">В противном случае преобразование неоднозначно и возникает ошибка времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="d11f1-514">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="d11f1-515">Наконец примените преобразование:</span><span class="sxs-lookup"><span data-stu-id="d11f1-515">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="d11f1-516">Если `S` не `SX`, затем стандартный явное преобразование из `S` для `SX` выполняется.</span><span class="sxs-lookup"><span data-stu-id="d11f1-516">If `S` is not `SX`, then a standard explicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="d11f1-517">Наиболее подходящий оператор определенного пользователем преобразования вызывается для преобразования из `SX` для `TX`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-517">The most specific user-defined conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="d11f1-518">Если `TX` не `T`, затем стандартный явное преобразование из `TX` для `T` выполняется.</span><span class="sxs-lookup"><span data-stu-id="d11f1-518">If `TX` is not `T`, then a standard explicit conversion from `TX` to `T` is performed.</span></span>

## <a name="anonymous-function-conversions"></a><span data-ttu-id="d11f1-519">Преобразования анонимных функций</span><span class="sxs-lookup"><span data-stu-id="d11f1-519">Anonymous function conversions</span></span>

<span data-ttu-id="d11f1-520">*Anonymous_method_expression* или *lambda_expression* классифицируется как анонимная функция ([выражения анонимных функций](expressions.md#anonymous-function-expressions)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-520">An *anonymous_method_expression* or *lambda_expression* is classified as an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)).</span></span> <span data-ttu-id="d11f1-521">Выражение не имеет типа, но может быть неявно преобразован в совместимый тип делегата или тип дерева выражения.</span><span class="sxs-lookup"><span data-stu-id="d11f1-521">The expression does not have a type but can be implicitly converted to a compatible delegate type or expression tree type.</span></span> <span data-ttu-id="d11f1-522">В частности, анонимная функция `F` совместим с типом делегата `D` указано:</span><span class="sxs-lookup"><span data-stu-id="d11f1-522">Specifically, an anonymous function `F` is compatible with a delegate type `D` provided:</span></span>

*  <span data-ttu-id="d11f1-523">Если `F` содержит *anonymous_function_signature*, затем `D` и `F` имеют одинаковое число параметров.</span><span class="sxs-lookup"><span data-stu-id="d11f1-523">If `F` contains an *anonymous_function_signature*, then `D` and `F` have the same number of parameters.</span></span>
*  <span data-ttu-id="d11f1-524">Если `F` не содержит *anonymous_function_signature*, затем `D` может иметь ноль или более параметров любого типа, пока не параметр `D` имеет `out` модификатор параметра.</span><span class="sxs-lookup"><span data-stu-id="d11f1-524">If `F` does not contain an *anonymous_function_signature*, then `D` may have zero or more parameters of any type, as long as no parameter of `D` has the `out` parameter modifier.</span></span>
*  <span data-ttu-id="d11f1-525">Если `F` имеет список явным образом типизированной параметров, каждый параметр в `D` имеет тот же тип и модификаторы, что и соответствующий параметр в `F`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-525">If `F` has an explicitly typed parameter list, each parameter in `D` has the same type and modifiers as the corresponding parameter in `F`.</span></span>
*  <span data-ttu-id="d11f1-526">Если `F` содержит список параметров в неявно типизированные, `D` не имеет `ref` или `out` параметров.</span><span class="sxs-lookup"><span data-stu-id="d11f1-526">If `F` has an implicitly typed parameter list, `D` has no `ref` or `out` parameters.</span></span>
*  <span data-ttu-id="d11f1-527">Если тело `F` имеет значение выражения и либо `D` имеет `void` тип возвращаемого значения или `F` является асинхронной и `D` имеет возвращаемый тип `Task`, то при каждого параметра `F` присваивается тип соответствующий параметр в `D`, тело `F` представляет собой допустимое выражение (wrt [выражения](expressions.md)) допустимы как *statement_expression* ([Операторы выражений](statements.md#expression-statements)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-527">If the body of `F` is an expression, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that would be permitted as a *statement_expression* ([Expression statements](statements.md#expression-statements)).</span></span>
*  <span data-ttu-id="d11f1-528">Если тело `F` имеет блок операторов и либо `D` имеет `void` тип возвращаемого значения или `F` является асинхронной и `D` имеет возвращаемый тип `Task`, то при каждого параметра `F` присваивается тип соответствующий параметр в `D`, тело `F` представляет собой допустимую инструкцию блок (среды выполнения Windows [блоки](statements.md#blocks)) в котором не `return` инструкция указывает выражение.</span><span class="sxs-lookup"><span data-stu-id="d11f1-528">If the body of `F` is a statement block, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) in which no `return` statement specifies an expression.</span></span>
*  <span data-ttu-id="d11f1-529">Если тело `F` представляет собой выражение, и *либо* `F` является синхронные и `D` имеет тип возврата, отличный от void `T`, *или* `F` является асинхронной и `D` имеет тип возвращаемого значения `Task<T>`, то при каждого параметра `F` присваивается тип соответствующего параметра в `D`, тело `F` представляет собой допустимое выражение (wrt [ Выражения](expressions.md)), может быть неявно преобразован `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-529">If the body of `F` is an expression, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that is implicitly convertible to `T`.</span></span>
*  <span data-ttu-id="d11f1-530">Если тело `F` — это блок операторов и *либо* `F` является синхронные и `D` имеет тип возврата, отличный от void `T`, *или* `F` является асинхронной и `D` с типом возврата `Task<T>`, то при каждого параметра `F` присваивается тип соответствующего параметра в `D`, тело `F` представляет собой блок допустимую инструкцию (среды выполнения Windows [блоков ](statements.md#blocks)) с не доступную конечную точку каждый `return` инструкция указывает выражение, которое может быть неявно преобразован `T`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-530">If the body of `F` is a statement block, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) with a non-reachable end point in which each `return` statement specifies an expression that is implicitly convertible to `T`.</span></span>

<span data-ttu-id="d11f1-531">Для краткости в этом разделе используется краткую форму для типов задач `Task` и `Task<T>` ([асинхронные функции](classes.md#async-functions)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-531">For the purpose of brevity, this section uses the short form for the task types `Task` and `Task<T>` ([Async functions](classes.md#async-functions)).</span></span>

<span data-ttu-id="d11f1-532">Лямбда-выражение `F` совместима с типа дерева выражений `Expression<D>` Если `F` совместим с типом делегата `D`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-532">A lambda expression `F` is compatible with an expression tree type `Expression<D>` if `F` is compatible with the delegate type `D`.</span></span> <span data-ttu-id="d11f1-533">Обратите внимание на то, что это не относится к анонимным методам, только лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="d11f1-533">Note that this does not apply to anonymous methods, only lambda expressions.</span></span>

<span data-ttu-id="d11f1-534">Некоторые лямбда-выражения невозможно преобразовать в типы дерева выражений: несмотря на то что преобразование *существует*, происходит сбой во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="d11f1-534">Certain lambda expressions cannot be converted to expression tree types: Even though the conversion *exists*, it fails at compile-time.</span></span> <span data-ttu-id="d11f1-535">Это является том случае, если лямбда-выражения:</span><span class="sxs-lookup"><span data-stu-id="d11f1-535">This is the case if the lambda expression:</span></span>

*  <span data-ttu-id="d11f1-536">Имеет *блок* текст</span><span class="sxs-lookup"><span data-stu-id="d11f1-536">Has a *block* body</span></span>
*  <span data-ttu-id="d11f1-537">Содержит операторы присваивания простых и составных</span><span class="sxs-lookup"><span data-stu-id="d11f1-537">Contains simple or compound assignment operators</span></span>
*  <span data-ttu-id="d11f1-538">Содержит динамически привязанное выражение.</span><span class="sxs-lookup"><span data-stu-id="d11f1-538">Contains a dynamically bound expression</span></span>
*  <span data-ttu-id="d11f1-539">Является асинхронной</span><span class="sxs-lookup"><span data-stu-id="d11f1-539">Is async</span></span>

<span data-ttu-id="d11f1-540">В следующих примерах используется универсальный тип делегата `Func<A,R>` , представляющий функцию, которая принимает аргумент типа `A` и возвращает значение типа `R`:</span><span class="sxs-lookup"><span data-stu-id="d11f1-540">The examples that follow use a generic delegate type `Func<A,R>` which represents a function that takes an argument of type `A` and returns a value of type `R`:</span></span>
```csharp
delegate R Func<A,R>(A arg);
```

<span data-ttu-id="d11f1-541">В поле назначения</span><span class="sxs-lookup"><span data-stu-id="d11f1-541">In the assignments</span></span>
```csharp
Func<int,int> f1 = x => x + 1;                 // Ok

Func<int,double> f2 = x => x + 1;              // Ok

Func<double,int> f3 = x => x + 1;              // Error

Func<int, Task<int>> f4 = async x => x + 1;    // Ok
```
<span data-ttu-id="d11f1-542">типы параметров и возвращаемых каждой анонимной функции определяются из типа переменной, которой присвоен анонимной функции.</span><span class="sxs-lookup"><span data-stu-id="d11f1-542">the parameter and return types of each anonymous function are determined from the type of the variable to which the anonymous function is assigned.</span></span>

<span data-ttu-id="d11f1-543">Первое присваивание успешно выполняется преобразование анонимной функции в тип делегата `Func<int,int>` поскольку, если `x` присваивается тип `int`, `x+1` представляет собой допустимое выражение, которое может быть неявно преобразован в тип `int`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-543">The first assignment successfully converts the anonymous function to the delegate type `Func<int,int>` because, when `x` is given type `int`, `x+1` is a valid expression that is implicitly convertible to type `int`.</span></span>

<span data-ttu-id="d11f1-544">Аналогичным образом, второе назначение успешно выполняется преобразование анонимной функции в тип делегата `Func<int,double>` так как результат `x+1` (типа `int`) может быть неявно преобразован в тип `double`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-544">Likewise, the second assignment successfully converts the anonymous function to the delegate type `Func<int,double>` because the result of `x+1` (of type `int`) is implicitly convertible to type `double`.</span></span>

<span data-ttu-id="d11f1-545">Тем не менее, третий присваивания — ошибка времени компиляции, так как, когда `x` присваивается тип `double`, результат `x+1` (типа `double`) не может быть неявно преобразован в тип `int`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-545">However, the third assignment is a compile-time error because, when `x` is given type `double`, the result of `x+1` (of type `double`) is not implicitly convertible to type `int`.</span></span>

<span data-ttu-id="d11f1-546">Четвертый назначения успешно преобразует анонимные асинхронной функции в тип делегата `Func<int, Task<int>>` так как результат `x+1` (типа `int`) может быть неявно преобразован в тип результата `int` типа задач `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-546">The fourth assignment successfully converts the anonymous async function to the delegate type `Func<int, Task<int>>` because the result of `x+1` (of type `int`) is implicitly convertible to the result type `int` of the task type `Task<int>`.</span></span>

<span data-ttu-id="d11f1-547">Анонимные функции могут влиять на разрешение перегрузки и участвовать в определение типа.</span><span class="sxs-lookup"><span data-stu-id="d11f1-547">Anonymous functions may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="d11f1-548">См. в разделе [функции-члены](expressions.md#function-members) для получения дополнительных сведений.</span><span class="sxs-lookup"><span data-stu-id="d11f1-548">See [Function members](expressions.md#function-members) for further details.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-delegate-types"></a><span data-ttu-id="d11f1-549">Вычисление анонимную функцию преобразования в типы делегатов</span><span class="sxs-lookup"><span data-stu-id="d11f1-549">Evaluation of anonymous function conversions to delegate types</span></span>

<span data-ttu-id="d11f1-550">Преобразование анонимной функции в тип делегата создает экземпляр делегата, который ссылается на анонимной функции и (возможно, пустой) набор внешних записанных переменных, которые активны во время вычисления.</span><span class="sxs-lookup"><span data-stu-id="d11f1-550">Conversion of an anonymous function to a delegate type produces a delegate instance which references the anonymous function and the (possibly empty) set of captured outer variables that are active at the time of the evaluation.</span></span> <span data-ttu-id="d11f1-551">При вызове делегата, выполняется Тело анонимной функции.</span><span class="sxs-lookup"><span data-stu-id="d11f1-551">When the delegate is invoked, the body of the anonymous function is executed.</span></span> <span data-ttu-id="d11f1-552">Код в теле выполняется с помощью набора внешних записанных переменных ссылается делегат.</span><span class="sxs-lookup"><span data-stu-id="d11f1-552">The code in the body is executed using the set of captured outer variables referenced by the delegate.</span></span>

<span data-ttu-id="d11f1-553">Список вызовов делегата, созданного на анонимную функцию, содержит одну запись.</span><span class="sxs-lookup"><span data-stu-id="d11f1-553">The invocation list of a delegate produced from an anonymous function contains a single entry.</span></span> <span data-ttu-id="d11f1-554">Не определены конечные объект и целевой метод делегата.</span><span class="sxs-lookup"><span data-stu-id="d11f1-554">The exact target object and target method of the delegate are unspecified.</span></span> <span data-ttu-id="d11f1-555">В частности, не указано, является ли целевой объект делегата `null`, `this` значение включающей функции-члена или некоторому другому объекту.</span><span class="sxs-lookup"><span data-stu-id="d11f1-555">In particular, it is unspecified whether the target object of the delegate is `null`, the `this` value of the enclosing function member, or some other object.</span></span>

<span data-ttu-id="d11f1-556">Преобразование семантически идентичные анонимные функции (возможно, пустой) же набор экземпляров внешних переменных к одному типу делегата разрешены (но не требуются) для возврата один и тот же экземпляр делегата.</span><span class="sxs-lookup"><span data-stu-id="d11f1-556">Conversions of semantically identical anonymous functions with the same (possibly empty) set of captured outer variable instances to the same delegate types are permitted (but not required) to return the same delegate instance.</span></span> <span data-ttu-id="d11f1-557">Семантически идентичные термин используется здесь означает, что выполнение анонимных функций во всех случаях дает одинаковые результаты с одинаковыми аргументами.</span><span class="sxs-lookup"><span data-stu-id="d11f1-557">The term semantically identical is used here to mean that execution of the anonymous functions will, in all cases, produce the same effects given the same arguments.</span></span> <span data-ttu-id="d11f1-558">Это правило позволяет оптимизировать следующий код.</span><span class="sxs-lookup"><span data-stu-id="d11f1-558">This rule permits code such as the following to be optimized.</span></span>

```csharp
delegate double Function(double x);

class Test
{
    static double[] Apply(double[] a, Function f) {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
    }

    static void F(double[] a, double[] b) {
        a = Apply(a, (double x) => Math.Sin(x));
        b = Apply(b, (double y) => Math.Sin(y));
        ...
    }
}
```

<span data-ttu-id="d11f1-559">Поскольку два делегата анонимной функции имеют те же (пустой) внешних записанных переменных, а поскольку анонимные функции семантически идентичны, компилятор может делегаты могут ссылаться на один и тот же целевой метод.</span><span class="sxs-lookup"><span data-stu-id="d11f1-559">Since the two anonymous function delegates have the same (empty) set of captured outer variables, and since the anonymous functions are semantically identical, the compiler is permitted to have the delegates refer to the same target method.</span></span> <span data-ttu-id="d11f1-560">Действительно компилятор может возвращать одинаковые экземпляры делегата из обоих выражения анонимных функций.</span><span class="sxs-lookup"><span data-stu-id="d11f1-560">Indeed, the compiler is permitted to return the very same delegate instance from both anonymous function expressions.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-expression-tree-types"></a><span data-ttu-id="d11f1-561">Вычисление анонимной функции преобразования к типы дерева выражений</span><span class="sxs-lookup"><span data-stu-id="d11f1-561">Evaluation of anonymous function conversions to expression tree types</span></span>

<span data-ttu-id="d11f1-562">Преобразование анонимной функции в тип дерева выражения создает дерево выражений ([типы дерева выражений](types.md#expression-tree-types)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-562">Conversion of an anonymous function to an expression tree type produces an expression tree ([Expression tree types](types.md#expression-tree-types)).</span></span> <span data-ttu-id="d11f1-563">Точнее вычисление преобразования анонимной функции приводит к конструкции структуру объекта, представляющий структуру саму функцию.</span><span class="sxs-lookup"><span data-stu-id="d11f1-563">More precisely, evaluation of the anonymous function conversion leads to the construction of an object structure that represents the structure of the anonymous function itself.</span></span> <span data-ttu-id="d11f1-564">Фактическая структура дерева выражения, а также процесс его построения, определяется реализацией.</span><span class="sxs-lookup"><span data-stu-id="d11f1-564">The precise structure of the expression tree, as well as the exact process for creating it, are implementation defined.</span></span>

### <a name="implementation-example"></a><span data-ttu-id="d11f1-565">Пример реализации</span><span class="sxs-lookup"><span data-stu-id="d11f1-565">Implementation example</span></span>

<span data-ttu-id="d11f1-566">В этом разделе описывается возможная реализация преобразования анонимных функций с точки зрения других конструкций C#.</span><span class="sxs-lookup"><span data-stu-id="d11f1-566">This section describes a possible implementation of anonymous function conversions in terms of other C# constructs.</span></span> <span data-ttu-id="d11f1-567">Описанные здесь реализация основана на принципах, используемых компилятором Microsoft C#, но он отнюдь не является обязательной и не только возможно.</span><span class="sxs-lookup"><span data-stu-id="d11f1-567">The implementation described here is based on the same principles used by the Microsoft C# compiler, but it is by no means a mandated implementation, nor is it the only one possible.</span></span> <span data-ttu-id="d11f1-568">Он только кратко рассматривается преобразования в деревья выражений, как их точное семантика выходит за рамки этой спецификации.</span><span class="sxs-lookup"><span data-stu-id="d11f1-568">It only briefly mentions conversions to expression trees, as their exact semantics are outside the scope of this specification.</span></span>

<span data-ttu-id="d11f1-569">В оставшейся части этого раздела приводится несколько примеров кода, содержащего анонимных функций с разными характеристиками.</span><span class="sxs-lookup"><span data-stu-id="d11f1-569">The remainder of this section gives several examples of code that contains anonymous functions with different characteristics.</span></span> <span data-ttu-id="d11f1-570">Для каждого примера предоставляется представлен соответствующий код, использующий только другие конструкции C#.</span><span class="sxs-lookup"><span data-stu-id="d11f1-570">For each example, a corresponding translation to code that uses only other C# constructs is provided.</span></span> <span data-ttu-id="d11f1-571">В примерах, идентификатор `D` предполагается, что, представляющие следующий тип делегата:</span><span class="sxs-lookup"><span data-stu-id="d11f1-571">In the examples, the identifier `D` is assumed by represent the following delegate type:</span></span>
```csharp
public delegate void D();
```

<span data-ttu-id="d11f1-572">Самая простая форма анонимная функция — это приложения, не записывает внешние переменные:</span><span class="sxs-lookup"><span data-stu-id="d11f1-572">The simplest form of an anonymous function is one that captures no outer variables:</span></span>
```csharp
class Test
{
    static void F() {
        D d = () => { Console.WriteLine("test"); };
    }
}
```

<span data-ttu-id="d11f1-573">Это можно преобразовать для создания экземпляра делегата, который ссылается на статический метод созданный компилятором, в который помещается код анонимной функции:</span><span class="sxs-lookup"><span data-stu-id="d11f1-573">This can be translated to a delegate instantiation that references a compiler generated static method in which the code of the anonymous function is placed:</span></span>
```csharp
class Test
{
    static void F() {
        D d = new D(__Method1);
    }

    static void __Method1() {
        Console.WriteLine("test");
    }
}
```

<span data-ttu-id="d11f1-574">В следующем примере анонимной функции, ссылающийся на экземпляр членами `this`:</span><span class="sxs-lookup"><span data-stu-id="d11f1-574">In the following example, the anonymous function references instance members of `this`:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = () => { Console.WriteLine(x); };
    }
}
```

<span data-ttu-id="d11f1-575">Это может быть переведен в созданный компилятором метод экземпляра, содержащий код анонимной функции:</span><span class="sxs-lookup"><span data-stu-id="d11f1-575">This can be translated to a compiler generated instance method containing the code of the anonymous function:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = new D(__Method1);
    }

    void __Method1() {
        Console.WriteLine(x);
    }
}
```

<span data-ttu-id="d11f1-576">В этом примере анонимная функция записывает локальную переменную:</span><span class="sxs-lookup"><span data-stu-id="d11f1-576">In this example, the anonymous function captures a local variable:</span></span>
```csharp
class Test
{
    void F() {
        int y = 123;
        D d = () => { Console.WriteLine(y); };
    }
}
```

<span data-ttu-id="d11f1-577">Время существования локальной переменной необходимо увеличить для по крайней мере времени существования делегата анонимной функции.</span><span class="sxs-lookup"><span data-stu-id="d11f1-577">The lifetime of the local variable must now be extended to at least the lifetime of the anonymous function delegate.</span></span> <span data-ttu-id="d11f1-578">Это достигается путем «подъем» локальной переменной в поле класса созданный компилятором.</span><span class="sxs-lookup"><span data-stu-id="d11f1-578">This can be achieved by "hoisting" the local variable into a field of a compiler generated class.</span></span> <span data-ttu-id="d11f1-579">При создании экземпляра локальной переменной ([создание экземпляров локальных переменных](expressions.md#instantiation-of-local-variables)) будет соответствовать созданию экземпляра класса компилятором и доступ к локальной переменной соответствует доступу к полю в экземпляре класс, созданный компилятором.</span><span class="sxs-lookup"><span data-stu-id="d11f1-579">Instantiation of the local variable ([Instantiation of local variables](expressions.md#instantiation-of-local-variables)) then corresponds to creating an instance of the compiler generated class, and accessing the local variable corresponds to accessing a field in the instance of the compiler generated class.</span></span> <span data-ttu-id="d11f1-580">Кроме того анонимная функция становится методом экземпляра класса, созданный компилятором:</span><span class="sxs-lookup"><span data-stu-id="d11f1-580">Furthermore, the anonymous function becomes an instance method of the compiler generated class:</span></span>
```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.y = 123;
        D d = new D(__locals1.__Method1);
    }

    class __Locals1
    {
        public int y;

        public void __Method1() {
            Console.WriteLine(y);
        }
    }
}
```

<span data-ttu-id="d11f1-581">Наконец, анонимные следующая функция захваты `this` а также двух локальных переменных с различное время существования:</span><span class="sxs-lookup"><span data-stu-id="d11f1-581">Finally, the following anonymous function captures `this` as well as two local variables with different lifetimes:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        int y = 123;
        for (int i = 0; i < 10; i++) {
            int z = i * 2;
            D d = () => { Console.WriteLine(x + y + z); };
        }
    }
}
```

<span data-ttu-id="d11f1-582">Здесь компилятором класса создается для каждой инструкции блока, в какие локальные регистрируются таким образом, что локальные переменные в различных блоков может иметь независимые время существования.</span><span class="sxs-lookup"><span data-stu-id="d11f1-582">Here, a compiler generated class is created for each statement block in which locals are captured such that the locals in the different blocks can have independent lifetimes.</span></span> <span data-ttu-id="d11f1-583">Экземпляр `__Locals2`, компилятором класса для блока внутренняя инструкция содержит локальную переменную `z` и поле, которое ссылается на экземпляр `__Locals1`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-583">An instance of `__Locals2`, the compiler generated class for the inner statement block, contains the local variable `z` and a field that references an instance of `__Locals1`.</span></span>  <span data-ttu-id="d11f1-584">Экземпляр `__Locals1`, класс создан компилятором для блока внешняя инструкция содержит локальную переменную `y` и поле, которое ссылается на `this` внешней функции-члена.</span><span class="sxs-lookup"><span data-stu-id="d11f1-584">An instance of `__Locals1`, the compiler generated class for the outer statement block, contains the local variable `y` and a field that references `this` of the enclosing function member.</span></span> <span data-ttu-id="d11f1-585">С помощью этих структур данных, его можно получить доступ все захваченные внешние переменные через экземпляр `__Local2`, и код анонимной функции таким образом могут быть реализованы как метод экземпляра этого класса.</span><span class="sxs-lookup"><span data-stu-id="d11f1-585">With these data structures it is possible to reach all captured outer variables through an instance of `__Local2`, and the code of the anonymous function can thus be implemented as an instance method of that class.</span></span>

```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.__this = this;
        __locals1.y = 123;
        for (int i = 0; i < 10; i++) {
            __Locals2 __locals2 = new __Locals2();
            __locals2.__locals1 = __locals1;
            __locals2.z = i * 2;
            D d = new D(__locals2.__Method1);
        }
    }

    class __Locals1
    {
        public Test __this;
        public int y;
    }

    class __Locals2
    {
        public __Locals1 __locals1;
        public int z;

        public void __Method1() {
            Console.WriteLine(__locals1.__this.x + __locals1.y + z);
        }
    }
}
```

<span data-ttu-id="d11f1-586">Также можно использовать ту же методику, применить здесь, чтобы записать локальные переменные, при преобразовании анонимные функции в деревья выражений: ссылки на объекты, созданные компилятором, которые могут храниться в дерево выражения, и доступ к локальным переменным можно представить в виде обращается к полю на эти объекты.</span><span class="sxs-lookup"><span data-stu-id="d11f1-586">The same technique applied here to capture local variables can also be used when converting anonymous functions to expression trees: References to the compiler generated objects can be stored in the expression tree, and access to the local variables can be represented as field accesses on these objects.</span></span> <span data-ttu-id="d11f1-587">Преимуществом этого подхода том, что он позволяет «ликвидированный» локальные переменные, чтобы совместно использовать делегаты и деревья выражений.</span><span class="sxs-lookup"><span data-stu-id="d11f1-587">The advantage of this approach is that it allows the "lifted" local variables to be shared between delegates and expression trees.</span></span>

## <a name="method-group-conversions"></a><span data-ttu-id="d11f1-588">Преобразования групп методов</span><span class="sxs-lookup"><span data-stu-id="d11f1-588">Method group conversions</span></span>

<span data-ttu-id="d11f1-589">Неявное преобразование ([неявные преобразования](conversions.md#implicit-conversions)) из группы методов существует ([классификации выражений](expressions.md#expression-classifications)) для совместимого типа делегата.</span><span class="sxs-lookup"><span data-stu-id="d11f1-589">An implicit conversion ([Implicit conversions](conversions.md#implicit-conversions)) exists from a method group ([Expression classifications](expressions.md#expression-classifications)) to a compatible delegate type.</span></span> <span data-ttu-id="d11f1-590">Указанный тип делегата `D` и выражение `E` , классифицируется как группа методов, существует неявное преобразование из `E` для `D` Если `E` содержит по крайней мере один метод, который применяется в его нормальной формы () [Применимого члена функции](expressions.md#applicable-function-member)) на список аргументов, созданный путем использования параметров типы и модификаторы `D`, как описано в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="d11f1-590">Given a delegate type `D` and an expression `E` that is classified as a method group, an implicit conversion exists from `E` to `D` if `E` contains at least one method that is applicable in its normal form ([Applicable function member](expressions.md#applicable-function-member)) to an argument list constructed by use of the parameter types and modifiers of `D`, as described in the following.</span></span>

<span data-ttu-id="d11f1-591">Во время компиляции приложения из группы методов преобразования `E` типу делегата `D` описан в следующем.</span><span class="sxs-lookup"><span data-stu-id="d11f1-591">The compile-time application of a conversion from a method group `E` to a delegate type `D` is described in the following.</span></span> <span data-ttu-id="d11f1-592">Обратите внимание, что существование неявное преобразование из `E` для `D` не гарантирует успешное завершение компиляции приложения преобразования без ошибок.</span><span class="sxs-lookup"><span data-stu-id="d11f1-592">Note that the existence of an implicit conversion from `E` to `D` does not guarantee that the compile-time application of the conversion will succeed without error.</span></span>

*  <span data-ttu-id="d11f1-593">Единственный метод `M` выбран соответствующий вызов метода ([вызовы методов](expressions.md#method-invocations)) формы `E(A)`, с помощью следующих изменений:</span><span class="sxs-lookup"><span data-stu-id="d11f1-593">A single method `M` is selected corresponding to a method invocation ([Method invocations](expressions.md#method-invocations)) of the form `E(A)`, with the following modifications:</span></span>
    * <span data-ttu-id="d11f1-594">Список аргументов `A` — это список выражений, каждое классифицированные как переменную, а также с типом и модификатор (`ref` или `out`) соответствующего параметра в *formal_parameter_list* из `D`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-594">The argument list `A` is a list of expressions, each classified as a variable and with the type and modifier (`ref` or `out`) of the corresponding parameter in the *formal_parameter_list* of `D`.</span></span>
    * <span data-ttu-id="d11f1-595">Методы кандидат считается являются только те методы, применимые в нормальной форме ([применимого члена функции](expressions.md#applicable-function-member)), не те, которые применимы только в расширенной форме.</span><span class="sxs-lookup"><span data-stu-id="d11f1-595">The candidate methods considered are only those methods that are applicable in their normal form ([Applicable function member](expressions.md#applicable-function-member)), not those applicable only in their expanded form.</span></span>
*  <span data-ttu-id="d11f1-596">Если алгоритм [вызовы методов](expressions.md#method-invocations) приводит к ошибке, то возникает ошибка времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="d11f1-596">If the algorithm of [Method invocations](expressions.md#method-invocations) produces an error, then a compile-time error occurs.</span></span> <span data-ttu-id="d11f1-597">В противном случае алгоритм возвращает подходящий метод `M` с таким же числом параметров, как `D` и преобразование считается существует.</span><span class="sxs-lookup"><span data-stu-id="d11f1-597">Otherwise the algorithm produces a single best method `M` having the same number of parameters as `D` and the conversion is considered to exist.</span></span>
*  <span data-ttu-id="d11f1-598">Выбранный метод `M` должно быть совместимо ([совместимость делегатов](delegates.md#delegate-compatibility)) с типом делегата `D`, или в противном случае возникает ошибка времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="d11f1-598">The selected method `M` must be compatible ([Delegate compatibility](delegates.md#delegate-compatibility)) with the delegate type `D`, or otherwise, a compile-time error occurs.</span></span>
*  <span data-ttu-id="d11f1-599">Если выбранный метод `M` является методом экземпляра, выражение экземпляра, связанное с `E` определяет целевой объект делегата.</span><span class="sxs-lookup"><span data-stu-id="d11f1-599">If the selected method `M` is an instance method, the instance expression associated with `E` determines the target object of the delegate.</span></span>
*  <span data-ttu-id="d11f1-600">Если выбранный метод M является методом расширения, который определяется посредством доступа к члену выражения экземпляра, такое выражение определяет целевой объект делегата.</span><span class="sxs-lookup"><span data-stu-id="d11f1-600">If the selected method M is an extension method which is denoted by means of a member access on an instance expression, that instance expression determines the target object of the delegate.</span></span>
*  <span data-ttu-id="d11f1-601">Результатом преобразования является значение типа `D`, а именно: созданный делегат, который ссылается на выбранный метод и целевой объект.</span><span class="sxs-lookup"><span data-stu-id="d11f1-601">The result of the conversion is a value of type `D`, namely a newly created delegate that refers to the selected method and target object.</span></span>
*  <span data-ttu-id="d11f1-602">Обратите внимание, что этот процесс может привести к созданию делегат для метода расширения, если алгоритм [вызовы методов](expressions.md#method-invocations) не может найти метод экземпляра, но выполняется успешно при обработке вызова `E(A)` как расширение вызов метода ([вызовы методов расширения](expressions.md#extension-method-invocations)).</span><span class="sxs-lookup"><span data-stu-id="d11f1-602">Note that this process can lead to the creation of a delegate to an extension method, if the algorithm of [Method invocations](expressions.md#method-invocations) fails to find an instance method but succeeds in processing the invocation of `E(A)` as an extension method invocation ([Extension method invocations](expressions.md#extension-method-invocations)).</span></span> <span data-ttu-id="d11f1-603">Созданный таким образом делегат записывает метод расширения, а также первого аргумента.</span><span class="sxs-lookup"><span data-stu-id="d11f1-603">A delegate thus created captures the extension method as well as its first argument.</span></span>

<span data-ttu-id="d11f1-604">В следующем примере показано преобразования групп методов:</span><span class="sxs-lookup"><span data-stu-id="d11f1-604">The following example demonstrates method group conversions:</span></span>
```csharp
delegate string D1(object o);

delegate object D2(string s);

delegate object D3();

delegate string D4(object o, params object[] a);

delegate string D5(int i);

class Test
{
    static string F(object o) {...}

    static void G() {
        D1 d1 = F;            // Ok
        D2 d2 = F;            // Ok
        D3 d3 = F;            // Error -- not applicable
        D4 d4 = F;            // Error -- not applicable in normal form
        D5 d5 = F;            // Error -- applicable but not compatible

    }
}
```

<span data-ttu-id="d11f1-605">Назначение `d1` неявно преобразует группа методов `F` значение типа `D1`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-605">The assignment to `d1` implicitly converts the method group `F` to a value of type `D1`.</span></span>

<span data-ttu-id="d11f1-606">Назначение `d2` показано, как можно создать делегат метода, что имеет менее производные типы параметров (контравариантным) и более производный (ковариантным) тип возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="d11f1-606">The assignment to `d2` shows how it is possible to create a delegate to a method that has less derived (contra-variant) parameter types and a more derived (covariant) return type.</span></span>

<span data-ttu-id="d11f1-607">Назначение `d3` показано как не существует преобразования, если метод не применим.</span><span class="sxs-lookup"><span data-stu-id="d11f1-607">The assignment to `d3` shows how no conversion exists if the method is not applicable.</span></span>

<span data-ttu-id="d11f1-608">Назначение `d4` показано, как этот метод должен быть применима в обычной форме.</span><span class="sxs-lookup"><span data-stu-id="d11f1-608">The assignment to `d4` shows how the method must be applicable in its normal form.</span></span>

<span data-ttu-id="d11f1-609">Назначение `d5` показано, как типы параметров и возвращаемого значения делегата и метода могут отличаться только для ссылочных типов.</span><span class="sxs-lookup"><span data-stu-id="d11f1-609">The assignment to `d5` shows how parameter and return types of the delegate and method are allowed to differ only for reference types.</span></span>

<span data-ttu-id="d11f1-610">Как и все другие явные и неявные преобразования, можно использовать оператор cast для явного выполнения преобразования группы методов.</span><span class="sxs-lookup"><span data-stu-id="d11f1-610">As with all other implicit and explicit conversions, the cast operator can be used to explicitly perform a method group conversion.</span></span> <span data-ttu-id="d11f1-611">Таким образом пример</span><span class="sxs-lookup"><span data-stu-id="d11f1-611">Thus, the example</span></span>
```csharp
object obj = new EventHandler(myDialog.OkClick);
```
<span data-ttu-id="d11f1-612">может быть записан</span><span class="sxs-lookup"><span data-stu-id="d11f1-612">could instead be written</span></span>
```csharp
object obj = (EventHandler)myDialog.OkClick;
```

<span data-ttu-id="d11f1-613">Метод группы может влиять на разрешение перегрузки и участвовать в определение типа.</span><span class="sxs-lookup"><span data-stu-id="d11f1-613">Method groups may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="d11f1-614">См. в разделе [функции-члены](expressions.md#function-members) для получения дополнительных сведений.</span><span class="sxs-lookup"><span data-stu-id="d11f1-614">See [Function members](expressions.md#function-members) for further details.</span></span>

<span data-ttu-id="d11f1-615">Вычисление во время выполнения преобразования группы метод продолжается следующим образом.</span><span class="sxs-lookup"><span data-stu-id="d11f1-615">The run-time evaluation of a method group conversion proceeds as follows:</span></span>

*  <span data-ttu-id="d11f1-616">Если метод, выбранный во время компиляции является методом экземпляра, или он является методом расширения, которому происходит обращение как метод экземпляра, целевой объект делегата определяется на основе экземпляра выражения, связанного с `E`:</span><span class="sxs-lookup"><span data-stu-id="d11f1-616">If the method selected at compile-time is an instance method, or it is an extension method which is accessed as an instance method, the target object of the delegate is determined from the instance expression associated with `E`:</span></span>
    * <span data-ttu-id="d11f1-617">Выражение экземпляра.</span><span class="sxs-lookup"><span data-stu-id="d11f1-617">The instance expression is evaluated.</span></span> <span data-ttu-id="d11f1-618">Если эта оценка вызывает исключение, никакие дополнительные действия выполняются.</span><span class="sxs-lookup"><span data-stu-id="d11f1-618">If this evaluation causes an exception, no further steps are executed.</span></span>
    * <span data-ttu-id="d11f1-619">Если выражение экземпляра имеет *reference_type*, значение, вычисленное выражение экземпляра, становится целевой объект.</span><span class="sxs-lookup"><span data-stu-id="d11f1-619">If the instance expression is of a *reference_type*, the value computed by the instance expression becomes the target object.</span></span> <span data-ttu-id="d11f1-620">Если выбранный метод является методом экземпляра, а целевой объект — `null`, `System.NullReferenceException` возникает исключение и никакие дополнительные действия не выполняются.</span><span class="sxs-lookup"><span data-stu-id="d11f1-620">If the selected method is an instance method and the target object is `null`, a `System.NullReferenceException` is thrown and no further steps are executed.</span></span>
    * <span data-ttu-id="d11f1-621">Если выражение экземпляра имеет *value_type*, операция упаковки ([осуществлять преобразования-упаковки](types.md#boxing-conversions)) выполняется, чтобы преобразовать значение в объект, и этот объект становится целевой объект.</span><span class="sxs-lookup"><span data-stu-id="d11f1-621">If the instance expression is of a *value_type*, a boxing operation ([Boxing conversions](types.md#boxing-conversions)) is performed to convert the value to an object, and this object becomes the target object.</span></span>
*  <span data-ttu-id="d11f1-622">В противном случае выбранный метод является частью вызов статического метода, и целевой объект делегата является `null`.</span><span class="sxs-lookup"><span data-stu-id="d11f1-622">Otherwise the selected method is part of a static method call, and the target object of the delegate is `null`.</span></span>
*  <span data-ttu-id="d11f1-623">Новый экземпляр типа делегата `D` выделяется.</span><span class="sxs-lookup"><span data-stu-id="d11f1-623">A new instance of the delegate type `D` is allocated.</span></span> <span data-ttu-id="d11f1-624">Если не хватает памяти для выделения нового экземпляра, `System.OutOfMemoryException` возникает исключение и никакие дополнительные действия не выполняются.</span><span class="sxs-lookup"><span data-stu-id="d11f1-624">If there is not enough memory available to allocate the new instance, a `System.OutOfMemoryException` is thrown and no further steps are executed.</span></span>
*  <span data-ttu-id="d11f1-625">Новый экземпляр делегата инициализируется со ссылкой на метод, который был определен во время компиляции и ссылку на целевой объект вычисленный выше.</span><span class="sxs-lookup"><span data-stu-id="d11f1-625">The new delegate instance is initialized with a reference to the method that was determined at compile-time and a reference to the target object computed above.</span></span>
