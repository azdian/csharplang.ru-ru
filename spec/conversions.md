# <a name="conversions"></a>Преобразования

Объект ***преобразования*** позволяет выражению могут обрабатываться как определенного типа. Преобразование может вызвать выражение типа, заданного для рассматриваться как имеющий другой тип, иначе могут возникнуть выражение без типа, определенного типа. Преобразования могут быть ***неявное*** или ***явные***, и это определяет, является ли обязательным явное приведение. Например, преобразование из типа `int` ввода `long` является неявным, Да выражения типа `int` неявно могут рассматриваться как тип `long`. Обратное преобразование из типа `long` ввода `int`, является явным и поэтому не требуется явное приведение.

```csharp
int a = 123;
long b = a;         // implicit conversion from int to long
int c = (int) b;    // explicit conversion from long to int
```

Некоторые преобразования определяются языком. Программы могут также определять собственные преобразования ([заданные пользователем преобразования](conversions.md#user-defined-conversions)).

## <a name="implicit-conversions"></a>Неявные преобразования

Неявные преобразования относятся следующие преобразования:

*  Преобразования идентификатора
*  Неявные числовые преобразования
*  Неявные преобразования перечисляемых типов.
*  Неявные преобразования, допускающие значение NULL
*  Преобразования литерала NULL.
*  Неявные преобразования ссылочных типов
*  Упаковки-преобразования
*  Неявные преобразования динамических типов
*  Неявные преобразования выражений констант
*  Определяемые пользователем неявные преобразования
*  Преобразования анонимных функций
*  Преобразования групп методов

Неявные преобразования могут происходить в разнообразных ситуациях, включая вызовов функций-членов ([Проверка динамического разрешения перегрузки во время компиляции](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), выражения приведения ([выражения приведения](expressions.md#cast-expressions)), и назначения ([операторы присваивания](expressions.md#assignment-operators)).

Предопределенные неявные преобразования всегда выполняются успешно и никогда не вызывают исключений. Правильно спроектированное определяемые пользователем неявные преобразования должен продемонстрировать эти характеристики.

В целях преобразования, типы `object` и `dynamic` считаются эквивалентными.

Тем не менее динамическое преобразование ([неявные преобразования динамических](conversions.md#implicit-dynamic-conversions) и [явные преобразования динамических](conversions.md#explicit-dynamic-conversions)) применяются только к выражениям типа `dynamic` ([динамический тип](types.md#the-dynamic-type)).

### <a name="identity-conversion"></a>Преобразование удостоверения

Преобразование удостоверения преобразует из любого типа в тот же тип. Это преобразование используется таким образом, что сущность, которая уже имеет требуемый тип можно сказать, что быть преобразуемым к этому типу.

*  Так как объект и динамические типы считаются эквивалентными является преобразование идентификации между `object` и `dynamic`, а также между сконструированных типов, которые повторяются при замене всех вхождений `dynamic` с `object`.

### <a name="implicit-numeric-conversions"></a>Неявные числовые преобразования

Неявные числовые преобразования являются:

*  Из `sbyte` для `short`, `int`, `long`, `float`, `double`, или `decimal`.
*  Из `byte` для `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, или `decimal`.
*  Из `short` для `int`, `long`, `float`, `double`, или `decimal`.
*  Из `ushort` для `int`, `uint`, `long`, `ulong`, `float`, `double`, или `decimal`.
*  Из `int` для `long`, `float`, `double`, или `decimal`.
*  Из `uint` для `long`, `ulong`, `float`, `double`, или `decimal`.
*  Из `long` для `float`, `double`, или `decimal`.
*  Из `ulong` для `float`, `double`, или `decimal`.
*  Из `char` для `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, или `decimal`.
*  Из `float` для `double`.

Преобразования из `int`, `uint`, `long`, или `ulong` для `float` и из `long` или `ulong` для `double` может привести к потере точности, но никогда не причина потере значения. Все данные не потеряны других неявных числовых преобразований.

Не поддерживается неявное преобразование, чтобы `char` тип, поэтому значения других целочисленных типов не преобразуются автоматически `char` типа.

### <a name="implicit-enumeration-conversions"></a>Неявные преобразования перечисляемых типов

Обеспечивает преобразование неявное перечисление *decimal_integer_literal* `0` для преобразования в любой *enum_type* и в любой *nullable_type* которого базовый тип является *enum_type*. В последнем случае преобразование вычисляется путем преобразования в базовый *enum_type* и упаковки результат ([обнуляемые типы](types.md#nullable-types)).

### <a name="implicit-interpolated-string-conversions"></a>Преобразования неявных интерполированную строку

Неявный интерполированные строки преобразования разрешает *interpolated_string_expression* ([интерполированные строки](expressions.md#interpolated-strings)) для преобразования в `System.IFormattable` или `System.FormattableString` (который реализует `System.IFormattable`).

При применении этого преобразования в строковое значение не состоит из интерполированной строки. Вместо этого экземпляр `System.FormattableString` будет создана, как более подробно описано в [интерполированные строки](expressions.md#interpolated-strings).

### <a name="implicit-nullable-conversions"></a>Неявные преобразования, допускающие значение NULL

Предопределенные неявные преобразования, которые работают с типами, не поддерживающий значение NULL может также использоваться с обнуляемых типов. Для каждого из предопределенные неявные идентификации и числовых преобразований, преобразование типа не поддерживающий значение NULL `S` типу, не поддерживающий значение NULL `T`, существуют следующие неявные преобразования допускает значения NULL:

*  Неявное преобразование из `S?` для `T?`.
*  Неявное преобразование из `S` для `T?`.

На основе оценки неявного преобразования допускает значения NULL на преобразовании из `S` для `T` продолжается следующим образом:

*  Если преобразование допускает значения NULL из `S?` для `T?`:
    * Если значение источника равно null (`HasValue` свойство имеет значение false), возвращается значение null типа `T?`.
    * В противном случае преобразование вычисляется как развертывание из `S?` для `S`, а затем преобразовании из `S` для `T`, а затем оболочки ([обнуляемые типы](types.md#nullable-types)) из `T` для `T?`.

*  При преобразовании допускает значения NULL из `S` для `T?`, считается, что преобразование преобразовании из `S` для `T` следуют перенос из `T` для `T?`.

### <a name="null-literal-conversions"></a>Преобразования литерала NULL.

Существует неявное преобразование из `null` литерала для любого типа, допускающего значение NULL. Это преобразование создает значение null ([обнуляемые типы](types.md#nullable-types)) заданного типа, допускающего значение NULL.

### <a name="implicit-reference-conversions"></a>Неявные преобразования ссылочных типов

Неявные преобразования являются:

*  Из любого *reference_type* для `object` и `dynamic`.
*  Из любого *class_type* `S` к любому *class_type* `T`, в который `S` является производным от `T`.
*  Из любого *class_type* `S` к любому *interface_type* `T`, в который `S` реализует `T`.
*  Из любого *interface_type* `S` к любому *interface_type* `T`, в который `S` является производным от `T`.
*  Из *array_type* `S` с типом элемента `SE` для *array_type* `T` с типом элемента `TE`, если выполняются все следующие условия:
    * `S` и `T` различаются только по типу элементов. Другими словами `S` и `T` имеют одинаковое количество измерений.
    * Оба `SE` и `TE` являются *reference_type*s.
    * Существует и неявное ссылочное преобразование из `SE` для `TE`.
*  Из любого *array_type* для `System.Array` и он реализует интерфейсы.
*  Одномерный массив типа `S[]` для `System.Collections.Generic.IList<T>` и его базовые интерфейсы, если существует неявное преобразование идентификатора или ссылки из `S` для `T`.
*  Из любого *delegate_type* для `System.Delegate` и он реализует интерфейсы.
*  От литерала null к любому *reference_type*.
*  Из любого *reference_type* для *reference_type* `T` если он имеет неявное преобразование идентификатора или ссылки в *reference_type* `T0` и `T0` имеет преобразование удостоверения для `T`.
*  Из любого *reference_type* в интерфейсе или делегате тип `T` если он имеет неявное преобразование идентификатора или ссылки на тип интерфейса или делегата `T0` и `T0` является вариантно преобразуемым ([ Вариантное преобразование](interfaces.md#variance-conversion)) для `T`.
*  Неявные преобразования, включающие параметры типа, которые являются ссылочными типами. См. в разделе [неявные преобразования, включающие параметры типа](conversions.md#implicit-conversions-involving-type-parameters) узнать больше о неявные преобразования, включающие параметры типа.

Неявные преобразования являются такие преобразования между *reference_type*, могут быть установлены всегда выполняются успешно и не требуют проверки во время выполнения.

Преобразования ссылок, явные и неявные, никогда не изменяют ссылочный идентификатор преобразуемого объекта. Другими словами преобразование ссылки может изменить тип ссылки, он никогда не изменяет тип или значение объекта, на которую выполняется ссылка.

### <a name="boxing-conversions"></a>Упаковки-преобразования

Упаковка-преобразование позволяет *value_type* должен неявно преобразовываться к ссылочному типу. Существует преобразования-упаковки из любого *non_nullable_value_type* для `object` и `dynamic`, `System.ValueType` и в любой *interface_type* реализуется *non_ nullable_value_type*. Кроме того *enum_type* можно преобразовать в тип `System.Enum`.

Существует преобразования-упаковки из *nullable_type* к ссылочному типу, если и только если упаковка-преобразование существует базового *non_nullable_value_type* в ссылочный тип.

Тип значения имеет упаковки-преобразования к типу интерфейса `I` наличия упаковки-преобразования к типу интерфейса `I0` и `I0` имеет преобразование удостоверения для `I`.

Тип значения имеет упаковки-преобразования к типу интерфейса `I` при наличии упаковки-преобразования в тип интерфейса или делегата `I0` и `I0` является вариантно преобразуемым ([Вариантное преобразование](interfaces.md#variance-conversion)) для `I`.

Упаковка значения *non_nullable_value_type* состоит выделение экземпляра объекта и копирование *value_type* значение в этом экземпляре. Структура допускает упаковку-преобразование к типу `System.ValueType`, так как это базовый класс для всех структур ([наследования](structs.md#inheritance)).

Упаковка значения *nullable_type* продолжается следующим образом:

*  Если значение источника равно null (`HasValue` свойство имеет значение false), результатом является пустой ссылкой типа целевого объекта.
*  В противном случае результат — это ссылка на упакованное `T` созданные развертывания и упаковки исходного значения.

Упаковки-преобразования описаны далее в [осуществлять преобразования-упаковки](types.md#boxing-conversions).

### <a name="implicit-dynamic-conversions"></a>Неявные преобразования динамических типов

Существует неявное преобразование динамических из выражения типа `dynamic` к любому типу `T`. Преобразование является динамическим ([динамической привязки](expressions.md#dynamic-binding)), что означает, что неявное преобразование будет использоваться во время выполнения из типа времени выполнения выражения `T`. Если преобразование не найдено, создается исключение времени выполнения.

Обратите внимание, что это неявное преобразование противоречит рекомендации, приведенные в начале [неявные преобразования](conversions.md#implicit-conversions) неявное преобразование не должно вызывать исключение. Однако это не преобразование, но *поиск* преобразования, который вызывает исключение. Риск возникновения исключения во время выполнения присущих использование динамической привязки. Если динамическую привязку преобразования не требуется, то можно быть сначала преобразовано в `object`, а затем к требуемому типу.

Следующий пример иллюстрирует неявное динамическое преобразование:

```csharp
object o  = "object"
dynamic d = "dynamic";

string s1 = o; // Fails at compile-time -- no conversion exists
string s2 = d; // Compiles and succeeds at run-time
int i     = d; // Compiles but fails at run-time -- no conversion exists
```

Назначения, которые `s2` и `i` оба применять неявные преобразования динамических, в которой привязки операций приостанавливается до времени выполнения. Во время выполнения, неявные преобразования выполняется поиск типа во время выполнения `d`  --  `string` --в целевой тип. Обнаружено, преобразование `string` , но не к `int`.

### <a name="implicit-constant-expression-conversions"></a>Неявные преобразования выражений констант

Неявные преобразования выражений констант обеспечивают следующие преобразования:

*  Объект *constant_expression* ([константные выражения](expressions.md#constant-expressions)) типа `int` можно преобразовать в тип `sbyte`, `byte`, `short`, `ushort`, `uint`, или `ulong`, если значение *constant_expression* находится в диапазоне конечного типа.
*  Объект *constant_expression* типа `long` можно преобразовать в тип `ulong`, если значение *constant_expression* не отрицательна.

### <a name="implicit-conversions-involving-type-parameters"></a>Неявные преобразования, включающие параметры типа

Существуют следующие неявные преобразования для заданного параметра типа `T`:

*  Из `T` для его эффективным базовым классом `C`, из `T` любой базовый класс `C`и из `T` любой интерфейс, реализуемый `C`. Если время выполнения, AT `T` является типом значения, преобразование выполняется как упаковка-преобразование. В противном случае преобразование выполняется как неявное преобразование ссылок или преобразование идентификации.
*  Из `T` к типу интерфейса `I` в `T`настройки и эффективный интерфейс и из `T` любой базовый интерфейс `I`. Если время выполнения, AT `T` является типом значения, преобразование выполняется как упаковка-преобразование. В противном случае преобразование выполняется как неявное преобразование ссылок или преобразование идентификации.
*  Из `T` к параметру типа `U`, в который `T` зависит от `U` ([ограничения параметров типа](classes.md#type-parameter-constraints)). Если время выполнения, AT `U` является типом значения, затем `T` и `U` обязательно относятся к одному типу и не выполняют никаких преобразований. В противном случае, если `T` является типом значения, преобразование выполняется как упаковка-преобразование. В противном случае преобразование выполняется как неявное преобразование ссылок или преобразование идентификации.
*  От литерала null в `T`, в который `T` известно, быть ссылочным типом.
*  Из `T` к ссылочному типу `I` если он имеет неявное преобразование к ссылочному типу `S0` и `S0` имеет преобразование удостоверения для `S`. Во время выполнения преобразование выполняется так же, как преобразование в `S0`.
*  Из `T` к типу интерфейса `I` если он имеет неявное преобразование к типу интерфейса или делегата `I0` и `I0` является вариантно преобразуемым к `I` ([Вариантное преобразование](interfaces.md#variance-conversion) ). Если время выполнения, AT `T` является типом значения, преобразование выполняется как упаковка-преобразование. В противном случае преобразование выполняется как неявное преобразование ссылок или преобразование идентификации.

Если `T` известно, быть ссылочным типом ([ограничения параметров типа](classes.md#type-parameter-constraints)), описанные выше преобразования классифицируются как неявные преобразования ссылочных типов ([неявные преобразования ссылочных типов](conversions.md#implicit-reference-conversions)). Если `T` является не известно, быть ссылочным типом, описанные выше преобразования классифицируются как осуществлять преобразования-упаковки ([осуществлять преобразования-упаковки](conversions.md#boxing-conversions)).

### <a name="user-defined-implicit-conversions"></a>Определяемые пользователем неявные преобразования

Неявное преобразование, определяемые пользователем состоит из необязательно стандартный неявное преобразование, следуют выполнения оператора определяемые пользователем неявные преобразования, следуют другой необязательно стандартное неявное преобразование. Точные правила вычисления определяемые пользователем неявные преобразования описаны в [обработку определяемые пользователем неявные преобразования](conversions.md#processing-of-user-defined-implicit-conversions).

### <a name="anonymous-function-conversions-and-method-group-conversions"></a>Преобразования анонимных функций и преобразования групп методов

Анонимные функции групп методов имеют сами по себе, но может быть неявно преобразован к типу делегата или типы дерева выражений. Преобразования анонимных функций описаны более подробно в [преобразования анонимных функций](conversions.md#anonymous-function-conversions) и преобразования групп методов в [преобразования групп методов](conversions.md#method-group-conversions).

## <a name="explicit-conversions"></a>Явные преобразования

Явные преобразования относятся следующие преобразования:

*  Все неявные преобразования.
*  Явные числовые преобразования.
*  Явные преобразования перечисляемых типов.
*  Явные преобразования типов, допускающий значение NULL.
*  Явные преобразования ссылочных типов.
*  Явные преобразования типов интерфейса.
*  Распаковки-преобразования.
*  Явные преобразования динамических
*  Пользовательские явные преобразования.

Явные преобразования могут произойти в выражения приведения ([выражения приведения](expressions.md#cast-expressions)).

Набор явные преобразования включает все неявные преобразования. Это означает, что разрешены избыточные выражения приведения.

Явные преобразования типов, которые не являются неявные преобразования, преобразования, которые невозможно подтвердить всегда выполняются успешно, преобразования, которые заведомо привести к потере данных и преобразования в областях типов, существенно различающихся для явной позволил компании merit нотация.

### <a name="explicit-numeric-conversions"></a>Явные числовые преобразования

Явные числовые преобразования преобразовывают из *numeric_type* в другой *numeric_type* для которого неявное числовое преобразование ([неявных числовых преобразований](conversions.md#implicit-numeric-conversions)) еще не существует:

*  Из `sbyte` для `byte`, `ushort`, `uint`, `ulong`, или `char`.
*  Из `byte` для `sbyte` и `char`.
*  Из `short` для `sbyte`, `byte`, `ushort`, `uint`, `ulong`, или `char`.
*  Из `ushort` для `sbyte`, `byte`, `short`, или `char`.
*  Из `int` для `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, или `char`.
*  Из `uint` для `sbyte`, `byte`, `short`, `ushort`, `int`, или `char`.
*  Из `long` для `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, или `char`.
*  Из `ulong` для `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, или `char`.
*  Из `char` для `sbyte`, `byte`, или `short`.
*  Из `float` для `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, или `decimal`.
*  Из `double` для `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, или `decimal`.
*  Из `decimal` для `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, или `double`.

Так как явные преобразования всех явных и неявных числовых преобразований, всегда есть возможность для преобразования из любых *numeric_type* любым другим *numeric_type* using (выражения приведения [Выражения приведения](expressions.md#cast-expressions)).

Явные числовые преобразования привести к потере данных или привести исключения. Явное числовое преобразование обрабатывается следующим образом:

*  Для преобразования из целого типа в другой целочисленный тип, выполнения зависит от контекста проверки переполнения ([операторы checked и unchecked](expressions.md#the-checked-and-unchecked-operators)) в котором оно выполняется:
    * В `checked` контекста, преобразование выполняется успешно, если значение исходного операнда находится в диапазоне конечного типа, но создает `System.OverflowException` Если значение исходного операнда находится вне диапазона целевого типа.
    * В `unchecked` контекст, преобразование всегда завершается успешно и выполняется следующим образом.
        * Если исходный тип больше целевого, исходное значение усекается путем отбрасывания его "лишних" самых значимых битов. Результат затем обрабатывается как значение целевого типа.
        * Если исходный тип меньше целевого, исходное значение дополняется знаками или нулями, чтобы иметь тот же размер, что и целевой тип. Знаки добавляются, если исходный тип имеет знак. Если у исходного типа нет знака, добавляются нули. Результат затем обрабатывается как значение целевого типа.
        * Если исходный тип совпадает по размеру с целевым, исходное значение обрабатывается как значение целевого типа.
*  Для преобразования из `decimal` в целочисленный тип, исходное значение округляется в сторону нуля до ближайшего целого значения, и которое становится результатом преобразования. Если полученное целое значение находится вне диапазона целевого типа, `System.OverflowException` возникает исключение.
*  Для преобразования из `float` или `double` в целочисленный тип, выполнения зависит от контекста проверки переполнения ([операторы checked и unchecked](expressions.md#the-checked-and-unchecked-operators)) в котором оно выполняется:
    * В `checked` контекста, преобразование продолжается следующим образом:
        * Если значение операнда NaN или infinite, `System.OverflowException` возникает исключение.
        * В противном случае исходного операнда округляется в сторону нуля до ближайшего целого значения. Если это целочисленное значение находится в диапазоне конечного типа это значение является результатом преобразования.
        * В противном случае возникает исключение `System.OverflowException`.
    * В `unchecked` контекст, преобразование всегда завершается успешно и выполняется следующим образом.
        * Если значение операнда имеет значение NaN или бесконечным, результатом преобразования является неопределенное значение целевого типа.
        * В противном случае исходного операнда округляется в сторону нуля до ближайшего целого значения. Если это целочисленное значение находится в диапазоне конечного типа это значение является результатом преобразования.
        * В противном случае результатом преобразования является неопределенное значение целевого типа.
*  Для преобразования из `double` для `float`, `double` значение округляется до ближайшего `float` значение. Если `double` значение слишком мал для представления в виде `float`, результат становится равным нулю положительный или отрицательный нуль. Если `double` значение слишком велико для представления в виде `float`, результатом становится положительная бесконечность или отрицательная бесконечность. Если `double` значение NaN, результат также имеет значение NaN.
*  Для преобразования из `float` или `double` для `decimal`, исходное значение преобразуется в `decimal` представление и округляется до ближайшего числа после 28-го десятичного разряда, при необходимости ([десятичного типа](types.md#the-decimal-type)). Если исходное значение слишком мал для представления в виде `decimal`, результатом будет ноль. Если значение источника равно NaN, бесконечность, или слишком велико для представления в виде `decimal`, `System.OverflowException` возникает исключение.
*  Для преобразования из `decimal` для `float` или `double`, `decimal` значение округляется до ближайшего `double` или `float` значение. Это преобразование может привести к потере точности, никогда не вызывает исключение, исключение.

### <a name="explicit-enumeration-conversions"></a>Явные преобразования перечисляемых типов

Явные преобразования перечисляемых типов являются:

*  Из `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, или `decimal` для любого *enum_type*.
*  Из любого *enum_type* для `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, или `decimal`.
*  Из любого *enum_type* любым другим *enum_type*.

Явное преобразование между двумя типами обрабатывается, рассматривая все участвующие *enum_type* как базовый тип, *enum_type*и затем выполняет явный или неявный числовое преобразование результирующих типов. Например, если *enum_type* `E` с и базовый тип `int`, преобразование из `E` для `byte` обрабатывается как явное числовое преобразование ([Explicit числовые преобразования](conversions.md#explicit-numeric-conversions)) из `int` для `byte`и преобразование из `byte` для `E` обрабатывается как неявное числовое преобразование ([неявных числовых преобразований](conversions.md#implicit-numeric-conversions)) из `byte` для `int`.

### <a name="explicit-nullable-conversions"></a>Явные преобразования обнуляемых типов

***Явные преобразования обнуляемых типов*** permit предопределенные явные преобразования, которые работают с типами не поддерживающий значение NULL, также можно использовать с обнуляемых типов. Для каждого из стандартных явные преобразования, преобразование типа не поддерживающий значение NULL `S` типу, не поддерживающий значение NULL `T` ([преобразование идентификации](conversions.md#identity-conversion), [неявных числовых преобразований](conversions.md#implicit-numeric-conversions), [Неявные преобразования перечисляемых типов](conversions.md#implicit-enumeration-conversions), [явных числовых преобразований](conversions.md#explicit-numeric-conversions), и [явные преобразования перечисляемых типов](conversions.md#explicit-enumeration-conversions)), следующие допускает значения NULL преобразований:

*  Явное преобразование из `S?` для `T?`.
*  Явное преобразование из `S` для `T?`.
*  Явное преобразование из `S?` для `T`.

Вычисление допускает значения NULL преобразования на основе на преобразовании из `S` для `T` продолжается следующим образом:

*  Если преобразование допускает значения NULL из `S?` для `T?`:
    * Если значение источника равно null (`HasValue` свойство имеет значение false), возвращается значение null типа `T?`.
    * В противном случае преобразование вычисляется как развертывание из `S?` для `S`, а затем преобразовании из `S` для `T`, а затем перенос из `T` для `T?`.
*  При преобразовании допускает значения NULL из `S` для `T?`, считается, что преобразование преобразовании из `S` для `T` следуют перенос из `T` для `T?`.
*  При преобразовании допускает значения NULL из `S?` для `T`, оно вычисляется как развертывание из `S?` для `S` следуют преобразовании из `S` для `T`.

Обратите внимание, что при попытке распаковки допускающее null значение приведет к возникновению исключения, если значение `null`.

### <a name="explicit-reference-conversions"></a>Явные преобразования ссылочных типов

Ниже приведены явных преобразований.

*  Из `object` и `dynamic` любым другим *reference_type*.
*  Из любого *class_type* `S` к любому *class_type* `T`, в который `S` является базовым классом для `T`.
*  Из любого *class_type* `S` к любому *interface_type* `T`, в который `S` не запечатан и не предоставляются `S` не реализует `T`.
*  Из любого *interface_type* `S` к любому *class_type* `T`, в который `T` не запечатан и не предоставляются `T` реализует `S`.
*  Из любого *interface_type* `S` к любому *interface_type* `T`, в который `S` не является производным от `T`.
*  Из *array_type* `S` с типом элемента `SE` для *array_type* `T` с типом элемента `TE`, если выполняются все следующие условия:
    * `S` и `T` различаются только по типу элементов. Другими словами `S` и `T` имеют одинаковое количество измерений.
    * Оба `SE` и `TE` являются *reference_type*s.
    * Существует неявное преобразование из `SE` для `TE`.
*  Из `System.Array` и интерфейсы, который реализуется, чтобы любой *array_type*.
*  Одномерный массив типа `S[]` для `System.Collections.Generic.IList<T>` и его базовые интерфейсы, если существует неявное преобразование из `S` для `T`.
*  Из `System.Collections.Generic.IList<S>` и его базовых интерфейсов в тип одномерного массива `T[]`при условии, что имеется явное преобразование идентификатора или ссылки из `S` для `T`.
*  Из `System.Delegate` и интерфейсы, который реализуется, чтобы любой *delegate_type*.
*  От ссылочного типа к ссылочному типу `T` если он имеет неявное преобразование к ссылочному типу `T0` и `T0` имеет преобразование идентификации `T`.
*  От ссылочного типа в тип интерфейса или делегата `T` если он имеет неявное преобразование к типу интерфейса или делегата `T0` и либо `T0` является вариантно преобразуемым к `T` или `T` — вариантно преобразуемым к `T0` ([Вариантное преобразование](interfaces.md#variance-conversion)).
*  Из `D<S1...Sn>` для `D<T1...Tn>` где `D<X1...Xn>` является типом универсального метода-делегата, `D<S1...Sn>` несовместим с или идентичен `D<T1...Tn>`и для каждого параметра типа `Xi` из `D` содержит следующие:
    * Если `Xi` является инвариантным, затем `Si` идентична `Ti`.
    * Если `Xi` является ковариантным, то существует явное или неявное преобразование идентификатора или ссылки из `Si` для `Ti`.
    * Если `Xi` является контравариантным, затем `Si` и `Ti` могут быть одинаковыми или обе ссылки на типы.
*  Явные преобразования, включающие параметры типа, которые являются ссылочными типами. Дополнительные сведения о явных преобразованиях, включающие параметры типа, см. в разделе [явные преобразования, включающие параметры типа](conversions.md#explicit-conversions-involving-type-parameters).

Явных преобразований являются такие преобразования между ссылочными типами, которые требуют проверки времени выполнения, чтобы убедиться, что они верны.

Для преобразования явной ссылки для успешного выполнения во время выполнения, значение исходного операнда должно быть `null`, или фактический тип объекта, который ссылается исходного операнда должен быть типом, который может быть преобразован в целевой тип путем неявную ссылку преобразование ([неявные преобразования ссылочных типов](conversions.md#implicit-reference-conversions)) или упаковка-преобразование ([осуществлять преобразования-упаковки](conversions.md#boxing-conversions)). При сбое преобразования явной ссылки `System.InvalidCastException` возникает исключение.

Преобразования ссылок, явные и неявные, никогда не изменяют ссылочный идентификатор преобразуемого объекта. Другими словами преобразование ссылки может изменить тип ссылки, он никогда не изменяет тип или значение объекта, на которую выполняется ссылка.

### <a name="unboxing-conversions"></a>Распаковки-преобразования

Распаковки-преобразования позволяет ссылочного типа явно преобразовать *value_type*. Существует распаковки-преобразования из типов `object`, `dynamic` и `System.ValueType` к любому *non_nullable_value_type*и из любого *interface_type* к любому *non_ nullable_value_type* , реализующий *interface_type*. Кроме того, введите `System.Enum` могут быть распакованы в любой *enum_type*.

Существует распаковки-преобразования ссылочных типов для *nullable_type* существования распаковки-преобразования от ссылочного типа к базовому объекту *non_nullable_value_type* из  *nullable_type*.

Тип значения `S` имеет распаковки-преобразования из типа интерфейса `I` наличия распаковки-преобразования из типа интерфейса `I0` и `I0` имеет преобразование удостоверения для `I`.

Тип значения `S` имеет распаковки-преобразования из типа интерфейса `I` при наличии распаковки-преобразования из типа интерфейса или делегата `I0` и либо `I0` является вариантно преобразуемым к `I` или `I`является вариантно преобразуемым к `I0` ([Вариантное преобразование](interfaces.md#variance-conversion)).

Операция распаковки состоит из, что экземпляр объекта является упакованным значением заданного *value_type*, а затем скопировав значение из экземпляра. Распаковка-преобразование пустая ссылка для *nullable_type* null значение *nullable_type*. Структуры могут быть распакованы из типа `System.ValueType`, так как это базовый класс для всех структур ([наследования](structs.md#inheritance)).

Преобразования, распаковки-преобразования описаны далее в [преобразования, распаковки-преобразования](types.md#unboxing-conversions).

### <a name="explicit-dynamic-conversions"></a>Явные преобразования динамических

Существует явное преобразование динамических из выражения типа `dynamic` к любому типу `T`. Преобразование является динамическим ([динамической привязки](expressions.md#dynamic-binding)), что означает, что во время выполнения из типа времени выполнения выражения будет использоваться явное преобразование `T`. Если преобразование не найдено, создается исключение времени выполнения.

Если динамическую привязку преобразования не требуется, то можно быть сначала преобразовано в `object`, а затем к требуемому типу.

Предположим, что определен следующий класс:
```csharp
class C
{
    int i;

    public C(int i) { this.i = i; }

    public static explicit operator C(string s) 
    {
        return new C(int.Parse(s));
    }
}
```

В следующем примере показано явное динамическое преобразование:
```csharp
object o  = "1";
dynamic d = "2";

var c1 = (C)o; // Compiles, but explicit reference conversion fails
var c2 = (C)d; // Compiles and user defined conversion succeeds
```

Лучшее преобразование из `o` для `C` найден во время компиляции, чтобы выполнить преобразование явной ссылки. Это происходит сбой во время выполнения, так как `"1"` не является на самом деле `C`. Преобразование `d` для `C` тем не менее, как явное преобразование динамических, приостанавливается на время выполнения, где пользовательское преобразование из типа времени выполнения `d`  --  `string` --до `C` найден, и завершается успешно.

### <a name="explicit-conversions-involving-type-parameters"></a>Явные преобразования, включающие параметры типа

Существуют следующие явные преобразования для заданного параметра типа `T`:

*  От действующих базового класса `C` из `T` для `T` и от базового класса из `C` для `T`. Если время выполнения, AT `T` является типом значения, преобразование выполняется как распаковки-преобразования. В противном случае преобразование выполняется как преобразование явной ссылки или преобразование идентификации.
*  Из любой другой тип интерфейса, чтобы `T`. Если время выполнения, AT `T` является типом значения, преобразование выполняется как распаковки-преобразования. В противном случае преобразование выполняется как преобразование явной ссылки или преобразование идентификации.
*  Из `T` к любому *interface_type* `I` условии уже не существует неявное преобразование из `T` для `I`. Если время выполнения, AT `T` является типом значения, преобразование выполняется как упаковка-преобразование, а затем неявное преобразование. В противном случае преобразование выполняется как преобразование явной ссылки или преобразование идентификации.
*  От параметра типа `U` для `T`, в который `T` зависит от `U` ([ограничения параметров типа](classes.md#type-parameter-constraints)). Если время выполнения, AT `U` является типом значения, затем `T` и `U` обязательно относятся к одному типу и не выполняют никаких преобразований. В противном случае, если `T` является типом значения, преобразование выполняется как распаковки-преобразования. В противном случае преобразование выполняется как преобразование явной ссылки или преобразование идентификации.

Если `T` является известно, быть ссылочным типом, описанные выше преобразования классифицируются как явные преобразования ссылочных типов ([явные преобразования ссылочных типов](conversions.md#explicit-reference-conversions)). Если `T` является не известно, быть ссылочным типом, описанные выше преобразования классифицируются как распаковки-преобразования ([преобразования, распаковки-преобразования](conversions.md#unboxing-conversions)).

Приведенные выше правила не допускают прямого явного преобразования из безусловного параметра типа к типу без интерфейсов, которые могут быть неожиданными. Причина для этого правила — избежать путаницы и семантика таких преобразований. В качестве примера рассмотрим следующее объявление:
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)t;                // Error 
    }
}
```

Если прямое явное преобразование из `t` для `int` были разрешены, можно легко предположить, что, `X<int>.F(7)` вернет `7L`. Тем не менее это происходит, поскольку стандартные числовые преобразования применяются только в том случае, если известно, что типы числовыми во время привязки. Чтобы семантика clear, приведенном выше примере необходимо записать:
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)(object)t;        // Ok, but will only work when T is long
    }
}
```

Этот код теперь будет компилироваться но выполняемой `X<int>.F(7)` затем вызовет исключение во время выполнения, так как упакованное `int` не может быть преобразованы прямо в `long`.

### <a name="user-defined-explicit-conversions"></a>Пользовательские явные преобразования

Явное преобразование, определяемые пользователем состоит из необязательно стандартный явное преобразование, следуют выполнения оператора пользовательские явного или неявного преобразования, следуют другой необязательно стандартное явное преобразование. Точные правила вычисления пользовательские явные преобразования описаны в [обработку пользовательские явные преобразования](conversions.md#processing-of-user-defined-explicit-conversions).

## <a name="standard-conversions"></a>Стандартные преобразования

Стандартные преобразования — это предопределенные преобразования, которые могут возникать как часть определенного пользователем преобразования.

### <a name="standard-implicit-conversions"></a>Стандартные неявные преобразования

Следующие неявных преобразований классифицируются как стандартные неявные преобразования:

*  Преобразования идентификатора ([преобразование идентификации](conversions.md#identity-conversion))
*  Неявных числовых преобразований ([неявных числовых преобразований](conversions.md#implicit-numeric-conversions))
*  Неявные преобразования обнуляемых типов ([неявные преобразования обнуляемых типов](conversions.md#implicit-nullable-conversions))
*  Неявные преобразования ссылочных типов ([неявные преобразования ссылочных типов](conversions.md#implicit-reference-conversions))
*  Осуществлять преобразования-упаковки ([осуществлять преобразования-упаковки](conversions.md#boxing-conversions))
*  Неявные преобразования выражений констант ([неявные преобразования динамических](conversions.md#implicit-dynamic-conversions))
*  Неявные преобразования, включающие параметры типа ([неявные преобразования, включающие параметры типа](conversions.md#implicit-conversions-involving-type-parameters))

Стандартные неявные преобразования исключите определяемые пользователем неявные преобразования.

### <a name="standard-explicit-conversions"></a>Стандартные явные преобразования

Стандартные явного преобразования являются все стандартные неявные преобразования, а также подмножество явных преобразований, для которых существует обратные стандартные неявные преобразования. Другими словами, если стандартный неявный существует преобразование из типа `A` к типу `B`, то существует стандартное явное преобразование из типа `A` ввода `B` и от типа `B` ввода `A`.

## <a name="user-defined-conversions"></a>Заданные пользователем преобразования

C# позволяет предварительно определенных явные и неявные преобразования можно дополнить ***заданные пользователем преобразования***. Заданные пользователем преобразования вводятся, объявив операторы преобразования ([операторы преобразования](classes.md#conversion-operators)) в типах классов и структур.

### <a name="permitted-user-defined-conversions"></a>Разрешенные пользовательские преобразования

В C# допускается только определенные пользовательские преобразования для объявления. В частности это не невозможно переопределить уже существующего явного или неявного преобразования.

Для заданного исходного типа `S` и целевого типа `T`, если `S` или `T` являются обнуляемые типы позволяют `S0` и `T0` называть их базовые типы, в противном случае `S0` и `T0` являются равным `S` и `T` соответственно. Класс или структура может объявлять преобразование из типа источника `S` с целевым типом `T` только в том случае, если выполняются все следующие условия:

*  `S0` и `T0` различных типов.
*  Либо `S0` или `T0` — это тип класса или структуры, в котором происходит объявление оператора.
*  Ни `S0` , ни `T0` — *interface_type*.
*  За исключением определенных пользователем преобразований, не существует преобразования из `S` для `T` или из `T` для `S`.

Ограничения, которые применяются для определенных пользователем преобразований, рассматриваются далее в [операторы преобразования](classes.md#conversion-operators).

### <a name="lifted-conversion-operators"></a>Операторы преобразования ликвидированный

Оператор определенного пользователем преобразования, который преобразует тип значения, не допускающие значения NULL `S` типу, не поддерживающий значение NULL `T`, ***ликвидированный оператор преобразования*** существует, для преобразования из `S?` для `T?`. Этот оператор ликвидированный преобразование выполняет развертывание из `S?` для `S` следуют определенное пользователем преобразование из `S` для `T` следуют перенос из `T` для `T?`, за исключением того, что значение null с табличным значением `S?` преобразует непосредственно со значением null, в табличные значения `T?`.

Оператор преобразования ликвидированный имеет одной классификации явного или неявного как его базовый оператор определенного пользователем преобразования. Термин «определенное пользователем преобразование» применяется к использованию определяемых пользователем и ликвидируется операторы преобразования.

### <a name="evaluation-of-user-defined-conversions"></a>Вычисление пользовательские преобразования

Определенное пользователем преобразование преобразует значение из собственного ***типа источника***, чтобы другой тип с именем ***целевой тип***. Вычисление определенного пользователем преобразования ориентирована на поиск ***наиболее конкретный*** оператор определенного пользователем преобразования для отдельных исходных и целевых типов. Это определение разбивается на несколько шагов:

*  Находит набор классов и структур, из которого будет считаться определенные пользователем операторы преобразования. Этот набор состоит из исходного типа и его базовых классов и целевого типа и его базовых классов (с неявные предположения, что только классы и структуры можно объявить определяемых пользователем операторов, и у типов, не являющихся классами без базовых классов). Этот шаг, если исходный или конечный тип — в рамках *nullable_type*, их вместо него базовый тип используется.
*  Из этого набора типов определение которого определяемых пользователем и ликвидируется операторы преобразования применяются. Для оператора преобразования в силу, должна существовать возможность выполнить стандартное преобразование ([стандартные преобразования](conversions.md#standard-conversions)) из исходного типа операнда тип оператора, и она должна существовать возможность выполнить стандартное преобразование из результирующего типа оператора в целевой тип.
*  Набор применимых определяемых пользователем операторов определить, какой оператор однозначно наиболее подходящим. В общих чертах наиболее подходящий оператор является оператором типом операнда «ближайший» тип источника, а типом результат — «близко расположенные» в тип целевого объекта. Определенные пользователем операторы преобразования предпочтительнее, чем операторы ликвидированный преобразования. Точные правила определения наиболее подходящего оператора определенное пользователем преобразование определяются в следующих разделах.

После определения наиболее подходящего оператора определенное пользователем преобразование, фактическое выполнение определенного пользователем преобразования включает в себя в три этапа:

*  Во-первых Если это необходимо, выполняется стандартное преобразование из исходного типа в тип операнда оператора преобразования пользовательских или ликвидированный.
*  Затем вызывается преобразование определяемых пользователем или ликвидированный оператора для выполнения преобразования.
*  И, наконец при необходимости, выполняется стандартное преобразование из типа результата оператора преобразования пользовательских или поднятые в целевой тип.

При оценке определенное пользователем преобразование никогда не используется более одного оператора преобразования пользовательских или ликвидированный. Другими словами, преобразование из типа `S` ввода `T` сначала никогда не будет выполнена определенное пользователем преобразование из `S` для `X` , а затем выполнять определенное пользователем преобразование из `X` для `T`.

В следующих разделах предоставляется точного определения вычисления пользовательские явного или неявного преобразования. Условные обозначения использовать следующие термины:

*  Если стандартное неявное преобразование ([стандартные неявные преобразования](conversions.md#standard-implicit-conversions)) из типа `A` к типу `B`и если ни один из `A` , ни `B` являются *interface_type*s, затем `A` считается ***, охватываемого*** `B`, и `B` говорят, что ***encompass*** `A`.
*  ***Наиболее включающий тип*** в набор типов является один тип, который включает все остальные типы в наборе. Если ни один тип включает все остальные типы, набор имеет тип, не включающим. Более интуитивно понятно, включающим тип является типом «наибольшее» в наборе — один тип, к которому каждый из других типов может быть неявно преобразован.
*  ***Наиболее охватываемого типа*** в набор типов является один тип, который охватывается всех других типов в наборе. Если ни один тип охватывается всех других типов, а затем наборе нет наиболее охватываемого типа. Более интуитивно понятно, включаемый тип является типом «наименьшее» в наборе — один тип, который может быть неявно преобразован к каждому из других типов.

### <a name="processing-of-user-defined-implicit-conversions"></a>Обработка определяемые пользователем неявные преобразования

Неявное преобразование из типа, определяемого пользователем `S` ввода `T` обрабатывается следующим образом:

*  Определения типов `S0` и `T0`. Если `S` или `T` , допускающих значение NULL типов `S0` и `T0` являются их базовые типы, в противном случае `S0` и `T0` равны `S` и `T` соответственно.
*  Найти набор типов, `D`, из какой определенное пользователем преобразование будет считаться операторы. Этот набор состоит из `S0` (если `S0` — это класс или структура), базовые классы для `S0` (если `S0` — это класс), и `T0` (если `T0` — это класс или структура).
*  Найти набор применимых определяемых пользователем и ликвидированный операторов преобразования, `U`. Этот набор состоит из определяемых пользователем и ликвидированный неявное преобразование операторы, объявленные в классах или структурах в `D` , преобразование из типа включающий `S` к типу, охватываемого `T`. Если `U` является пустым, преобразование не определено и возникает ошибка времени компиляции.
*  Найти наиболее конкретный тип источника, `SX`, операторов в `U`:
    * Если какие-либо из операторов в `U` преобразования из `S`, затем `SX` является `S`.
    * В противном случае `SX` является типом, включаемый в объединенном наборе исходных типов операторов в `U`. Если несколько включаемых не удается найти тип, то преобразование неоднозначно и возникает ошибка времени компиляции.
*  Найти наиболее конкретный конечный тип `TX`, операторов в `U`:
    * Если какие-либо из операторов в `U` преобразовать `T`, затем `TX` является `T`.
    * В противном случае `TX` наиболее включающий тип в объединенном наборе конечных типов операторов в `U`. Если не удается найти ровно один тип наиболее охватывающий, затем преобразование неоднозначно и возникает ошибка во время компиляции.
*  Найти наиболее подходящего оператора преобразования:
    * Если `U` содержит ровно один оператор определенного пользователем преобразования, который преобразует `SX` для `TX`, то это наиболее подходящего оператора преобразования.
    * В противном случае, если `U` содержит ровно один оператор ликвидированный преобразования, который преобразует `SX` для `TX`, то это наиболее подходящего оператора преобразования.
    * В противном случае преобразование неоднозначно и возникает ошибка времени компиляции.
*  Наконец примените преобразование:
    * Если `S` не `SX`, затем стандартное неявное преобразование из `S` для `SX` выполняется.
    * Наиболее подходящего оператора преобразования вызывается для преобразования из `SX` для `TX`.
    * Если `TX` не `T`, затем стандартное неявное преобразование из `TX` для `T` выполняется.

### <a name="processing-of-user-defined-explicit-conversions"></a>Обработка пользовательские явные преобразования

Явное преобразование из типа, определяемого пользователем `S` ввода `T` обрабатывается следующим образом:

*  Определения типов `S0` и `T0`. Если `S` или `T` , допускающих значение NULL типов `S0` и `T0` являются их базовые типы, в противном случае `S0` и `T0` равны `S` и `T` соответственно.
*  Найти набор типов, `D`, из какой определенное пользователем преобразование будет считаться операторы. Этот набор состоит из `S0` (если `S0` — это класс или структура), базовые классы для `S0` (если `S0` — это класс), `T0` (если `T0` — это класс или структура) и базовые классы для `T0` (если `T0`— это класс).
*  Найти набор применимых определяемых пользователем и ликвидированный операторов преобразования, `U`. Этот набор состоит из определяемых пользователем и ликвидированный неявные или операторы явного преобразования, объявленные классов или структур в `D` , преобразование из типа которая объединяет в себе или включенные в `S` типу, которая объединяет в себе или включенные в `T`. Если `U` является пустым, преобразование не определено и возникает ошибка времени компиляции.
*  Найти наиболее конкретный тип источника, `SX`, операторов в `U`:
    * Если какие-либо из операторов в `U` преобразования из `S`, затем `SX` является `S`.
    * В противном случае, если любой из операторов в `U` преобразования из типов, охватывающих `S`, затем `SX` является типом, включаемый в объединенном наборе исходных типов этих операторов. Если не включаемый тип может быть найден, а затем преобразование неоднозначно и возникает ошибка во время компиляции.
    * В противном случае `SX` наиболее включающий тип в объединенном наборе исходных типов операторов в `U`. Если не удается найти ровно один тип наиболее охватывающий, затем преобразование неоднозначно и возникает ошибка во время компиляции.
*  Найти наиболее конкретный конечный тип `TX`, операторов в `U`:
    * Если какие-либо из операторов в `U` преобразовать `T`, затем `TX` является `T`.
    * В противном случае, если любой из операторов в `U` преобразование в типы, которые охватываются `T`, затем `TX` наиболее включающий тип в объединенном наборе конечных типов этих операторов. Если не удается найти ровно один тип наиболее охватывающий, затем преобразование неоднозначно и возникает ошибка во время компиляции.
    * В противном случае `TX` является типом, включаемый в объединенном наборе конечных типов операторов в `U`. Если не включаемый тип может быть найден, а затем преобразование неоднозначно и возникает ошибка во время компиляции.
*  Найти наиболее подходящего оператора преобразования:
    * Если `U` содержит ровно один оператор определенного пользователем преобразования, который преобразует `SX` для `TX`, то это наиболее подходящего оператора преобразования.
    * В противном случае, если `U` содержит ровно один оператор ликвидированный преобразования, который преобразует `SX` для `TX`, то это наиболее подходящего оператора преобразования.
    * В противном случае преобразование неоднозначно и возникает ошибка времени компиляции.
*  Наконец примените преобразование:
    * Если `S` не `SX`, затем стандартный явное преобразование из `S` для `SX` выполняется.
    * Наиболее подходящий оператор определенного пользователем преобразования вызывается для преобразования из `SX` для `TX`.
    * Если `TX` не `T`, затем стандартный явное преобразование из `TX` для `T` выполняется.

## <a name="anonymous-function-conversions"></a>Преобразования анонимных функций

*Anonymous_method_expression* или *lambda_expression* классифицируется как анонимная функция ([выражения анонимных функций](expressions.md#anonymous-function-expressions)). Выражение не имеет типа, но может быть неявно преобразован в совместимый тип делегата или тип дерева выражения. В частности, анонимная функция `F` совместим с типом делегата `D` указано:

*  Если `F` содержит *anonymous_function_signature*, затем `D` и `F` имеют одинаковое число параметров.
*  Если `F` не содержит *anonymous_function_signature*, затем `D` может иметь ноль или более параметров любого типа, пока не параметр `D` имеет `out` модификатор параметра.
*  Если `F` имеет список явным образом типизированной параметров, каждый параметр в `D` имеет тот же тип и модификаторы, что и соответствующий параметр в `F`.
*  Если `F` содержит список параметров в неявно типизированные, `D` не имеет `ref` или `out` параметров.
*  Если тело `F` имеет значение выражения и либо `D` имеет `void` тип возвращаемого значения или `F` является асинхронной и `D` имеет возвращаемый тип `Task`, то при каждого параметра `F` присваивается тип соответствующий параметр в `D`, тело `F` представляет собой допустимое выражение (wrt [выражения](expressions.md)) допустимы как *statement_expression* ([Операторы выражений](statements.md#expression-statements)).
*  Если тело `F` имеет блок операторов и либо `D` имеет `void` тип возвращаемого значения или `F` является асинхронной и `D` имеет возвращаемый тип `Task`, то при каждого параметра `F` присваивается тип соответствующий параметр в `D`, тело `F` представляет собой допустимую инструкцию блок (среды выполнения Windows [блоки](statements.md#blocks)) в котором не `return` инструкция указывает выражение.
*  Если тело `F` представляет собой выражение, и *либо* `F` является синхронные и `D` имеет тип возврата, отличный от void `T`, *или* `F` является асинхронной и `D` имеет тип возвращаемого значения `Task<T>`, то при каждого параметра `F` присваивается тип соответствующего параметра в `D`, тело `F` представляет собой допустимое выражение (wrt [ Выражения](expressions.md)), может быть неявно преобразован `T`.
*  Если тело `F` — это блок операторов и *либо* `F` является синхронные и `D` имеет тип возврата, отличный от void `T`, *или* `F` является асинхронной и `D` с типом возврата `Task<T>`, то при каждого параметра `F` присваивается тип соответствующего параметра в `D`, тело `F` представляет собой блок допустимую инструкцию (среды выполнения Windows [блоков ](statements.md#blocks)) с не доступную конечную точку каждый `return` инструкция указывает выражение, которое может быть неявно преобразован `T`.

Для краткости в этом разделе используется краткую форму для типов задач `Task` и `Task<T>` ([асинхронные функции](classes.md#async-functions)).

Лямбда-выражение `F` совместима с типа дерева выражений `Expression<D>` Если `F` совместим с типом делегата `D`. Обратите внимание на то, что это не относится к анонимным методам, только лямбда-выражения.

Некоторые лямбда-выражения невозможно преобразовать в типы дерева выражений: несмотря на то что преобразование *существует*, происходит сбой во время компиляции. Это является том случае, если лямбда-выражения:

*  Имеет *блок* текст
*  Содержит операторы присваивания простых и составных
*  Содержит динамически привязанное выражение.
*  Является асинхронной

В следующих примерах используется универсальный тип делегата `Func<A,R>` , представляющий функцию, которая принимает аргумент типа `A` и возвращает значение типа `R`:
```csharp
delegate R Func<A,R>(A arg);
```

В поле назначения
```csharp
Func<int,int> f1 = x => x + 1;                 // Ok

Func<int,double> f2 = x => x + 1;              // Ok

Func<double,int> f3 = x => x + 1;              // Error

Func<int, Task<int>> f4 = async x => x + 1;    // Ok
```
типы параметров и возвращаемых каждой анонимной функции определяются из типа переменной, которой присвоен анонимной функции.

Первое присваивание успешно выполняется преобразование анонимной функции в тип делегата `Func<int,int>` поскольку, если `x` присваивается тип `int`, `x+1` представляет собой допустимое выражение, которое может быть неявно преобразован в тип `int`.

Аналогичным образом, второе назначение успешно выполняется преобразование анонимной функции в тип делегата `Func<int,double>` так как результат `x+1` (типа `int`) может быть неявно преобразован в тип `double`.

Тем не менее, третий присваивания — ошибка времени компиляции, так как, когда `x` присваивается тип `double`, результат `x+1` (типа `double`) не может быть неявно преобразован в тип `int`.

Четвертый назначения успешно преобразует анонимные асинхронной функции в тип делегата `Func<int, Task<int>>` так как результат `x+1` (типа `int`) может быть неявно преобразован в тип результата `int` типа задач `Task<int>`.

Анонимные функции могут влиять на разрешение перегрузки и участвовать в определение типа. См. в разделе [функции-члены](expressions.md#function-members) для получения дополнительных сведений.

### <a name="evaluation-of-anonymous-function-conversions-to-delegate-types"></a>Вычисление анонимную функцию преобразования в типы делегатов

Преобразование анонимной функции в тип делегата создает экземпляр делегата, который ссылается на анонимной функции и (возможно, пустой) набор внешних записанных переменных, которые активны во время вычисления. При вызове делегата, выполняется Тело анонимной функции. Код в теле выполняется с помощью набора внешних записанных переменных ссылается делегат.

Список вызовов делегата, созданного на анонимную функцию, содержит одну запись. Не определены конечные объект и целевой метод делегата. В частности, не указано, является ли целевой объект делегата `null`, `this` значение включающей функции-члена или некоторому другому объекту.

Преобразование семантически идентичные анонимные функции (возможно, пустой) же набор экземпляров внешних переменных к одному типу делегата разрешены (но не требуются) для возврата один и тот же экземпляр делегата. Семантически идентичные термин используется здесь означает, что выполнение анонимных функций во всех случаях дает одинаковые результаты с одинаковыми аргументами. Это правило позволяет оптимизировать следующий код.

```csharp
delegate double Function(double x);

class Test
{
    static double[] Apply(double[] a, Function f) {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
    }

    static void F(double[] a, double[] b) {
        a = Apply(a, (double x) => Math.Sin(x));
        b = Apply(b, (double y) => Math.Sin(y));
        ...
    }
}
```

Поскольку два делегата анонимной функции имеют те же (пустой) внешних записанных переменных, а поскольку анонимные функции семантически идентичны, компилятор может делегаты могут ссылаться на один и тот же целевой метод. Действительно компилятор может возвращать одинаковые экземпляры делегата из обоих выражения анонимных функций.

### <a name="evaluation-of-anonymous-function-conversions-to-expression-tree-types"></a>Вычисление анонимной функции преобразования к типы дерева выражений

Преобразование анонимной функции в тип дерева выражения создает дерево выражений ([типы дерева выражений](types.md#expression-tree-types)). Точнее вычисление преобразования анонимной функции приводит к конструкции структуру объекта, представляющий структуру саму функцию. Фактическая структура дерева выражения, а также процесс его построения, определяется реализацией.

### <a name="implementation-example"></a>Пример реализации

В этом разделе описывается возможная реализация преобразования анонимных функций с точки зрения других конструкций C#. Описанные здесь реализация основана на принципах, используемых компилятором Microsoft C#, но он отнюдь не является обязательной и не только возможно. Он только кратко рассматривается преобразования в деревья выражений, как их точное семантика выходит за рамки этой спецификации.

В оставшейся части этого раздела приводится несколько примеров кода, содержащего анонимных функций с разными характеристиками. Для каждого примера предоставляется представлен соответствующий код, использующий только другие конструкции C#. В примерах, идентификатор `D` предполагается, что, представляющие следующий тип делегата:
```csharp
public delegate void D();
```

Самая простая форма анонимная функция — это приложения, не записывает внешние переменные:
```csharp
class Test
{
    static void F() {
        D d = () => { Console.WriteLine("test"); };
    }
}
```

Это можно преобразовать для создания экземпляра делегата, который ссылается на статический метод созданный компилятором, в который помещается код анонимной функции:
```csharp
class Test
{
    static void F() {
        D d = new D(__Method1);
    }

    static void __Method1() {
        Console.WriteLine("test");
    }
}
```

В следующем примере анонимной функции, ссылающийся на экземпляр членами `this`:
```csharp
class Test
{
    int x;

    void F() {
        D d = () => { Console.WriteLine(x); };
    }
}
```

Это может быть переведен в созданный компилятором метод экземпляра, содержащий код анонимной функции:
```csharp
class Test
{
    int x;

    void F() {
        D d = new D(__Method1);
    }

    void __Method1() {
        Console.WriteLine(x);
    }
}
```

В этом примере анонимная функция записывает локальную переменную:
```csharp
class Test
{
    void F() {
        int y = 123;
        D d = () => { Console.WriteLine(y); };
    }
}
```

Время существования локальной переменной необходимо увеличить для по крайней мере времени существования делегата анонимной функции. Это достигается путем «подъем» локальной переменной в поле класса созданный компилятором. При создании экземпляра локальной переменной ([создание экземпляров локальных переменных](expressions.md#instantiation-of-local-variables)) будет соответствовать созданию экземпляра класса компилятором и доступ к локальной переменной соответствует доступу к полю в экземпляре класс, созданный компилятором. Кроме того анонимная функция становится методом экземпляра класса, созданный компилятором:
```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.y = 123;
        D d = new D(__locals1.__Method1);
    }

    class __Locals1
    {
        public int y;

        public void __Method1() {
            Console.WriteLine(y);
        }
    }
}
```

Наконец, анонимные следующая функция захваты `this` а также двух локальных переменных с различное время существования:
```csharp
class Test
{
    int x;

    void F() {
        int y = 123;
        for (int i = 0; i < 10; i++) {
            int z = i * 2;
            D d = () => { Console.WriteLine(x + y + z); };
        }
    }
}
```

Здесь компилятором класса создается для каждой инструкции блока, в какие локальные регистрируются таким образом, что локальные переменные в различных блоков может иметь независимые время существования. Экземпляр `__Locals2`, компилятором класса для блока внутренняя инструкция содержит локальную переменную `z` и поле, которое ссылается на экземпляр `__Locals1`.  Экземпляр `__Locals1`, класс создан компилятором для блока внешняя инструкция содержит локальную переменную `y` и поле, которое ссылается на `this` внешней функции-члена. С помощью этих структур данных, его можно получить доступ все захваченные внешние переменные через экземпляр `__Local2`, и код анонимной функции таким образом могут быть реализованы как метод экземпляра этого класса.

```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.__this = this;
        __locals1.y = 123;
        for (int i = 0; i < 10; i++) {
            __Locals2 __locals2 = new __Locals2();
            __locals2.__locals1 = __locals1;
            __locals2.z = i * 2;
            D d = new D(__locals2.__Method1);
        }
    }

    class __Locals1
    {
        public Test __this;
        public int y;
    }

    class __Locals2
    {
        public __Locals1 __locals1;
        public int z;

        public void __Method1() {
            Console.WriteLine(__locals1.__this.x + __locals1.y + z);
        }
    }
}
```

Также можно использовать ту же методику, применить здесь, чтобы записать локальные переменные, при преобразовании анонимные функции в деревья выражений: ссылки на объекты, созданные компилятором, которые могут храниться в дерево выражения, и доступ к локальным переменным можно представить в виде обращается к полю на эти объекты. Преимуществом этого подхода том, что он позволяет «ликвидированный» локальные переменные, чтобы совместно использовать делегаты и деревья выражений.

## <a name="method-group-conversions"></a>Преобразования групп методов

Неявное преобразование ([неявные преобразования](conversions.md#implicit-conversions)) из группы методов существует ([классификации выражений](expressions.md#expression-classifications)) для совместимого типа делегата. Указанный тип делегата `D` и выражение `E` , классифицируется как группа методов, существует неявное преобразование из `E` для `D` Если `E` содержит по крайней мере один метод, который применяется в его нормальной формы () [Применимого члена функции](expressions.md#applicable-function-member)) на список аргументов, созданный путем использования параметров типы и модификаторы `D`, как описано в следующем разделе.

Во время компиляции приложения из группы методов преобразования `E` типу делегата `D` описан в следующем. Обратите внимание, что существование неявное преобразование из `E` для `D` не гарантирует успешное завершение компиляции приложения преобразования без ошибок.

*  Единственный метод `M` выбран соответствующий вызов метода ([вызовы методов](expressions.md#method-invocations)) формы `E(A)`, с помощью следующих изменений:
    * Список аргументов `A` — это список выражений, каждое классифицированные как переменную, а также с типом и модификатор (`ref` или `out`) соответствующего параметра в *formal_parameter_list* из `D`.
    * Методы кандидат считается являются только те методы, применимые в нормальной форме ([применимого члена функции](expressions.md#applicable-function-member)), не те, которые применимы только в расширенной форме.
*  Если алгоритм [вызовы методов](expressions.md#method-invocations) приводит к ошибке, то возникает ошибка времени компиляции. В противном случае алгоритм возвращает подходящий метод `M` с таким же числом параметров, как `D` и преобразование считается существует.
*  Выбранный метод `M` должно быть совместимо ([совместимость делегатов](delegates.md#delegate-compatibility)) с типом делегата `D`, или в противном случае возникает ошибка времени компиляции.
*  Если выбранный метод `M` является методом экземпляра, выражение экземпляра, связанное с `E` определяет целевой объект делегата.
*  Если выбранный метод M является методом расширения, который определяется посредством доступа к члену выражения экземпляра, такое выражение определяет целевой объект делегата.
*  Результатом преобразования является значение типа `D`, а именно: созданный делегат, который ссылается на выбранный метод и целевой объект.
*  Обратите внимание, что этот процесс может привести к созданию делегат для метода расширения, если алгоритм [вызовы методов](expressions.md#method-invocations) не может найти метод экземпляра, но выполняется успешно при обработке вызова `E(A)` как расширение вызов метода ([вызовы методов расширения](expressions.md#extension-method-invocations)). Созданный таким образом делегат записывает метод расширения, а также первого аргумента.

В следующем примере показано преобразования групп методов:
```csharp
delegate string D1(object o);

delegate object D2(string s);

delegate object D3();

delegate string D4(object o, params object[] a);

delegate string D5(int i);

class Test
{
    static string F(object o) {...}

    static void G() {
        D1 d1 = F;            // Ok
        D2 d2 = F;            // Ok
        D3 d3 = F;            // Error -- not applicable
        D4 d4 = F;            // Error -- not applicable in normal form
        D5 d5 = F;            // Error -- applicable but not compatible

    }
}
```

Назначение `d1` неявно преобразует группа методов `F` значение типа `D1`.

Назначение `d2` показано, как можно создать делегат метода, что имеет менее производные типы параметров (контравариантным) и более производный (ковариантным) тип возвращаемого значения.

Назначение `d3` показано как не существует преобразования, если метод не применим.

Назначение `d4` показано, как этот метод должен быть применима в обычной форме.

Назначение `d5` показано, как типы параметров и возвращаемого значения делегата и метода могут отличаться только для ссылочных типов.

Как и все другие явные и неявные преобразования, можно использовать оператор cast для явного выполнения преобразования группы методов. Таким образом пример
```csharp
object obj = new EventHandler(myDialog.OkClick);
```
может быть записан
```csharp
object obj = (EventHandler)myDialog.OkClick;
```

Метод группы может влиять на разрешение перегрузки и участвовать в определение типа. См. в разделе [функции-члены](expressions.md#function-members) для получения дополнительных сведений.

Вычисление во время выполнения преобразования группы метод продолжается следующим образом.

*  Если метод, выбранный во время компиляции является методом экземпляра, или он является методом расширения, которому происходит обращение как метод экземпляра, целевой объект делегата определяется на основе экземпляра выражения, связанного с `E`:
    * Выражение экземпляра. Если эта оценка вызывает исключение, никакие дополнительные действия выполняются.
    * Если выражение экземпляра имеет *reference_type*, значение, вычисленное выражение экземпляра, становится целевой объект. Если выбранный метод является методом экземпляра, а целевой объект — `null`, `System.NullReferenceException` возникает исключение и никакие дополнительные действия не выполняются.
    * Если выражение экземпляра имеет *value_type*, операция упаковки ([осуществлять преобразования-упаковки](types.md#boxing-conversions)) выполняется, чтобы преобразовать значение в объект, и этот объект становится целевой объект.
*  В противном случае выбранный метод является частью вызов статического метода, и целевой объект делегата является `null`.
*  Новый экземпляр типа делегата `D` выделяется. Если не хватает памяти для выделения нового экземпляра, `System.OutOfMemoryException` возникает исключение и никакие дополнительные действия не выполняются.
*  Новый экземпляр делегата инициализируется со ссылкой на метод, который был определен во время компиляции и ссылку на целевой объект вычисленный выше.
