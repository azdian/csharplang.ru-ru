# <a name="enums"></a>перечислениям;

***Тип перечисления*** является особым типом значения ([типы значений](types.md#value-types)), объявляет набор именованных констант.

Пример

```csharp
enum Color
{
    Red,
    Green,
    Blue
}
```

Объявляет тип перечисления с именем `Color` с членами `Red`, `Green`, и `Blue`.

## <a name="enum-declarations"></a>Объявления перечислений

Объявление перечисления объявляет новый тип перечисления. Объявление перечисления начинается с ключевого слова `enum`и определяет имя, специальных возможностей, базового типа и членов перечисления.

```antlr
enum_declaration
    : attributes? enum_modifier* 'enum' identifier enum_base? enum_body ';'?
    ;

enum_base
    : ':' integral_type
    ;

enum_body
    : '{' enum_member_declarations? '}'
    | '{' enum_member_declarations ',' '}'
    ;
```

Каждый тип перечисления имеет соответствующий целочисленных типов, который ***базовый тип*** типа перечисления. Этот базовый тип должен иметь возможность представлять все значения перечислителя, определенных в перечислении. Объявление перечисления может явно объявлять является базовым типом `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` или `ulong`. Обратите внимание, что `char` нельзя использовать в качестве базового типа. Объявления явно объявляет базовый тип перечисления имеет базовый тип из `int`.

Пример

```csharp
enum Color: long
{
    Red,
    Green,
    Blue
}
```

Объявляет перечисление с базовым типом `long`. Разработчик может выбрать для использования является базовым типом `long`, как показано в примере, чтобы включить использование значений, которые находятся в диапазоне от `long` , но не в диапазоне от `int`, или сохранить этот параметр в будущем.

## <a name="enum-modifiers"></a>Модификаторы перечислений

*Enum_declaration* может включать последовательность модификаторов перечисления:

```antlr
enum_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    ;
```

Это ошибка времени компиляции для один и тот же модификатор встречается несколько раз в объявлении перечисления.

Модификаторы объявления перечисления имеют одинаковое значение, что и объявление класса ([класса модификаторы](classes.md#class-modifiers)). Обратите внимание, что `abstract` и `sealed` модификаторы не разрешается использовать в объявлении перечисления. Перечисления не может быть абстрактным и не допускают наследование.

## <a name="enum-members"></a>Члены перечисления

Текст объявления типа перечисления определяет ноль или несколько членов перечисления, которые являются именованными константами перечисляемого типа. Два члена не может иметь тем же именем.

```antlr
enum_member_declarations
    : enum_member_declaration (',' enum_member_declaration)*
    ;

enum_member_declaration
    : attributes? identifier ('=' constant_expression)?
    ;
```

Каждый член перечисления имеет связанное значение константы. Тип этого значения является базовым типом для содержащего его перечисления. Постоянное значение для каждого члена перечисления должен быть в диапазоне базового типа для перечисления. Пример

```csharp
enum Color: uint
{
    Red = -1,
    Green = -2,
    Blue = -3
}
```

приводит к ошибке времени компиляции, так как значения констант `-1`, `-2`, и `-3` не находятся в диапазоне базового целочисленного типа `uint`.

Несколько членов перечисления могут совместно использовать то же связанное значение. Пример

```csharp
enum Color 
{
    Red,
    Green,
    Blue,

    Max = Blue
}
```

показано перечисление, в какие два члена перечисления-- `Blue` и `Max` --имеют же связанное значение.

Связанное значение члена перечисления назначается явно или неявно. Если объявление члена перечисления содержит *constant_expression* инициализатор, значение константного выражения, неявно преобразуется в базовый тип перечисления, является связанное значение члена перечисления. Если объявление члена перечисления не содержится инициализатор, связанное с ним значение задано, неявно, как показано ниже:

*  Если член перечисления является первым членом перечисления, объявленных в типе перечисления, связанное с ним значение равно нулю.
*  В противном случае связанное значение члена перечисления получается путем увеличения на единицу связанное значение объявленного члена перечисления. Это увеличенное значение должно быть в диапазоне значений, которые могут быть представлены в базовый тип, иначе возникает ошибка времени компиляции.

Пример

```csharp
using System;

enum Color
{
    Red,
    Green = 10,
    Blue
}

class Test
{
    static void Main() {
        Console.WriteLine(StringFromColor(Color.Red));
        Console.WriteLine(StringFromColor(Color.Green));
        Console.WriteLine(StringFromColor(Color.Blue));
    }

    static string StringFromColor(Color c) {
        switch (c) {
            case Color.Red: 
                return String.Format("Red = {0}", (int) c);

            case Color.Green:
                return String.Format("Green = {0}", (int) c);

            case Color.Blue:
                return String.Format("Blue = {0}", (int) c);

            default:
                return "Invalid color";
        }
    }
}
```

Выводит имена членов перечисления и связанных с ними значений. Результат.

```
Red = 0
Green = 10
Blue = 11
```

по следующим причинам:

*  член перечисления `Red` автоматически присваивается значение ноль (так как он не содержится инициализатор и является первым членом перечисления);
*  член перечисления `Green` явным образом присваивается значение `10`;
*  и член перечисления `Blue` автоматически присваивается значение больше, чем элемента, превышающее один.

Связанное значение члена перечисления не может, прямо или косвенно, используйте значение свой собственный связанного члена перечисления. Кроме этого ограничения зацикливания инициализаторы членов перечисления могут свободно ссылаться на другие инициализаторы членов перечисления, независимо от их положения в тексте. В инициализаторе члена перечисления значения других членов перечисления всегда обрабатываются как имеющие тип их базового типа, таким образом, чтобы приведения не обязательны, при ссылке на другие члены перечисления.

Пример

```csharp
enum Circular
{
    A = B,
    B
}
```

приводит к ошибке времени компиляции, так как объявления `A` и `B` являются циклическими. `A` зависит от `B` явным образом, и `B` зависит от `A` неявно.

Члены перечисления с именем и в совершенно аналогично полям в классах с заданной областью. Областью члена перечисления является тело его содержащий тип перечисления. Внутри этой области Члены перечисления можно ссылаться по их простому имени. Из другого кода имя члена перечисления должно уточняться именем его перечисляемого типа. Члены перечисления не любой объявленный уровень доступности — члена перечисления доступен, если его содержащий тип перечисления доступен.

## <a name="the-systemenum-type"></a>Тип System.Enum

Тип `System.Enum` — это абстрактный базовый класс для всех типов перечисления (это distinct и отличается от типа базового типа перечисления) и члены, унаследованные от `System.Enum` доступны в любой тип перечисления. Упаковка-преобразование ([осуществлять преобразования-упаковки](types.md#boxing-conversions)) из любой тип перечисления для существует `System.Enum`и распаковки-преобразования ([преобразования, распаковки-преобразования](types.md#unboxing-conversions)) существует `System.Enum` в любой тип перечисления.

Обратите внимание, что `System.Enum` сам не *enum_type*. Кроме того, это *class_type* из которой все *enum_type*s являются производными. Тип `System.Enum` наследует от типа `System.ValueType` ([типа System.ValueType](types.md#the-systemvaluetype-type)), который, в свою очередь, наследует от типа `object`. Во время выполнения, значение типа `System.Enum` может быть `null` или ссылка на упакованное значение любого типа enum.

## <a name="enum-values-and-operations"></a>Значения перечислений и операции

Каждый тип перечисления определяет отдельный тип; явное преобразование ([явные преобразования перечисляемых типов](conversions.md#explicit-enumeration-conversions)) необходима для преобразования между типом enum и целочисленный тип или между двумя типами перечисления. Набор значений, которые может принимать тип перечисления не ограничивается его членами перечисления. В частности любое значение базового типа перечисления может быть приведен к типу перечисления и будет являться допустимым дискретным значением этого типа перечисления.

Члены перечисления имеют тип содержащего их перечисляемого типа (за исключением в другие инициализаторы членов перечисления: см. в разделе [члены перечисления](enums.md#enum-members)). Значение элемента перечисления, объявленного в перечисляемом типе `E` со связанным значением `v` является `(E)v`.

Для значений типов перечисления можно использовать следующие операторы: `==`, `!=`, `<`, `>`, `<=`, `>=` ([операторы сравнения перечисления](expressions.md#enumeration-comparison-operators)), двоичный файл `+` ([Оператор сложения](expressions.md#addition-operator)), двоичная `-` ([оператор вычитания](expressions.md#subtraction-operator)), `^`, `&`, `|` ([перечисления логических операторы](expressions.md#enumeration-logical-operators)), `~` ([оператор поразрядного дополнения](expressions.md#bitwise-complement-operator)), `++` и `--` ([постфиксных инкремента и декремента](expressions.md#postfix-increment-and-decrement-operators) и [ Префиксный инкремент и декремент операторы](expressions.md#prefix-increment-and-decrement-operators)).

Каждый тип перечисления автоматически является производным от класса `System.Enum` (который, в свою очередь, является производным от `System.ValueType` и `object`). Таким образом унаследованные методы и свойства этого класса может использоваться для значений типа перечисления.
