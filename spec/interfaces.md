# <a name="interfaces"></a>интерфейсов,

Интерфейс определяет контракт. Класс или структура, реализующие интерфейс необходимо придерживаться этого контракта. Интерфейс может наследовать от нескольких базовых интерфейсах и класс или структура может реализовывать несколько интерфейсов.

Интерфейсы могут содержать методы, свойства, события и индексаторы. Сам интерфейс не предоставляет реализаций для членов, которые он определяет. Интерфейс лишь перечисляет члены, которые должны быть определены в классах или структурах, реализующих этот интерфейс.

## <a name="interface-declarations"></a>Объявления интерфейсов

*Interface_declaration* — *type_declaration* ([объявления типов](namespaces.md#type-declarations)), объявляет новый тип интерфейса.

```antlr
interface_declaration
    : attributes? interface_modifier* 'partial'? 'interface'
      identifier variant_type_parameter_list? interface_base?
      type_parameter_constraints_clause* interface_body ';'?
    ;
```

*Interface_declaration* состоит из необязательного набора *атрибуты* ([атрибуты](attributes.md)), а затем необязательный набор *interface_modifier*s ([модификаторы интерфейса](interfaces.md#interface-modifiers)), а затем использовать необязательный `partial` модификатор, а затем с помощью ключевого слова `interface` и *идентификатор* , которая содержит название интерфейса следуют необязательный *variant_type_parameter_list* спецификации ([списков параметров типа Variant](interfaces.md#variant-type-parameter-lists)), а затем использовать необязательный *interface_base* Спецификация ([базовые интерфейсы](interfaces.md#base-interfaces)), а затем использовать необязательный *type_parameter_constraints_clause*спецификации s ([ограничения параметров типа](classes.md#type-parameter-constraints)) , за которым следует *interface_body* ([тело интерфейса](interfaces.md#interface-body)), при необходимости, а затем точкой с запятой.

### <a name="interface-modifiers"></a>Модификаторы интерфейса

*Interface_declaration* может включать последовательность модификаторов интерфейса:

```antlr
interface_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | interface_modifier_unsafe
    ;
```

Это ошибка времени компиляции для один и тот же модификатор встречается несколько раз в объявлении интерфейса.

`new` Модификатор должен находиться на интерфейсы, определенные в классе. Он указывает, что интерфейс скрывает унаследованный член с тем же именем, как описано в разделе [Модификатор new](classes.md#the-new-modifier).

`public`, `protected`, `internal`, И `private` модификаторы определяют доступность интерфейса. В зависимости от контекста, в котором производится объявление интерфейса, могут быть разрешены только некоторые из этих модификаторов ([объявленную доступность](basic-concepts.md#declared-accessibility)).

### <a name="partial-modifier"></a>Модификатор partial

`partial` Модификатор указывает, что это *interface_declaration* является объявлением разделяемого типа. Несколько объявлений частичного интерфейса с тем же именем в едином объявлении пространства имен или типа объединяются в одно объявление интерфейса, следуя правилам указан в [разделяемых типов](classes.md#partial-types).

### <a name="variant-type-parameter-lists"></a>Списки параметров типа варианта

Списки параметров типа варианта возможна только на типы интерфейсов и делегатов. Отличие от обычного *type_parameter_list*s необязателен *variance_annotation* для каждого типа параметра.

```antlr
variant_type_parameter_list
    : '<' variant_type_parameters '>'
    ;

variant_type_parameters
    : attributes? variance_annotation? type_parameter
    | variant_type_parameters ',' attributes? variance_annotation? type_parameter
    ;

variance_annotation
    : 'in'
    | 'out'
    ;
```

Значение, если заметка дисперсия `out`, параметр типа считается ***ковариантным***. Значение, если заметка дисперсия `in`, параметр типа считается ***контравариантным***. Если ни одна заметка не дисперсия, параметр типа считается ***инвариантного***.

В примере
```csharp
interface C<out X, in Y, Z> 
{
  X M(Y y);
  Z P { get; set; }
}
```
`X` является ковариантным, `Y` является контравариантным и `Z` является инвариантным.

#### <a name="variance-safety"></a>Безопасность вариативности

Вхождение вариантные заметки в списке параметров типа ограничивает местах, где может произойти типы в объявлении типа.

Тип `T` — ***небезопасным при выводе*** Если справедливо одно из следующих условий:

*  `T` является параметром контравариантного типа
*  `T` является типом массива с типом элемента небезопасный выходных данных
*  `T` является типом интерфейса или делегата `S<A1,...,Ak>` создан на основе универсального типа `S<X1,...,Xk>` where хотя бы для одного `Ai` содержит одно из следующих:
   * `Xi` является ковариантным или инвариантным и `Ai` является небезопасным при выводе.
   * `Xi` является ковариантным или инвариантным и `Ai` является безопасным.
   
Тип `T` — ***небезопасным*** Если справедливо одно из следующих условий:

*  `T` параметр ковариантного типа
*  `T` является типом массива с типом элемента небезопасным
*  `T` является типом интерфейса или делегата `S<A1,...,Ak>` создан на основе универсального типа `S<X1,...,Xk>` where хотя бы для одного `Ai` содержит одно из следующих:
   * `Xi` является ковариантным или инвариантным и `Ai` является безопасным.
   * `Xi` является ковариантным или инвариантным и `Ai` является небезопасным при выводе.

Интуитивно понятным образом выходные данные небезопасного типа запрещено использовать в позиции вывода, и является небезопасным типом запрещена в позиции ввода.

Тип — ***безопасным при выводе*** в случае вывода unsafe, и ***безопасным*** если он не является безопасным.

#### <a name="variance-conversion"></a>Вариантное преобразование

Вариантные заметки предназначена для обеспечения менее строгую (но по-прежнему типобезопасным) для преобразования в типы интерфейсов и делегатов. К этому окончания определения неявные ([неявные преобразования](conversions.md#implicit-conversions)) и явные преобразования ([явные преобразования](conversions.md#explicit-conversions)) сделать использование понятие вариантного преобразования, который определен следующим образом:

Тип `T<A1,...,An>` является вариантно преобразуемым к типу `T<B1,...,Bn>` Если `T` тип делегата, либо интерфейс объявлен с параметрами вариантного типа `T<X1,...,Xn>`и для каждого параметра типа variant `Xi` одно из следующих содержит:

*  `Xi` является ковариантным и существует неявное преобразование идентификации или ссылки из `Ai` для `Bi`
*  `Xi` является контравариантным и неявные ссылки, или существует преобразование удостоверения из `Bi` для `Ai`
*  `Xi` неизменяемое имя и удостоверение существует преобразования из `Ai` для `Bi`

### <a name="base-interfaces"></a>Базовые интерфейсы

Интерфейс может наследовать из нуля или более типов интерфейсов, которые называются ***явные базовые интерфейсы*** интерфейса. Если интерфейс содержит один или несколько явные базовые интерфейсы, затем в объявлении этого интерфейса, идентификатор интерфейса следует двоеточие и запятую с запятыми список типов базового интерфейса.

```antlr
interface_base
    : ':' interface_type_list
    ;
```

Для интерфейса сформированного типа, явные базовые интерфейсы сформированным путем объявления явного базового интерфейса в объявлении универсального типа, замещения для каждого *параметр_типа* в базовом интерфейсе объявления, соответствующего *type_argument* сконструированного типа.

Явные базовые интерфейсы интерфейса должен быть по крайней мере такой же уровень доступности, как сам интерфейс ([ограничения доступности](basic-concepts.md#accessibility-constraints)). Например, это ошибка времени компиляции для указания `private` или `internal` интерфейс *interface_base* из `public` интерфейс.

Это ошибка времени компиляции, прямо или косвенно наследовать от себя самого интерфейса.

***Базовые интерфейсы*** интерфейса являются явные базовые интерфейсы и их базовые интерфейсы. Другими словами набор базовых интерфейсов является завершения транзитивное замыкание явные базовые интерфейсы, явные базовые интерфейсы и т. д. Интерфейс наследует все члены из его базовых интерфейсов. В примере
```csharp
interface IControl
{
    void Paint();
}

interface ITextBox: IControl
{
    void SetText(string text);
}

interface IListBox: IControl
{
    void SetItems(string[] items);
}

interface IComboBox: ITextBox, IListBox {}
```
базовые интерфейсы `IComboBox` являются `IControl`, `ITextBox`, и `IListBox`.

Другими словами `IComboBox` наследует члены `SetText` и `SetItems` производительны `Paint`.

Каждый базовый интерфейс интерфейса должен быть безопасным при выводе ([безопасность вариативности](interfaces.md#variance-safety)). Класс или структура, реализующие интерфейс, также неявно реализует все интерфейсы базового интерфейса.

### <a name="interface-body"></a>Теле интерфейса

*Interface_body* интерфейса определяет членов интерфейса.

```antlr
interface_body
    : '{' interface_member_declaration* '}'
    ;
```

## <a name="interface-members"></a>Члены интерфейса

Члены интерфейса являются члены, унаследованные от базовых интерфейсов и элементов, объявленных в самом интерфейсе.

```antlr
interface_member_declaration
    : interface_method_declaration
    | interface_property_declaration
    | interface_event_declaration
    | interface_indexer_declaration
    ;
```

Объявление интерфейса может объявлять ноль или несколько членов. Члены интерфейса должны быть методы, свойства, события и индексаторы. Интерфейс не может содержать константы, поля, операторы, конструкторы экземпляров, деструкторы или типы, а также интерфейс должен содержать статические члены любого типа.

Все члены интерфейса неявно имеют общий доступ. Это ошибка времени компиляции для объявления членов интерфейса Включение модификаторов. В частности, члены интерфейсов не могут объявляться с модификаторами `abstract`, `public`, `protected`, `internal`, `private`, `virtual`, `override`, или `static`.

Пример
```csharp
public delegate void StringListEvent(IStringList sender);

public interface IStringList
{
    void Add(string s);
    int Count { get; }
    event StringListEvent Changed;
    string this[int index] { get; set; }
}
```
объявляет интерфейс, который содержит один каждого из возможных видов членов: Метод, свойство, событие и индексатор.

*Interface_declaration* создает новую область объявления ([объявления](basic-concepts.md#declarations)) и *interface_member_declaration*s, непосредственно содержащиеся в *interface_declaration* представляют новые члены в этой области объявления. Следующие правила применяются к *interface_member_declaration*s:

*  Имя метода должно отличаться от имен всех свойств и событий, объявленных в том же интерфейсе. Кроме того, подпись ([сигнатуры и перегрузка](basic-concepts.md#signatures-and-overloading)) из метода должны отличаться от сигнатур всех других методов, объявленных в тот же интерфейс, и два метода, объявленного в тот же интерфейс, не могут иметь сигнатуры, отличаются только модификаторами `ref` и `out`.
*  Имя свойства или события должно отличаться от имен всех остальных членов, объявленных в тот же интерфейс.
*  Сигнатура индексатора должна отличаться от сигнатур любых других индексаторов, объявленных в том же интерфейсе.

Наследуемые члены интерфейса не относятся области объявления интерфейса. Таким образом интерфейс может объявлять элемент с тем же именем или сигнатурой, наследуемого члена. В этом случае элемент производного интерфейса называется скрывать член базового интерфейса. Скрытие унаследованного члена не считается ошибкой, но он приводит к компилятор выдаст предупреждение. Чтобы подавить предупреждение, необходимо включить объявление члена производного интерфейса `new` модификатор, чтобы указать, что производный член должен скрыть базовый член. Эта тема будет рассматриваться далее в [скрытие через наследование](basic-concepts.md#hiding-through-inheritance).

Если `new` модификатор включен в объявление, которое не скрывает унаследованный член, то выдается предупреждение об этом. Это предупреждение можно отключить путем удаления `new` модификатор.

Обратите внимание, что члены в классе `object` — нет, строго говоря, членами какого-либо интерфейса ([члены интерфейса](interfaces.md#interface-members)). Тем не менее элементы в классе `object` доступны через поиск члена в любой другой тип интерфейса ([поиск члена](expressions.md#member-lookup)).

### <a name="interface-methods"></a>Методы интерфейса

Методы интерфейса объявляются с помощью *interface_method_declaration*s:

```antlr
interface_method_declaration
    : attributes? 'new'? return_type identifier type_parameter_list
      '(' formal_parameter_list? ')' type_parameter_constraints_clause* ';'
    ;
```

*Атрибуты*, *return_type*, *идентификатор*, и *formal_parameter_list* объявления метода интерфейса с одинаковыми Это означает, что и объявление метода в классе ([методы](classes.md#methods)). В объявлении метода интерфейса не разрешается указывать тело метода и объявление таким образом всегда заканчивается точкой с запятой.

Каждый тип формальный параметр метода интерфейса должен быть безопасным ([безопасность вариативности](interfaces.md#variance-safety)), и тип возвращаемого значения должен быть либо `void` или типизированные выходные данные. Кроме того каждый ограничение типа класса, ограничение типа интерфейса и ограничения параметра типа в любой тип параметра метода, должен быть безопасным.

Эти правила гарантируют, что все ковариантные или контравариантные использования интерфейса остается строго типизированным. Например, примененная к объекту директива
```csharp
interface I<out T> { void M<U>() where U : T; }
```
не допускается из-за использования `T` как ограничения параметра типа на `U` не является безопасным.

Это ограничение не имели место возможно нарушение безопасности типа следующим образом:
```csharp
class B {}
class D : B{}
class E : B {}
class C : I<D> { public void M<U>() {...} }
...
I<B> b = new C();
b.M<E>();
```
Это вызов `C.M<E>`. Но, что требует вызова `E` являются производными от `D`, поэтому здесь ради безопасности типов.

### <a name="interface-properties"></a>Свойства интерфейса.

Свойства интерфейса объявляются с помощью *interface_property_declaration*s:

```antlr
interface_property_declaration
    : attributes? 'new'? type identifier '{' interface_accessors '}'
    ;

interface_accessors
    : attributes? 'get' ';'
    | attributes? 'set' ';'
    | attributes? 'get' ';' attributes? 'set' ';'
    | attributes? 'set' ';' attributes? 'get' ';'
    ;
```

*Атрибуты*, *тип*, и *идентификатор* объявлении свойства интерфейса имеют тот же смысл, что и объявление свойства в классе ([ Свойства](classes.md#properties)).

Методы доступа в объявлении свойства интерфейса соответствуют методам объявлении свойств класса ([методы доступа](classes.md#accessors)), за исключением того, что тело метода доступа всегда должен быть точкой с запятой. Таким образом методы доступа просто указывают, является ли свойство чтения и записи, только для чтения или только для записи.

Тип свойства интерфейса должен быть безопасным при выводе при наличии метода доступа get и должен быть безопасным, если имеется метод доступа set.

### <a name="interface-events"></a>События интерфейса

События интерфейса объявляются с помощью *interface_event_declaration*s:

```antlr
interface_event_declaration
    : attributes? 'new'? 'event' type identifier ';'
    ;
```

*Атрибуты*, *тип*, и *идентификатор* объявлении события интерфейса имеют тот же смысл, что и объявление события в классе ([события ](classes.md#events)).

Тип события интерфейса должен быть безопасным.

### <a name="interface-indexers"></a>Индексаторы в интерфейсах

Индексаторы интерфейса объявляются с помощью *interface_indexer_declaration*s:

```antlr
interface_indexer_declaration
    : attributes? 'new'? type 'this' '[' formal_parameter_list ']' '{' interface_accessors '}'
    ;
```

*Атрибуты*, *тип*, и *formal_parameter_list* объявлении индексатора интерфейса имеют одинаковое значение как объявление индексатора в классе ([ Индексаторы](classes.md#indexers)).

Методы доступа в объявлении индексатора интерфейса соответствуют методам объявление индексатора класса ([индексаторы](classes.md#indexers)), за исключением того, что тело метода доступа всегда должен быть точкой с запятой. Таким образом методы доступа просто указать, является ли индексатор для чтения, только для чтения или только для записи.

Все типы формальных параметров индексатора интерфейса должен быть безопасным. Кроме того любой `out` или `ref` типы формальных параметров также должен быть безопасным при выводе. Обратите внимание что даже `out` параметры, требуется ли входные данные с точки зрения, из-за ограничений базовой платформы выполнения.

Тип индексатора интерфейса должен быть безопасным при выводе при наличии метода доступа get и должен быть безопасным, если имеется метод доступа set.

### <a name="interface-member-access"></a>Доступ к членам интерфейса

Члены интерфейса осуществляется через доступ к членам ([доступ к членам](expressions.md#member-access)) и доступа к индексатору ([доступа к индексатору](expressions.md#indexer-access)) выражения формы `I.M` и `I[A]`, где `I` является типом интерфейса `M` — это метод, свойство или событие этого типа интерфейса, и `A` — список аргументов индексатора.

Для интерфейсов, которые являются строго одиночного наследования (каждый интерфейс в цепочке наследования имеет ноль или ровно один прямой базовый интерфейс), результаты поиска членов ([поиск члена](expressions.md#member-lookup)), вызов метода ([ Вызовы методов](expressions.md#method-invocations)) и доступ к индексатору ([доступа к индексатору](expressions.md#indexer-access)) правила точно не отличаются от классов и структур: Скрыть члены более производные меньше производном членов с тем же именем или сигнатурой. Тем не менее для интерфейсов множественного наследования, неоднозначности может возникнуть, когда два или более несвязанных базовые интерфейсы объявления членов с тем же именем или сигнатурой. В этом разделе приведены несколько примеров таких ситуаций. Во всех случаях явное приведение типов можно использовать для устранения неоднозначностей.

В примере
```csharp
interface IList
{
    int Count { get; set; }
}

interface ICounter
{
    void Count(int i);
}

interface IListCounter: IList, ICounter {}

class C
{
    void Test(IListCounter x) {
        x.Count(1);                  // Error
        x.Count = 1;                 // Error
        ((IList)x).Count = 1;        // Ok, invokes IList.Count.set
        ((ICounter)x).Count(1);      // Ok, invokes ICounter.Count
    }
}
```
Первые две инструкции вызывают ошибки времени компиляции, поскольку поиск члена ([поиск члена](expressions.md#member-lookup)) из `Count` в `IListCounter` является неоднозначным. Как показано в примере, неоднозначность разрешается путем приведения `x` к типу соответствующего базового интерфейса. Такого приведения имеют без затрат времени выполнения — они просто состоят из Просмотр экземпляра в виде менее производный тип во время компиляции.

В примере
```csharp
interface IInteger
{
    void Add(int i);
}

interface IDouble
{
    void Add(double d);
}

interface INumber: IInteger, IDouble {}

class C
{
    void Test(INumber n) {
        n.Add(1);                // Invokes IInteger.Add
        n.Add(1.0);              // Only IDouble.Add is applicable
        ((IInteger)n).Add(1);    // Only IInteger.Add is a candidate
        ((IDouble)n).Add(1);     // Only IDouble.Add is a candidate
    }
}
```
вызов `n.Add(1)` выбирает `IInteger.Add` путем применения правил разрешения перегрузки [разрешение перегрузки](expressions.md#overload-resolution). Аналогичным образом вызов `n.Add(1.0)` выбирает `IDouble.Add`. При вставке явные приведения, имеется только один кандидат метод и что позволяет избежать неоднозначности.

В примере
```csharp
interface IBase
{
    void F(int i);
}

interface ILeft: IBase
{
    new void F(int i);
}

interface IRight: IBase
{
    void G();
}

interface IDerived: ILeft, IRight {}

class A
{
    void Test(IDerived d) {
        d.F(1);                 // Invokes ILeft.F
        ((IBase)d).F(1);        // Invokes IBase.F
        ((ILeft)d).F(1);        // Invokes ILeft.F
        ((IRight)d).F(1);       // Invokes IBase.F
    }
}
```
`IBase.F` член спрятан `ILeft.F` член. Вызов `d.F(1)` таким образом выбирает `ILeft.F`, даже если `IBase.F` отображается не скрыт в пути доступа, который проведет через `IRight`.

Интуитивное правило скрытие в интерфейсах с множественным наследованием звучит так: Если элемент скрывается в любом пути доступа, он скрыт во всех путях доступа. Так как путь доступа из `IDerived` для `ILeft` для `IBase` скрывает `IBase.F`, элемент также скрывается в пути доступа из `IDerived` для `IRight` для `IBase`.

## <a name="fully-qualified-interface-member-names"></a>Имена членов полный интерфейс

Член интерфейса иногда указывается по его ***полное имя***. Полное имя элемента интерфейса состоит из имени интерфейса, в котором член объявлен, и точку, за которым следует имя члена. Полное имя элемента ссылается на интерфейс, в котором объявлен этот элемент. Например в объявлениях
```csharp
interface IControl
{
    void Paint();
}

interface ITextBox: IControl
{
    void SetText(string text);
}
```
полностью квалифицированное имя `Paint` — `IControl.Paint` и полное имя `SetText` является `ITextBox.SetText`.

В приведенном выше примере, это не можно будет ссылаться в `Paint` как `ITextBox.Paint`.

Если интерфейс является частью пространства имен, полное имя члена интерфейса включает в себя имя пространства имен. Пример
```csharp
namespace System
{
    public interface ICloneable
    {
        object Clone();
    }
}
```

В данном случае — полное имя `Clone` метод `System.ICloneable.Clone`.

## <a name="interface-implementations"></a>Реализации интерфейсов

Интерфейсы могут быть реализованы классами и структурами. Чтобы указать, что класс или структура непосредственно реализует интерфейс, идентификатор интерфейса включается в списке базовых классов класса или структуры. Пример:
```csharp
interface ICloneable
{
    object Clone();
}

interface IComparable
{
    int CompareTo(object other);
}

class ListEntry: ICloneable, IComparable
{
    public object Clone() {...}
    public int CompareTo(object other) {...}
}
```

Класс или структура, непосредственно реализует интерфейс также непосредственно реализует все базовые интерфейсы интерфейса неявно. Это справедливо, даже если класса или структуры не указаны явным образом все базовые интерфейсы в списке базовых классов. Пример:
```csharp
interface IControl
{
    void Paint();
}

interface ITextBox: IControl
{
    void SetText(string text);
}

class TextBox: ITextBox
{
    public void Paint() {...}
    public void SetText(string text) {...}
}
```

Здесь класс `TextBox` реализует `IControl` и `ITextBox`.

Если в классе `C` непосредственно реализует интерфейс, все классы, производные от C, также реализуют интерфейс неявно. Базовые интерфейсы, указанные в объявлении класса может быть построенный интерфейс типов ([создан типы](types.md#constructed-types)). Базовый интерфейс не может быть параметром типа сам по себе, хотя он может включать параметры типа, которые находятся в области действия. В следующем коде показано, как можно реализовать класс и расширить сконструированных типов:
```csharp
class C<U,V> {}

interface I1<V> {}

class D: C<string,int>, I1<string> {}

class E<T>: C<int,T>, I1<T> {}
```

Базовые интерфейсы, входящем в объявление универсального класса должны удовлетворять уникальность правила, описанные в [уникальность реализованных интерфейсов](interfaces.md#uniqueness-of-implemented-interfaces).

### <a name="explicit-interface-member-implementations"></a>Явные реализации члена интерфейса

Для целей реализации интерфейсов, может объявлять в классе или структуре ***явные реализации члена интерфейса***. Явная реализация члена интерфейса является объявление метода, свойства, события или индексатора, которое ссылается на имя члена, полное имя интерфейса. Пример
```csharp
interface IList<T>
{
    T[] GetElements();
}

interface IDictionary<K,V>
{
    V this[K key];
    void Add(K key, V value);
}

class List<T>: IList<T>, IDictionary<int,T>
{
    T[] IList<T>.GetElements() {...}
    T IDictionary<int,T>.this[int index] {...}
    void IDictionary<int,T>.Add(int index, T value) {...}
}
```

Здесь `IDictionary<int,T>.this` и `IDictionary<int,T>.Add` — интерфейс явной реализации членов.

В некоторых случаях имя члена интерфейса может оказаться не подходит для реализующего класса, в котором регистр члена интерфейса могут быть реализованы с помощью явная реализация члена интерфейса. Класс реализует абстракцию файла, например, скорее всего будет реализовывать `Close` функция-член, действует по освобождению ресурсов файл и реализовать `Dispose` метод `IDisposable` интерфейс, с помощью явного интерфейса реализация члена:
```csharp
interface IDisposable
{
    void Dispose();
}

class MyFile: IDisposable
{
    void IDisposable.Dispose() {
        Close();
    }

    public void Close() {
        // Do what's necessary to close the file
        System.GC.SuppressFinalize(this);
    }
}
```

Доступ к явной реализации члена интерфейса через его полное имя в вызов метода, доступ к свойству или индексатору невозможна. Явная реализация члена интерфейса может осуществляться только через экземпляр интерфейса и используется в этом случае просто по имени элемента.

Произошла ошибка во время компиляции, для явной реализации члена интерфейса включать модификаторы доступа и произошла ошибка во время компиляции, чтобы включать модификаторы `abstract`, `virtual`, `override`, или `static`.

Явные реализации члена интерфейса имеют разные уровни доступа характеристики других членов. Поскольку явные реализации члена интерфейса, никогда не доступны через их полное имя в вызове метода или доступ к свойству, они в некотором смысле закрытый. Тем не менее так как они может осуществляться через экземпляр интерфейса, они в некотором смысле также общедоступный.

Явные реализации члена интерфейса служат двум основным целям.

*  Поскольку явные реализации члена интерфейса недоступны через экземпляры класса или структуры, они позволяют реализации интерфейса должны быть исключены из открытого интерфейса класса или структуры. Это особенно полезно в том случае, если класс или структура реализует внутренний интерфейс, который не представляет интереса к потребителю этого класса или структуры.
*  Явные реализации члена интерфейса позволяют неоднозначности членов интерфейса с одинаковыми сигнатурами. Без явные реализации члена интерфейса невозможно для класса или структуры для различных реализаций интерфейсы-члены с одинаковой сигнатурой и типом возвращаемого значения, как было бы невозможно для класса или структуры любые реализации все члены интерфейса с одинаковыми сигнатурами, но разными типами возвращаемых значений.

Явная реализация члена интерфейса была допустимой класса или структуры необходимо имя интерфейса в списке базовых классов, содержащего элемент, полное доменное имя, тип и типы параметров совпадать члена явный интерфейс Реализация. Таким образом в следующем классе
```csharp
class Shape: ICloneable
{
    object ICloneable.Clone() {...}
    int IComparable.CompareTo(object other) {...}    // invalid
}
```
объявление `IComparable.CompareTo` приводит к ошибке времени компиляции, так как `IComparable` отсутствует в списке базовых классов `Shape` и не является базовым интерфейсом `ICloneable`. Аналогичным образом в объявлениях
```csharp
class Shape: ICloneable
{
    object ICloneable.Clone() {...}
}

class Ellipse: Shape
{
    object ICloneable.Clone() {...}    // invalid
}
```
объявление `ICloneable.Clone` в `Ellipse` приводит к ошибке времени компиляции, так как `ICloneable` явно не указан в списке базовых классов `Ellipse`.

Полное имя члена интерфейса должен ссылаться на интерфейс, в котором был объявлен член. Таким образом в объявлениях
```csharp
interface IControl
{
    void Paint();
}

interface ITextBox: IControl
{
    void SetText(string text);
}

class TextBox: ITextBox
{
    void IControl.Paint() {...}
    void ITextBox.SetText(string text) {...}
}
```
Явная реализация члена интерфейса из `Paint` должно быть записано как `IControl.Paint`.

### <a name="uniqueness-of-implemented-interfaces"></a>Уникальность реализованных интерфейсов

Интерфейсы, реализованные в объявлении универсального типа должны оставаться уникальными для всех возможных сконструированных типов. Без этого правило было бы невозможно определить правильный метод для вызова для определенных сконструированных типов. Предположим, например, объявление универсального класса может иметь следующий вид:
```csharp
interface I<T>
{
    void F();
}

class X<U,V>: I<U>, I<V>                    // Error: I<U> and I<V> conflict
{
    void I<U>.F() {...}
    void I<V>.F() {...}
}
```

Были это разрешено, было бы невозможно определить, какой код должен выполняться в следующем случае:
```csharp
I<int> x = new X<int,int>();
x.F();
```

Для определения допустимости интерфейс список объявление универсального типа, выполняются следующие действия:

*  Позвольте `L` быть список интерфейсов, непосредственно указывается в объявлении интерфейса, структуры или универсальный класс `C`.
*  Добавить `L` любые базовые интерфейсы, которые уже интерфейсов `L`.
*  Удалить все повторяющиеся значения из `L`.
*  Если какой-либо возможной сконструированный тип, созданный из `C` после замены аргументов типа в `L`, вызвать два интерфейса в `L` идентичными, то объявление `C` является недопустимым. Ограничение объявления не учитываются при определении всех возможных сконструированных типов.

В объявлении класса `X` выше списке интерфейсов `L` состоит из `I<U>` и `I<V>`. Объявление является недопустимым, поскольку любой сконструированного типа с `U` и `V` имеют одинаковый тип вызовет эти два интерфейса будут иметь одинаковый тип.

Это возможно, интерфейсы, находящиеся на разных уровнях наследования для объединения:
```csharp
interface I<T>
{
    void F();
}

class Base<U>: I<U>
{
    void I<U>.F() {...}
}

class Derived<U,V>: Base<U>, I<V>    // Ok
{
    void I<V>.F() {...}
}
```

Этот код является допустимым, даже если `Derived<U,V>` реализует `I<U>` и `I<V>`. Код
```csharp
I<int> x = new Derived<int,int>();
x.F();
```
вызывает метод в `Derived`, так как `Derived<int,int>` фактически выполняет `I<int>` ([повторной реализации интерфейса](interfaces.md#interface-re-implementation)).

### <a name="implementation-of-generic-methods"></a>Реализация универсальных методов

Если универсальный метод неявно реализует метод интерфейса, ограничения, заданные для каждого параметра типа метода должны быть эквивалентными в обоих объявлениях (после любой другой тип интерфейса параметры заменяются с соответствующими аргументами типа), где метод параметры типа определяются порядковые, слева направо.

Если универсальный метод явным образом реализует метод интерфейса, однако нет ограничения разрешены в метод реализации. Вместо этого ограничения, унаследованные от метода интерфейса

```csharp
interface I<A,B,C>
{
    void F<T>(T t) where T: A;
    void G<T>(T t) where T: B;
    void H<T>(T t) where T: C;
}

class C: I<object,C,string>
{
    public void F<T>(T t) {...}                    // Ok
    public void G<T>(T t) where T: C {...}         // Ok
    public void H<T>(T t) where T: string {...}    // Error
}
```

Метод `C.F<T>` реализует неявно `I<object,C,string>.F<T>`. В этом случае `C.F<T>` не требуется (и не допускается) указывать ограничение `T:object` поскольку `object` неявное ограничение для всех параметров типа. Метод `C.G<T>` реализует неявно `I<object,C,string>.G<T>` из-за ограничений соответствия строкам в интерфейсе после замены параметров типа интерфейса с соответствующими аргументами типа. Ограничение для метода `C.H<T>` является ошибкой, так как запечатанные типы (`string` в данном случае) нельзя использовать в качестве ограничения. Отсутствие ограничения также приведет к ошибке, так как ограничения неявных реализациях метода интерфейса должны совпадать. Таким образом, вы не сможете неявно реализовать `I<object,C,string>.H<T>`. Этот метод интерфейса можно реализовать только с помощью явной реализации члена интерфейса:
```csharp
class C: I<object,C,string>
{
    ...

    public void H<U>(U u) where U: class {...}

    void I<object,C,string>.H<T>(T t) {
        string s = t;    // Ok
        H<T>(t);
    }
}
```

В этом примере явная реализация члена интерфейса вызывает открытый метод с применением более мягких ограничений. Обратите внимание, что назначение из `t` для `s` действителен с момента `T` наследует ограничение `T:string`, несмотря на то, что это ограничение не указано в исходном коде.

### <a name="interface-mapping"></a>Сопоставление интерфейса

Класс или структура должны позволяют реализовывать все члены интерфейсов, которые перечислены в списке базовых классов класса или структуры. Процесс обнаружения реализации члена интерфейса в реализующем классе или структуре называется ***сопоставление интерфейса***.

Сопоставление интерфейса для класса или структуры `C` находит реализацию для каждого из интерфейсов, указанных в списке базовых классов элементов `C`. Реализация конкретного члена интерфейса `I.M`, где `I` — это интерфейс, в котором член `M` объявляется, определяется путем проверки каждого класса или структуры `S`, начиная с `C` и Повторение для каждого последующего базового класса из `C`, пока не находится соответствия:

*  Если `S` содержит декларацию явная реализация члена интерфейса, соответствующий `I` и `M`, а затем этот член является реализация `I.M`.
*  В противном случае, если `S` содержит объявление открытого члена статическим, который соответствует `M`, а затем этот член является реализация `I.M`. Если более чем один член совпадений, он не указан какой член является реализацией `I.M`. Такая ситуация возможна только в том случае, если `S` является сконструированным типом, где два члена, как объявлено в универсальном типе, иметь разные сигнатуры, но аргументы типа делают их подписи идентичными.

Ошибка времени компиляции возникает, если реализации не удалось найти для всех элементов, указанных в списке базовых классов из всех интерфейсов `C`. Обратите внимание на то, что члены интерфейса содержат члены, унаследованные от базовых интерфейсов.

Для целей интерфейс сопоставления, член класса `A` соответствует член интерфейса `B` при:

*  `A` и `B` методов, и имя, тип, и список формальных параметров `A` и `B` идентичны.
*  `A` и `B` только свойства, имя и тип `A` и `B` идентичны, и `A` имеет те же методы доступа как `B` (`A` может иметь дополнительные методы доступа, если это не явный интерфейс реализация члена).
*  `A` и `B` события и имя и тип `A` и `B` идентичны.
*  `A` и `B` , индексаторы, тип и список формальных параметров `A` и `B` идентичны, и `A` имеет те же методы доступа как `B` (`A` может иметь дополнительные методы доступа, если это не Явная реализация члена интерфейса).

Ниже приведены важные последствия алгоритм сопоставления интерфейса.

*  При определении члена класса или структуры, который реализует член интерфейса, явные реализации члена интерфейса имеют приоритет над другие члены в том же классе или структуре.
*  Не являющиеся открытыми, ни статические члены участвовать в сопоставление интерфейса.

В примере
```csharp
interface ICloneable
{
    object Clone();
}

class C: ICloneable
{
    object ICloneable.Clone() {...}
    public object Clone() {...}
}
```
`ICloneable.Clone` членом `C` становится реализация `Clone` в `ICloneable` Поскольку явные реализации члена интерфейса имеют приоритет над другими участниками.

Если класс или структура реализует два или большее число интерфейсов содержит член с тем же именем, типом и типы параметров, можно сопоставить каждый из таких членов интерфейса один член класса или структуры. Пример
```csharp
interface IControl
{
    void Paint();
}

interface IForm
{
    void Paint();
}

class Page: IControl, IForm
{
    public void Paint() {...}
}
```

Здесь `Paint` методы как `IControl` и `IForm` сопоставляются со `Paint` метод в `Page`. Это безусловно также могут существовать отдельные явные реализации члена интерфейса для двух методов.

Если класс или структура реализует интерфейс, который содержит скрытые элементы, то некоторые члены обязательно должен быть реализован через явные реализации члена интерфейса. Пример
```csharp
interface IBase
{
    int P { get; }
}

interface IDerived: IBase
{
    new int P();
}
```

Реализация этого интерфейса требуется по крайней мере один явная реализация члена интерфейса и может принимать одно из следующих форм
```csharp
class C: IDerived
{
    int IBase.P { get {...} }
    int IDerived.P() {...}
}

class C: IDerived
{
    public int P { get {...} }
    int IDerived.P() {...}
}

class C: IDerived
{
    int IBase.P { get {...} }
    public int P() {...}
}
```

Если класс реализует несколько интерфейсов, которые имеют общий базовый интерфейс, может существовать только одна реализация базового интерфейса. В примере
```csharp
interface IControl
{
    void Paint();
}

interface ITextBox: IControl
{
    void SetText(string text);
}

interface IListBox: IControl
{
    void SetItems(string[] items);
}

class ComboBox: IControl, ITextBox, IListBox
{
    void IControl.Paint() {...}
    void ITextBox.SetText(string text) {...}
    void IListBox.SetItems(string[] items) {...}
}
```
Невозможно иметь отдельные реализации для `IControl` с именем в списке базовых классов, `IControl` унаследованы `ITextBox`и `IControl` унаследованы `IListBox`. Действительно нет понятия отдельные удостоверения для этих интерфейсов. Вместо этого реализации `ITextBox` и `IListBox` реализована из `IControl`, и `ComboBox` считается просто реализовать три интерфейса `IControl`, `ITextBox`, и `IListBox`.

Члены базового класса участвовать в сопоставлении интерфейсов. В примере
```csharp
interface Interface1
{
    void F();
}

class Class1
{
    public void F() {}
    public void G() {}
}

class Class2: Class1, Interface1
{
    new public void G() {}
}
```
метод `F` в `Class1` используется в `Class2`в реализации `Interface1`.

### <a name="interface-implementation-inheritance"></a>Реализация наследования интерфейса

Класс наследует все реализации интерфейса, предоставляемые его базовых классов.

Без явно ***каждый раз реализовывать*** интерфейс, производном классе невозможно каким-либо образом изменить интерфейс сопоставления, он наследует из его базовых классов. Например в объявлениях
```csharp
interface IControl
{
    void Paint();
}

class Control: IControl
{
    public void Paint() {...}
}

class TextBox: Control
{
    new public void Paint() {...}
}
```
`Paint` метод в `TextBox` скрывает `Paint` метод в `Control`, но его не удалось изменить сопоставление `Control.Paint` на `IControl.Paint`и вызовы `Paint` через класс экземпляры и экземпляры интерфейса будут иметь следующие последствия
```csharp
Control c = new Control();
TextBox t = new TextBox();
IControl ic = c;
IControl it = t;
c.Paint();            // invokes Control.Paint();
t.Paint();            // invokes TextBox.Paint();
ic.Paint();           // invokes Control.Paint();
it.Paint();           // invokes Control.Paint();
```

Тем не менее при сопоставлении метода интерфейса виртуального метода в классе, производных классах переопределить виртуальный метод и изменить реализацию интерфейса. Например переопределения приведенных выше объявлений на
```csharp
interface IControl
{
    void Paint();
}

class Control: IControl
{
    public virtual void Paint() {...}
}

class TextBox: Control
{
    public override void Paint() {...}
}
```
Теперь будет наблюдаться следующие эффекты
```csharp
Control c = new Control();
TextBox t = new TextBox();
IControl ic = c;
IControl it = t;
c.Paint();            // invokes Control.Paint();
t.Paint();            // invokes TextBox.Paint();
ic.Paint();           // invokes Control.Paint();
it.Paint();           // invokes TextBox.Paint();
```

Поскольку явные реализации члена интерфейса не могут объявляться как виртуальной, не можно переопределить явная реализация члена интерфейса. Тем не менее он идеально подходит для явной реализации члена интерфейса вызывать другой метод, и что другой метод может быть объявлен виртуальным, что позволяет производным классам переопределять его. Пример
```csharp
interface IControl
{
    void Paint();
}

class Control: IControl
{
    void IControl.Paint() { PaintControl(); }
    protected virtual void PaintControl() {...}
}

class TextBox: Control
{
    protected override void PaintControl() {...}
}
```

Здесь, классы, производные от `Control` можно specialize реализация `IControl.Paint` путем переопределения `PaintControl` метод.

### <a name="interface-re-implementation"></a>Повторная реализация интерфейса

Класс, наследующий реализацию интерфейса разрешено ***повторно реализовать*** интерфейс, включив его в списке базовых классов.

Повторная реализация интерфейса работает точно так же интерфейс сопоставления как начальная реализация интерфейса. Таким образом сопоставление наследуемого интерфейса не влияет на сопоставление интерфейса установить в повторной реализации интерфейса. Например в объявлениях
```csharp
interface IControl
{
    void Paint();
}

class Control: IControl
{
    void IControl.Paint() {...}
}

class MyControl: Control, IControl
{
    public void Paint() {}
}
```
тот факт, `Control` сопоставляет `IControl.Paint` на `Control.IControl.Paint` не влияет на повторная реализация в `MyControl`, которое соответствует `IControl.Paint` на `MyControl.Paint`.

Унаследованные объявления открытых членов и член наследуемого интерфейса явные объявления участвовать в процессе сопоставления интерфейс повторно реализованных интерфейсов. Пример
```csharp
interface IMethods
{
    void F();
    void G();
    void H();
    void I();
}

class Base: IMethods
{
    void IMethods.F() {}
    void IMethods.G() {}
    public void H() {}
    public void I() {}
}

class Derived: Base, IMethods
{
    public void F() {}
    void IMethods.H() {}
}
```

В данном случае — реализация `IMethods` в `Derived` сопоставляет методы интерфейса `Derived.F`, `Base.IMethods.G`, `Derived.IMethods.H`, и `Base.I`.

Когда класс реализует интерфейс, он неявно также реализует все базовые интерфейсы этого интерфейса. Аналогично, повторная реализация интерфейса является также неявно повторная реализация все базовые интерфейсы интерфейса. Пример
```csharp
interface IBase
{
    void F();
}

interface IDerived: IBase
{
    void G();
}

class C: IDerived
{
    void IBase.F() {...}
    void IDerived.G() {...}
}

class D: C, IDerived
{
    public void F() {...}
    public void G() {...}
}
```

В данном случае — повторная реализация `IDerived` также повторно реализует `IBase`, сопоставляя `IBase.F` на `D.F`.

### <a name="abstract-classes-and-interfaces"></a>Абстрактные классы и интерфейсы

Как неабстрактного класса абстрактный класс должен содержать реализации все члены интерфейсов, которые перечислены в списке базовых классов класса. Тем не менее абстрактный класс может сопоставлять методы интерфейса абстрактные методы. Пример
```csharp
interface IMethods
{
    void F();
    void G();
}

abstract class C: IMethods
{
    public abstract void F();
    public abstract void G();
}
```

В данном случае — реализация `IMethods` сопоставляет `F` и `G` абстрактным методам, который должен быть переопределен в неабстрактных классах, производных от `C`.

Обратите внимание, что явные реализации члена интерфейса не может быть абстрактным, но явные реализации члена интерфейса конечно разрешается вызывать абстрактные методы. Пример
```csharp
interface IMethods
{
    void F();
    void G();
}

abstract class C: IMethods
{
    void IMethods.F() { FF(); }
    void IMethods.G() { GG(); }
    protected abstract void FF();
    protected abstract void GG();
}
```

В данном случае — неабстрактных классах, производных от `C` потребовался бы для переопределения `FF` и `GG`, обеспечивая фактическую реализацию `IMethods`.
