# <a name="introduction"></a>Вступление

C# (произносится как "си шарп") — простой, современный объектно-ориентированный и типобезопасный язык программирования. C# относится к широко известному семейству языков C и будет немедленно знакомые программистам C, C++ и Java. C# Стандартизован ECMA International в качестве ***ECMA-334*** standard и ISO/IEC как ***ISO/IEC 23270*** standard. Компилятор с C# корпорации Майкрософт для .NET Framework является соответствующая реализация обоих этих стандартов.

C# является объектно-ориентированным языком, но поддерживает также и ***компонентно-ориентированное*** программирование. Разработка современных приложений все больше тяготеет к созданию программных компонентов в форме автономных и самоописательных пакетов, реализующих отдельные функциональные возможности. Важная особенность таких компонентов — это модель программирования на основе свойств, методов и событий. Каждый компонент имеет атрибуты, предоставляющие декларативные сведения о компоненте, а также встроенные элементы документации. C# предоставляет языковые конструкции, непосредственно поддерживающие такую концепцию работы благодаря этому C# очень естественного языка, в котором для создания и применения программных компонентов.

Несколько C# функции помощь в создании надежных и устойчивых приложений: ***Сборка мусора*** автоматически освобождает память, занятую неиспользуемые объекты; ***обработки исключений*** предоставляет структурированный и расширяемый способ определения ошибки и восстановления; и ***типобезопасный*** языка делает невозможной для чтения из неинициализированных переменных приведения типов массивов за пределы их границы или выполнить unchecked для индексирования.

В C# существует ***единая система типов***. Все типы C#, включая типы-примитивы, такие как `int` и `double`, наследуют от одного корневого типа `object`. Таким образом, все типы используют общий набор операций, и значения любого типа можно хранить, передавать и обрабатывать схожим образом. Кроме того, C# поддерживает пользовательские ссылочные типы и типы значений, позволяя как динамически выделять память для объектов, так и хранить упрощенные структуры в стеке.

Чтобы убедиться, что программы на C# и библиотеки со временем могут развиваться совместимость, много внимания было уделено ***управление версиями*** в разработке C#. Многие языки программирования обходят вниманием этот вопрос, и в результате программы на этих языках ломаются чаще, чем хотелось бы, при выходе новых версий зависимых библиотек. Аспекты разработки C#, на которые повлияли вопросы управления версиями раздельные `virtual` и `override` модификаторы, правила разрешения перегрузки методов и поддержка явного объявления членов интерфейса.

В оставшейся части этой главе описываются основные возможности языка C#. Несмотря на то, что в последующих главах описывают правила и исключения подробно ориентированные и иногда математические, для ясности и краткости за счет полноты стремится в этой главе. Целью является предоставить общие сведения о языке, которая будет полезна при написании простых программ и считывание в последующих главах.

## <a name="hello-world"></a>Здравствуй, мир

Для первого знакомства с языком программирования традиционно используется программа "Hello, World". Вот ее пример на C#:

```csharp
using System;

class Hello
{
    static void Main() {
        Console.WriteLine("Hello, World");
    }
}
```

Файлы исходного кода C# обычно имеют расширение `.cs`. Предположим, что программа «Hello, World» хранится в файле `hello.cs`, программу можно скомпилировать с помощью командной строки компилятора Microsoft C#
```
csc hello.cs
```
что порождает исполняемую сборку с именем `hello.exe`. — Выходные данные этого приложения при его выполнении
```
Hello, World
```

Программа "Hello, World" начинается с директивы `using`, которая ссылается на пространство имен `System`. Пространства имен позволяют иерархически упорядочивать программы и библиотеки C#. Пространства имен содержат типы и другие пространства имен. Например, пространство имен `System` содержит несколько типов (в том числе используемый в нашей программе класс `Console`) и несколько других пространств имен, таких как `IO` и `Collections`. Директива `using`, которая ссылается на пространство имен, позволяет использовать типы из этого пространства имен без указания полного имени. Благодаря директиве `using` в коде программы можно использовать сокращенное имя `Console.WriteLine` вместо полного варианта `System.Console.WriteLine`.

Класс `Hello`, объявленный в программе "Hello, World", имеет только один член — это метод с именем `Main`. `Main` Метод объявлен с `static` модификатор. Методы экземпляра могут ссылаться на конкретный экземпляр объекта, используя ключевое слово `this`, а статические методы работают без ссылки на конкретный объект. По стандартному соглашению точкой входа программы является статический метод с именем `Main`.

Выходные данные программы создаются в методе `WriteLine` класса `Console` из пространства имен `System`. Этот класс предоставляется в библиотеках классов .NET Framework, которые по умолчанию автоматически ссылается компилятор Microsoft C#. Обратите внимание, что C# сам собственная библиотека времени выполнения. Вместо этого .NET Framework — это библиотека среды выполнения C#.

## <a name="program-structure"></a>Структура программы

В C# основными понятиями организационной структуры являются ***программы***, ***пространства имен***, ***типы***, ***члены*** и ***сборки***. Программа на языке C# состоит из одного или нескольких файлов. В программе объявляются типы, которые содержат члены. Эти типы можно организовать в пространства имен. Примерами типов являются классы и интерфейсы. К членам относятся поля, методы, свойства и события. При компиляции программы на C# упаковываются в сборки. Сборки, обычно имеют расширение файла `.exe` или `.dll`, в зависимости от ли они реализуют ***приложений*** или ***библиотеки***.

Пример

```csharp
using System;

namespace Acme.Collections
{
    public class Stack
    {
        Entry top;

        public void Push(object data) {
            top = new Entry(top, data);
        }

        public object Pop() {
            if (top == null) throw new InvalidOperationException();
            object result = top.data;
            top = top.next;
            return result;
        }

        class Entry
        {
            public Entry next;
            public object data;
    
            public Entry(Entry next, object data) {
                this.next = next;
                this.data = data;
            }
        }
    }
}
```
объявляет класс с именем `Stack` в пространство имен с именем `Acme.Collections`. Полное имя этого класса: `Acme.Collections.Stack`. Этот класс содержит несколько членов: поле с именем `top`, два метода с именами `Push` и `Pop`, а также вложенный класс с именем `Entry`. Класс `Entry`, в свою очередь, содержит три члена: поле с именем `next`, поле с именем `data` и конструктор. Если мы сохраним исходный код этого примера в файле `acme.cs`, то для его компиляции нужно выполнить такую командную строку:

```
csc /t:library acme.cs
```
Результатом компиляции будет библиотека (код без точки входа `Main`), сохраненная в сборке с именем `acme.dll`.

Сборки содержат исполняемый код в виде ***промежуточный язык*** инструкции (IL) и символьную информацию в виде ***метаданных***. Перед выполнением сборки ее код на языке IL автоматически преобразуется в код для конкретного процессора. Эту задачу выполняет JIT-компилятор среды .NET CLR (Common Language Runtime).

Cборка полностью описывает сама себя и содержит весь код и метаданные, поэтому в C# не используются директивы `#include` и файлы заголовков. Чтобы использовать в программе C# открытые типы и члены, содержащиеся в определенной сборке, вам достаточно указать ссылку на эту сборку при компиляции программы. Например, эта программа использует класс `Acme.Collections.Stack` из сборки `acme.dll`:

```csharp
using System;
using Acme.Collections;

class Test
{
    static void Main() {
        Stack s = new Stack();
        s.Push(1);
        s.Push(10);
        s.Push(100);
        Console.WriteLine(s.Pop());
        Console.WriteLine(s.Pop());
        Console.WriteLine(s.Pop());
    }
}
```
Если программа хранится в файле `test.cs`, когда `test.cs` компилируется, `acme.dll` сборки можно ссылаться с помощью компилятора `/r` параметр:

```
csc /r:acme.dll test.cs
```
Эта команда создает исполняемую сборку с именем `test.exe`, которая при запуске возвращает такие данные:

```
100
10
1
```
В C# исходный текст программы можно хранить в нескольких исходных файлах. При компиляции многофайловой программы на C# все исходные файлы обрабатываются вместе, и все они могут свободно ссылаться друг на друга. По сути обработка выполняется так, как если бы все исходные файлы были объединены в один большой файл. В C# никогда не используются опережающие объявления, поскольку порядок объявления, за редким исключением, не играет никакой роли. В C# нет требований объявлять только один открытый тип в одном исходном файле, а также имя исходного файла не обязано совпадать с типом, объявляемом в этом файле.

## <a name="types-and-variables"></a>Типы и переменные

В C# существуют две разновидности типов: ***ссылочные типы*** и ***типы значений***. Переменные типа значений содержат непосредственно данные, а в переменных ссылочных типов хранятся ссылки на нужные данные, которые именуются объектами. Две переменные ссылочного типа могут ссылаться на один и тот же объект, поэтому может случиться так, что операции над одной переменной затронут объект, на который ссылается другая переменная. Каждая переменная типа значения имеет собственную копию данных, и операции над одной переменной не могут затрагивать другую (за исключением переменных параметров `ref` и `out`).

Типы значений C# подразделяются ***простых типов***, ***типы перечисления***, ***типы структур***, и ***обнуляемые типы***и справочник по C# типы подразделяются ***типы классов***, ***типы интерфейсов***, ***типы массивов***, и ***типы делегатов***.

Ниже приведены общие сведения о системе типов C#.

| __Категория__    |                 | __Описание__ |
|-----------------|-----------------|-----------------|
| Типы значений     | Простые типы    | Целочисленный со знаком: `sbyte`, `short`, `int`,`long` |
|                 |                 | Целочисленный без знака: `byte`, `ushort`, `uint`,`ulong` |
|                 |                 | Символы Юникода: `char` |
|                 |                 | IEEE-представление с плавающей запятой: `float`, `double` |
|                 |                 | Десятичный с повышенной точностью: `decimal` |
|                 |                 | Логическое значение: `bool` |
|                 | Типы перечисления      | Пользовательские типы в формате `enum E {...}` |
|                 | Типы структур    | Пользовательские типы в формате `struct S {...}` |
|                 | Типы, допускающие значения NULL  | Расширения других типов значений, допускающие значение `null` |
| Ссылочные типы | Типы классов     | Исходный базовым классом для всех типов: `object` |
|                 |                 | Строки Юникода: `string` |
|                 |                 | Пользовательские типы в формате `class C {...}` |
|                 | Типы интерфейса | Пользовательские типы в формате `interface I {...}` |
|                 | Типы массивов     | Одно- и многомерные, например, `int[]` и `int[,]` |
|                 | Тип делегатов  | Определяемые пользователем типы формы например `delegate int  D(...)` |

Восемь целочисленных типов обеспечивают поддержку 8-разрядных, 16-разрядных, 32-разрядных и 64-разрядных значений со знаком или без знака.

Два с плавающей запятой укажите типы, `float` и `double`, представлены с помощью 32-разрядный одиночной точности и 64-разрядных двойной точности IEEE 754 форматов.

Тип `decimal` — это 128-разрядный тип данных для финансовых и денежных расчетов.

C# `bool` тип используется для представления логических значений, которые могут иметь `true` или `false`.

Обработка знаков и строк в C# выполняется в кодировке Юникода. Тип `char` представляет элемент в кодировке UTF-16, а тип `string` представляет последовательность элементов в кодировке UTF-16.

В следующей таблице перечислены числовых типов C#.


| __Категория__      | __BITS__ | __Type__  | __Диапазон и точность__ |
|-------------------|----------|-----------|---------------------|
| Целочисленный со знаком   | 8        | `sbyte`   | – 128... 127 |
|                   | 16       | `short`   | -32, 768... 32, 767 |
|                   | 32       | `int`     | -2,147,483, 648... 2 147, 483, 647 |
|                   | 64       | `long`    | -9,223,372,036,854,775, 808... 9 223, 372, 036, 854, 775, 807 |
| Целочисленный без знака | 8        | `byte`    | 0... 255 |
|                   | 16       | `ushort`  | 0... 65 535 |
|                   | 32       | `uint`    | 0... 4 294 967 295 |
|                   | 64       | `ulong`   | 0... 18446744073709551615 |
| С плавающей запятой    | 32       | `float`   | 1,5 × 10 ^ 45 до 3,4 × 10 ^ 38, 7-значной точностью |
|                   | 64       | `double`  | 5,0 × 10 ^ – 324 до 1,7 × 10 ^ 308, 15 цифр точности |
| Десятичное число           | 128      | `decimal` | 1.0 × 10 ^ −28 до 7,9 × 10 ^ 28, 28 разрядами |

Программы C# используют ***объявления типов*** для создания новых типов. В объявлении типа указываются имя и члены нового типа. Пять из C# категории типов определяются пользователем: класс типы, типы структур, типы интерфейсов, типы перечисления и типы делегатов.

Тип класса определяет структуру данных, содержащую данные-члены (поля) и функции-члены (методы, свойства и другие). Классы поддерживают механизмы одиночного наследования и полиморфизма, которые позволяют создавать производные классы, расширяющие и уточняющие определения базовых классов.

Типом структуры похож на тип класса, в том, что он представляет структуру, используя данные-члены и функции-члены. Тем не менее в отличие от классов, структуры являются типами значений и не требуется выделение кучи. Типы структуры не поддерживают определяемое пользователем наследование, и все типы структуры неявно наследуют от типа `object`.

Тип интерфейса определяет контракт в виде именованного набора открытых функций-членов. Класс или структура, реализующие интерфейс должен содержать реализации функции-члены этого интерфейса. Интерфейс может наследовать от нескольких базовых интерфейсах и класс или структура может реализовывать несколько интерфейсов.

Тип делегата представляет ссылки на методы с конкретным списком параметров и типом возвращаемого значения. Делегаты позволяют использовать методы как сущности, сохраняя их в переменные и передавая в качестве параметров. Принцип работы делегатов близок к указателям функций из некоторых языков, но в отличие от указателей функций делегаты являются объектно-ориентированными и строго типизированными.

Типы поддерживают универсальные шаблоны, они позволяют передавать с другими типами, класса, структуры, интерфейса и делегата.

Тип перечисления является отдельным типом со списком именованных констант. Каждый тип перечисления имеет базовый тип, который должен быть одним из восьми целочисленных типов. Набор значений типа перечисления является таким же, как набор значений базового типа.

C# поддерживает одно- и многомерные массивы любого типа. В отличие от перечисленных выше типов, типы массивов не требуется объявлять перед использованием. Типы массивов можно сформировать, просто введя квадратные скобки после имени типа. Например `int[]` представляет собой одномерный массив `int`, `int[,]` является двумерным массивом значений типа `int`, и `int[][]` представляет собой одномерный массив одномерных массивов `int`.

Обнуляемые типы, кроме того, нет необходимости объявить, прежде чем они могут использоваться. Для каждого типа не допускающим значения `T` имеется соответствующий обнуляемый тип `T?`, который может содержать дополнительное значение `null`. Например `int?` — это тип, который может содержать любое 32-разрядное целое число или значение `null`.

Система типов C# унифицирована таким образом, что значение любого типа можно рассматривать как объект. Каждый тип в C# является прямо или косвенно производным от типа класса `object`, и этот тип `object` является исходным базовым классом для всех типов. Чтобы значения ссылочного типа обрабатывались как объекты, им просто присваивается тип `object`. Значения типов значений, рассматриваются как объекты, выполняя ***упаковки-преобразования*** и ***распаковки*** операций. В следующем примере значение `int` преобразуется в `object`, а затем обратно в `int`.

```csharp
using System;

class Test
{
    static void Main() {
        int i = 123;
        object o = i;          // Boxing
        int j = (int)o;        // Unboxing
    }
}
```
Если значение типа значения преобразуется в тип `object`, для хранения значения выделяется экземпляр объекта, также называемый «упаковка», и значение копируется в эту упаковку. И наоборот, если `object` ссылка приводится к типу значения, то выполняется проверка, указанный объект является правильного типа и, если проверка завершится успешно, копируется значение в поле.

Системы с единым типом C#, фактически означает, что типы значений могут преобразовываться в объекты «по требованию». Такая унификация позволяет применять универсальные библиотеки, использующие тип `object`, как со ссылочными типами, так и с типами значений.

В C# существует несколько типов ***переменных***, в том числе поля, элементы массива, локальные переменные и параметры. Переменные представляют места хранения, и каждая переменная имеет тип, который определяет значения, которые могут быть сохранены в переменной, как показано в следующей таблице.


| __Тип переменной__    | __Возможное содержимое__ |
|-------------------------|-----------------------|
| Тип значения, не допускающий значения Null | Значение такого типа |
| Тип значения, допускающий значение Null     | Значение null или значение такого типа |
| `object`                | Пустая ссылка, ссылку на объект любого ссылочного типа или ссылка на упакованное значение любого типа значения |
| Тип класса              | Пустая ссылка, ссылку на экземпляр этого типа класса или ссылку на экземпляр класса, производным от типа класса |
| Тип интерфейса          | Пустая ссылка, ссылку на экземпляр типа класса, который реализует такой тип интерфейса или ссылка на упакованное значение типа значения, который реализует такой тип интерфейса |
| Тип массива              | Пустая ссылка, ссылку на экземпляр такого типа массива или ссылку на экземпляр совместимого типа массива |
| Тип делегата           | Пустая ссылка или ссылка на экземпляр этого типа делегата |

## <a name="expressions"></a>Выражения

***Выражения*** создаются из ***операндов*** и ***операторов***. Операторы в выражении указывают, какие действия нужно применить к операндам. Примеры операторов: `+`, `-`, `*`, `/` и `new`. Операндами могут являться литералы, поля, локальные переменные, выражения и т. п.

Если выражение содержит несколько операторов, порядок вычисления этих операторов определяется их ***приоритетом***. Например, выражение `x + y * z` вычисляется как `x + (y * z)`, поскольку оператор `*` имеет более высокий приоритет, чем оператор `+`.

Большинство операторов допускают ***перегрузку***. Перегрузка операторов позволяет создать пользовательскую реализацию оператора для таких операций, в которых один или оба операнда имеют определяемый пользователем тип класса или структуры.

В следующей таблице перечислены операторы C#, категории операторов в порядке от самого высокого до самого низкого. Операторы в одной категории имеют одинаковый приоритет.


| __Категория__                     | __Выражение__    | __Описание__ |
|----------------------------------|-------------------|-----------------|
| Первичный                          | `x.m`             | Доступ к членам |
|                                  | `x(...)`          | Вызов метода и делегата |
|                                  | `x[...]`          | Доступ к массиву и индексатору |
|                                  | `x++`             | Постфиксный инкремент |
|                                  | `x--`             | Постфиксный декремент |
|                                  | `new T(...)`      | Создание объекта и делегата |
|                                  | `new T(...){...}` | Создание объекта с инициализатором |
|                                  | `new {...}`       | Анонимный инициализатор объекта |
|                                  | `new T[...]`      | Создание массива |
|                                  | `typeof(T)`       | Получить `System.Type` для объекта `T` |
|                                  | `checked(x)`      | Вычисление выражения в проверенном контексте |
|                                  | `unchecked(x)`    | Вычисление выражения в непроверенном контексте |
|                                  | `default(T)`      | Получение значения по умолчанию для типа `T` |
|                                  | `delegate {...}`  | Анонимная функция (анонимный метод) |
| Унарный                            | `+x`              | идентификации |
|                                  | `-x`              | Отрицание |
|                                  | `!x`              | Логическое отрицание |
|                                  | `~x`              | Поразрядное отрицание |
|                                  | `++x`             | Префиксный инкремент |
|                                  | `--x`             | Префиксный декремент |
|                                  | `(T)x`            | Явным образом преобразовать `x` ввода `T` |
|                                  | `await x`         | Асинхронное Ожидание `x` для завершения |
| Мультипликативный                   | `x * y`           | Умножение |
|                                  | `x / y`           | Деление |
|                                  | `x % y`           | Остаток |
| Аддитивный                         | `x + y`           | Сложение, объединение строк, объединение делегатов |
|                                  | `x - y`           | Вычитание, удаление делегатов |
| Сдвиг                            | `x << y`          | Сдвиг влево |
|                                  | `x >> y`          | Сдвиг вправо |
| Тестирования типа и относительные      | `x < y`           | Меньше |
|                                  | `x > y`           | Больше |
|                                  | `x <= y`          | Меньше или равно |
|                                  | `x >= y`          | Больше или равно |
|                                  | `x is T`          | Вернуть `true` Если `x` — `T`, `false` в противном случае |
|                                  | `x as T`          | Вернуть `x` типизируется как `T`, или `null` Если `x` не `T` |
| Равенство                         | `x == y`          | Равно      |
|                                  | `x != y`          | Не равно |
| Логическое И                      | `x & y`           | Целочисленного побитовое и, логическое и |
| Логическое исключающее ИЛИ                      | `x ^ y`           | Поразрядное исключающее ИЛИ для операндов целочисленного типа, логическое исключающее ИЛИ для операндов логического типа |
| Логическое ИЛИ                       | <code>x &#124; y</code> | Поразрядное ИЛИ для операндов целочисленного типа, логическое ИЛИ для операндов логического типа |
| Условное И                  | `x && y`          | Результатом является `y` только если `x` — `true` |
| Условное ИЛИ                   | <code>x &#124;&#124; y</code> | Результатом является `y` только если `x` — `false` |
| Объединение со значением NULL                  | `X ?? y`          | Принимает значение `y` Если `x` — `null`, `x` в противном случае |
| Условие                      | `x ? y : z`       | Результатом является `y` Если `x` — `true`, `z` Если `x` — `false` |
| Присваивание или анонимная функция | `x = y`           | Назначение |
|                                  | `x op= y`         | Составное присваивание; Ниже перечислены поддерживаемые операторы `*=` `/=` `%=` `+=` `-=` `<<=` `>>=` `&=` `^=` <code>&#124;=</code> |
|                                  | `(T x) => y`      | Анонимная функция (лямбда-выражение) |

## <a name="statements"></a>Операторы

Действия программы выражаются с помощью ***операторов***. C# поддерживает несколько типов операторов, некоторые из которых определяются как внедренные операторы.

С помощью ***блоков*** можно использовать несколько операторов в таких контекстах, где ожидается только один оператор. Блок состоит из списка инструкций, заключенных между разделителями `{` и `}`.

***Операторы объявления*** используются для объявления локальных переменных и констант.

***Операторы выражений*** позволяют вычислять выражения. Выражения, которые могут использоваться как операторы включают в себя вызовов методов, выделение объектов с помощью `new` оператор, при сбое с помощью `=` и составные операторы присваивания, операции увеличения и уменьшения, с помощью `++`и `--` операторы и выражения await.

***Операторы выбора*** используются для выбора одного оператора из нескольких возможных вариантов в зависимости от значения какого-либо выражения. К этой группе относятся операторы `if` и `switch`.

***Операторы итерации*** используются для многократного выполнения внедренного оператора. К этой группе относятся операторы `while`, `do`, `for` и `foreach`.

***Операторы перехода*** используются для передачи управления. К этой группе относятся операторы `break`, `continue`, `goto`, `throw`, `return` и `yield`.

Операторы `try`...`catch` позволяют перехватывать исключения, создаваемые при выполнении блока кода, а оператор `try`...`finally` используется для указания кода завершения, который выполняется всегда, независимо от появления исключений.

`checked` И `unchecked` инструкции используются для управления контекстом для целочисленных арифметических операций и преобразований проверки переполнения.

Оператор `lock` позволяет создать взаимоисключающую блокировку заданного объекта перед выполнением определенных операторов, а затем снять блокировку.

Оператор `using` используется для получения ресурса перед определенным оператором, и для удаления ресурса после его завершения.

Ниже приведены примеры каждого типа инструкции

__Объявления локальных переменных__

```csharp
static void Main() {
   int a;
   int b = 2, c = 3;
   a = 1;
   Console.WriteLine(a + b + c);
}
```


__В объявлении локальной константы__

```csharp
static void Main() {
    const float pi = 3.1415927f;
    const int r = 25;
    Console.WriteLine(pi * r * r);
}
```


__Оператор выражений__

```csharp
static void Main() {
    int i;
    i = 123;                // Expression statement
    Console.WriteLine(i);   // Expression statement
    i++;                    // Expression statement
    Console.WriteLine(i);   // Expression statement
}
```

__`if` Инструкции__

```csharp
static void Main(string[] args) {
    if (args.Length == 0) {
        Console.WriteLine("No arguments");
    }
    else {
        Console.WriteLine("One or more arguments");
    }
}
```


__`switch` Инструкции__

```csharp
static void Main(string[] args) {
    int n = args.Length;
    switch (n) {
        case 0:
            Console.WriteLine("No arguments");
            break;
        case 1:
            Console.WriteLine("One argument");
            break;
        default:
            Console.WriteLine("{0} arguments", n);
            break;
    }
}
```

__`while` Инструкции__

```csharp
static void Main(string[] args) {
    int i = 0;
    while (i < args.Length) {
        Console.WriteLine(args[i]);
        i++;
    }
}
```


__`do` Инструкции__

```csharp
static void Main() {
    string s;
    do {
        s = Console.ReadLine();
        if (s != null) Console.WriteLine(s);
    } while (s != null);
}
```

__`for` Инструкции__

```csharp
static void Main(string[] args) {
    for (int i = 0; i < args.Length; i++) {
        Console.WriteLine(args[i]);
    }
}
```

__`foreach` Инструкции__

```csharp
static void Main(string[] args) {
    foreach (string s in args) {
        Console.WriteLine(s);
    }
}
```

__`break` Инструкции__

```csharp
static void Main() {
    while (true) {
        string s = Console.ReadLine();
        if (s == null) break;
        Console.WriteLine(s);
    }
}
```

__`continue` Инструкции__

```csharp
static void Main(string[] args) {
    for (int i = 0; i < args.Length; i++) {
        if (args[i].StartsWith("/")) continue;
        Console.WriteLine(args[i]);
    }
}
```

__`goto` Инструкции__

```csharp
static void Main(string[] args) {
    int i = 0;
    goto check;
    loop:
    Console.WriteLine(args[i++]);
    check:
    if (i < args.Length) goto loop;
}
```

__`return` Инструкции__

```csharp
static int Add(int a, int b) {
    return a + b;
}

static void Main() {
    Console.WriteLine(Add(1, 2));
    return;
}
```

__`yield` Инструкции__

```csharp
static IEnumerable<int> Range(int from, int to) {
    for (int i = from; i < to; i++) {
        yield return i;
    }
    yield break;
}

static void Main() {
    foreach (int x in Range(-10,10)) {
        Console.WriteLine(x);
    }
}
```

__`throw` и `try` инструкций__

```csharp
static double Divide(double x, double y) {
    if (y == 0) throw new DivideByZeroException();
    return x / y;
}

static void Main(string[] args) {
    try {
        if (args.Length != 2) {
            throw new Exception("Two numbers required");
        }
        double x = double.Parse(args[0]);
        double y = double.Parse(args[1]);
        Console.WriteLine(Divide(x, y));
    }
    catch (Exception e) {
        Console.WriteLine(e.Message);
    }
    finally {
        Console.WriteLine("Good bye!");
    }
}
```

__`checked` и `unchecked` инструкций__

```csharp
static void Main() {
    int i = int.MaxValue;
    checked {
        Console.WriteLine(i + 1);        // Exception
    }
    unchecked {
        Console.WriteLine(i + 1);        // Overflow
    }
}
```

__`lock` Инструкции__

```csharp
class Account
{
    decimal balance;
    public void Withdraw(decimal amount) {
        lock (this) {
            if (amount > balance) {
                throw new Exception("Insufficient funds");
            }
            balance -= amount;
        }
    }
}
```

__`using` Инструкции__

```csharp
static void Main() {
    using (TextWriter w = File.CreateText("test.txt")) {
        w.WriteLine("Line one");
        w.WriteLine("Line two");
        w.WriteLine("Line three");
    }
}
```

## <a name="classes-and-objects"></a>Классы и объекты

***Классы*** являются самым важным типом в языке C#. Класс представляет собой структуру данных, которая объединяет в себе значения (поля) и действия (методы и другие функции-члены). Класс предоставляет определение для динамически создаваемых ***экземпляров*** класса, которые также именуются ***объектами***. Классы поддерживают механизмы ***наследования*** и ***полиморфизма***, которые позволяют создавать ***производные классы***, расширяющие и уточняющие определения ***базовых классов***.

Новые классы создаются с помощью объявлений классов. Объявление класса начинается с заголовка, в котором указаны атрибуты и модификаторы класса, имя класса, базовый класс (если есть) и интерфейсы, реализуемые этим классом. За заголовком между разделителями `{` и `}` следует тело класса, в котором последовательно объявляются все члены класса.

Вот простой пример объявления класса с именем `Point`:

```csharp
public class Point
{
    public int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```
Экземпляры классов создаются с помощью оператора `new`, который выделяет память для нового экземпляра, вызывает конструктор для инициализации этого экземпляра и возвращает ссылку на экземпляр. Следующие инструкции создают два `Point` объектов и сохранения ссылок на эти объекты в двух переменных:

```
Point p1 = new Point(0, 0);
Point p2 = new Point(10, 20);
```
Занимаемая объектом память автоматически освобождается, когда объект больше не используется. В C# нет ни необходимости, ни возможности освобождать память объектов явным образом.

### <a name="members"></a>Участники

Члены класса являются либо ***статические члены*** или ***члены экземпляра***. Статические члены принадлежат классу в целом, а члены экземпляра принадлежат конкретным объектам (экземплярам классов).

Ниже приведены общие сведения о виды членов, которые могут содержаться в классе.


| __Член__   | __Описание__ |
|------------  |-----------------|
| Константы    | Константные значения, связанные с классом. |
| Поля       | Переменные класса. |
| Методы      | Вычисления и действия, которые может выполнять класс. |
| Свойства   | Действия, связанные с чтением и записью именованных свойств класса. |
| Индексаторы     | Действия, реализующие индексирование экземпляров класса, чтобы обращаться к ним как к массиву. |
| События       | Уведомления, которые могут быть созданы этим классом. |
| Операторы    | Поддерживаемые классом операторы преобразования и выражения. |
| Конструкторы | Действия, необходимые для инициализации экземпляров класса или класса в целом. |
| Деструкторы  | Действия, выполняемые перед окончательным удалением экземпляров класса. |
| Типы        | Вложенные типы, объявленные в классе. |

### <a name="accessibility"></a>Специальные возможности

Каждый член класса имеет определенный уровень доступности. Он определяет, из какой области программы можно обращаться к этому члену. Существует пять уровней доступности. Эти отчеты представлены в следующей таблице.


| __Специальные возможности__    | __Значение__ |
|----------------------|-----------------|
| `public`             | Доступ не ограничен. |
| `protected`          | Доступ возможен из этого класса и из классов, унаследованных от него. |
| `internal`           | Доступ возможен только из текущей программы. |
| `protected internal` | Доступ возможен только из текущей программы и из классов, унаследованных от этого класса. |
| `private`            | Доступ возможен только из этого класса. |

### <a name="type-parameters"></a>Параметры типа

Определение класса может задать набор параметров типа. Список имен параметров типа указывается в угловых скобках после имени класса. Параметры типа могут использоваться в теле объявления класса для определения членов класса. В следующем примере для класса `Pair` заданы параметры типа `TFirst` и `TSecond`:

```csharp
public class Pair<TFirst,TSecond>
{
    public TFirst First;
    public TSecond Second;
}
```
Типом класса, объявленного параметры типа, называется типом универсального класса. Типы структуры, интерфейса и делегата также могут быть универсальными.

Если вы используете универсальный класс, необходимо указать аргумент типа для каждого параметра типа, вот так:

```csharp
Pair<int,string> pair = new Pair<int,string> { First = 1, Second = "two" };
int i = pair.First;     // TFirst is int
string s = pair.Second; // TSecond is string
```
Универсальный тип с предоставленными аргументами типа, например `Pair<int,string>
    ` , называется сконструированного типа.

### <a name="base-classes"></a>базовых классов;

В объявлении класса можно указать базовый класс, включив имя базового класса после имени класса и параметров типа, и отделив его двоеточием. Если спецификация базового класса не указана, класс наследуется от типа `object`. В следующем примере `Point3D` имеет базовый класс `Point`, а `Point` — базовый класс `object`:

```csharp
public class Point
{
    public int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

public class Point3D: Point
{
    public int z;

    public Point3D(int x, int y, int z): base(x, y) {
        this.z = z;
    }
}
```
Класс наследует члены базового класса. Наследование означает, что класс неявно содержит все члены базового класса, за исключением экземпляра и статические конструкторы и деструкторы базового класса. Производный класс может дополнить наследуемые элементы новыми элементами, но он не может удалить определение для наследуемого члена. В предыдущем примере `Point3D` наследует поля `x` и `y` из `Point`, и каждый экземпляр `Point3D` содержит три поля: `x`, `y` и `z`.

Используется неявное преобразование из типа класса к любому из типов соответствующего базового класса. Это означает, что переменная типа класса может ссылаться как на экземпляр этого класса, так и на экземпляры любого производного класса. Например, если мы используем описанные выше объявления классов, то переменная типа `Point` может ссылаться на `Point` или `Point3D`:

```csharp
Point a = new Point(10, 20);
Point b = new Point3D(10, 20, 30);
```

### <a name="fields"></a>Поля

Поле — это переменная, который связан с классом или экземпляром класса.

Поле объявлено с `static` модификатор определяет ***статическое поле***. Статическое поле определяет строго одно место хранения. Независимо от того, сколько будет создано экземпляров этого класса, существует только одна копия статического поля.

Поле объявлено без `static` модификатор определяет ***поле экземпляра***. Каждый экземпляр класса содержит отдельные копии всех полей экземпляра, определенных для этого класса.

В следующем примере каждый экземпляр класса `Color` содержит отдельную копию полей экземпляра `r`, `g` и `b`, но для каждого из статических полей `Black`, `White`, `Red`, `Green` и `Blue` существует только одна копия:

```csharp
public class Color
{
    public static readonly Color Black = new Color(0, 0, 0);
    public static readonly Color White = new Color(255, 255, 255);
    public static readonly Color Red = new Color(255, 0, 0);
    public static readonly Color Green = new Color(0, 255, 0);
    public static readonly Color Blue = new Color(0, 0, 255);
    private byte r, g, b;

    public Color(byte r, byte g, byte b) {
        this.r = r;
        this.g = g;
        this.b = b;
    }
}
```
Как показано в предыдущем примере, можно объявить ***поля только для чтения***, используя модификатор `readonly`. Назначение `readonly` поля может происходить только как часть объявления поля или в конструкторе в том же классе.

### <a name="methods"></a>Методы

***Метод*** — это член, реализующий вычисление или действие, которое может выполнять объект или класс. Доступ к ***статическим методам*** осуществляется через класс. Доступ к ***методам экземпляра*** осуществляется через экземпляр класса.

Методы имеют (возможно, пустой) список ***параметры***, которые представляют значения или ссылки на переменные, передаваемые методу и ***тип возвращаемого значения***, который указывает тип значения, вычисляемого и возвращаемого по метод. Тип возвращаемого значения метода `void` если он не возвращает значение.

Как и типы, методы могут иметь набор параметров типа, для которых при вызове метода необходимо указывать аргументы типа. В отличие от типов, аргументы типа зачастую могут выводиться из аргументов вызова метода, и тогда их не обязательно задавать явным образом.

***Сигнатура*** метода должна быть уникальной в пределах класса, в котором объявлен этот метод. Сигнатура метода включает имя метода, количество параметров типа, а также количество, модификаторы и типы параметров метода. Сигнатура метода не включает возвращаемый тип.

#### <a name="parameters"></a>Параметры

Параметры позволяют передать в метод значения или ссылки на переменные. Фактические значения параметрам метода присваиваются на основе ***аргументов***, заданных при вызове метода. Существует четыре типа параметров: параметры значения, ссылочные параметры, параметры вывода и массивы параметров.

***Параметр значения*** передает один входной параметр. Параметр значения сопоставляется с локальной переменной, которая получит начальное значение из значения аргумента, переданного в этом параметре. Изменения параметра значения не влияют на аргумент, переданный для этого параметра.

Параметры значения можно сделать необязательными, указав для них значения по умолчанию. Тогда соответствующие аргументы можно не указывать.

***Ссылочный параметр*** используется как для входных, так и для выходных параметров. Аргумент, передаваемый ссылочному параметру, должен являться переменной. При выполнении метода ссылочный параметр указывает на то же место хранения, где размещена переменная аргумента. Чтобы объявить ссылочный параметр, используйте модификатор `ref`. Следующий пример кода демонстрирует использование параметров `ref`.

```csharp
using System;

class Test
{
    static void Swap(ref int x, ref int y) {
        int temp = x;
        x = y;
        y = temp;
    }

    static void Main() {
        int i = 1, j = 2;
        Swap(ref i, ref j);
        Console.WriteLine("{0} {1}", i, j);            // Outputs "2 1"
    }
}
```
***Параметр вывода*** передает один выходной параметр. Параметр вывода действует так же, как и ссылочный параметр, но для него не используется исходное значение аргумента, предоставленного при вызове метода. Чтобы объявить параметр вывода, используйте модификатор `out`. Следующий пример кода демонстрирует использование параметров `out`.

```csharp
using System;

class Test
{
    static void Divide(int x, int y, out int result, out int remainder) {
        result = x / y;
        remainder = x % y;
    }

    static void Main() {
        int res, rem;
        Divide(10, 3, out res, out rem);
        Console.WriteLine("{0} {1}", res, rem);    // Outputs "3 1"
    }
}
```
***Массив параметров*** позволяет передавать в метод переменное число аргументов. Чтобы объявить массив параметров, используйте модификатор `params`. Массив параметров может быть только последним параметром в методе. Для него можно использовать только тип одномерного массива. `Write` И `WriteLine` методы `System.Console` класс — это хорошие примеры использования массива параметров. Ниже представлены объявления этих методов.

```csharp
public class Console
{
    public static void Write(string fmt, params object[] args) {...}
    public static void WriteLine(string fmt, params object[] args) {...}
    ...
}
```
Внутри метода массив параметров полностью идентичен обычному параметру типа массив. Но зато при вызове метода, использующего массив параметров, ему можно передать либо один аргумент типа массив, либо любое количество аргументов типа элемент для массива параметров. В последнем случае экземпляр массива автоматически создается и инициализируется с заданными аргументами. Код из этого примера...

```csharp
Console.WriteLine("x={0} y={1} z={2}", x, y, z);
```
...эквивалентен следующей конструкции:

```csharp
string s = "x={0} y={1} z={2}";
object[] args = new object[3];
args[0] = x;
args[1] = y;
args[2] = z;
Console.WriteLine(s, args);
```

#### <a name="method-body-and-local-variables"></a>Тело метода и локальные переменные

В теле метода задает операторы, выполняемые при вызове метода.

В теле метода можно объявлять переменные, относящиеся к выполнению этого метода. Такие переменные называются ***локальными переменными***. В объявлении локальной переменной нужно указать имя типа и имя переменной. Также можно задать ее начальное значение. Следующий пример кода объявляет локальную переменную `i` с нулевым начальным значением, и еще одну локальную переменную `j` без начального значения.

```csharp
using System;

class Squares
{
    static void Main() {
        int i = 0;
        int j;
        while (i < 10) {
            j = i * i;
            Console.WriteLine("{0} x {0} = {1}", i, j);
            i = i + 1;
        }
    }
}
```
C# требует, чтобы локальной переменной было ***явно присвоено значение***, прежде чем можно будет получить это значение. Например, если в предложенное выше объявление `i` не включить начальное значение, компилятор сообщит об ошибке при последующем использовании `i`, поскольку для `i` нет явно присвоенного значения.

Метод может использовать инструкцию `return`, чтобы вернуть управление вызывающему объекту. Если метод возвращает `void`, в нем нельзя использовать инструкцию `return` с выражением. Метод возвращает не -`void`, `return` инструкции должны содержать выражение, которое вычисляет возвращаемое значение.

#### <a name="static-and-instance-methods"></a>Статические методы и методы экземпляра

Метод, объявленный с `static` модификатор ***статический метод***. Статический метод не работает с конкретным экземпляром и может напрямую обращаться только к статическим членам.

Метод, объявленный без `static` модификатор ***метод экземпляра***. Метод экземпляра работает в определенном экземпляре и может обращаться как к статическим методам, так и к методам этого экземпляра. В методе можно напрямую обратиться к экземпляру, для которого этот метод был вызван, используя дескриптор `this`. Использование `this` в статическом методе приводит к ошибке.

Следующий класс `Entity` содержит статические члены и члены экземпляра.

```csharp
class Entity
{
    static int nextSerialNo;
    int serialNo;

    public Entity() {
        serialNo = nextSerialNo++;
    }

    public int GetSerialNo() {
        return serialNo;
    }

    public static int GetNextSerialNo() {
        return nextSerialNo;
    }

    public static void SetNextSerialNo(int value) {
        nextSerialNo = value;
    }
}
```
Каждый экземпляр `Entity` содержит серийный номер (и может содержать другие данные, которые здесь не показаны). Конструктор объекта `Entity` (который рассматривается как метод экземпляра) задает для нового экземпляра следующий доступный серийный номер. Поскольку конструктор является членом экземпляра, он может обращаться как к полю экземпляра `serialNo`, так и к статическому полю `nextSerialNo`.

Статические методы `GetNextSerialNo` и `SetNextSerialNo` могут обращаться к статическому полю `nextSerialNo`, но прямое обращение из них к полю экземпляра `serialNo` приводит к ошибке.

В следующем примере показано использование `Entity` класса.

```csharp
using System;

class Test
{
    static void Main() {
        Entity.SetNextSerialNo(1000);
        Entity e1 = new Entity();
        Entity e2 = new Entity();
        Console.WriteLine(e1.GetSerialNo());           // Outputs "1000"
        Console.WriteLine(e2.GetSerialNo());           // Outputs "1001"
        Console.WriteLine(Entity.GetNextSerialNo());   // Outputs "1002"
    }
}
```
Обратите внимание, что статические методы `SetNextSerialNo` и `GetNextSerialNo` вызываются для класса, а метод экземпляра `GetSerialNo` вызывается для экземпляров класса.

#### <a name="virtual-override-and-abstract-methods"></a>Виртуальные, переопределяющие и абстрактные методы

Если объявление метода экземпляра включает модификатор `virtual`, такой метод называется ***виртуальным методом***. Если аргумент `virtual` модификатора, метод считается ***невиртуальный метод***.

При вызове виртуального метода могут быть вызваны разные его реализации в зависимости от того, какой ***тип среды выполнения*** имеет экземпляр, для которого вызван этот метод. При вызове невиртуального метода решающим фактором является ***тип во время компиляции*** для этого экземпляра.

Виртуальный метод можно ***переопределить*** в производном классе. Если объявление метода экземпляра включает `override` модификатор, метод переопределяет унаследованный виртуальный метод с такой же сигнатурой. Изначальное объявление виртуального метода создает новый метод, а переопределение этого метода создает специализированный виртуальный метод с новой реализацией взамен унаследованного виртуального метода.

***Абстрактный*** метод является виртуальным методом без реализации. Абстрактный метод объявляется с `abstract` модификатор и допускается только в классе, объявленном как `abstract`. Абстрактный метод должен обязательно переопределяться в каждом производном классе, не являющемся абстрактным.

Следующий пример кода объявляет абстрактный класс `Expression`, который представляет узел дерева выражений, а также три производных класса: `Constant`, `VariableReference` и `Operation`, которые реализуют узлы дерева выражений для констант, ссылок на переменные и арифметических операций. (Это похоже на, но не следует путать с типы дерева выражений, представленные в [типы дерева выражений](types.md#expression-tree-types)).

```csharp
using System;
using System.Collections;

public abstract class Expression
{
    public abstract double Evaluate(Hashtable vars);
}

public class Constant: Expression
{
    double value;

    public Constant(double value) {
        this.value = value;
    }

    public override double Evaluate(Hashtable vars) {
        return value;
    }
}

public class VariableReference: Expression
{
    string name;

    public VariableReference(string name) {
        this.name = name;
    }

    public override double Evaluate(Hashtable vars) {
        object value = vars[name];
        if (value == null) {
            throw new Exception("Unknown variable: " + name);
        }
        return Convert.ToDouble(value);
    }
}

public class Operation: Expression
{
    Expression left;
    char op;
    Expression right;

    public Operation(Expression left, char op, Expression right) {
        this.left = left;
        this.op = op;
        this.right = right;
    }

    public override double Evaluate(Hashtable vars) {
        double x = left.Evaluate(vars);
        double y = right.Evaluate(vars);
        switch (op) {
            case '+': return x + y;
            case '-': return x - y;
            case '*': return x * y;
            case '/': return x / y;
        }
        throw new Exception("Unknown operator");
    }
}
```
Четыре приведенных выше класса можно использовать для моделирования арифметических выражений. Например, с помощью экземпляров этих классов выражение `x + 3` можно представить следующим образом.

```csharp
Expression e = new Operation(
    new VariableReference("x"),
    '+',
    new Constant(3));
```
Метод `Evaluate` экземпляра `Expression` вызывается для вычисления данного выражения и создает значение `double`. Этот метод принимает в качестве аргумента `Hashtable` , содержащий имена переменных (в качестве ключей записей) и значения (в качестве значений записей). `Evaluate` Метод является виртуальным методом абстрактный, это означает, что неабстрактные производные классы должны переопределить его, чтобы предоставить фактическую реализацию.

В `Constant` реализация метода `Evaluate` просто возвращает хранимую константу. Объект `VariableReference`реализация этого метода выполняет поиск имени переменной в хэш-таблицу и возвращает результирующее значение. В `Operation` реализация этого метода сначала вычисляет левый и правый операнды (рекурсивно вызывая их методы `Evaluate`), а затем выполняет предоставленную арифметическую операцию.

В следующей программе классы `Expression` используются для вычисления выражения `x * (y + 2)` с различными значениями `x` и `y`.

```csharp
using System;
using System.Collections;

class Test
{
    static void Main() {
        Expression e = new Operation(
            new VariableReference("x"),
            '*',
            new Operation(
                new VariableReference("y"),
                '+',
                new Constant(2)
            )
        );
        Hashtable vars = new Hashtable();
        vars["x"] = 3;
        vars["y"] = 5;
        Console.WriteLine(e.Evaluate(vars));        // Outputs "21"
        vars["x"] = 1.5;
        vars["y"] = 9;
        Console.WriteLine(e.Evaluate(vars));        // Outputs "16.5"
    }
}
```

#### <a name="method-overloading"></a>Перегрузка методов

***Перегрузка*** метода позволяет использовать в одном классе несколько методов с одинаковыми именами, если они имеют уникальные сигнатуры. Когда при компиляции встречается вызов перегруженного метода, компилятор использует принцип ***разрешения перегрузки***, чтобы определить, какой из методов следует вызвать. Разрешение перегрузки выбирает из методов тот, который лучше всего соответствует предоставленным аргументам, или возвращает ошибку, если не удается выбрать конкретный подходящий метод. В следующем примере показано, как работает разрешение перегрузки. Комментарий к каждому вызову метода `Main` подсказывает, какой из методов будет вызван для этой строки.

```csharp
class Test
{
    static void F() {
        Console.WriteLine("F()");
    }

    static void F(object x) {
        Console.WriteLine("F(object)");
    }

    static void F(int x) {
        Console.WriteLine("F(int)");
    }

    static void F(double x) {
        Console.WriteLine("F(double)");
    }

    static void F<T>(T x) {
        Console.WriteLine("F<T>(T)");
    }

    static void F(double x, double y) {
        Console.WriteLine("F(double, double)");
    }

    static void Main() {
        F();                 // Invokes F()
        F(1);                // Invokes F(int)
        F(1.0);              // Invokes F(double)
        F("abc");            // Invokes F(object)
        F((double)1);        // Invokes F(double)
        F((object)1);        // Invokes F(object)
        F<int>(1);           // Invokes F<T>(T)
        F(1, 1);             // Invokes F(double, double)
    }
}
```
Как видно из этого примера, вы всегда можете выбрать конкретный метод, явным образом приведя типы аргументов к соответствующим типам параметров, и (или) явно предоставив аргументы нужного типа.

### <a name="other-function-members"></a>Другие функции-члены

Все члены класса, содержащие исполняемый код, совокупно называются ***функции-члены***. В предыдущем разделе мы рассмотрели основные варианты методов, используемых как функции-члены. В этом разделе описываются другие типы функций-членов, поддерживающиеся C#: конструкторы, свойства, индексаторы, события, операторы и деструкторы.

В следующем коде показано универсальный класс с именем `List<T>`, который реализует расширяемый список объектов. Этот класс содержит несколько наиболее распространенных типов функций-членов.


```csharp
public class List<T> {
    // Constant...
    const int defaultCapacity = 4;

    // Fields...
    T[] items;
    int count;

    // Constructors...
    public List(int capacity = defaultCapacity) {
        items = new T[capacity];
    }

    // Properties...
    public int Count {
        get { return count; }
    }
    public int Capacity {
        get {
            return items.Length;
        }
        set {
            if (value < count) value = count;
            if (value != items.Length) {
                T[] newItems = new T[value];
                Array.Copy(items, 0, newItems, 0, count);
                items = newItems;
            }
        }
    }

    // Indexer...
    public T this[int index] {
        get {
            return items[index];
        }
        set {
            items[index] = value;
            OnChanged();
        }
    }

    // Methods...
    public void Add(T item) {
        if (count == Capacity) Capacity = count * 2;
        items[count] = item;
        count++;
        OnChanged();
    }
    protected virtual void OnChanged() {
        if (Changed != null) Changed(this, EventArgs.Empty);
    }
    public override bool Equals(object other) {
        return Equals(this, other as List<T>);
    }
    static bool Equals(List<T> a, List<T> b) {
        if (a == null) return b == null;
        if (b == null || a.count != b.count) return false;
        for (int i = 0; i < a.count; i++) {
            if (!object.Equals(a.items[i], b.items[i])) {
                return false;
            }
        }
        return true;
    }

    // Event...
    public event EventHandler Changed;

    // Operators...
    public static bool operator ==(List<T> a, List<T> b) {
        return Equals(a, b);
    }
    public static bool operator !=(List<T> a, List<T> b) {
        return !Equals(a, b);
    }
}
```

#### <a name="constructors"></a>Конструкторы

C# поддерживает конструкторы экземпляров и статические конструкторы. ***Конструктор экземпляра*** является членом, который реализует действия для инициализации нового экземпляра класса. ***Статический конструктор*** является членом, который реализует действия для инициализации самого класса при первоначальной его загрузке.

Конструктор объявляется в виде метода без возвращаемого типа, имя которого совпадает с именем класса, в котором он определен. Если объявление конструктора содержит `static` модификатор, он объявляет статический конструктор. В противном случае это объявление считается конструктором экземпляра.

Конструкторы экземпляров могут быть перегружены. Например, класс `List<T>
` объявляет два конструктора экземпляра: один без параметров и один с параметром `int`. Конструкторы экземпляров вызываются с помощью оператора `new`. Следующий пример кода выделяет два `List<string>
` экземпляров с помощью каждого из конструкторов `List` класса.

```csharp
List<string> list1 = new List<string>();
List<string> list2 = new List<string>(10);
```
В отличие от других членов конструкторы экземпляров не наследуются, и класс не имеет конструкторов экземпляров, кроме объявленных в самом этом классе. Если в классе не объявлен конструктор экземпляра, для него автоматически создается пустой конструктор без параметров.

#### <a name="properties"></a>Свойства

***Свойства*** естественным образом дополняют поля. И те, и другие являются именованными членами со связанными типами, и для доступа к ним используется одинаковый синтаксис. Однако свойства, в отличие от полей, не указывают места хранения. Вместо этого свойства содержат ***методы доступа***, в которых описаны инструкции для выполнения при чтении или записи значений.

Свойство объявлено как поле, за исключением того, что объявление заканчивается `get` метода доступа и/или `set` метод доступа, записанных между разделителями `{` и `}` вместо заканчиваются точкой с запятой. Свойство, имеющее оба `get` метода доступа и `set` метод доступа является ***чтения и записи свойство***, свойство, имеющее только `get` метод доступа является ***свойство только для чтения***и свойство, имеющее только `set` метод доступа является ***свойство, доступное только для записи***.

Объект `get` метод доступа соответствует оформляется как метод с возвращаемым значением типа свойства. За исключением случаев, целевым объектом назначения, при ссылке на свойство в выражении, `get` для вычисления значения свойства вызывается метод доступа свойства.

Объект `set` доступа соответствует методу с одним параметром с именем `value` и без возвращаемого типа. Если ссылка на свойство как целевым объектом назначения или как операнд `++` или `--`, `set` вызывается метод доступа с аргументом, содержащим новое значение.

`List<T>
` Класс объявляет два свойства `Count` и `Capacity`, которые являются только для чтения и чтения и записи, соответственно. Образец использования этих свойств приведен ниже.

```csharp
List<string> names = new List<string>();
names.Capacity = 100;            // Invokes set accessor
int i = names.Count;             // Invokes get accessor
int j = names.Capacity;          // Invokes get accessor
```
Как и в отношении полей и методов, C# поддерживает свойства экземпляра и статические свойства. Статические свойства объявляются с `static` модификатор, а свойства экземпляра объявлены без него.

Акцессоры свойства могут быть виртуальными. Если объявление свойства содержит модификатор `virtual`, `abstract` или `override`, этот модификатор применяется к акцессорам свойства.

#### <a name="indexers"></a>Индексаторы

***Индексатор*** является членом, позволяющим индексировать объекты так, как будто они включены в массив. Индексатор объявляется как свойство, за исключением того, что имя члена — `this` следуют список параметров, записанных между разделителями `[` и `]`. Эти параметры доступны в акцессорах индексатора. Как и свойства, можно объявить индексаторы для чтения и записи, только для чтения или только для записи. Кроме того, поддерживаются виртуальные акцессоры индексатора.

Класс `List` объявляет один индексатор для чтения и записи, который принимает параметр `int`. Индексатор позволяет индексировать экземпляры `List` значениями с типом `int`. Пример

```csharp
List<string> names = new List<string>();
names.Add("Liz");
names.Add("Martha");
names.Add("Beth");
for (int i = 0; i < names.Count; i++) {
    string s = names[i];
    names[i] = s.ToUpper();
}
```
Индексаторы можно перегружать, то есть в одном классе можно объявить несколько индексаторов, если у них различаются количество или типы параметров.

#### <a name="events"></a>События

***Событие*** — это член, с помощью которого класс или объект предоставляют уведомления. Событие объявляется как поле, за исключением того, что объявление включает `event` ключевое слово и тип должен быть типом делегата.

В классе, который объявляет член события, это событие действует, как обычное поле с типом делегата (если это событие не является абстрактным и не объявляет акцессоры). Это поле хранит ссылку на делегат, который представляет добавленные к событию обработчики событий. Если обработчики событий отсутствуют, то поле выравнивается `null`.

Класс `List<T>
` объявляет один член события с именем `Changed`, который обрабатывает добавление нового элемента. `Changed` Событие `OnChanged` виртуальный метод, который сначала проверяет, является ли событие `null` (это означает, что обработчики не присутствуют). Концепция создания события в точности соответствует вызову делегата, представленного этим событием. Это позволяет обойтись без особой языковой конструкции для создания событий.

Клиенты реагируют на события посредством ***обработчиков событий***. Обработчики событий можно подключать с помощью оператора `+=` и удалять с помощью оператора `-=`. Следующий пример кода подключает обработчик события `Changed` к событию `List<string>
`.

```csharp
using System;

class Test
{
    static int changeCount;

    static void ListChanged(object sender, EventArgs e) {
        changeCount++;
    }

    static void Main() {
        List<string> names = new List<string>();
        names.Changed += new EventHandler(ListChanged);
        names.Add("Liz");
        names.Add("Martha");
        names.Add("Beth");
        Console.WriteLine(changeCount);        // Outputs "3"
    }
}
```
Для более сложных сценариев, требующих контроля над базовым хранилищем события, в объявлении события можно явным образом предоставить акцессоры `add` и `remove`. Они будут действовать примерно так же, как акцессор `set` для свойства.

#### <a name="operators"></a>Операторы

***Оператор*** является членом, который определяет правила применения определенного выражения к экземплярам класса. Вы можете определить операторы трех типов: унарные операторы, двоичные операторы и операторы преобразования. Все операторы объявляются с модификаторами `public` и `static`.

Класс `List<T>
` объявляет два оператора: `operator==` и `operator!=`. Это позволяет определить новое значение для выражений, которые применяют эти операторы к экземплярам `List`. В частности, эти операторы определяют равенство двух `List<T>
` экземпляров проверяется путем сравнения всех содержащихся в них объектов с помощью их `Equals` методы. Следующий пример кода использует оператор `==` для сравнения двух экземпляров `List<int>
`.

```csharp
using System;

class Test
{
    static void Main() {
        List<int> a = new List<int>();
        a.Add(1);
        a.Add(2);
        List<int> b = new List<int>();
        b.Add(1);
        b.Add(2);
        Console.WriteLine(a == b);        // Outputs "True"
        b.Add(3);
        Console.WriteLine(a == b);        // Outputs "False"
    }
}
```

Первый `Console.WriteLine` выводит `True`, поскольку два списка содержат одинаковое число объектов с одинаковыми значениями в том же порядке. Если бы в `List<T>
` не было определения `operator==`, первый `Console.WriteLine` возвращал бы `False`, поскольку `a` и `b` указывают на различные экземпляры `List<int>
`.

#### <a name="destructors"></a>Деструкторы

Объект ***деструктор*** является членом, который реализует действия для уничтожения экземпляра класса. Деструкторы не могут иметь параметры, они не могут иметь модификаторы доступа и их нельзя вызвать явным образом. Деструктор для экземпляра вызывается автоматически во время сборки мусора.

Сборщик мусора может широкую степень свободы в выборе времени уничтожения объектов и вызова деструкторов. В частности о времени для вызова деструктора не является детерминированным и деструкторы могут выполняться в любом потоке. Для этих и других причин классы должны реализовывать деструкторы только в том случае, когда невозможны другие решения нет.

Уничтожение объектов лучше контролировать с помощью инструкции `using`.

## <a name="structs"></a>Структуры

Как и классы, ***структуры*** — это сущности для хранения данных, которые могут содержать данные-члены и функции-члены. Но в отличие от классов, структуры являются типами значений и для них не выделяется память из кучи. Переменная типа структура напрямую хранит все свои данные, а переменная типа класс хранит ссылку на динамически выделяемый объект. Типы структуры не поддерживают определяемое пользователем наследование, и все типы структуры неявно наследуют от типа `object`.

Структуры особенно удобны для небольших структур данных, имеющих семантику значений. Хорошими примерами структур можно считать комплексные числа, точки в системе координат или словари с парами ключ-значение. Если использовать структуры вместо классов для небольших структур данных, можно существенно снизить количество операций по выделению памяти в приложении. Например, следующая программа создает и инициализирует массив из 100 точек. Если реализовать `Point` как класс, создаются экземпляры для 101 отдельных объектов — один для массива и еще 100 для его элементов.

```csharp
class Point
{
    public int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

class Test
{
    static void Main() {
        Point[] points = new Point[100];
        for (int i = 0; i < 100; i++) points[i] = new Point(i, i);
    }
}
```
Другой вариант — реализовать `Point` структуры.

```csharp
struct Point
{
    public int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```
Теперь создается всего один объект (для массива), а экземпляры `Point` хранятся в стеке массива.

Конструктор структур вызывается оператором `new`, но это не приводит к выделению дополнительной памяти. Вместо того, чтобы динамически выделять объект и возвращать ссылку на него, конструктор структуры возвращает само значение структуры (обычно сохраняя его во временном расположении в стеке), и затем это значение копируется туда, где оно нужно.

При использовании классов две переменные могут ссылаться на один и тот же объект, поэтому может случиться так, что операции над одной переменной затронут объект, на который ссылается другая переменная. При использовании структур каждая переменная имеет собственную копию данных, и операции над одной переменной не могут затрагивать другую. Например, выходные данные в следующем фрагменте кода зависит от того `Point` это класс или структура.

```csharp
Point a = new Point(10, 10);
Point b = a;
a.x = 20;
Console.WriteLine(b.x);
```
Если `Point` — это класс, выводится `20` поскольку `a` и `b` ссылаются на один объект. Если `Point` является структурой, возвращается значение `10` так как назначение `a` для `b` создает копию значения, и это значение не изменяется при последующем присваивании в `a.x`.

Предыдущий пример демонстрирует два ограничения, действующие для структур. Во-первых, копирование структуры целиком обычно менее эффективно, чем копирование ссылки на объект, поэтому присваивание и передача в качестве параметра потребует больше затрат для структур, чем для ссылочных типов. Во-вторых, вы не можете создавать ссылки на структуры (за исключением параметров `ref` и `out`), что в некоторых ситуациях мешает их применять.

## <a name="arrays"></a>Массивы

***Массив*** — это структура данных, содержащая несколько переменных, доступ к которым осуществляется по вычисляемым индексам. Содержащиеся в массиве переменные именуются ***элементами*** этого массива. Все они имеют одинаковый тип, который называется ***типом элементов*** массива.

Сами массивы имеют ссылочный тип, и объявление переменной массива только выделяет память для ссылки на экземпляр массива. Фактические экземпляры массива создаются динамически во время выполнения с помощью `new` оператор. `new` Операции указывает ***длина*** нового экземпляра массива, которая остается неизменной в течение времени существования экземпляра. Элементы массива имеют индексы в диапазоне от `0` до `Length - 1`. Оператор `new` автоматически инициализирует все элементы массива значением по умолчанию. Например, для всех числовых типов устанавливается нулевое значение, а для всех ссылочных типов — значение `null`.

Следующий пример кода создает массив из `int` элементов, затем инициализирует этот массив и выводит содержимое массива.

```csharp
using System;

class Test
{
    static void Main() {
        int[] a = new int[10];
        for (int i = 0; i < a.Length; i++) {
            a[i] = i * i;
        }
        for (int i = 0; i < a.Length; i++) {
            Console.WriteLine("a[{0}] = {1}", i, a[i]);
        }
    }
}
```
Этот пример создает и использует ***одномерный массив***. Кроме этого, C# поддерживает ***многомерные массивы***. Число измерений массива, которое именуется ***рангом*** для типа массива, всегда на единицу больше числа запятых, включенных в квадратные скобки типа массива. Следующий пример создает одномерный, двухмерный и трехмерный массив.

```csharp
int[] a1 = new int[10];
int[,] a2 = new int[10, 5];
int[,,] a3 = new int[10, 5, 2];
```
Массив `a1` содержит 10 элементов, массив `a2` — 50 элементов (10 × 5), и наконец `a3` содержит 100 элементов (10 × 5 × 2).

Элементы массива могут иметь любой тип, в том числе тип массива. Массив с элементами типа массива иногда называют ***ступенчатым массивом***, поскольку элементы такого массива не обязаны иметь одинаковую длину. Следующий пример создает массив массивов `int`.

```csharp
int[][] a = new int[3][];
a[0] = new int[10];
a[1] = new int[5];
a[2] = new int[20];
```
В первой строке создается массив с тремя элементами, каждый из которых имеет тип `int[]` и начальное значение `null`. В последующих строках эти три элемента инициализируются ссылками на отдельные экземпляры массивов различной длины.

`new` Оператор позволяет задать начальные значения элементов массива с помощью ***инициализатор массива***, который является список выражений, записанных между разделителями `{` и `}`. Следующий пример создает и инициализирует массив `int[]` с тремя элементами.

```csharp
int[] a = new int[] {1, 2, 3};
```
Обратите внимание, что длина массива определяется количество выражений между `{` и `}`. Локальные объявления переменных и полей можно сократить, поскольку тип массива не обязательно объявлять повторно.

```csharp
int[] a = {1, 2, 3};
```
Оба указанных выше примера дают результат, эквивалентный такому объявлению.

```csharp
int[] t = new int[3];
t[0] = 1;
t[1] = 2;
t[2] = 3;
int[] a = t;
```
## <a name="interfaces"></a>интерфейсов,

***Интерфейс*** определяет контракт, который может быть реализован классами и структурами. Интерфейс может содержать методы, свойства, события и индексаторы. Интерфейс не предоставляет реализацию членов, которые в нем определены. Он лишь перечисляет члены, которые должны быть определены в классах или структурах, реализующих этот интерфейс.

Интерфейсы могут применять ***множественное наследование***. В следующем примере интерфейс `IComboBox` наследует одновременно от `ITextBox` и `IListBox`.

```csharp
interface IControl
{
    void Paint();
}

interface ITextBox: IControl
{
    void SetText(string text);
}

interface IListBox: IControl
{
    void SetItems(string[] items);
}

interface IComboBox: ITextBox, IListBox {}
```
Классы и структуры могут реализовывать несколько интерфейсов. В следующем примере класс `EditBox` реализует одновременно `IControl` и `IDataBound`.

```csharp
interface IDataBound
{
    void Bind(Binder b);
}

public class EditBox: IControl, IDataBound
{
    public void Paint() {...}
    public void Bind(Binder b) {...}
}
```
Если класс или структура реализует конкретный интерфейс, любой экземпляр этого класса или структуры можно неявно преобразовать в такой тип интерфейса. Пример

```csharp
EditBox editBox = new EditBox();
IControl control = editBox;
IDataBound dataBound = editBox;
```
Если в статическом контексте невозможно достоверно знать, что экземпляр реализует определенный интерфейс, можно использовать динамическое приведение типов. Например, следующие операторы используют динамическое приведение типов для получения объекта `IControl` и `IDataBound` реализации интерфейсов. Так как фактический тип объекта является `EditBox`, приведения выполняются успешно.

```csharp
object obj = new EditBox();
IControl control = (IControl)obj;
IDataBound dataBound = (IDataBound)obj;
```
В предыдущем `EditBox` класс, `Paint` метода из `IControl` интерфейс и `Bind` метода из `IDataBound` интерфейса реализуются с помощью `public` членов. C# также поддерживает ***явные реализации члена интерфейса***, с помощью которого класса или структуры можно избежать создания членов `public`. Явная реализация члена интерфейса записывается с использованием полного имени члена интерфейса. Например, класс `EditBox` может реализовывать методы `IControl.Paint` и `IDataBound.Bind` с использованием явной реализации членов интерфейса, как показано в следующем примере.

```csharp
public class EditBox: IControl, IDataBound
{
    void IControl.Paint() {...}
    void IDataBound.Bind(Binder b) {...}
}
```
Обращение к явным членам интерфейса можно осуществлять только через тип интерфейса. Например, реализация `IControl.Paint` предоставляемые предыдущего `EditBox` класс может вызываться только сначала следует преобразовать `EditBox` ссылка `IControl` тип интерфейса.

```csharp
EditBox editBox = new EditBox();
editBox.Paint();                        // Error, no such method
IControl control = editBox;
control.Paint();                        // Ok
```

## <a name="enums"></a>перечислениям;

***Тип enum*** представляет собой тип значения с набором именованных констант. В следующем примере, объявляет и использует тип перечисления с именем `Color` с три константы: `Red`, `Green`, и `Blue`.

```csharp
using System;

enum Color
{
    Red,
    Green,
    Blue
}

class Test
{
    static void PrintColor(Color color) {
        switch (color) {
            case Color.Red:
                Console.WriteLine("Red");
                break;
            case Color.Green:
                Console.WriteLine("Green");
                break;
            case Color.Blue:
                Console.WriteLine("Blue");
                break;
            default:
                Console.WriteLine("Unknown color");
                break;
        }
    }

    static void Main() {
        Color c = Color.Red;
        PrintColor(c);
        PrintColor(Color.Blue);
    }
}
```
Каждый тип перечисления имеет соответствующий целочисленных типов, который ***базовый тип*** типа перечисления. Базовый тип явно не объявлен тип перечисления имеет базовый тип из `int`. Формат хранения и диапазон возможных значений типа перечисления определяются его базовым типом. Набор значений, которые может принимать тип перечисления не ограничивается его членами перечисления. В частности любое значение базового типа перечисления может быть приведен к типу перечисления и являться допустимым дискретным значением этого типа перечисления.

В следующем примере объявляется тип перечисления с именем `Alignment` с базовым типом `sbyte`.

```csharp
enum Alignment: sbyte
{
    Left = -1,
    Center = 0,
    Right = 1
}
```
Как показано в предыдущем примере, объявление члена перечисления может включать константное выражение, задающее значение члена. Постоянное значение для каждого члена перечисления должен быть в диапазоне базового типа перечисления. При объявлении члена перечисления значение не указано явным образом, члену присваивается нулевое (если это первый элемент в тип перечисления) значение или значения объявленного члена перечисления, а также один.

Значения перечислений можно преобразовать к целочисленным значениям и наоборот с помощью приведения типов. Пример

```csharp
int i = (int)Color.Blue;        // int i = 2;
Color c = (Color)2;             // Color c = Color.Blue;
```
Значение по умолчанию любого типа перечисления — целочисленное значение ноль преобразуется в тип перечисления. В случаях, когда переменная автоматически инициализируются значением по умолчанию это значение, присваиваемое переменным перечисляемого типа. В порядке для значения по умолчанию для типа перечисления было легко доступно литерала `0` неявно преобразует в любой тип перечисления. Таким образом, допустимо следующее выражение.

```csharp
Color c = 0;
```

## <a name="delegates"></a>Делегаты

***Тип delegate*** представляет ссылки на методы с конкретным списком параметров и типом возвращаемого значения. Делегаты позволяют использовать методы как сущности, сохраняя их в переменные и передавая в качестве параметров. Принцип работы делегатов близок к указателям функций из некоторых языков, но в отличие от указателей функций делегаты являются объектно-ориентированными и строго типизированными.

Следующий пример кода объявляет и использует тип делегата с именем `Function`.

```csharp
using System;

delegate double Function(double x);

class Multiplier
{
    double factor;

    public Multiplier(double factor) {
        this.factor = factor;
    }

    public double Multiply(double x) {
        return x * factor;
    }
}

class Test
{
    static double Square(double x) {
        return x * x;
    }

    static double[] Apply(double[] a, Function f) {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
    }

    static void Main() {
        double[] a = {0.0, 0.5, 1.0};
        double[] squares = Apply(a, Square);
        double[] sines = Apply(a, Math.Sin);
        Multiplier m = new Multiplier(2.0);
        double[] doubles =  Apply(a, m.Multiply);
    }
}
```
Экземпляр `Function` с типом делегата может ссылаться на любой метод, который принимает аргумент `double` и возвращает значение `double`. `Apply` Метод применим данный `Function` к элементам `double[]`, возвращение `double[]` с результатами. В методе `Main` используется `Apply` для применения трех различных функций к `double[]`.

Делегат может ссылаться на статический метод (например, `Square` или `Math.Sin` в предыдущем примере) или метод экземпляра (например, `m.Multiply` в предыдущем примере). Делегат, который ссылается на метод экземпляра, также содержит ссылку на конкретный объект. Когда метод экземпляра вызывается через делегат, этот объект превращается в `this` в вызове.

Делегаты могут также создаваться с использованием анонимных функций, то есть создаваемых на ходу "встроенных методов". Анонимные функции могут использовать локальные переменные соседних методов. Таким образом, приведенный выше пример умножения можно записать проще и без использования `Multiplier` класса:

```csharp
double[] doubles =  Apply(a, (double x) => x * 2.0);
```
Также стоит упомянуть о такой интересной и полезной особенности делегата, что он не имеет информации или ограничений в отношении того, к какому классу относится указанный в нем метод. Достаточно лишь, чтобы указанный метод имел такие же типы параметров и возвращаемого значения, которые назначены для делегата.

## <a name="attributes"></a>Атрибуты

Типы, члены и другие сущности в программе C# поддерживают модификаторы, которые управляют некоторыми аспектами их поведения. Например, доступность метода определяется с помощью модификаторов `public`, `protected`, `internal` и `private`. C# обобщает эту возможность, позволяя пользователям определять собственные типы декларативных сведений, назначать их для сущностей программы и извлекать во время выполнения. В программах эти дополнительные декларативные сведения определяются и используются посредством ***атрибутов***.

Следующий пример кода объявляет атрибут `HelpAttribute`, который можно поместить в сущности программы для указания связей с соответствующей документацией.

```csharp
using System;

public class HelpAttribute: Attribute
{
    string url;
    string topic;

    public HelpAttribute(string url) {
        this.url = url;
    }

    public string Url {
        get { return url; }
    }

    public string Topic {
        get { return topic; }
        set { topic = value; }
    }
}
```
Все классы атрибутов являются производными от `System.Attribute` базового класса, предоставляемые платформой .NET Framework. Чтобы задать атрибут, его имя и возможные аргументы указываются в квадратных скобках непосредственно перед объявлением соответствующей сущности. Если имя атрибута заканчивается на `Attribute`, можно опустить, часть имени, при ссылке на атрибут. Например, атрибут с именем `HelpAttribute` можно использовать так:

```csharp
[Help("http://msdn.microsoft.com/.../MyClass.htm")]
public class Widget
{
    [Help("http://msdn.microsoft.com/.../MyClass.htm", Topic = "Display")]
    public void Display(string text) {}
}
```
В этом примере подключается `HelpAttribute` для `Widget` класса, а другой `HelpAttribute` для `Display` метода в классе. Открытые конструкторы класса атрибута указывают, какие сведения необходимо указать при назначении атрибута некоторой сущности программы. Дополнительные сведения можно предоставить через обращения к открытым свойствам класса атрибута, доступным для чтения и записи (например, как указанная выше ссылка на свойство `Topic`).

В следующем примере показано, как можно получить сведения об атрибутах для заданной сущности программы во время выполнения с помощью отражения.

```csharp
using System;
using System.Reflection;

class Test
{
    static void ShowHelp(MemberInfo member) {
        HelpAttribute a = Attribute.GetCustomAttribute(member,
            typeof(HelpAttribute)) as HelpAttribute;
        if (a == null) {
            Console.WriteLine("No help for {0}", member);
        }
        else {
            Console.WriteLine("Help for {0}:", member);
            Console.WriteLine("  Url={0}, Topic={1}", a.Url, a.Topic);
        }
    }

    static void Main() {
        ShowHelp(typeof(Widget));
        ShowHelp(typeof(Widget).GetMethod("Display"));
    }
}
```
Когда выполняется запрос конкретного атрибута через отражение, вызывается конструктор для класса атрибута с указанием сведений, представленных в исходном коде программы, а затем возвращается созданный экземпляр атрибута. Если дополнительные сведения предоставляются через свойства, перед возвращением экземпляра атрибута этим свойствам присваиваются указанные значения.
